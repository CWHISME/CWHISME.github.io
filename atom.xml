<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WangJiaYing</title>
  
  
  <link href="https://cwhisme.github.io/atom.xml" rel="self"/>
  
  <link href="https://cwhisme.github.io/"/>
  <updated>2022-12-11T02:01:22.617Z</updated>
  <id>https://cwhisme.github.io/</id>
  
  <author>
    <name>CWHISME</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>协变和逆变</title>
    <link href="https://cwhisme.github.io/2022/12/10/%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/"/>
    <id>https://cwhisme.github.io/2022/12/10/%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/</id>
    <published>2022-12-10T09:06:56.000Z</published>
    <updated>2022-12-11T02:01:22.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于协变和逆变，早在前些日子就在想整理一下了，不过由于前几天研究了下 <a href="">Unity 的阴影与光照烘焙</a> ，所以一直放在心上却没有实施，都忘了之前是准备想怎么写开头了…也忘了作笔记，只能现在重新想一想。</p><p>逆变 和 协变其实是对面向对象的一个补充，在 C# 中通过 in 标识逆变，out 标识 协变，如果没有标识，那么默认就是 『不变』。</p><p>之前想思考了好些天了，感觉有些地方还是有点没想透彻，这次整理的同时进行更多的试验，确定自己的想法对不对。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>变体仅针对引用类型，且只有 数组(隐式协变)、泛型委托、泛型接口 可以使用。</p><p><font color=red>注：对于同一泛型参数，逆变和协变不能同时存在。</font></p><p>正常来说，根据里氏替换原则：子类型（subtype）必须能够替换掉他们的基类型（base type）</p><p>我们通常在写代码的时候，也会不自觉地用到这一点：例如派生出多个子类的父类，可以作为一个『统一的方法参数』接受子类传递然后处理：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Log</span>(<span class="params">Parent pt</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(pt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child child = <span class="keyword">new</span> Child();</span><br><span class="line">ChildBoy childBoy = <span class="keyword">new</span> ChildBoy();</span><br><span class="line">Log(child);</span><br><span class="line">Log(childBoy);</span><br></pre></td></tr></table></figure><p>我们可以说一个类是另一个类的基类，但是一个接口、一个委托正常是没有这种关系的，所以当包裹一层(委托、接口)后就不行了——理论上它们并没有子类指向父类的关系。</p><p>泛型是对类型系统的进一步抽象，上面的变化映射至(数组、泛型委托、泛型接口)就是逆变与协变的概念。</p><p>从简单表现上来看：</p><ul><li>协变用于隐式将返回参数(容器)的子类转为父类</li><li>逆变用于隐式将传入参数(容器)的父类转为子类</li></ul><p>想想看：</p><ul><li>协——子类指向父类的关系符合原始的关系转换方向</li><li>逆——父类转子类</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试协变"><a href="#测试协变" class="headerlink" title="测试协变"></a>测试协变</h3><h4 id="1-数组"><a href="#1-数组" class="headerlink" title="(1) 数组"></a>(1) 数组</h4><p>数组的协变相信大多数人都不自觉使用过，例如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] strings = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">object</span>[] objects = strings;</span><br></pre></td></tr></table></figure><p>上述代码就是数组隐式支持的协变：我们可以把子类数组直接赋值给定义的基类数组。</p><p>上面已经解释过，协变用于 『返回值隐式转换为父类』</p><blockquote><p>因为不管如何从数组中取值：strings[index] 都可以转为 object</p></blockquote><p>符合 『子类指向父类的关系』，协变成立。</p><h4 id="2-接口"><a href="#2-接口" class="headerlink" title="(2) 接口"></a>(2) 接口</h4><p>接口的协变以 C# 内置 IReadOnlyList 接口为例，该接口标记了 out，List 就实现了该接口。</p><p>首先定义两个有父子关系的引用对象：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Parent：父类&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Child</span> : <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Child：子类&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进行调用测试：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Child&gt; childList = <span class="keyword">new</span> List&lt;Child&gt;() &#123; <span class="keyword">new</span> Child() &#125;;</span><br><span class="line"><span class="comment">//====报错====列表是普通类，没有也不支持协变功能</span></span><br><span class="line"><span class="comment">//List&lt;Parent&gt; parentList = childList;</span></span><br><span class="line"><span class="comment">//正常赋值，协变使得声明子类的接口可隐式转为父类</span></span><br><span class="line">IReadOnlyList&lt;Parent&gt; baseList = childList;</span><br><span class="line">Debug.Log(baseList[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test (0.008s)</span><br><span class="line">---</span><br><span class="line">Child：子类</span><br></pre></td></tr></table></figure><p>可能在这里还会有点不明白发生了什么，再以 List 实现的另一个接口 <code>IList&lt;T&gt;</code> 为例，IList 接口并未做标识，因此它是『不变』的，如果我们想这样赋值：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//报错，提示无法隐式转换 List&lt;Child&gt;-&gt;IList&lt;Panret&gt;</span></span><br><span class="line">IList&lt;Parent&gt; list = childList;</span><br></pre></td></tr></table></figure><p>作为『不变』的泛型接口，想要将泛型子类赋值泛型父类就会得到报错。</p><p>现在应该大概有点感觉了——特别是当拥有多个子类，我们想统一接收的时候，拥有协变就可以直接这样写：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;Child&gt; childList = <span class="keyword">new</span> List&lt;Child&gt;() &#123; <span class="keyword">new</span> Child() &#125;;</span><br><span class="line">List&lt;ChildBoy&gt; childList2 = <span class="keyword">new</span> List&lt;ChildBoy&gt;() &#123; <span class="keyword">new</span> ChildBoy() &#125;;</span><br><span class="line">List&lt;ChildGirl&gt; childList3 = <span class="keyword">new</span> List&lt;ChildGirl&gt;() &#123; <span class="keyword">new</span> ChildGirl() &#125;;</span><br><span class="line">Log(childList);</span><br><span class="line">Log(childList2);</span><br><span class="line">Log(childList3);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Log</span>(<span class="params">IReadOnlyList&lt;Parent&gt; baseList</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(baseList[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Test (0.009s)</span><br><span class="line">---</span><br><span class="line">Child：子类</span><br><span class="line">ChildBoy：子类</span><br><span class="line">ChildGirl：子类</span><br></pre></td></tr></table></figure><blockquote><p>当我们调用 childList[0] 可以得到一个 Child<br>当我们调用 childList2[0] 可以得到一个 ChildBoy<br>当我们调用 childList3[0] 可以得到一个 ChildGirl</p></blockquote><p>最后从接口得到的这个对象，都可以安全转为 Parent<br>符合 『子类指向父类的关系』，协变成立。</p><h4 id="3-委托"><a href="#3-委托" class="headerlink" title="(3) 委托"></a>(3) 委托</h4><p>除此之外，还有接触最多的 <code>TResult Func&lt;out TResult&gt;</code> 委托，它的返回值也是支持协变的：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;Parent&gt; parentFunc = () =&gt; <span class="keyword">new</span> Parent();</span><br><span class="line">Func&lt;Child&gt; childFunc = () =&gt; <span class="keyword">new</span> Child();</span><br><span class="line">parentFunc = childFunc;</span><br></pre></td></tr></table></figure><p>上面已经解释过，协变用于 『返回值隐式转换为父类』：因为 Child 可以转为 Parent，所以<code>Func&lt;Child&gt;</code> 也可以安全转为 <code>Func&lt;Parent&gt;</code>.</p><blockquote><p>当我们调用 childFunc() 可以得到一个 子类<br>当我们调用 parentFunc() 可以得到一个 父类<br>当 parentFunc=childFunc 调用可以得到一个 父类</p></blockquote><p>符合 『子类指向父类的关系』，协变成立。</p><h3 id="测试逆变"><a href="#测试逆变" class="headerlink" title="测试逆变"></a>测试逆变</h3><p>协变标识返回值，逆变标识参数。</p><p>虽然听起来差不多，不过协变看着其实更符合思考，因为基于接口、委托的执行返回值我们可以更加直观地得出结论，逆变可能就没那么容易理解了。</p><p>还是先以 C# 内置 IComparable 接口为例，该接口标记了逆变，我们定义两个类：Parent 和 Child，并使 Parent 实现该接口。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IComparable&lt;Parent&gt; ip = <span class="keyword">new</span> Parent();</span><br><span class="line">IComparable&lt;Child&gt; iChild = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="comment">//====报错====</span></span><br><span class="line">ip = iChild;</span><br><span class="line"><span class="comment">//正常赋值，逆变使得声明父类接口隐式转为声明子类接口</span></span><br><span class="line">iChild = ip;</span><br></pre></td></tr></table></figure><p>在上述代码中，反而是 Child 接口能够接受 Parent 接口对象，第一个地方将 iChild(子类接口) 赋值 ip(父类接口) 为什么会报错呢？</p><p>在上面我们已经测试过协变了，协变得出的结论是最终返回结果的类型一定是符合转换规则的，那么这里应该也可以先从执行结果上考虑：</p><blockquote><p>若执行 <code>IComparable&lt;Parent&gt;</code> 接口，需要接受 Parent 或 Child 参数<br>若执行 <code>IComparable&lt;Child&gt;</code> 接口，只能接受 Child 参数</p></blockquote><ul><li>如果我们把 ip 赋值给 iChild，那么在参数中就变成只能接受 Child 类型了。</li><li>但是如果把 iChild 赋值给 ip，那么参数中种就变成也可以接受 Parent 类型了。</li></ul><p>所以，区别是什么？</p><p>区别在于：<font color=red>(1) ip 本来是接受父类型，变成只能接受子类型，是合理的。(2) iChild 本来只能接受子类型，如果变成接受父类型参数则不合理。</font></p><p>想一想，一个方法的参数接受的是子类，但是把父类传进去，是不是只有强制类型转换？但是强制类型转换是不是又涉及到这个『父类实际上装的并不是这个子类』问题呢？</p><p>说实话，逆变确实感觉更绕，但从结果上来看，又能感觉确实应当如此。</p><p>泛型委托也是一样的道理：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;Parent&gt; parentAction = (p) =&gt; Debug.Log(p);</span><br><span class="line">Action&lt;Child&gt; childAction = (c) =&gt; Debug.Log(c);</span><br><span class="line"><span class="comment">//报错，因为如果赋值成功，调用 parentAction(childAction) 就可以传入父类型了</span></span><br><span class="line">parentAction = childAction;</span><br><span class="line"><span class="comment">//正常赋值，childAction 只能接受 Child 类型，parentAction 接受 Child 类型符合父类指向子类的关系</span></span><br><span class="line">childAction = parentAction;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>协变(out)逆(in）：数组是协变的-子类数组可以隐式转为父类数组使用，只能用于『数组、泛型委托、泛型接口』，协变用于返回值隐式转为父类(容器)，逆变用于传入值可以被隐式转为子类(容器)(当然在调用时类型就变成确定了)，不变：不可互转，变体仅适用于引用类型。</p><ul><li>逆变常见是 Action&lt;子类&gt;=Action&lt;父类&gt;，参数为父类的委托赋值给参数子类的委托，调用时必须传入子类对象，根据面向对象规则子类一定包含父类字段或方法，可以正常调用</li><li>协变常见的比如 List 实现的 IEnumerable，正常情况下 List&lt;子类型&gt; 无法赋值给 List&lt;父类型&gt;，这个接口就标记了协变，使得可以声明 IEnumerabl&lt;父类型&gt; = List&lt;子类型&gt;</li><li>也可以简单记为：协变可以使得声明为父类的泛型可以装载子类，逆变使得声明子类的泛型可以可装载父类，其最终执行的返回值、参数符合里氏替换原则。</li></ul><p>对于这两者，从表现上来看：</p><ul><li>协变：声明的泛型容器子类可以赋值父类</li><li>逆变：声明的泛型容器父类可以赋值子类</li></ul><p>从调用结果上来看：</p><ul><li>协变：返回结果符合里氏替换原则，返回值为父类型的方法也可以返回子类型</li><li>逆变：接收参数符合里氏替换原则，参数为父类型的方法可以接受子类型的参数</li></ul><p>所以回到前面的一个问题：对于同一个模板参数 T ，协变和逆变不能同时存在，为什么呢？</p><blockquote><p>仔细考虑一下，如果一个接口参数同时支持协变和逆变，那么上述测试的赋值方式就必须同时双向支持，这样就会导致出现『参数为子类型的接口，可以传入父类型』，这是不合法的。<br>反之亦然，返回参数为子类型的接口，返回了实际为父类型的对象，也是不合法的。</p></blockquote><p>C# 中常见的自带协变逆变的接口或委托：</p><ul><li><code>IEnumerable&lt;out T&gt;</code></li><li><code>IEnumerator&lt;out T&gt;</code></li><li><code>System.Linq.IQueryable&lt;out T&gt;</code></li><li><code>IComparer&lt;in T&gt;</code></li><li><code>IComparable&lt;in T&gt;</code></li><li><code>IEqualityComparer&lt;in T&gt;</code></li><li><code>IReadOnlyList&lt;out T&gt;</code></li><li><code>TResult Func&lt;in T, out TResult&gt;(T arg) 等</code></li><li><code>void Action&lt;in T&gt;(T obj) 等</code></li><li>数组默认协变</li></ul><p>—————————————————————————————————————————</p><blockquote><p>参考文档：</p><ul><li><a href="https://learn.microsoft.com/zh-cn/dotnet/standard/generics/covariance-and-contravariance">covariance-and-contravariance</a></li><li><a href="https://www.cnblogs.com/VVStudy/p/11404300.html">C# - 协变、逆变 看完这篇就懂了</a></li><li><a href="https://www.cnblogs.com/CLR010/p/3274310.html">逆变与协变详解 </a></li><li><a href="https://www.cnblogs.com/Ninputer/archive/2008/11/22/generic_covariant.html">.NET 4.0中的泛型协变和反变</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;关于协变和逆变，早在前些日子就在想整理一下了，不过由于前几天研究了下 &lt;a href=&quot;&quot;&gt;Unity 的阴影与光照烘焙&lt;/a&gt; ，所以一直</summary>
      
    
    
    
    <category term="C#" scheme="https://cwhisme.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity 的阴影与光照烘焙</title>
    <link href="https://cwhisme.github.io/2022/12/06/Unity%E7%9A%84%E9%98%B4%E5%BD%B1%E4%B8%8E%E5%85%89%E7%85%A7%E7%83%98%E7%84%99/"/>
    <id>https://cwhisme.github.io/2022/12/06/Unity%E7%9A%84%E9%98%B4%E5%BD%B1%E4%B8%8E%E5%85%89%E7%85%A7%E7%83%98%E7%84%99/</id>
    <published>2022-12-06T10:32:41.000Z</published>
    <updated>2022-12-11T02:01:22.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天跟同事讨论 Unity Lightmap ，在 Shader(自定义) 中是怎么取的，然后我说 Unity 在 Shader 中直接会给数据，调用 Unity 提弄函数直接采样就行了。</p><p>同事表示说，这个光照贴图 UV 呢？哪里取。</p><p>当时也是回答说是 Unity 直接提供的，虽说实际也差不多，不过后面下来又想了想，细节方面也已经记不清了。</p><p>再想到过去研究光照这块，早已经是多年前的事了，于是重新实际试了试，直接把光照烘焙这块都重新了解了下，简单做个记录。</p><p>主要使用工具有：</p><ul><li>Unity3D 2021.3.6f1</li><li>默认渲染管线</li><li>Forward RenderPath</li><li>Standard Shader</li></ul><h2 id="LightMapping-数据"><a href="#LightMapping-数据" class="headerlink" title="LightMapping 数据"></a>LightMapping 数据</h2><p>首先回到上面那个问题，光照烘焙后，会为场景生成对应光照贴图，贴图数据本身位于场景同名同级的子目录中，Lighting 设置中 LightMaps 会自动被设置上去，此时直接在同场景对应静态物体上也能预览：</p><p><img src="/blogimages/2022/2022-12-06/m_40890511256b2a6d713c9161123984d2_r.png"></p><p>默认情况下， Lightmap Index、TilingX、TilingY、OffsetX、OffsetY 这类参数虽然看起来是直接记录在场景对象上的，实际并不是，最简单的测试方法就是将该对象存储为 Prefab(或者复制一份)，就会发现 Prefab 上的 LightMap 信息已经丢失——再放回去也是丢失状态(可能是为了避免污染 Prefab)。<br>当然此时也可以通过记录 Render.lightmapIndex 之类的，通过脚本给还原。</p><p>动态加载 Lightmap 一般都该是通过这种方式进行：先给 LightmapSettings.lightmaps 赋值对应的 Lightmap 数据、贴图，然后给场景静态物体 Render 设置上对应的 lightmapIndex 等数据，Shader 中就能通过 Unity 提供的函数识别然后采样。</p><p>注1：烘焙光照贴图 Shader 中通过 TEXCOORD1 采样：</p><blockquote><p>Unity stores baked lightmap UVs in its mesh in the Mesh.uv2 channel. This channel maps to the TEXCOORD1 shader semantic, and is commonly called “UV1”.</p></blockquote><p>注2：实时光照贴图 Shader 中通过 TEXCOORD2 采样（勾选 Lighting-&gt;Realtime Lighting 生效）：</p><blockquote><p>Unity can use data in the Mesh.uv3 channel as input for the real-time lightmap UV calculations. Mesh.uv3 maps to the TEXCOORD2 shader semantic, and is commonly called “UV2”.</p></blockquote><h2 id="光源与阴影"><a href="#光源与阴影" class="headerlink" title="光源与阴影"></a>光源与阴影</h2><p>每一个光源，若光源是实时的，对于动态物体至少是双倍消耗，对于静态物体也一样。</p><p>消耗点主要在于动态阴影上，在 Forwardbase Render Path 中，绘制阴影分为两部分：自己接收阴影以及投射阴影，MeshRender 上也可以单独在 Lighting 选项设置开关。</p><ul><li>是否有阴影跟三个条件有关：<ul><li>(1) Shader 中的 接收投射阴影 Pass</li><li>(2) Render 上的接收投射开关</li><li>(3) 光源是否设置阴影</li></ul></li></ul><p>投射阴影的 Pass 是特有的一个，它会将自身到光源的方向渲染至一张深度图，投射及采样的大概步骤如下：</p><ul><li><p>Shader 中阴影投射 Pass 必须：</p><ul><li>打 Tags {“LightMode”:”ShadowCaster”}，标记该 Pass 专用于阴影投射</li><li>增加预编译指令 #pragma multi_compile_shadowcaster</li><li>在顶点、片段中调用 Unity 提供的预定义进行处理：V2F_SHADOW_CASTER、TRANSFER_SHADOW_CASTER_NORMALOFFSET、SHADOW_CASTER_FRAGMENT<ul><li>V2F_SHADOW_CASTER：顶点到片段数据变量，直接在 v2f 定义即可</li><li>TRANSFER_SHADOW_CASTER_NORMALOFFSET：在顶点 Shader 函数中计算了 物体顶点世界坐标-(减)光源坐标，即当前顶点到光源向量</li><li>SHADOW_CASTER_FRAGMENT：在片段 Shader 函数中将顶点到光源向量转长度，计算深度 (光源设置的 shadowbias 就在这里用的：UnityEncodeCubeShadowDepth((长度+unity_Light_ShadowBias.x)*_LightPositionRange.w))</li></ul></li></ul></li><li><p>Shader 中阴影接收 Pass 必须：</p><ul><li>打 Tags {“LightMode”:”ForwardBase”}，标记该 Pass 为向前渲染</li><li>增加预编译指令 #pragma multi_compile_fwdbase</li><li>在顶点、片段中调用 Unity 提供的预定义进行处理：<ul><li>SHADOWCOORDS(ID)：v2f 结构体使用，ID 是个数值，表示使用的 TEXCOORD+ID，保存顶点函数通过 ComputeScreenPos(o.pos) 计算的 showCoord 以传入片元着色函数(定义的 ID 要避免与其它 TEXCOORD 产生冲突)</li><li>TRANFER_SHADOW(o)：通过顶点 clip 裁剪空间坐标计算屏幕空间阴影采样坐标内部调用的是：ComputeScreenPos(o.pos)</li><li>SHADOW_ATTENUATION(i)：根据 showCoord 采样阴影颜色，返回叠加的阴影强度值。</li></ul></li></ul></li></ul><p>其中投射 Pass 是必须的一个单独 Pass，导致了额外 DrawCall 消耗。接收 Pass 则可以与正常 Pass 一块处理对颜色进行叠加。</p><p>在 Standard Shader 中，开启实时阴影的情况下一个普通的 Sphere 对象甚至产生了 3 个 DrawCall：</p><p><img src="/blogimages/2022/2022-12-06/m_919aead0b6648620444cd393ee1c38f0_r.png"></p><p>1 个渲染深度<br>1 个渲染物体到光源向量<br>1 个渲染物体本身</p><p>理论上加上阴影的话，不是只会增加一个 ShadowCaster DrawCall 吗？为什么多渲染了 2 次？渲染深度是为了什么？</p><p>从上面 FrameDebugger 截图的信息中显示，额外的一个深度渲染依然是由 ShadowCaster 发起的，但是为什么呢？</p><p>其实，这是因为在 PC 平台的原因。</p><p>Unity Standard Shader 会判断对应平台，如果是手机平台，才会使用上述传统的 Shadowcaster 方式绘制阴影，而 PC 平台则会另外使用 『屏幕空间阴影』，因此才多额外一个 DrawCall 渲染物体的深度。</p><p>屏幕空间阴影原本应该是延迟渲染路径采用的方法，Unity 在默认渲染管线下，对支持的平台的前向渲染路径也采用相同方式，可以减少 OverDraw 但是会增加 DrawCall。</p><p>切换至 Adnroid 平台，再利用 FrameDebugger 查看：</p><p><img src="/blogimages/2022/2022-12-06/m_0ac8f9f53256d5e74b1ff0d17f2b99cc_r.png"></p><p>1 个渲染物体到光源向量<br>1 个渲染物体本身</p><p>对上号了。</p><h2 id="烘焙"><a href="#烘焙" class="headerlink" title="烘焙"></a>烘焙</h2><p>烘焙只用于静态物体，可以让静态物体单独采样烘焙好的贴图，而非实时光源，减少计算。</p><p>烘焙后的效果——离线渲染自然也会比实时渲染效果好。</p><p>Light Probe Group：根据官方文档及经过测试表明，该组件使得已烘焙的间接光照效果可以施加于动态物体上，更多是对内存消耗。（烘焙静态物体不使用，查看静态对象面板，烘焙后的 Light Probe 选项是置灰 Off 无法修改的）</p><p>Reflection Probe：对动态、静态对象都有影响，配合 Light Probe Group 效果更好。</p><p>对于烘焙的三个模式，官方文档解释有：</p><blockquote><ul><li>Baked Indirect 模式将实时直接光照与烘焙间接光照结合在一起，提供实时阴影。这种光照模式提供逼真的光照和合理的阴影保真度，适用于中档硬件。</li></ul></blockquote><ul><li>Shadowmask 模式将实时直接光照与烘焙间接光照结合在一起，为远处的游戏对象启用烘焙阴影，并将烘焙阴影与实时阴影自动融合。这是最真实但也是最耗费资源的光照模式。您可以使用质量设置 (Quality Settings) 来配置其性能和视觉保真度。这种光照模式适用于高端或中档硬件。</li><li>Subtractive 模式提供烘焙的直射和间接光照，仅针对一个方向光渲染直接实时阴影。这种光照模式不能提供特别逼真的光照效果，适合于风格化的艺术效果或低端硬件。</li></ul><h3 id="MixLighting"><a href="#MixLighting" class="headerlink" title="MixLighting"></a>MixLighting</h3><ul><li>！混合灯光会大量(相比Baked模式)增加 Batches、顶点数量，它对静态物体也会产生 Baches ，如果不是一定需求阴影最好还是用纯 Baked</li></ul><p>测试场景为：</p><ul><li>一个平行光+一个点光源</li><li>10 个静态物体，2 个动态物体</li></ul><h4 id="Backed-Indirect"><a href="#Backed-Indirect" class="headerlink" title="Backed Indirect"></a>Backed Indirect</h4><ul><li>Backed Indirect：只烘焙间接光，灯光效果、阴影必须设置为 Backed 才会真的被烘焙，否则(Mixed)静态物体都会直接走实时计算。（消耗很高）<blockquote><p>Shadow Distance：范围内的值使用实时阴影，超过此距离则不再渲染阴影。<br><font color=red>注：Mixed 点光源在 Shadow Distance 内对所有物体产生阴影，因为是实时的。</font></p></blockquote></li></ul><p>如图所示，烘焙后开启灯光+隐藏灯光：<br><img src="/blogimages/2022/2022-12-06/m_8f9e6b0a707f474dc2616ee926fad357_r.png"></p><h4 id="Subtractive"><a href="#Subtractive" class="headerlink" title="Subtractive"></a>Subtractive</h4><ul><li>Subtractive：Mixed 设置的灯光直接光和间接光都会被烘焙，被烘焙的静态物体在运行时不占用实时光计算，动态物体则单独走实时计算。<blockquote><p>Shadow Distance：范围内的值动态对象使用实时阴影，超过此距离则不再渲染阴影。<br><font color=red>注：Mixed 点光源对动态物体不产生阴影。</font></p></blockquote></li></ul><p>如图所示，烘焙后开启灯光+隐藏灯光：<br><img src="/blogimages/2022/2022-12-06/m_b350fc47c8c1ea6da34cb43acd1634cb_r.png"><br>从上图可以看出，点光源并未对物体形成阴影，只有平行光的阴影。</p><h4 id="Shadowmask"><a href="#Shadowmask" class="headerlink" title="Shadowmask"></a>Shadowmask</h4><ul><li><p>Shadowmask：根据设置决定显示，这个选项可以配合 Setting-&gt;Quality-&gt;Shadows 使用</p><blockquote><p>Shadow Distance：范围内的值使用实时阴影，超过此距离则使用烘焙阴影。<br>ShadowMask：静态物体使用烘焙阴影。<br>Shadow Cascades：阴影级联数量，官方文档解释说级联数量越多质量越高，性能消耗越大。但是经过测试，开启后阴影变硬，性能消耗是感觉到了，质量上反而觉得更难看。<br><font color=red>注：Mixed 点光源在 Shadow Distance 内对所有物体产生阴影，因为是实时的。</font></p></blockquote></li><li><p>Mixed 设置的灯光必须存在场景中才能生效，烘焙后隐藏 Light 就(对静态物体也)无效了。具体表现取决于 Quality Shadowmask Mode 设置。<br>两种设置模式中：</p><ul><li>Shadow Distance：在范围内静态物体也是实时光，范围外烘焙光，<del>当 Distance 设置为 0 时与 Shadowmask 消耗一致</del>(静态物体均使用烘焙阴影)——比 Shadowmask 消耗还低，因为…没有动态物体的实时阴影了，但是这样不如直接用 Subtractive 消耗更低。</li><li>Shadowmask：静态物体始终使用烘焙阴影，动态物体使用实时阴影。</li></ul></li></ul><p>烘焙后相比 Backed Indirect 多了一张 Shadowmask 贴图，实际测试近距离下同一个场景效果及 Batches 与 Backed Indirect 基本一致（因为 Shadow Distance 都是实时阴影）</p><p>如图所示，烘焙后 ShadowDistance+ShadowMask 模式：</p><p><img src="/blogimages/2022/2022-12-06/m_b20be5022100021ace39a857015451aa_r.png"></p><h3 id="Shader-使用-Lightmap"><a href="#Shader-使用-Lightmap" class="headerlink" title="Shader 使用 Lightmap"></a>Shader 使用 Lightmap</h3><p>大致上分为四步：</p><ul><li>顶点着色器接收参数结构 定义 float2 texcoord1 : TEXCOORD1 以接收 Unity 传入的光照 uv</li><li>顶点着色器为 uv 做一次转换： v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw</li><li>片段着色器调用内置函数 DecodeLightmap 对 unity_Lightmap 采样颜色</li><li>与物体像素本来颜色叠加混合</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><del>目前测试下来，唯一的问题就是在 Forward RenderPath 下，烘焙光照中，仅平行光能被烘焙为静态对象的阴影，点光源只能用实时阴影。<br>表现情况是：点光源设置为 Baked 模式，仅光源颜色信息被烘焙至光照贴图，阴影却没有。</del></p><p>上述结论为错误操作导致！<br>Point Light 和 Directional Light 均有 『Baked Shadow Radius』和『Baked Shadow Angle』，合适的值可以让阴影被烘焙得更加柔和，但两者参数范围是完全是不同的，若光源设置过大，会导致直接丢失阴影——可能在测试过程中不小心动到，导致了上述错误的结论。</p><p>经过测试，可以确定 Subtractive 消耗最低，Backed Indirect 和 Shadowmask 消耗都不少，按照消耗多少可以排序为：</p><ul><li>Shadowmask(Shadow Distance Mode)-&gt;Backed Indirect-&gt;Shadowmask(Shadowmask Mode)-&gt;Subtractive</li></ul><p>对比：</p><ul><li>Shadowmask：<font color=red>烘焙间接光照、最多四个光源的 shadowmask</font>(超出会直接将阴影及光照烘焙至光照贴图上，降级与 Subtractive 差不多)，所有对象均为实时直接光照。(比另外两种多了一张 Shadowmask 贴图)，动态与静态阴影可以存在融合。<ul><li>Shadow Distance Mode：范围内静态、动态均为实时直接光照、阴影，范围外静态对象为烘焙阴影。</li><li>Shadowmask Mode：静态对象使用 实时直接光照、烘焙间接光照、阴影、范围内动态对象为实时阴影(同上比另外两种多了一张 Shadowmask 贴图，最多可存4个灯光的 shadowmask，可与动态物体阴影混合)。</li></ul></li><li>Backed Indirect：<font color=red>仅烘焙间接光</font>，范围内静态、动态均为实时直接光照、阴影，范围外无阴影。</li><li>Subtractive：<font color=red>静态对象的所有直接光照、间接光照、阴影均烘焙</font>、范围内动态对象为实时阴影，范围外无阴影。Mixed 点光源对动态物体无阴影(这次应该没错了吧？)。静态物体无高光效果(使用 Reflection Probe 会有改善)。</li></ul><p>其它重要设置：</p><ul><li>Shadow Distance：范围内采用实时阴影，实际情况合理设置，在 Shadow Resolution 阴影分辨率不变的情况下，Shadow Distance 越大，显示质量反而可能降低。</li><li>Shadow Cascades：只对方向光有效，可以将阴影的渲染划分成对应的几块区域，提升近处阴影的分辨率占用，减轻近处阴影的锯齿感，当然也会产生更多性能消耗。经过实测开启后阴影会变得更加清晰(更硬)。</li><li>Shadow Projection：默认为 Stable Fit，整体阴影分辨率不变的情况下 Close Fit 可以进一步的提高近处物件的阴影分辨率，同时也有更高的开销</li><li>光照贴图 UV 可以在模型设置上启用 Generate Lightmap UVs 自动生成。</li><li>Direction Mode：设置为 Direction 会多烘焙一张光源方向贴图，可用于模型法线计算。</li><li>Lightmap Resolution：设置越大越精细，当占用量超出 MaxLightMapSize 就会导致烘焙出多份光照贴图的情况。</li></ul><p>参考文档：</p><ul><li><a href="https://docs.unity3d.com/cn/2021.3/Manual/LightingGiUvs.html">LightingGiUvs</a></li><li><a href="https://docs.unity.cn/2021.3/Documentation/Manual/lighting-mode.html">lighting-mode</a></li><li><a href="http://ma-yidong.com/2017/09/02/mixed-lighting-lightmap-shader-in-unity/">mixed-lighting-lightmap-shader-in-unity</a></li><li><a href="https://blog.csdn.net/zengjunjie59/article/details/111356636">Unity接收阴影</a></li><li><a href="https://zhuanlan.zhihu.com/p/478431671">Unity中的混合光照</a></li><li><a href="https://zhuanlan.zhihu.com/p/68841952">Unity移动平台下的光照烘焙及优化</a></li><li><a href="https://www.zhihu.com/question/289621666">Unity 为什么使用screen space shadow</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前几天跟同事讨论 Unity Lightmap ，在 Shader(自定义) 中是怎么取的，然后我说 Unity 在 Shader 中直接会</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://cwhisme.github.io/categories/Unity3D/"/>
    
    
  </entry>
  
  <entry>
    <title>打包 AssetBundle 的基础规则整理</title>
    <link href="https://cwhisme.github.io/2022/11/23/%E6%89%93%E5%8C%85AssetBundle%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86/"/>
    <id>https://cwhisme.github.io/2022/11/23/%E6%89%93%E5%8C%85AssetBundle%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86/</id>
    <published>2022-11-23T10:12:11.000Z</published>
    <updated>2022-12-11T02:01:22.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前其实有写一篇 『<a href="">AssetBundle 的实际测试与总结</a>』的文章，不过现在看了下，感觉漏了一些，而且不够完善。</p><p>但是感觉改又不好改了，于是新建了一篇文章，重新整理一下。</p><p>主要使用工具有：</p><ul><li>Unity3D 2018.4.36f1</li><li>Unity3D 2021.3.6f1</li><li>Microsoft Visual Studio 2022</li><li>Unity 工具：AssetBundles-Browser-1.7.0</li></ul><h2 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h2><p>已知目前 Unity 主要提供了两种方式打 AssetBundle 包</p><ul><li>一种是全打，根据整个项目资源的 AssetBundleName 标记自动生成，该过程全自动化，只有设置 AssetBundleName 这个步骤可以人为控制</li><li>另一种是单打，根据传入的资源路径、指定的 AssetBundleName 单独生成指定资源的 AssetBundle 包</li></ul><p>均为一个接口的两个重载：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全打接口，根据项目已设置 AssetBundleName 的资源</span></span><br><span class="line"><span class="comment">//传入参数为 整个输出路径、打包选项及打包平台</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AssetBundleManifest <span class="title">BuildAssetBundles</span>(<span class="params"><span class="built_in">string</span> outputPath, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//单打接口，可以传入一个『需要打包』的资源列表、打包选项及打包平台</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AssetBundleManifest <span class="title">BuildAssetBundles</span>(<span class="params"><span class="built_in">string</span> outputPath, AssetBundleBuild[] builds, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform</span>)</span></span><br></pre></td></tr></table></figure><h3 id="公共参数"><a href="#公共参数" class="headerlink" title="公共参数"></a>公共参数</h3><p>其中公共参数为：</p><ul><li>BuildAssetBundleOptions</li><li>BuildTarget</li></ul><h4 id="BuildTarget"><a href="#BuildTarget" class="headerlink" title="BuildTarget"></a>BuildTarget</h4><p>BuildTarget 就像名字一样很简单，主要是具体为哪个平台打的资源包，最简单的方式是直接使用 <code>EditorUserBuildSettings.activeBuildTarget</code> 即可。</p><p>或者利用预定义：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_STANDALONE_WIN</span></span><br><span class="line"><span class="comment">//BuildTarget.StandaloneWindows64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> UNITY_IPHONE</span></span><br><span class="line"><span class="comment">//BuildTarget.iOS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> UNITY_ANDROID</span></span><br><span class="line"><span class="comment">//BuildTarget.Android</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>单独分平台判断也可以(用预定义的话，有必要的情况下这里还可以做些其它操作)。</p><h4 id="BuildAssetBundleOptions"><a href="#BuildAssetBundleOptions" class="headerlink" title="BuildAssetBundleOptions"></a>BuildAssetBundleOptions</h4><p>默认情况下 AssetBundle 压缩格式为 LZMA，这个选项可以额外选择设置为 不压缩 或者 LZ4 压缩格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BuildAssetBundleOptions.UncompressedAssetBundle</span><br><span class="line">BuildAssetBundleOptions.ChunkBasedCompression</span><br></pre></td></tr></table></figure><p>可能有人会好奇两个同时传入会如何(比如说我)?</p><p>试了下编辑器会直接报错，提示：</p><blockquote><p><font color=red>Cannot use options UncompressedAssetBundle and ChunkBasedCompression at the same time.</font></p></blockquote><p>其它比较重要的还有：</p><h5 id="1）BuildAssetBundleOptions-DeterministicAssetBundle"><a href="#1）BuildAssetBundleOptions-DeterministicAssetBundle" class="headerlink" title="1）BuildAssetBundleOptions.DeterministicAssetBundle"></a>1）BuildAssetBundleOptions.DeterministicAssetBundle</h5><p><del>这个参数会保证同样的资源每次打出来的 AssetBundle 包二进制一致。</del></p><p><del>我的测试方式是：不传入该参数，先全打一次资源备份好，然后删除项目的 Library 再全打一次，就发现新的资源大小虽然跟原本的一样，但是内部二进制就有很大的不同了：<br>~~<br>~~(以下错误尝试及结论内容已删除)</del></p><p>经过反复尝试，多次试验后得出结果：DeterministicAssetBundle 似乎并非这个作用。<br>之所以第一次删除 Library 后打包得出结果不一致，主要是因为 Library 生成的缓存不一致。在试验中，除了第一次删除试验，之后每次重新删除 Library ，再重新打开，后续工程打出来的 AssetBundle 包对比文件均一致了。</p><p>尝试在一个工程同时打出带 DeterministicAssetBundle 及不带该选项的资源包，结果最终生成的二进制 AssetBundle 资源包同样完全一致：</p><p><img src="/blogimages/2022/2022-11-23/m_bc96359133bb56dd0d1223b6639bf8d5_r.png"></p><p>只有在单打某个资源时，该选项打出的资源包才会产生差异。</p><p>说明这个选项，至少在同一个环境下全打资源是不会对 AssetBundle 资源包产生任何影响的。</p><p><a href="https://docs.unity.cn/cn/current/ScriptReference/BuildAssetBundleOptions.DeterministicAssetBundle.html">官方文档说明</a>：</p><blockquote><p>重新构建资源包时，资源包中对象的 ID 将在完成重新构建后 保持不变。<br> 从 DeterministicAssetBundle 中加载内容也比一般资源包要慢。</p></blockquote><p>那么这个选项究竟是起什么作用呢？有坏处，却没说明白好处。</p><p>官方的说明文档信息太少了，反复斟酌之后，偶然看到了说明的最后一行文字：</p><blockquote><p>注意：此功能会始终启用。</p></blockquote><p>……原来如此？难怪传入不传入，都没有影响。</p><p>后来又经过多方查找后，还看到有说找 Unity官方确认，确定 Unity5.X 以后的确是默认加入的选项了：</p><blockquote><p><a href="https://answer.uwa4d.com/question/5a7a8b23847802258a065038">https://answer.uwa4d.com/question/5a7a8b23847802258a065038</a></p></blockquote><p>然后后续继续查找资料，在 Unity官方论坛 <a href="https://forum.unity.com/threads/is-the-deterministic-asset-bundle-option-obsolete.455510/">Is the deterministic asset bundle option obsolete?</a> 帖子也提到了同样的困惑，Unity 官方人员回答说该选项已经无效：</p><blockquote><p>It’s a bit of a mess, but yes, it’s enabled permanently - the option has no effect.</p></blockquote><p>但是为什么单打时，这个选项针对同一个资源，又会产生影响了？</p><p>测试单打资源显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BuildAssetBundleOptions.None: 54.7 KB (56,036 字节)</span><br><span class="line">BuildAssetBundleOptions.DeterministicAssetBundle：54.7 KB (56,039 字节)</span><br></pre></td></tr></table></figure><p>传入 DeterministicAssetBundle 选项时增加了 3 个字节大小，那么是否可以怀疑，单打时依然会有影响，官方说的『始终启用』仅针对全打资源的情况？</p><p>毕竟单打时的引用关系处理，跟全打也是有差异的。</p><p>所以这里可以总结为：该选项主要用于生成确定性 ID 以处理重新打包资源时依赖、引用关系，确保增量打包时没有真实修改的资源不会被重打。目前 Unity 全打接口已默认包含该项，且无论是否传入均不影响，单打资源时才会有影响且导致资源产生差异。</p><h5 id="2）BuildAssetBundleOptions-DisableWriteTypeTree"><a href="#2）BuildAssetBundleOptions-DisableWriteTypeTree" class="headerlink" title="2）BuildAssetBundleOptions.DisableWriteTypeTree"></a>2）BuildAssetBundleOptions.DisableWriteTypeTree</h5><p>禁用写入类型树。</p><p>根据相关介绍，这个为了给Unity跨版本之间做兼容性用的，在真机包出包版本与热更资源都是由一个版本出包情况下，这个选项可以考虑传入以优化性能。</p><p>禁用后可以降低包体和内存并提高加载效率，但是可能会造成 Unity 版本的兼容问题。</p><p>原理是根据序列化的字段进行反序列化，例如我们资源 meta 版本都有 serializedVersion ，以区分各个版本序列化选项情况，不同版本每个选项可能并不一致。</p><p>开启写入类型树时，Unity 在打 AssetBundle 时会先把数据内容的树状结构先写入一遍，然后再写入对应值，这样在加载 AssetBundle 时，先解析出字段的树状结构，然后与真机包包体的解析结构进对比，再解析实际数据值，处理缺失或多余字段，避免反序列化出错(错位)。</p><p>如果不写入，那就是直接根据顺序去反序列化了，换了 Unity 版本字段可能就会反序列化错位，导致出现问题。</p><p>为了确定上述说法，可以进行一个简单的测试。</p><p>我用 Unity2018.4.36f1 打了两个 Cube.prefab AssetBundle 资源包，分为默认启用以及禁用，压缩模式为 不压缩：</p><p><img src="/blogimages/2022/2022-11-23/m_ce296dced15e16733103cfb044033bab_r.png"></p><p>然后在 Unity2021.3.6f1 中进行加载测试：</p><p><img src="/blogimages/2022/2022-11-23/m_334251ea9573f4af016c1fdf351a5600_r.png"></p><p>默认打包模式是可以直接读取的(虽然按照名字加载失败了)，确实加载到了对应资源。<br>场景中也可以利用 <code>GameObject.Instantiate(x[0] as GameObject);</code> 正确实例化出来。</p><p>而换成加载 『cube2018_disablewritetypetree』则直接报错，提示：</p><blockquote><p>The AssetBundle ‘Assets\MyBundles\cube2018_disablewritetypetree’ could not be loaded because it contains run-time classes of incompatible version. Rebuild the AssetBundle to fix this error.</p></blockquote><p>对于上述测试，利用 AssetBundles-Browser 也可以直接看出问题，默认的可以预览 Cube 各项属性，DisableWriteTypeTree 的资源版本则报同样错误。</p><p>如图所示：</p><p><img src="/blogimages/2022/2022-11-23/m_d2487c01c62a4a665b66a3d1deab67a2_r.png"></p><p>当然，这个兼容性也有代价，首先每个 AssetBundle 都得包含额外的 TypeTree 信息，加载 AssetBundle 资源时会先构建这个 TypeTree 结构，然后再解析字段，增加部分 CPU 和 内存消耗。</p><h5 id="3）BuildAssetBundleOptions-ForceRebuildAssetBundle"><a href="#3）BuildAssetBundleOptions-ForceRebuildAssetBundle" class="headerlink" title="3）BuildAssetBundleOptions.ForceRebuildAssetBundle"></a>3）BuildAssetBundleOptions.ForceRebuildAssetBundle</h5><p>默认为增量构建，基于上一次的打包结果，对发生变化的资源重新打包，若传入这个参数，会完全重新打一次。<br>经过测试，增量构建的关键点在于 Unity 为每个 AssetBundle 资源同时生成的 .manifest 文件。<br><font color=red>注1：删除文件的 .manifest 也会产生同样的效果。<br>注2：我们项目的 AssetBundle 关系由自己维护，尝试打完了之后删除 .manifest 节省空间，发现会被重新全打一次。<br>注3：关系总表的 .manifest 对其它资源不产生影响，只删除某个资源的 .manifest 就会导致该资源直接被重打。</font></p><h5 id="4）DisableLoadAssetByFileName、DisableLoadAssetByFileNameWithExtension"><a href="#4）DisableLoadAssetByFileName、DisableLoadAssetByFileNameWithExtension" class="headerlink" title="4）DisableLoadAssetByFileName、DisableLoadAssetByFileNameWithExtension"></a>4）DisableLoadAssetByFileName、DisableLoadAssetByFileNameWithExtension</h5><p>禁用使用 名字加载，这两个选项只影响内置的 AssetBundle.LoadAsset 方法。</p><p>如通过 AssetBundle.LoadAllAssets 加载后根据名字判断依然可行。</p><p>文件名+扩展名会在加载成功后生成，取决于项目的 AssetBundle 资源具体加载方式，可以传入减少一点点内存占用。例如通过全路径或者 AssetBundleRequest allAssets 自己判断方式。</p><p>例如，我们通常通过 AssetBundle.LoadAllAssets(LoadAllAssetsAsync) 加载全部资源，然后管理，AssetBundle 自带的 LoadAsset 接口是不会使用的，此时就可以禁用名字加载。</p><p>测试代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> pathDir = System.IO.Path.Combine(Application.dataPath, <span class="string">&quot;MyBundles&quot;</span>);</span><br><span class="line">AssetBundle assetBundle = AssetBundle.LoadFromFile(Path.Combine(pathDir, Name));</span><br><span class="line">Object[] x = assetBundle.LoadAllAssets();</span><br><span class="line">Object o = assetBundle.LoadAsset(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line">Object o1 = assetBundle.LoadAsset(<span class="string">&quot;Cube.prefab&quot;</span>);</span><br><span class="line">Object o2 = assetBundle.LoadAsset(<span class="string">&quot;Assets/Cube.prefab&quot;</span>);</span><br><span class="line">Debug.Log(<span class="string">&quot;OK2&quot;</span>);</span><br></pre></td></tr></table></figure><p>表现如下：</p><p><img src="/blogimages/2022/2022-11-23/m_5b4b541cc358119d2bdfde8bf1e09a6d_r.png"></p><p>—————————————————————————————————————————</p><p>最后，简单测试一下各个不同选项打出来资源大小：</p><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LZMA：</span><br><span class="line">tex_default:272 KB (279,003 字节)</span><br><span class="line">tex_disablename：272 KB (278,994 字节)</span><br><span class="line">tex_disablewritetypetree：271 KB (278,163 字节)</span><br><span class="line">tex_disablewritetypetree_and_disablename：271 KB (278,147 字节)</span><br><span class="line"></span><br><span class="line">Uncompress:</span><br><span class="line">tex_default：466 KB (477,968 字节)</span><br><span class="line">tex_disablename：466 KB (477,984 字节)</span><br><span class="line">tex_disablewritetypetree：466 KB (477,904 字节)</span><br><span class="line">tex_disablewritetypetree_and_disablename：466 KB (477,936 字节)</span><br><span class="line"></span><br><span class="line">LZ4:</span><br><span class="line">tex_default：302 KB (309,643 字节)</span><br><span class="line">tex_disablename：302 KB (309,653 字节)</span><br><span class="line">tex_disablewritetypetree：300 KB (308,172 字节)</span><br><span class="line">tex_disablewritetypetree_and_disablename：300 KB (308,183 字节)</span><br></pre></td></tr></table></figure><h5 id="Prefab"><a href="#Prefab" class="headerlink" title="Prefab"></a>Prefab</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LZMA：</span><br><span class="line">tex_default：54.7 KB (56,036 字节)</span><br><span class="line">tex_disablename：54.7 KB (56,040 字节)</span><br><span class="line">tex_disablewritetypetree：47.6 KB (48,775 字节)</span><br><span class="line">tex_disablewritetypetree_and_disablename：47.6 KB (48,789 字节)</span><br><span class="line"></span><br><span class="line">Uncompress:</span><br><span class="line">tex_default：194 KB (198,880 字节)</span><br><span class="line">tex_disablename：194 KB (198,896 字节)</span><br><span class="line">tex_disablewritetypetree：116 KB (119,168 字节)</span><br><span class="line">tex_disablewritetypetree_and_disablename：116 KB (119,200 字节)</span><br><span class="line"></span><br><span class="line">LZ4:</span><br><span class="line">tex_default：80.2 KB (82,141 字节)</span><br><span class="line">tex_disablename：80.2 KB (82,148 字节)</span><br><span class="line">tex_disablewritetypetree：62.1 KB (63,668 字节)</span><br><span class="line">tex_disablewritetypetree_and_disablename：62.1 KB (63,678 字节)</span><br></pre></td></tr></table></figure><p>可以发现实际测试下来，在资源包大小上 DisableWriteTypeTree 影响更大，特别是 Prefab 资源，不压缩减少了 60% 左右、LZ4 模式减少了 25% 左右大小，LZMA 也有 13%。<br>虽然对纯图片资源这种(其它音效之类一样)减少不会很明显——差不多就 1KB 的样子，毕竟图片资源的 meta 项本身也不会太多。</p><p>相对来说禁止名字加载对资源包的大小基本就没什么影响了，顶多几个字节的差异(甚至是增加大小)，不过据说 DisableLoadAssetByFileName、DisableLoadAssetByFileNameWithExtension<br>更多是减少运行时内存——这一点在 <a href="https://docs.unity3d.com/ScriptReference/BuildAssetBundleOptions.DisableLoadAssetByFileName.html">官方文档</a> 也有明确说明，更详细的内存方面的对比，后续我会再进行详细测试。</p><h3 id="全打接口"><a href="#全打接口" class="headerlink" title="全打接口"></a>全打接口</h3><p>关于全打接口，大概可以总结如下基本规则：</p><ol><li><strong>资源与其引用资源都指定了不同的 AssetBunldeName ，会分别分离单打</strong></li><li><strong>没有指定 AssetBunldeName，那么会跟引用它的对象打一个包</strong></li><li><strong>没有指定 AssetBunldeName，存在多个对它的引用就会有多个副本，造成内存冗余</strong></li></ol><p>对于全打接口的工作原理，使用 AssetBundles-Browser 也可以比较清晰看出其关系。</p><p>设置对应的 AseetbundleName 之后，就会展示在 AssetBundles-Browser 中。</p><ol><li>Prefab 和 图片设置不同 AseetbundleName：<br><img src="/blogimages/2022/2022-11-23/m_2bd4afc7e2d136def3d3d0b3c35716bf_r.png"></li><li>只设置 Prefab AseetbundleName:<br><img src="/blogimages/2022/2022-11-23/m_06a422a91bf2e0782625afe388a5f7e2_r.png"></li><li>不指定 AssetbunldeName，而又有多个对它产生引用的对象，AssetBundles-Browser 都会直接进行提示：<br><img src="/blogimages/2022/2022-11-23/m_26177c9cb01b7f3e654c5b61cfd11c6b_r.png"><br>若忽略提示，打包出来结果如下：<br><img src="/blogimages/2022/2022-11-23/m_4b5774781fe0214bc8fa42a0fdae1c72_r.png"><br>两个 Assetbunlde 包就分别包含了两份同样的图片资源。</li></ol><p>调用全打接口代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;AssetBundleTest/PackALL&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Pack</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    BuildPipeline.BuildAssetBundles(Path.Combine(Application.dataPath, <span class="string">&quot;MyBundles&quot;</span>), BuildAssetBundleOptions.DeterministicAssetBundle, EditorUserBuildSettings.activeBuildTarget);</span><br><span class="line">    AssetDatabase.Refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于上述设置一，会生成两个分别包含 RawImage(test1) 和 Tex(tex) 的AssetBundle 资源包</li><li>对于上述设置二，会生成一个同时包含 RawImage 和 Tex 的 AssetBundle 资源包，名字为 『test1』</li><li>对于上述设置三，会生成两个同时包含 Prefab 和 图片的 AssetBundle 资源包，名字为 『test1』、『test2』</li></ul><p>使用 <a href="https://github.com/Perfare/AssetStudio">AssetStudio</a> 进行观察打出的 AssetBundle 资源包，可以验证与上述关系一致。</p><h3 id="单打接口"><a href="#单打接口" class="headerlink" title="单打接口"></a>单打接口</h3><p>单打接口实际规则，跟全打有一点差异。</p><p>总结规则如下：</p><ol><li><strong>若只有主资源存在列表，无论引用资源是否有设置其它 AssetBundleName，其引用资源会自动与主资源打成一个包</strong></li><li><strong>若将主资源及其引用资源都传入，且引用资源有自己的 AssetBundleName ，那么会分别根据各自的 AssetBundleName 单打</strong></li><li><strong><del>若将主资源及其引用资源都传入，但引用资源没有设置自己的 AssetBundleName ，那么引用资源都打入主资源一个包里。</del>(注：此处应当是因为触发了第一项规则)</strong></li></ol><p>与『全打资源』最大的区别，大概要数第一项：无论被引用资源是否设置自己的 AssetBundleName，只要这次单打没有传入引用资源，那么就会被打入主资源包里。</p><p>单打测试代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;AssetBundleTest/PackSelect(LZMA)&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PackSelectLZMA</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PackSelect(BuildAssetBundleOptions.DeterministicAssetBundle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PackSelect</span>(<span class="params">BuildAssetBundleOptions opt, <span class="built_in">string</span> extName = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Object o = Selection.activeObject;</span><br><span class="line">    <span class="built_in">string</span> path = AssetDatabase.GetAssetPath(o);</span><br><span class="line">    AssetImporter importer = AssetImporter.GetAtPath(path);</span><br><span class="line">    <span class="keyword">if</span> (importer == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    AssetBundleBuild build = <span class="keyword">new</span> AssetBundleBuild();</span><br><span class="line">    build.assetBundleName = <span class="built_in">string</span>.IsNullOrEmpty(extName) ? importer.assetBundleName : <span class="built_in">string</span>.Concat(importer.assetBundleName, <span class="string">&quot;_&quot;</span>, extName);</span><br><span class="line">    build.assetNames = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; path &#125;;</span><br><span class="line"></span><br><span class="line">    BuildPipeline.BuildAssetBundles(Path.Combine(Application.dataPath, <span class="string">&quot;MyBundles&quot;</span>), <span class="keyword">new</span> AssetBundleBuild[] &#123; build &#125;, opt, EditorUserBuildSettings.activeBuildTarget);</span><br><span class="line">    AssetDatabase.Refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上述『PackSelect』代码及上述资源为例，为 『RaweImage』『RaweImage2』及『Tex』分别设置不同的 AssetBunldeName，调用 PackSelect 传入各自的 AssetBunldeName 及资源路径分别进行单打操作，结果：<br><img src="/blogimages/2022/2022-11-23/m_24dd53cc74994ba2914dce5568cb0a08_r.png"><br>主资源及其引用图片被打进了一个包里。</p><p>对比调用 『PackALL』 全打资源结果：<br><img src="/blogimages/2022/2022-11-23/m_a445e82bab3e8e6d2ae40826775a5bd0_r.png"><br>其中 test1、test2 均引用了 tex 资源，从大小上看即可表明单打接口资源是被分别单打的了。</p><p>—————————————————————————————————————————</p><p>若单打资源，同时传入了主资源和引用资源呢？</p><p>稍微修改一下『PackSelect』代码，使其可以单打所有『当前选中』的资源：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;AssetBundleTest/PackSelectALL&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PackSelectALL</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Object[] o = Selection.GetFiltered&lt;Object&gt;(SelectionMode.Assets);</span><br><span class="line">    AssetBundleBuild[] buildArray = <span class="keyword">new</span> AssetBundleBuild[o.Length];</span><br><span class="line">    AssetImporter importer;</span><br><span class="line">    AssetBundleBuild build;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; buildArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        importer = AssetImporter.GetAtPath(AssetDatabase.GetAssetPath(o[i]));</span><br><span class="line">        build = <span class="keyword">new</span> AssetBundleBuild();</span><br><span class="line">        build.assetBundleName = importer.assetBundleName;</span><br><span class="line">        build.assetNames = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; importer.assetPath &#125;;</span><br><span class="line">        buildArray[i] = build;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BuildPipeline.BuildAssetBundles(Path.Combine(Application.dataPath, <span class="string">&quot;MyBundles&quot;</span>), buildArray, BuildAssetBundleOptions.DeterministicAssetBundle, EditorUserBuildSettings.activeBuildTarget);</span><br><span class="line">    AssetDatabase.Refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始研究这个单打接口，或许会写出这种单打当前选中所有资源的代码，然后总结出错误的结论(比如说我)：<del>若传入两个没有引用关系的资源，但是都为同一个 assetBundleName，单打会报错，只会生成其中一个资源的 assetBundle 包。</del></p><p>但要是深入一点测试、思考一下，就会发现这种写法是有问题的。</p><p>问题在哪儿呢？</p><p>首先尝试上述代码执行，选中两个设置了同一个 assetBundleName 的资源后，调用结果：</p><blockquote><p><font color=red>Trying to add file F:/Study/AssetbundleTest/Assets/MyBundles/tex.manifest to the list of ouptut files in the build report, but a file at that path has already been added.</font></p></blockquote><p>意思是添加的文件重复了，但明显资源名字是不同的，那问题可能就是在 assetBundleName？</p><p>然后往参数那边看，每一个 AssetBundleBuild 中的 assetNames 参数实际上是一个『数组』，也就是一系列的资源路径，所以对于单打接口，每个 AssetBundleBuild 都是独立的，它不会自动去判断传入的总列表中是否有重复的标签，因此需要我们手动去重：把同一个标签，重复的合并在一个结构中。</p><p>修改后代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;AssetBundleTest/PackSelectALL&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PackSelectALL</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Object[] o = Selection.GetFiltered&lt;Object&gt;(SelectionMode.Assets);</span><br><span class="line">    List&lt;AssetBundleBuild&gt; assetBundleBuilds = <span class="keyword">new</span> List&lt;AssetBundleBuild&gt;(o.Length);</span><br><span class="line">    AssetImporter importer;</span><br><span class="line">    AssetBundleBuild build;</span><br><span class="line">    <span class="built_in">int</span> index;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; o.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        importer = AssetImporter.GetAtPath(AssetDatabase.GetAssetPath(o[i]));</span><br><span class="line">        <span class="comment">//判断是否存在重复</span></span><br><span class="line">        index = assetBundleBuilds.FindIndex((x) =&gt; x.assetBundleName == importer.assetBundleName);</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            build = <span class="keyword">new</span> AssetBundleBuild();</span><br><span class="line">            build.assetBundleName = importer.assetBundleName;</span><br><span class="line">            build.assetNames = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; importer.assetPath &#125;;</span><br><span class="line">            assetBundleBuilds.Add(build);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//重复，则添加进去</span></span><br><span class="line">            build = assetBundleBuilds[index];</span><br><span class="line">            <span class="built_in">string</span>[] newAssets = <span class="keyword">new</span> <span class="built_in">string</span>[build.assetNames.Length + <span class="number">1</span>];</span><br><span class="line">            newAssets[<span class="number">0</span>] = importer.assetPath;</span><br><span class="line">            System.Array.Copy(build.assetNames, <span class="number">0</span>, newAssets, <span class="number">1</span>, build.assetNames.Length);</span><br><span class="line">            build.assetNames = newAssets;</span><br><span class="line">            assetBundleBuilds[index] = build;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BuildPipeline.BuildAssetBundles(Path.Combine(Application.dataPath, <span class="string">&quot;MyBundles&quot;</span>), assetBundleBuilds.ToArray(), BuildAssetBundleOptions.DeterministicAssetBundle, EditorUserBuildSettings.activeBuildTarget);</span><br><span class="line">    AssetDatabase.Refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次尝试，同一个 AssetBunldeName 没有引用关系的几个资源，顺利被打入同一个 AssetBundle 资源包。</p><h2 id="动画资源"><a href="#动画资源" class="headerlink" title="动画资源"></a>动画资源</h2><p>昨天主程会提到了动画脱壳，简单试一下资源包大小：</p><p><img src="/blogimages/2022/2022-11-23/m_0fbdab2ab9986238e383a031a9f9af5e_r.png"></p><p>上述分别为：</p><p>anim_off：带 FBX 动画，关闭 Anim.Compression<br>animall：带 FBX 动画，Anim.Compression 为默认的 KeyFramReduction<br>animreopt：不带 FBX 动画，Anim.Compression 为默认的 KeyFramReduction<br>animreduce：不带 FBX 动画，Anim.Compression 为 Optimal</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>调用全打资源接口时：</p><ol><li><strong>资源与其引用资源都指定了不同的 AssetBunldeName ，会分别分离单打</strong></li><li><strong>没有指定 AssetBunldeName，那么会跟引用它的对象打一个包</strong></li><li><strong>没有指定 AssetBunldeName，存在多个对它的引用就会有多个副本，造成内存冗余</strong></li></ol><p>调用单打资源接口时：</p><ol><li><strong>若只有主资源存在列表，无论引用资源是否有设置其它 AssetBundleName，其引用资源会自动与主资源打成一个包</strong></li><li><strong>若将主资源及其引用资源都传入，且引用资源有自己的 AssetBundleName ，那么会分别根据各自的 AssetBundleName 单打</strong></li></ol><p>取决于项目资源加载管理，可采用的优化选项：DisableWriteTypeTree、DisableLoadAssetByFileName、DisableLoadAssetByFileNameWithExtension</p><p>例如，像我们项目通过 AssetBundle.LoadAllAssets(LoadAllAssetsAsync) 加载全部资源，然后管理，AssetBundle 自带的 LoadAsset(Name) 接口是不会使用的，此时就可以禁用名字加载。(正常情况下加载一个资源，一般来说也是使用完整路径的)</p><p>另外，通常出包以及出热更包必然也是同一个 Unity 版本(应该不可能有 『项目还在线上就去动 release 分支 Unity 版本』的操作吧)，此时可以禁用写入类型树以优化内存及加载。</p><p><font color=red>其它：DeterministicAssetBundle 经测试与多方对比，可以认为全打资源默认始终包含该选项，仅单打资源时该项会对资源产生额外影响。(这大概也是为什么同为『始终启用』的 CollectDependencies 被标记为弃用，但它没有——大概就是因为 DeterministicAssetBundle 对于单打该选项还有效)</font></p><blockquote><p>参考文档：</p><ul><li><a href="https://docs.unity.cn/cn/current/ScriptReference/BuildPipeline.BuildAssetBundles.html">BuildPipeline.BuildAssetBundles</a></li><li><a href="https://docs.unity.cn/cn/current/Manual/AssetBundles-Building.html">AssetBundles-Building</a></li><li><a href="https://developer.unity.cn/projects/61566223edbc2a0021557364">Asset的一生</a></li><li><a href="https://www.cnblogs.com/ybgame/p/3973177.html">Unity AssetBundle爬坑手记</a></li><li><a href="https://answer.uwa4d.com/question/5a7a8b23847802258a065038">AB增量打包问题</a></li><li><a href="https://forum.unity.com/threads/is-the-deterministic-asset-bundle-option-obsolete.455510/">Is the deterministic asset bundle option obsolete?</a></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/BuildAssetBundleOptions.DeterministicAssetBundle.html">DeterministicAssetBundle</a></li><li><a href="https://docs.unity3d.com/ScriptReference/BuildAssetBundleOptions.DisableLoadAssetByFileName.html">DisableLoadAssetByFileName</a></li><li><a href="https://forum.unity.com/threads/assetbundles-and-dependencies.377760/">assetbundles-and-dependencies</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前其实有写一篇 『&lt;a href=&quot;&quot;&gt;AssetBundle 的实际测试与总结&lt;/a&gt;』的文章，不过现在看了下，感觉漏了一些，而且不够完</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://cwhisme.github.io/categories/Unity3D/"/>
    
    
  </entry>
  
  <entry>
    <title>StringBuilder 扩容规则研究</title>
    <link href="https://cwhisme.github.io/2022/11/18/StringBuilder%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E7%A0%94%E7%A9%B6/"/>
    <id>https://cwhisme.github.io/2022/11/18/StringBuilder%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E7%A0%94%E7%A9%B6/</id>
    <published>2022-11-18T09:37:51.000Z</published>
    <updated>2022-12-11T02:01:22.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上面 <a href="">对项目字符串性能优化方式及测试</a> 文章中，我查看了 StringBuilder 的源码，并总结出了 StringBuilder 的一般及自动扩容规则：</p><p>容量足够的情况下，通过 unsafe 方法进行指针及直接内存操作：</p><ol><li>获取添加的字符串指针</li><li>获取字符数组待添加下标指针</li><li>调用 Buffer.Memcpy 进行内存拷贝进字符数组</li></ol><p>如果后续容量不够，则进行动态扩容，不过动态扩容不是直接扩容字符数组，而是通过单向链表的方式：</p><p><strong>将当前数据全部转移至『上一个』节点，然后自己创建一个新的字符数组进行处理。</strong></p><p>简单来说，就是创建一个新的 StringBuilder，把自己当前所有数据转移过去，自己创建一个新的数组继续继续处理余下的。</p><p>然后就一直有个疑问：如何做到每次扩容是之前的 2 倍大小的？</p><p>然后现在研究半天发现，都知道实现扩容的具体方法是通过单链表，2 倍扩容的原理其实已经是明面上的规则了：是个非常简单的原理，只是思维上一直没考虑到而已，所以作个记录。</p><p>这里前言先不说具体原理，从试验和测试开始，具体的留到文后总结再写吧。 </p><h2 id="扩容测试"><a href="#扩容测试" class="headerlink" title="扩容测试"></a>扩容测试</h2><p>StringBuilder 默认容量是 16 个字符，如果测试扩容的话，数量太大容易混淆。</p><p>因此我传设置了默认的容量 1，并依次传入 1、2、3、4、5，并打印每个数值 Append 之后容量大小，测试代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 执行测试</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoTest</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">1</span>);</span><br><span class="line">    builder.Append(<span class="number">1</span>);</span><br><span class="line">    Console.WriteLine(builder.Capacity);</span><br><span class="line">    builder.Append(<span class="number">2</span>);</span><br><span class="line">    Console.WriteLine(builder.Capacity);</span><br><span class="line">    builder.Append(<span class="number">3</span>);</span><br><span class="line">    Console.WriteLine(builder.Capacity);</span><br><span class="line">    builder.Append(<span class="number">4</span>);</span><br><span class="line">    Console.WriteLine(builder.Capacity);</span><br><span class="line">    builder.Append(<span class="number">5</span>);</span><br><span class="line">    Console.WriteLine(builder.Capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>可以发现，每次扩容容量都是以 2 倍递增，所以为什么呢？</p><p>用反编译工具对 StringBuilder 的源代码看了又看，有点想不明白。</p><p>想不明白就像试一试，直接上调试大法，断点打到 StringBuilder 里边去：</p><p><img src="/blogimages/2022/2022-11-18/m_28c3073b4ee0fe17074da5a4471f73b6_r.png"></p><p>上述截图显示的是：当前 StringBuilder 容量为 2，且 Append(3) 的情况。</p><p>盯着这个看了下，计算了一下数值与结果，一个个分析下：</p><ul><li>minBlockCharCount 当前为 1</li><li>当前长度 Length 为 2</li><li>扩容长度为 Max(Length,minBlockCharCount)[8000 是翻倍上限，后续翻倍到这数量级后最多扩容 8000，除非传入字符串剩余字符大于 8000]</li><li>即扩容 Max(2,1)</li></ul><p>而 Length 在这里是个属性，点进 Length 去看：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前实际存储字符长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Length</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.m_ChunkOffset + <span class="keyword">this</span>.m_ChunkLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其由 m_ChunkOffset+m_ChunkLength 构成。</p><p>将代码往上一层的 <code>Append(char* value, int valueCount)</code> 方法移动：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当空间不足走扩容逻辑时</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//当前剩余容量</span></span><br><span class="line"><span class="built_in">int</span> num3 = <span class="keyword">this</span>.m_ChunkChars.Length - <span class="keyword">this</span>.m_ChunkLength;</span><br><span class="line"><span class="keyword">if</span> (num3 &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//剩余容量大于0，就先复制一部分填满</span></span><br><span class="line"><span class="keyword">new</span> ReadOnlySpan&lt;<span class="built_in">char</span>&gt;((<span class="keyword">void</span>*)<span class="keyword">value</span>, num3).CopyTo(<span class="keyword">this</span>.m_ChunkChars.AsSpan(<span class="keyword">this</span>.m_ChunkLength));</span><br><span class="line"><span class="comment">//m_ChunkLength 设置为字符数组满长度</span></span><br><span class="line"><span class="keyword">this</span>.m_ChunkLength = <span class="keyword">this</span>.m_ChunkChars.Length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//至少扩容长度=添加字符串长度-剩余已添加字符长度</span></span><br><span class="line"><span class="built_in">int</span> num4 = valueCount - num3;</span><br><span class="line"><span class="comment">//执行扩容</span></span><br><span class="line"><span class="keyword">this</span>.ExpandByABlock(num4);</span><br><span class="line"><span class="comment">//将剩余字符复制进扩容后的字符数组（以前的已经变成链表的上一个节点了）</span></span><br><span class="line"><span class="keyword">new</span> ReadOnlySpan&lt;<span class="built_in">char</span>&gt;((<span class="keyword">void</span>*)(<span class="keyword">value</span> + num3), num4).CopyTo(<span class="keyword">this</span>.m_ChunkChars);</span><br><span class="line"><span class="comment">//设置当前 StringBuilder 已使用长度</span></span><br><span class="line"><span class="keyword">this</span>.m_ChunkLength = num4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，每次扩容之前，前一个数组必然是被填满的，也就是说：</p><ul><li>m_ChunkLength=上一个节点实际使用字符长度</li><li>m_ChunkOffset 直接可以在扩容方法中看到，为前面所有节点的 m_ChunkLength(通过+=赋值的)</li></ul><p>由此可以得出结果：在扩容的时候，Length=this.m_ChunkOffset + this.m_ChunkLength=所有节点的总长度<br>(注：只有在扩容的时候才是如此，否则 Capacity[this.m_ChunkChars.Length + this.m_ChunkOffset] 才是就算没装满的所有节点的总容量)</p><p>当依照 所有节点的总长度 创建一个新节点的时候，新节点的字符数组长度即为之前所有节点总和。</p><p>这时候统计的就是新的节点加上以前所有节点长度，两者相加：相当于就扩容了两倍！</p><p>例如旧的所有节点相加为 32，扩容的新节点为 32，那么新的总节点容量就是 64…..以此类推。</p><p>然后就焕然大悟了，原来这么回事啊。</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>现在知道扩容为什么是翻倍的了。</p><p>然后在这个过程中，突然想到插入问题，插入与追加显然是不同的方法：比较单链表的模式，每个链表节点都是一个单独数组，想往前面的数组插入值？</p><p>想想这种模式插入就不大好办，看了下 Insert 代码，插入一次就得创建一个 StringBuilder(除非之前的节点有空闲空间，正常情况下不可能)</p><p>而且，不遵守扩容规则：最大为扩容字符串长度，最小为默认的 16 个字符，然后重连链表结构。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MakeRooms：每次调用插入，都会先创建一个 StringBuilder 占位，然后填充数据，一一处理链表节点</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(Math.Max(count, <span class="number">16</span>), chunk.m_MaxCapacity, chunk.m_ChunkPrevious);</span><br></pre></td></tr></table></figure><p>如果插入的下标正好还处于某一个节点字符数据中间，还需要遍历链表通过 CopyTo 移动数据，所以插入操作是比较耗时的。</p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>为此我尝试使用 TestRunner 进行测试，分别测试 追加、插入开始、插入中间、插入结束的性能。</p><p>每个操作分别进行 100000 次，测试代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> TestNum = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestAppend</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.Append(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Log(<span class="string">&quot;TestAppend Capacity&quot;</span> + builder.Capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestInsertStart</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.Insert(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Log(<span class="string">&quot;TestInsertStart Capacity&quot;</span> + builder.Capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestInsertMiddle</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.Insert(builder.Length / <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Log(<span class="string">&quot;TestInsertMiddle Capacity&quot;</span> + builder.Capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestInsertEnd</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.Insert(builder.Length, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Log(<span class="string">&quot;TestInsertEnd Capacity&quot;</span> + builder.Capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestAppendNormalParams</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.Append(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">        builder.Append(<span class="number">1</span>);</span><br><span class="line">        builder.Append(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Log(<span class="string">&quot;TestAppendNormalParams Capacity：&quot;</span> + builder.Capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestAppendFormatParams</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.AppendFormat(<span class="string">&quot;X&#123;0&#125;Y&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Log(<span class="string">&quot;TestAppend Capacity：&quot;</span> + builder.Capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TestAppend (0.026s)</span><br><span class="line">---</span><br><span class="line">TestAppend Capacity104192</span><br><span class="line"></span><br><span class="line">TestAppendNormalParams (0.030s)</span><br><span class="line">---</span><br><span class="line">TestAppendNormalParams Capacity：304192</span><br><span class="line"></span><br><span class="line">TestAppendFormatParams (0.032s)</span><br><span class="line">---</span><br><span class="line">TestAppend Capacity：304192</span><br><span class="line"></span><br><span class="line">TestInsertStart (5.795s)</span><br><span class="line">---</span><br><span class="line">TestInsertStart Capacity100000</span><br><span class="line"></span><br><span class="line">TestInsertMiddle (2.852s)</span><br><span class="line">---</span><br><span class="line">TestInsertMiddle Capacity100000</span><br><span class="line"></span><br><span class="line">TestInsertEnd (0.069s)</span><br><span class="line">---</span><br><span class="line">TestInsertEnd Capacity100000</span><br></pre></td></tr></table></figure><p>由于插入操作必须对插入节点后续的节点作额外处理，因此插入越靠前消耗越大，可以看出即使是直接插入最后一个节点，也是比追加字符操作更为耗时的，所以使用 StringBuilder 时，尽量不要采用插入操作。</p><p>另外 AppendFormat 采用了与 string.Format 类似的处理方式：遍历字符串找占位符，因此也会造成多余消耗(这里因为只有一个占位符，因此与普通3次追加差距不大，但消耗确实也多了，占位符越多消耗越大)。</p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>之前看源码，插入时通过创建一个新的 StringBuilder 插入链表，且默认最小容量为 16。</p><p>但是现在为什么打印出来的 Capacity 容量，这里插入操作的增加反而最小？难道之前分析错了？</p><p>—————————————————————————————————————————</p><p>于是另外写了一份更简单的插入代码，查看链表插入节点信息：</p><p><img src="/blogimages/2022/2022-11-18/m_71f1f5a195aab49f88c42ce132b4910e_r.png"></p><p><strong>Capacity=this.m_ChunkChars.Length + this.m_ChunkOffset<br>m_ChunkLength=上一个节点实际使用字符长度<br>m_ChunkChars.Length=字符数组长度<br>m_ChunkOffset=之前节点实际使用长度总和</strong></p><p>这里插入起始的这个节点，真实容量 Capacity=16<br>但是到了后续节点，由于后边节点只统计实际使用长度，后续节点 Capacity=1+当前字符数组长度 ，导致只统计了插入字符串实际长度大小，容量就变回去了。</p><p>所以对于插入的节点，测试打印出来的 Capacity 增加很小是个错觉，每个插入的 StringBuilder 依然还是有占用，至少 16 个空字符数组大小。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后发现原因就是这么简单：因为是链表结构，扩容的新节点长度等于以前节点总和，所以同样有了倍增的效果。</p><p>不过插入操作则会打乱倍增规律：例如原本 4 个下一次倍增应该为 8，若此时插入一个字符，下一次则扩容为 10。</p><p>另外 AppendFormat 原理与普通 string.Format 类似：遍历字符串找占位符，因此也会造成多余消耗。</p><p>同时顺便测试了下追加与插入等操作的性能，插入原理是创建一个新的、至少 16 个字符容量的 StringBuilder，性能消耗很大，因此得出尽量不要使用插入操作的结论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在上面 &lt;a href=&quot;&quot;&gt;对项目字符串性能优化方式及测试&lt;/a&gt; 文章中，我查看了 StringBuilder 的源码，并总结出了 St</summary>
      
    
    
    
    <category term="C#" scheme="https://cwhisme.github.io/categories/C/"/>
    
    
    <category term="性能优化" scheme="https://cwhisme.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>简单测试手动垃圾回收</title>
    <link href="https://cwhisme.github.io/2022/11/17/%E6%B5%8B%E8%AF%95%E6%89%8B%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://cwhisme.github.io/2022/11/17/%E6%B5%8B%E8%AF%95%E6%89%8B%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2022-11-17T08:28:06.000Z</published>
    <updated>2022-12-11T02:01:22.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这两天又复习了下垃圾回收机制，在看到 析构函数 的时候，突然想到：析构函数是在真正垃圾回收时才会执行的，那么是否可以用这个来测试一个对象，什么情况下可以立即被垃圾回收？或者说变成垃圾对象。</p><p>例如，使用完毕后立即赋值为空，它变成垃圾对象了吗？还是其它什么时机才会。</p><p>测试方式为：在不同场景下，调用 GC.Collect ，并查看运行结果：析构函数是否被调用。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>工具：</p><ul><li>VS2022</li><li>.Net6.0</li><li>测试类：<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Doing！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~TestClass()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;被垃圾被回收了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="1）情景一：方法内部定义对象使用后赋值为空"><a href="#1）情景一：方法内部定义对象使用后赋值为空" class="headerlink" title="1）情景一：方法内部定义对象使用后赋值为空"></a>1）情景一：方法内部定义对象使用后赋值为空</h3><p>方法内立即调用 GC.Collect()</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 执行测试</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoTest</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestMethod();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestMethod</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestClass test = <span class="keyword">new</span> TestClass();</span><br><span class="line">        test.DoSomething();</span><br><span class="line">        test = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        GC.Collect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Doing！</span><br></pre></td></tr></table></figure><p>析构函数未被调用。</p><p>将 GC.Collect() 方法调用移动到 DoTest() 方法的 TestMethod() 调用之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Doing！</span><br><span class="line">被垃圾被回收了！</span><br></pre></td></tr></table></figure><p>析构函数被调用了。</p><p>将 <code>test = null</code>去掉，依然执行了析构函数。</p><blockquote><h4 id="结论：方法块内的代码，使用完毕后无论是否赋值为空，都不会立即变成垃圾，当方法块结束后才会自动成为垃圾对象，能够被垃圾回收处理。"><a href="#结论：方法块内的代码，使用完毕后无论是否赋值为空，都不会立即变成垃圾，当方法块结束后才会自动成为垃圾对象，能够被垃圾回收处理。" class="headerlink" title="结论：方法块内的代码，使用完毕后无论是否赋值为空，都不会立即变成垃圾，当方法块结束后才会自动成为垃圾对象，能够被垃圾回收处理。"></a>结论：方法块内的代码，使用完毕后无论是否赋值为空，都不会立即变成垃圾，当方法块结束后才会自动成为垃圾对象，能够被垃圾回收处理。</h4></blockquote><h3 id="2）情景二：全局变量方法内部使用后赋值为空"><a href="#2）情景二：全局变量方法内部使用后赋值为空" class="headerlink" title="2）情景二：全局变量方法内部使用后赋值为空"></a>2）情景二：全局变量方法内部使用后赋值为空</h3><p>方法内立即调用 GC.Collect()</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestClass _test;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 执行测试</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoTest</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestMethod();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestMethod</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _test = <span class="keyword">new</span> TestClass();</span><br><span class="line">        _test.DoSomething();</span><br><span class="line">        _test = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        GC.Collect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Doing！</span><br></pre></td></tr></table></figure><p>析构函数未被调用。</p><p>将 GC.Collect() 方法调用移动到 DoTest() 方法的 TestMethod() 调用之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Doing！</span><br><span class="line">被垃圾被回收了！</span><br></pre></td></tr></table></figure><p>析构函数被调用了。</p><blockquote><h4 id="结论：全局变量方法内部使用后赋值为空，在该方法结束后，才会变成垃圾对象。"><a href="#结论：全局变量方法内部使用后赋值为空，在该方法结束后，才会变成垃圾对象。" class="headerlink" title="结论：全局变量方法内部使用后赋值为空，在该方法结束后，才会变成垃圾对象。"></a>结论：全局变量方法内部使用后赋值为空，在该方法结束后，才会变成垃圾对象。</h4></blockquote><h3 id="3）情景三：委托方法中包含对象"><a href="#3）情景三：委托方法中包含对象" class="headerlink" title="3）情景三：委托方法中包含对象"></a>3）情景三：委托方法中包含对象</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 执行测试</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoTest</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Action callback = TestMethod;</span><br><span class="line">        callback.Invoke();</span><br><span class="line">        GC.Collect();</span><br><span class="line">        GC.WaitForPendingFinalizers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestMethod</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestClass test = <span class="keyword">new</span> TestClass();</span><br><span class="line">        test.DoSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Doing！</span><br><span class="line">被垃圾被回收了！</span><br></pre></td></tr></table></figure><p>析构函数被调用了。</p><p>此处改成：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Action callback = () =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    TestClass test = <span class="keyword">new</span> TestClass();</span><br><span class="line">    test.DoSomething();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果一致。</p><blockquote><h4 id="结论：委托、匿名方法本身新建的局部变量，会按照正常的方法调用规则在调用结束后释放。"><a href="#结论：委托、匿名方法本身新建的局部变量，会按照正常的方法调用规则在调用结束后释放。" class="headerlink" title="结论：委托、匿名方法本身新建的局部变量，会按照正常的方法调用规则在调用结束后释放。"></a>结论：委托、匿名方法本身新建的局部变量，会按照正常的方法调用规则在调用结束后释放。</h4></blockquote><h3 id="4）情景四：匿名方法中包含对象"><a href="#4）情景四：匿名方法中包含对象" class="headerlink" title="4）情景四：匿名方法中包含对象"></a>4）情景四：匿名方法中包含对象</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 执行测试</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoTest</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestMethod().Invoke();</span><br><span class="line">        GC.Collect();</span><br><span class="line">        GC.WaitForPendingFinalizers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Action <span class="title">TestMethod</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestClass test = <span class="keyword">new</span> TestClass();</span><br><span class="line">        <span class="comment">//test.DoSomething();</span></span><br><span class="line">        <span class="keyword">return</span> () =&gt; test.DoSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Doing！</span><br></pre></td></tr></table></figure><p>析构函数未被调用，对象生命周期应该变成 DoTest 的了。</p><p>测试方法如下，在调用 DoTest 方法处再进行 GC.Collect 调用：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MainClass main = <span class="keyword">new</span> MainClass();</span><br><span class="line">main.DoTest();</span><br><span class="line">GC.Collect();</span><br><span class="line">GC.WaitForPendingFinalizers();</span><br></pre></td></tr></table></figure><p>则执行了析构函数。</p><p>缓存为类的全局变量：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Action callback;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 执行测试</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoTest</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    callback = TestMethod();</span><br><span class="line">    callback.Invoke();</span><br><span class="line">    callback = <span class="literal">null</span>;</span><br><span class="line">    GC.Collect();</span><br><span class="line">    GC.WaitForPendingFinalizers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未执行析构函数，除非与上述一样在 DoTest 执行完毕后调用 GC.Collect。</p><blockquote><h4 id="结论：匿名方法中引用了局部变量，会增加局部变量对象生命周期，提升至委托的调用-存放-级别，规则与普通对象一致——委托不被置为空，变量也会一直存活。"><a href="#结论：匿名方法中引用了局部变量，会增加局部变量对象生命周期，提升至委托的调用-存放-级别，规则与普通对象一致——委托不被置为空，变量也会一直存活。" class="headerlink" title="结论：匿名方法中引用了局部变量，会增加局部变量对象生命周期，提升至委托的调用(存放)级别，规则与普通对象一致——委托不被置为空，变量也会一直存活。"></a>结论：匿名方法中引用了局部变量，会增加局部变量对象生命周期，提升至委托的调用(存放)级别，规则与普通对象一致——委托不被置为空，变量也会一直存活。</h4></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在方法块内对某个对象赋值为空，不管是全局还是局部变量，该对象并不能立刻成为『垃圾』，至少等该方法块执行完毕后，才可能能够被回收。</p><p>若存在匿名方法使用了局部变量，其生存周期与委托绑定。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这两天又复习了下垃圾回收机制，在看到 析构函数 的时候，突然想到：析构函数是在真正垃圾回收时才会执行的，那么是否可以用这个来测试一个对象，什</summary>
      
    
    
    
    <category term="C#" scheme="https://cwhisme.github.io/categories/C/"/>
    
    
    <category term="性能优化" scheme="https://cwhisme.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>音效资源设置测试与总结</title>
    <link href="https://cwhisme.github.io/2022/11/08/%E9%9F%B3%E6%95%88%E8%B5%84%E6%BA%90%E8%AE%BE%E7%BD%AE%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <id>https://cwhisme.github.io/2022/11/08/%E9%9F%B3%E6%95%88%E8%B5%84%E6%BA%90%E8%AE%BE%E7%BD%AE%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%BB%E7%BB%93/</id>
    <published>2022-11-08T09:25:53.000Z</published>
    <updated>2022-12-11T02:01:22.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>之前虽然有用过，但是并没有对其做个人的整理与总结，只大概知道哪个选项会造成什么情况，此处进行一次详尽的实际测试并总结。</p><h2 id="0x02-工具"><a href="#0x02-工具" class="headerlink" title="0x02 工具"></a>0x02 工具</h2><ul><li>Unity2021.3.6f1</li><li>UnityProfiler</li><li>音效：<img src="/blogimages/2022/2022-11-08/m_2c999f422afd7de75758f0b6ae7a97c5_r.png"></li></ul><h2 id="0x03-设置选项"><a href="#0x03-设置选项" class="headerlink" title="0x03 设置选项"></a>0x03 设置选项</h2><h3 id="1-LoadType"><a href="#1-LoadType" class="headerlink" title="1. LoadType"></a>1. LoadType</h3><p>分为三个选项，这个选择比较重要：直接决定音效在内存中的大小。</p><h4 id="1-加载即解压-Decompress-On-Load"><a href="#1-加载即解压-Decompress-On-Load" class="headerlink" title="1). 加载即解压(Decompress On Load)"></a>1). 加载即解压(Decompress On Load)</h4><p>性能最好，不过会占用更多内存。</p><p>在内存中的大小至少是选择 PCM 压缩格式在 ImportedSize 的预览大小——因为在选择 Vorbis 后，再选择解压到内存会多一些。</p><p>分别查看设置对应压缩格式后，Imported Size 以及利用 Profiler 查看运行时内存大小。<br>对比如下：</p><ul><li>PCM：<br>  Imported Size：306KB<br>  运行时内存：309.6KB(+3.6KB)</li><li>ADPCM：<br>  Imported Size：86.2KB<br>  运行时内存：310.1KB(+4KB)</li><li>Vorbis(1%质量)：<br>  Imported Size：13.9KB<br>  运行时内存：343.2KB(+37.2KB)</li><li>Vorbis(70%质量)：<br>  Imported Size：16.6KB<br>  运行时内存：345.7KB(+39.7KB)</li><li>Vorbis(100%质量)：<br>  Imported Size：22.9KB<br>  运行时内存：348.1KB(+42KB)</li></ul><p>采样率设置为 <strong>22050Hz</strong>：</p><ul><li>PCM：<br>  Imported Size：153.1KB<br>  运行时内存：156.7KB(+3.6KB)</li><li>ADPCM：<br>  Imported Size：43.1KB<br>  运行时内存：157.1KB(+4KB)</li><li>Vorbis(1%质量)：<br>  Imported Size：7.6KB<br>  运行时内存：192.9KB(+40KB)</li><li>Vorbis(70%质量)：<br>  Imported Size：9.5KB<br>  运行时内存：192.9KB(+40KB)</li><li>Vorbis(100%质量)：<br>  Imported Size：12KB<br>  运行时内存：192.9KB(+40KB)</li></ul><p>Decompress On Load 模式下，在内存中的音效大小与 PCM 的 ImportedSize 显示的大小差不多，其中 PCM 和 ADPCM 在这个基础上多了几KB，可能是其它数据。</p><p>而当 Vorbis 压缩格式采用 Decompress On Load 则会导致更多的额外内存消耗，平均 40KB 左右。<br><del>且会随着质量设置越高而增加。</del>，见下方『注1』，推测为音效源文件 44100Hz 有不一致的地方，手动设置为更低采样率后保存一致。</p><h4 id="2-压缩格式存放在内存-Compressed-In-Memory"><a href="#2-压缩格式存放在内存-Compressed-In-Memory" class="headerlink" title="2). 压缩格式存放在内存(Compressed In Memory)"></a>2). 压缩格式存放在内存(Compressed In Memory)</h4><p>播放时会额外消耗CPU解压，内存情况测试如下：</p><p>Original Size：<strong>32.8KB</strong></p><ul><li>PCM：<br>  Imported Size：306KB<br>  运行时内存：309.7KB(+3.7KB)</li><li>ADPCM：<br>  Imported Size：86.2KB<br>  运行时内存：90.7KB(+4.5KB)</li><li>Vorbis(1%质量)：<br>  Imported Size：13.9KB<br>  运行时内存：39.1KB(+25.2KB)</li><li>Vorbis(70%质量)：<br>  Imported Size：16.6KB<br>  运行时内存：44.1KB(+27.5KB)</li><li>Vorbis(100%质量)：<br>  Imported Size：22.9KB<br>  运行时内存：52.9KB(+30KB)</li></ul><p>采样率设置为 <strong>22050Hz</strong>：</p><ul><li>PCM：<br>  Imported Size：306KB<br>  运行时内存：309.7KB(+3.7KB)</li><li>ADPCM：<br>  Imported Size：86.2KB<br>  运行时内存：90.7KB(+4.5KB)</li><li>Vorbis(1%质量)：<br>  Imported Size：7.6KB<br>  运行时内存：35.3KB(+27.7KB)</li><li>Vorbis(70%质量)：<br>  Imported Size：9.5KB<br>  运行时内存：37.3KB(+27.7KB)</li><li>Vorbis(100%质量)：<br>  Imported Size：12KB<br>  运行时内存：39.8KB(+27.7KB)</li></ul><p>通过测试可以看出：</p><p>Compressed In Memory 模式下，PCM 和 ADPCM 下内存占用情况为预览面板的 ImportedSize + 几KB，总体上差不多。</p><p>Vorbis 压缩模式会额外占用更多内存(大概多了 30KB 左右)。<br><del>且会随着质量设置越高而增加。</del>，见下方『注1』，推测为音效源文件 44100Hz 有不一致的地方，手动设置为更低采样率后保存一致。</p><h4 id="3-流式播放-Streaming"><a href="#3-流式播放-Streaming" class="headerlink" title="3). 流式播放(Streaming)"></a>3). 流式播放(Streaming)</h4><p>流式播放占用内存相对整个文件来说比较少——前提是音效文件本身大于 200KB，根据官方文档介绍，就算小于200KB的音效，采用流式播放也会产生 200KB 左右的缓存消耗。</p><p>坏处是播放的时候对 IO、CPU 都会有额外开销。</p><p><img src="/blogimages/2022/2022-11-08/m_8a5a8185e25aa508822013b2229e98e0_r.png"></p><p>以上述两个音效文件为例，当设置一致(SampleRateSetting为PreserveSampleRate[44100Hz])，并采用流式播放时结果如下：</p><ul><li>PCM：197.7KB</li><li>ADPCM：198KB</li><li>Vorbis(1%质量)：231.3KB</li><li>Vorbis(70%质量)：233.8KB</li><li>Vorbis(100%质量)：236.2KB</li></ul><p>Vorbis 下会多 30KB 左右，且受质量设置影响(比较小)</p><p>质量影响量太小了，尝试手动设置一下 Sample Rate 为 <strong>44100Hz</strong>：</p><ul><li>PCM：197.7KB</li><li>ADPCM：198KB</li><li>Vorbis(1%质量)：231.3KB</li><li>Vorbis(70%质量)：233.8KB</li><li>Vorbis(100%质量)：236.2KB</li></ul><p>发现同一采样率下，缓存内存占用量没有变化，另外选择 <strong>Optimiz SampleRate</strong> 也是同样的内存占用结果。</p><p>依然以上述两个音效为例，将 Sample Rate 手动设置为 <strong>22050Hz</strong>：</p><ul><li>PCM：163.7KB</li><li>ADPCM：164KB</li><li>Vorbis(1%质量)：199.9KB</li><li>Vorbis(70%质量)：199.9KB</li><li>Vorbis(100%质量)：199.9KB</li></ul><p>可以看到，Vorbis下依然会多 30KB 左右，但是质量选择已经没有影响了。</p><p>接着缓存 <strong>8000Hz</strong> 的 Sample Rate：</p><ul><li>PCM：141.7KB</li><li>ADPCM：142KB</li><li>Vorbis(1%质量)：167.9KB</li><li>Vorbis(70%质量)：167.9KB</li><li>Vorbis(100%质量)：167.9KB</li></ul><p>可以得出结论：Streaming 播放音效时，至少会产生 140KB(最低8000Hz采样率) 左右的内存缓存，Vorbis 压缩格式下会额外增加 30KB 左右的消耗。</p><p>采样率(越低内存占用越低)、强制单声道也会统一影响到三种设置在流式的缓存占用)，</p><p><font color=red>注1：上述 <strong>44100Hz</strong> 采样率时，Vorbis 压缩下内存占用会有微小差异，同样适用于  Decompress On Load、Compressed In Memory，推测是音效源文件的采样率部分不一致导致，因为手动设置为更低采样率后就保持一致了。</font></p><h3 id="2-Compression-Format-压缩格式"><a href="#2-Compression-Format-压缩格式" class="headerlink" title="2. Compression Format(压缩格式)"></a>2. Compression Format(压缩格式)</h3><ul><li>PCM：不压缩，效果最好文件最大，试过甚至比导入音效本身文件都还大<br><img src="/blogimages/2022/2022-11-08/m_53f9ea44065a5a44a00872836c0c4db6_r.png"></li><li>ADPCM：有一定压缩效果，压缩率视情况音效源文件而定，经过测试一般在 50%~80% 浮动，也可能比源文件大小更大。<br><img src="/blogimages/2022/2022-11-08/m_d5e6f3117362ddf0191c81fc14ff473d_r.png"></li><li>Vorbis/Mp3：压缩率最高的方式，唯一确定一定能压缩大小的选项，该选项还可以额外设置 Quality，值越小，压缩越厉害，大小也越小<br><img src="/blogimages/2022/2022-11-08/m_b9d67a27160a7a123e41e7187626c837_r.png"></li></ul><h3 id="3-Force-To-Mono"><a href="#3-Force-To-Mono" class="headerlink" title="3. Force To Mono"></a>3. Force To Mono</h3><p>强制单声道，例如下图：</p><p><img src="/blogimages/2022/2022-11-08/m_6b48857f690b8f651eb8298e484f2393_r.png"></p><p>这个音效就包含了 ch1、ch2 两个声道，若勾选该项，两个声道将会合并为一个，并减少一部分大小。</p><p><img src="/blogimages/2022/2022-11-08/m_e5634eac0a5337c2917083632be16d38_r.png"></p><p>测试结果：</p><p><strong>文件1：</strong></p><ul><li>PCM：153.1KB-&gt;76.6KB(50%)</li><li>ADPCM：43.1KB-&gt;21.6KB(50%)</li><li>Vorbis(1%)：7.6KB-&gt;6.4KB(15%)</li><li>Vorbis(100%)：12KB-&gt;9.8KB(18%)</li></ul><p><strong>文件2：</strong></p><ul><li>PCM：9.6MB-&gt;4.8MB(50%)</li><li>ADPCM：2.7MB-&gt;1.4MB(50%)</li><li>Vorbis(1%)：0.6MB-&gt;426.3KB(30%)</li><li>Vorbis(100%)：2.8MB-&gt;0.6MB(80%)</li></ul><p>通过对两个音效文件：一个大文件及一个小文件对比，可以得出结论：</p><p>强制单声道选项中，PCM 和 ADPCM 的格式可以减少 50% 大小，Vorbis 视压缩质量及音效本身大小而定——这个应该跟音效本身两个通道数据量有关，文件2实测双通道声音会有更大的差异。</p><p>注：单声道并不是说只有一个喇叭会播放声音，而是两个喇叭播放同样的声音。</p><h3 id="4-Sample-Rate"><a href="#4-Sample-Rate" class="headerlink" title="4. Sample Rate"></a>4. Sample Rate</h3><p>采样率，在不影响效果的情况，还可以考虑设置统一的更低的采样率，也会影响大小。</p><p>对于影响效果，测试结果如下：</p><ul><li>PCM(44100Hz)：306KB-&gt;153.1KB(22050Hz)-&gt;76.6KB(11025Hz)-&gt;55.6KB(8000Hz)</li><li>ADPCM(44100Hz)：86.2KB-&gt;43.1KB(22050Hz)-&gt;21.6KB(11025Hz)-&gt;15.7KB(8000Hz)</li><li>Vorbis(1%)(44100Hz)：13.9KB-&gt;7.6KB(22050Hz)-&gt;8.7KB(11025Hz)-&gt;6.1KB(8000Hz)</li><li>Vorbis(100%)(44100Hz)：22.9KB-&gt;12KB(22050Hz)-&gt;11.8KB(11025Hz)-&gt;8.8KB(8000Hz)</li></ul><p>从上述测试结果可以看出，采样率对内存占用影响成比例关系：减少多少采样率，相对就减少多少空间。</p><p>我们游戏音效导入默认是 44100Hz ，就是统一将其设置为 22050Hz，相比初始默认的 44100Hz，减少一半占用，Vorbis 压缩有部分浮动，不过也大体符合规则。</p><h3 id="5-Preload-Audio-Data"><a href="#5-Preload-Audio-Data" class="headerlink" title="5. Preload Audio Data"></a>5. Preload Audio Data</h3><p>根据说明，是会在场景加载时预先加载，默认开启的，适用于那种直接拖到 GameObject 上的音效，过多估计会影响场景加载速度。</p><p>一般最好关了，因为我们都是代码动态加载播放，场景不会直接挂。所以这个选项实际上没用。</p><h3 id="6-Load-In-Background"><a href="#6-Load-In-Background" class="headerlink" title="6. Load In Background"></a>6. Load In Background</h3><p>在单独线程延迟加载，不卡主线程，但是这个选项或许会造成音画不同步。</p><h2 id="0x04-总体资源消耗测试"><a href="#0x04-总体资源消耗测试" class="headerlink" title="0x04 总体资源消耗测试"></a>0x04 总体资源消耗测试</h2><p>上面在单项设置中，分别对比过各自会在内存中的占用量，此处将对 内存、CPU 消耗作一个总体对比。</p><p>对于如何测试 CPU 性能的消耗，由于单个音效的播放时很不明显，因此我在测试时采用 20 份播放同一个音效的 AudioSource，并对比总消耗、使用 Profiler 检查每个设置对 CPU 消耗造成的影响，取平均出现最多的值。</p><p>同时为了减少内存误差，测试文件更换了一个更大的音效，OriginalSize 为 2.8MB。</p><p>其默认测试设置如下：<br><img src="/blogimages/2022/2022-11-08/m_8ffecf7064f644e1473a9626eb88d393_r.png"></p><h4 id="1-压缩格式：Vorbis-1-质量"><a href="#1-压缩格式：Vorbis-1-质量" class="headerlink" title="1) 压缩格式：Vorbis(1%质量)"></a>1) 压缩格式：Vorbis(1%质量)</h4><p><img src="/blogimages/2022/2022-11-08/m_e427525c6a80e39dc0ecddc990751942_r.png"></p><p>从左自右 LoadType 分别为： Decompress On Load、Compress In Memery、Streaming</p><p>CPU消耗：1%-&gt;2.5%-&gt;2.8%<br>内存消耗：7.3MB-&gt;2.8MB-&gt;5.9MB</p><h4 id="2-压缩格式：Vorbis-100-质量"><a href="#2-压缩格式：Vorbis-100-质量" class="headerlink" title="2) 压缩格式：Vorbis(100%质量)"></a>2) 压缩格式：Vorbis(100%质量)</h4><p><img src="/blogimages/2022/2022-11-08/m_fcd8822723b729b78904dfc82246b15c_r.png"></p><p>从左自右 LoadType 分别为： Decompress On Load、Compress In Memery、Streaming</p><p>CPU消耗：1%-&gt;4.9%-&gt;5%<br>内存消耗：7.3MB-&gt;3.7MB-&gt;5.9MB</p><h4 id="3-压缩格式：ADPCM"><a href="#3-压缩格式：ADPCM" class="headerlink" title="3) 压缩格式：ADPCM"></a>3) 压缩格式：ADPCM</h4><p><img src="/blogimages/2022/2022-11-08/m_2c08a89d388540ae8df5de75acd03a33_r.png"></p><p>从左自右 LoadType 分别为： Decompress On Load、Compress In Memery、Streaming</p><p>CPU消耗：1%-&gt;1.8%-&gt;2.1%<br>内存消耗：7.2MB-&gt;3.8MB-&gt;5.6MB</p><h4 id="4-压缩格式：PCM"><a href="#4-压缩格式：PCM" class="headerlink" title="4) 压缩格式：PCM"></a>4) 压缩格式：PCM</h4><p><img src="/blogimages/2022/2022-11-08/m_531b2b0591cf77c7e75377e99be059ec_r.png"></p><p>从左自右 LoadType 分别为： Decompress On Load、Compress In Memery、Streaming</p><p>CPU消耗：1%-&gt;1.1%-&gt;1.4%<br>内存消耗：7.2MB-&gt;7.2MB-&gt;5.6MB</p><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5) 总结"></a>5) 总结</h4><p>上述测试结果中，感觉其中 Streaming Vorbis 内存占用与预计的有点不符，于是使用单 AudioSource 额外进行测试：</p><p><img src="/blogimages/2022/2022-11-08/m_8ea6c5c446af60829b7e9b32c492c26b_r.png"></p><p>Streaming 播放模式，从左自右分别为：Vorbis(100%质量)-&gt;Vorbis(1%质量)-&gt;ADPCM-&gt;PCM</p><p>CPU消耗：0.5%-&gt;0.5%-&gt;0.4%-&gt;0.3%<br>内存消耗：2.6MB-&gt;2.6MB-&gt;2.5MB-&gt;2.5MB</p><p>Vorbis 压缩格式，在 Streaming 下 Taotal Audio Memery 消耗多了 100KB 的样子，而在上面使用 Take Sample 单个查看时只额外多了 30KB 内存占用。</p><p>这里只能推测两个原因：</p><ul><li>要么 Taotal Audio Memery 还计算了其它数据</li><li>要么由于统计没有显示具体 KB 消耗值导致的误认(例如 PCM 原本为 2.57MB 一类，加上 30KB 左右就到 2.6MB 了)。</li></ul><p>另外需要注意的是，Streaming 播放模式下，会随着通同一个文件的反复加载，而叠加文件流及解码内存消耗——例如上述单个播放为 124KB-&gt;20个=124KBx20=2.4MB</p><h5 id="总体内存消耗："><a href="#总体内存消耗：" class="headerlink" title="总体内存消耗："></a>总体内存消耗：</h5><p>Decompress On Load：Vorbis 额外 30KB 左右内存消耗，总体差不多<br>Compress In Memery：PCM-&gt;ADPCM-&gt;Vorbis(100%质量)-&gt;Vorbis(1%质量)<br>Streaming：Vorbis 额外几十KB内存消耗，总体差不多</p><h5 id="总体CPU消耗："><a href="#总体CPU消耗：" class="headerlink" title="总体CPU消耗："></a>总体CPU消耗：</h5><p>Decompress On Load：CPU消耗基本一致<br>Compress In Memery：Vorbis(100%质量)-&gt;Vorbis(1%质量)-&gt;ADPCM-&gt;PCM<br>Streaming：Vorbis(100%质量)-&gt;Vorbis(1%质量)-&gt;ADPCM-&gt;PCM</p><h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><blockquote><p>对于总体内存消耗，或许会有疑问（比如说我自己）：在测试单个音效播放时，Profiler Audio 面板中的 Total Audio Memery 的内存数值，比 Profiler Memery 面板中 Take Sample 获取到的单个音效内存占用更大，这个是每个音效实际都比 TakeSample 大些，还是说仅仅因为 Total Audio Memery 计算了其它额外内存？</p></blockquote><p>于是进行测试，首先是空场景 Audio 信息统计：<br><img src="/blogimages/2022/2022-11-08/m_c1482d2c86711e3b82d23fed6e922ae3_r.png"></p><p>接着使用三个不同大小的音效，使用 PCM(Decompress On Load) 格式进行播放，查看 Total Audio Memery 数值：<br><img src="/blogimages/2022/2022-11-08/m_62f502a630dccf7903d280cd34439677_r.png"></p><p>可以发现 Total Audio Memery 数值是根据 PCM Imported Size 大小增加的，Sample Sound Memery(Decompress On Load 解压内存占用量) 亦是按照实际大小跟随递增。</p><h5 id="补充-PCM-Compressed-In-Memory-模式："><a href="#补充-PCM-Compressed-In-Memory-模式：" class="headerlink" title="补充 PCM(Compressed In Memory) 模式："></a>补充 PCM(Compressed In Memory) 模式：</h5><p><img src="/blogimages/2022/2022-11-08/m_93c42e0ec47651dd4433f781999ed190_r.png"><br>DSP CPU：项目在加载类型为 Compressed In Memory 的非流式声音的混音、音频效果和解压缩中使用的 CPU 量。<br>Sample Sound Memory：加载类型为 Decompress On Load 的音频文件用于所有已解压缩样本数据的内存量。</p><p>也就是可以得出结论：</p><ul><li>Total Audio Memery 是所有内存总量，确实是计算了额外消耗内存的。</li><li>Profiler Memery 面板中 Take Sample 获取到的单个音效内存就是实际占用量，与总消耗内存可以表现出一种递增的对应关系。</li><li>PCM 虽然是无压缩格式，但若是选择 Compressed In Memory ，虽然单个音效内存跟选择与否没有变化，但对总体内存也会有一定影响(测试表现是增加了一点)。</li></ul><h2 id="0x05-压缩格式对最终-AssetBunle-资源影响"><a href="#0x05-压缩格式对最终-AssetBunle-资源影响" class="headerlink" title="0x05 压缩格式对最终 AssetBunle 资源影响"></a>0x05 压缩格式对最终 AssetBunle 资源影响</h2><h4 id="1-默认设置、SampleRate-22050Hz、PCM-格式："><a href="#1-默认设置、SampleRate-22050Hz、PCM-格式：" class="headerlink" title="1) 默认设置、SampleRate 22050Hz、PCM 格式："></a>1) 默认设置、SampleRate 22050Hz、PCM 格式：</h4><p><img src="/blogimages/2022/2022-11-08/m_0d325cddd386fb945373c5d125e95248_r.png"><br><img src="/blogimages/2022/2022-11-08/m_0d75a39f780213b3007ecbd23f996ac8_r.png"></p><h4 id="2-默认设置、SampleRate-22050Hz、ADPCM-格式："><a href="#2-默认设置、SampleRate-22050Hz、ADPCM-格式：" class="headerlink" title="2) 默认设置、SampleRate 22050Hz、ADPCM 格式："></a>2) 默认设置、SampleRate 22050Hz、ADPCM 格式：</h4><p><img src="/blogimages/2022/2022-11-08/m_de861340a651647f686105eb35f7fb16_r.png"><br><img src="/blogimages/2022/2022-11-08/m_16d83cb95231207d45e0362af6914021_r.png"></p><h4 id="3-默认设置、SampleRate-22050Hz、Vorbis-压缩，质量-70-："><a href="#3-默认设置、SampleRate-22050Hz、Vorbis-压缩，质量-70-：" class="headerlink" title="3) 默认设置、SampleRate 22050Hz、Vorbis 压缩，质量 70%："></a>3) 默认设置、SampleRate 22050Hz、Vorbis 压缩，质量 70%：</h4><p><img src="/blogimages/2022/2022-11-08/m_7eea0eda7f26befe6ca6567c999d3493_r.png"><br><img src="/blogimages/2022/2022-11-08/m_a22fc28a39eb76fc140d69a392fd0928_r.png"></p><p>可以看出，跟图片压缩一样，压缩格式对最终出包的 AssetBunle 资源大小也会有影响，除压缩方式选择外，Vorbis 压缩质量数值也会影响。</p><p>最终 AssetBundle 包大小基本与音效面板上的 ImportedSize 差不多(+部分AssetBundle额外数据)。</p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>测试结果有些与之前预想的一致，也有部分预想被『推翻』。</p><p>在<font color=blue>内存占用量</font>上，对于 Decompress On Load、Compressed In Memory、Streaming 三种 LoadType 方式：</p><ul><li>Decompress On Load 是以 <font color=red>PCM 格式下 ImportedSize 大小</font>为基准，PCM、ADPCM 格式下在内存解压后占用量基本一致，Vorbis 多占用 40KB 左右</li><li>Compressed In Memory：压缩模式存放内存，Vorbis 压缩会比 <font color=red>自身 ImportedSize</font> 大 30KB 左右</li><li>Streaming 以 200KB 缓存为基准，Vorbis 压缩后加载相比另外两种会额外占用 30KB 左右的内存。<br><font color=red>注1：关于内存占用比较基准，需要注意的是比较基准对象是不同的，这篇文章写完了，我脑袋就混乱了几天才反应过来</font><br><font color=red>注2：大的音效也满足该标准，上述 OriginalSize 为 2.8MB、32.8KB 的音效 Profiler 表现基本一致</font></li></ul><p>在 <font color=blue>CPU 资源消耗</font>上，对于 Decompress On Load、Compressed In Memory、Streaming 三种 LoadType 方式：</p><ul><li>Decompress On Load：CPU 消耗差不多</li><li>Compressed In Memory：压缩存放内存时，以 PCM-&gt;ADPCM-&gt;Vorbis(质量越高消耗越多)</li><li>Streaming：流式播放时，以 PCM-&gt;ADPCM-&gt;Vorbis(质量越高消耗越多)</li></ul><p>在<font color=blue>音效质量</font>上：</p><ul><li>主要受压缩格式影响。PCM 不压缩效果最好，ADPCM 其次，Vorbis 最后。</li><li>对此可以在预览面板看出，更换压缩格式后，振幅会有轻微变动——不过从实际听起来的效果看，PCM、ADPCM 和 Vorbis 高质量压缩下的效果差不多，至少个人没听出太大差别。</li><li>经过测试，如果源音效质量就不大行，PCM 和 Vorbis 效果是一样，修改该项音效振幅不会发生任何改动——甚至 Vorbis 1%~100% 质量都没有差别，比如测试所用的 『lvbu』 音效。</li></ul><p>另外 Force To Mono、Sample Rate 统一影响上述表现(CPU、内存消耗、表现质量)</p><p>经过上面的测试，可以发现音效设置主要是质量换效率、或者空间换时间、或者时间换空间，总有一定取舍。</p><p>因此最后再说一下个人总结：</p><ul><li>可以使用 PCM 模式下的 Imported Size 预估实际解压消耗内存量</li><li>没有绝对的最好设置，这个设置可能需要平衡 包体、内存、CPU 消耗得出结论，前期可以选择一个合适的格式统一设置，后续完整了再进行具体优化</li><li>以 PCM ImportedSize 为基准，一两百KB、比较频繁使用的小音效，例如按钮声音、战斗中的技能音效，可以考虑使用 ADPCM 压缩格式<br>  普通小音效选择 Compress In Memery、非常频繁的音效选择 Decompress On Load</li><li>大一点或者比较少用的音效，不至于常影响到 CPU，采用 Vorbis 压缩，LoadType 采用 Compress In Memery。</li><li>采用 Vorbis 压缩可以调节质量滑块减少内存及 CPU 消耗(当然这样音效质量也会受到影响)</li><li>十几兆或者几十兆的，如果直接放在内存会很影响的情况下再考虑是否用流式播放(感觉手游应该也不至于，对于手游来说还是有点奢侈了)，采用流式播放最好采用 ADPCM 或 PCM 格式了，省一些播放时的 CPU 解压消耗。</li><li>另外在可以接受的情况下， Sample Rate 可以设置为 22050Hz，比默认 44100Hz 减少一半的占用</li><li>Force To Mono 在小音效上应该也可以勾上，例如按钮点击音效总不能也是真的立体声吧，也可以省下一半资源。不过在音效源文件本身就是纯单通道的时候，勾选与否都没有影响</li></ul><p>在我们游戏中，都是采用前两种 LoadType+Vorbis 压缩方式，质量70%、压缩模式存放(Compressed In Memory)、SampleRate 22050Hz。</p><p>注：选择压缩同时也会影响打包资源大小，最终 AssetBundle 包大小基本与音效面板上的 ImportedSize 差不多(+部分AssetBundle额外数据)。最终设置得权衡质量、包体和内存及性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;之前虽然有用过，但是并没有对其做个人的整理与总结，只大概知道哪个选项会造成什么情况，此处进行一次详尽</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://cwhisme.github.io/categories/Unity3D/"/>
    
    
    <category term="性能优化" scheme="https://cwhisme.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>关于二进制十六进制转十进制与ARGB图片存储格式</title>
    <link href="https://cwhisme.github.io/2022/11/03/%E5%85%B3%E4%BA%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6/"/>
    <id>https://cwhisme.github.io/2022/11/03/%E5%85%B3%E4%BA%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6/</id>
    <published>2022-11-03T02:38:36.000Z</published>
    <updated>2022-12-11T02:01:22.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>今天写文章的时候，突然想起用十六进制当做标题序号，于是再记录一下。</p><h2 id="0x02-十六进制与十进制转换"><a href="#0x02-十六进制与十进制转换" class="headerlink" title="0x02 十六进制与十进制转换"></a>0x02 十六进制与十进制转换</h2><p>首先，在十六进制中1~16数字代表有：0,1,2,3,4,56,7,8,9,A(10),B(11),C(12),D(13),E(14),F(15)</p><p>前位为0可以被忽略，例如：</p><p>0x1==0x01==1<br>0x0A==0xA==10</p><p>只有前一位有大于1的情况才会作计算，如：</p><p>0x1A==26==1*16+10</p><p>后位为0则会使前一位成为进位数：</p><p>0xA00==10<em>16</em>16+0+0=2560</p><p>对于进位来说，当前处于哪位，计算时就需要自身数值乘对应数量N的 $16^N-1$次方</p><p>$0xAAA==10<em>16^2+10</em>16^1+10*16^0==2730$</p><p>同理，经常见到的颜色值：0xFFFF 类似</p><p>0xFFFF==15<em>16</em>16<em>16+15</em>16<em>16+15</em>16+15==65535</p><p>这中最大值的情况，计算其实可以简化一下：$16^4-1==16<em>16</em>16*16-1==65535$</p><h2 id="0x03-二进制与十进制转换"><a href="#0x03-二进制与十进制转换" class="headerlink" title="0x03 二进制与十进制转换"></a>0x03 二进制与十进制转换</h2><p>对于二进制转十进制，常用的还是数数。</p><p>数二进制中有多少个 1 ，这个 1 所占用的位置N作为 2(N-1)次方，然后累加起来。</p><p>例如：$1011=2^3+2^1+2^0=15$</p><p>例如 4个字节 容量有多大？</p><p>我们知道：</p><p>1个字节有8位==0b11111111==255<br>2个字节有16位==0b1111111111111111==256<em>256-1=65535<br>3个字节有24位==0b111111111111111111111111==256</em>256<em>256-1=16777215<br>4个字节有32位==0b11111111111111111111111111111111==256</em>256<em>256</em>256-1=4294967295</p><p>一张 ARGB32 的图片格式就是：</p><p>每个通道 8位==255 表示一个颜色，也就是我们常见的 (255,255,255,255) 颜色组合，也即是『原图』。</p><p>上次评审也问到过这个问题：没答上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h2&gt;&lt;p&gt;今天写文章的时候，突然想起用十六进制当做标题序号，于是再记录一下。&lt;/p&gt;
&lt;h2 id=&quot;0x02</summary>
      
    
    
    
    <category term="数学" scheme="https://cwhisme.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>关于对项目字符串拼接的优化研究</title>
    <link href="https://cwhisme.github.io/2022/10/31/%E5%85%B3%E4%BA%8E%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>https://cwhisme.github.io/2022/10/31/%E5%85%B3%E4%BA%8E%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%9A%84%E4%BC%98%E5%8C%96/</id>
    <published>2022-10-31T02:17:26.000Z</published>
    <updated>2022-12-11T02:01:22.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在对组员代码进行审查时，经常碰到看着很不合理的字符串拼接操作，特别是对数组数据操作，也直接一个 for 循环，使用 + 号进行。</p><p>甚至有时候还是直接以 Text 作为主体，例如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; soldierData.Skills.Count; i++)</span><br><span class="line">&#123;</span><br><span class="line">m_soldiersDesc.text += soldierData.Skills[i].GetLvDesc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个地方，首先 m_soldiersDesc.text 是一个主体，『+=』操作相当于 取值+字符串拼接+赋值+重构Text数据，还是在循环中进行——有多费就不用多说了。</p><p>再次对组员进行强调：使用对应指定方式拼接字符串。</p><p>项目中其实已有公共的采取 StringBuilder 拼接相关方法，例如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 組合数组</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toString</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> List&lt;T&gt; list, <span class="built_in">string</span> split = <span class="string">&quot;,&quot;</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!list.valid()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">StringBuilder sbd = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Count; i++) sbd.Append(list[i] + (i &lt; list.Count - <span class="number">1</span> ? split : <span class="string">&quot;&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> sbd.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：虽然该方法是已有的，但是使用的不多(而且该方法使用 StringBuilder 方式也不大好，例如调用了 StringBuilder Append 还在用+号拼接小的)，大多都是在搞自我拼接。</p><p>所以虽然要求大家使用项目自定义的字符串拼接相关扩展方法，不过这边这块恐怕需要进行优化一下。</p><h2 id="2-第一版优化"><a href="#2-第一版优化" class="headerlink" title="2. 第一版优化"></a>2. 第一版优化</h2><p>为此我在这个基础上增加了一份扩展，优化主要有两点：使用 StringBuilder 拼接，且对其进行缓存，每次回收利用。</p><p>主要代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> StringBuilder _stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">32</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> _stringCacheLength;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> _stringCacheTopIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将数组组合为字符串</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toString</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> List&lt;T&gt; list, <span class="built_in">string</span> split = <span class="string">&quot;,&quot;</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!list.valid()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    _stringBuilder.Length = <span class="number">0</span>;</span><br><span class="line">    _stringCacheLength = list.Count;</span><br><span class="line">    _stringCacheTopIndex = _stringCacheLength - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _stringCacheLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _stringBuilder.Append(list[i]);</span><br><span class="line">        <span class="keyword">if</span> (i != _stringCacheTopIndex) _stringBuilder.Append(split);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _stringBuilder.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将列表组合为字符串</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toString</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> List&lt;T&gt; list, RCallback&lt;<span class="built_in">string</span>, T&gt; getStr, <span class="built_in">string</span> split = <span class="string">&quot;,&quot;</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!list.valid()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    _stringBuilder.Length = <span class="number">0</span>;</span><br><span class="line">    _stringCacheLength = list.Count;</span><br><span class="line">    _stringCacheTopIndex = _stringCacheLength - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _stringCacheLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _stringBuilder.Append(getStr(list[i]));</span><br><span class="line">        <span class="keyword">if</span> (i != _stringCacheTopIndex) _stringBuilder.Append(split);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _stringBuilder.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将字典组合为字符串</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toString</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;(<span class="params"><span class="keyword">this</span> Dictionary&lt;K, V&gt; dic, <span class="built_in">string</span> split = <span class="string">&quot;,&quot;</span>, Func&lt;K, V, <span class="built_in">string</span>&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dic.Count &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    _stringBuilder.Length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> dic)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (getStrCallback == <span class="literal">null</span>)</span><br><span class="line">            _stringBuilder.Append(item.Value);</span><br><span class="line">        <span class="keyword">else</span> _stringBuilder.Append(getStrCallback(item.Key, item.Value));</span><br><span class="line">        _stringBuilder.Append(split);</span><br><span class="line">    &#125;</span><br><span class="line">    _stringBuilder.Remove(_stringBuilder.Length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> _stringBuilder.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将数组组合为字符串，换行分割</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toStringLine</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> T[] arr, RCallback&lt;<span class="built_in">string</span>, T&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.toString(Environment.NewLine, getStrCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将列表组合为字符串，换行分割</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toStringLine</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> List&lt;T&gt; list, RCallback&lt;<span class="built_in">string</span>, T&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> list.toString(Environment.NewLine, getStrCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将字典组合为字符串，换行分割</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toStringLine</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;(<span class="params"><span class="keyword">this</span> Dictionary&lt;K, V&gt; dic, Func&lt;K, V, <span class="built_in">string</span>&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dic.toString(Environment.NewLine, getStrCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要提供有两种处理方式：一种直接将数组每个数据拼接，另一种会经过回调处理后再拼接。<br>并支持数组、列表、字典三个常用数据结构内容的拼接。</p><p>这里只使用一份 StringBuilder 缓存，是因为考虑到游戏中单线程模式即用就即时返回结果了，没有必要采用对象池模式去缓存多个。</p><h2 id="3-性能测试与优化"><a href="#3-性能测试与优化" class="headerlink" title="3. 性能测试与优化"></a>3. 性能测试与优化</h2><h3 id="四种拼接方式性能测试"><a href="#四种拼接方式性能测试" class="headerlink" title="四种拼接方式性能测试"></a>四种拼接方式性能测试</h3><p>对于性能测试，这里首先以 100000 个放置于一个数组中的随机字符串的拼接为例，分别采用 +号拼接、string.Join、自定义StringBuilder、带回调自定义StringBuilder 四种方式，测试其消耗时长：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> TestCount = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//纯字符串数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span>[] _strArray;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化测试数据</span></span><br><span class="line">    _strArray = <span class="keyword">new</span> <span class="built_in">string</span>[TestCount];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _strArray[i] = GetRandomStr();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试数据填充完毕</span></span><br><span class="line">    <span class="comment">//==========</span></span><br><span class="line"></span><br><span class="line">    Stopwatch stopwatch = Stopwatch.StartNew();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 测试直接拼接数组</span></span><br><span class="line">    stopwatch.Start();</span><br><span class="line">    <span class="built_in">string</span> finalStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _strArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        finalStr += <span class="string">&quot;,&quot;</span> + _strArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">    stopwatch.Stop();</span><br><span class="line">    UnityEngine.Debug.Log(finalStr);</span><br><span class="line">    UnityEngine.Debug.LogWarning(<span class="built_in">string</span>.Format(<span class="string">&quot;直接拼接数组：&#123;0&#125;&quot;</span>, stopwatch.Elapsed.ToString()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 测试内部函数 join 拼接数组</span></span><br><span class="line">    stopwatch.Reset();</span><br><span class="line">    stopwatch.Start();</span><br><span class="line">    finalStr = <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, _strArray);</span><br><span class="line">    stopwatch.Stop();</span><br><span class="line">    UnityEngine.Debug.Log(finalStr);</span><br><span class="line">    UnityEngine.Debug.LogWarning(<span class="built_in">string</span>.Format(<span class="string">&quot;string.Join 拼接数组：&#123;0&#125;&quot;</span>, stopwatch.Elapsed.ToString()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 测试自定义函数拼接数组</span></span><br><span class="line">    stopwatch.Reset();</span><br><span class="line">    stopwatch.Start();</span><br><span class="line">    finalStr = _strArray.toString();</span><br><span class="line">    stopwatch.Stop();</span><br><span class="line">    UnityEngine.Debug.Log(finalStr);</span><br><span class="line">    UnityEngine.Debug.LogWarning(<span class="built_in">string</span>.Format(<span class="string">&quot;自定义函数拼接数组：&#123;0&#125;&quot;</span>, stopwatch.Elapsed.ToString()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 测试带回调自定义函数拼接数组</span></span><br><span class="line">    stopwatch.Reset();</span><br><span class="line">    stopwatch.Start();</span><br><span class="line">    finalStr = _strArray.toString(<span class="string">&quot;,&quot;</span>, str =&gt; str);</span><br><span class="line">    stopwatch.Stop();</span><br><span class="line">    UnityEngine.Debug.Log(finalStr);</span><br><span class="line">    UnityEngine.Debug.LogWarning(<span class="built_in">string</span>.Format(<span class="string">&quot;带回调自定义函数拼接数组：&#123;0&#125;&quot;</span>, stopwatch.Elapsed.ToString()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回一个随机值字符串</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">GetRandomStr</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Intern(Random.Range(<span class="number">0</span>, <span class="number">1000000</span>).ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/blogimages/2022/2022-10-31/m_58a128e53038c421467e1deabe1943b5_r.png"></p><p>如上图所示，可以看见直接使用 + 号进行拼接的方式，相比另外几种方式其消耗时间可以说是一骑绝尘：可以确定内部基本上没有什么优化的。</p><p>严格来说，上述测试方式并不准确，不过这里主要是因为 + 号拼接太过于消耗时间，数据大了电脑跑不动。因此我就仅执行一次大批量测试了——确定这方式真可以丢一边了。</p><h3 id="平均性能测试"><a href="#平均性能测试" class="headerlink" title="平均性能测试"></a>平均性能测试</h3><p>接下来，剔除 + 号拼接方式，对比余下方式去取平均消耗时间。</p><p>join、concat、自定义函数、带回调自定义函数分别执行 100 次，取平均时间。<br>除此之外，增加对 列表、字典、类类型结构测试。</p><p>测试代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">StrClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _desStr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StrClass</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _desStr = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetDes</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> GetHashCode() + _desStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> TestValueCount = <span class="number">100000</span>;</span><br><span class="line"><span class="comment">//每一轮测试次数，取平均消耗时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> TestNum = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//保存一下结果</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> _logPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">//纯字符串数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span>[] _strArray;</span><br><span class="line"><span class="comment">//纯字符串列表</span></span><br><span class="line"><span class="keyword">private</span> List&lt;<span class="built_in">string</span>&gt; _strList;</span><br><span class="line"><span class="comment">//字典</span></span><br><span class="line"><span class="keyword">private</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; _strDic;</span><br><span class="line"><span class="comment">//返回字符串的类结构</span></span><br><span class="line"><span class="keyword">private</span> StrClass[] _strClassArray;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化测试数据</span></span><br><span class="line">    _strArray = <span class="keyword">new</span> <span class="built_in">string</span>[TestValueCount];</span><br><span class="line">    _strList = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;(TestValueCount);</span><br><span class="line">    _strClassArray = <span class="keyword">new</span> StrClass[TestValueCount];</span><br><span class="line">    _strDic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;(TestValueCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestValueCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _strArray[i] = GetRandomStr();</span><br><span class="line">        _strList.Add(GetRandomStr());</span><br><span class="line">        _strClassArray[i] = <span class="keyword">new</span> StrClass(GetRandomStr());</span><br><span class="line">        _strDic[i] = GetRandomStr();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试数据填充完毕</span></span><br><span class="line">    <span class="comment">//==========</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Stopwatch stopwatch = Stopwatch.StartNew();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 测试直接拼接数组</span></span><br><span class="line">    <span class="comment">//stopwatch.Start();</span></span><br><span class="line">    <span class="comment">//string finalStr = &quot;&quot;;</span></span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt; _strArray.Length; i++)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    finalStr += &quot;,&quot; + _strArray[i];</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//stopwatch.Stop();</span></span><br><span class="line">    <span class="comment">//UnityEngine.Debug.Log(finalStr);</span></span><br><span class="line">    <span class="comment">//UnityEngine.Debug.LogWarning(string.Format(&quot;直接拼接数组：&#123;0&#125;&quot;, stopwatch.Elapsed.ToString()));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空日志</span></span><br><span class="line">    _logPath = Path.Combine(Application.dataPath, <span class="string">&quot;TestLog.txt&quot;</span>);</span><br><span class="line">    File.WriteAllText(_logPath, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试内部函数 concat 拼接数组</span></span><br><span class="line">    DoTest(<span class="string">&quot;string.concat 拼接数组&quot;</span>, () =&gt; <span class="built_in">string</span>.Concat(_strArray));</span><br><span class="line">    <span class="comment">//2. 测试内部函数 join 拼接数组</span></span><br><span class="line">    DoTest(<span class="string">&quot;string.Join 拼接数组&quot;</span>, () =&gt; <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, _strArray));</span><br><span class="line">    <span class="comment">//3. 测试自定义函数拼接数组</span></span><br><span class="line">    DoTest(<span class="string">&quot;自定义函数拼接数组&quot;</span>, () =&gt; _strArray.toString());</span><br><span class="line">    <span class="comment">//4. 测试带回调自定义函数拼接数组</span></span><br><span class="line">    DoTest(<span class="string">&quot;带回调自定义函数拼接数组&quot;</span>, () =&gt; _strArray.toString(<span class="string">&quot;,&quot;</span>, str =&gt; str));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 测试 join 函数拼接列表</span></span><br><span class="line">    DoTest(<span class="string">&quot;string.Join 拼接列表&quot;</span>, () =&gt; _strList.toString());</span><br><span class="line">    <span class="comment">//6. 测试自定义函数拼接列表</span></span><br><span class="line">    DoTest(<span class="string">&quot;自定义函数拼接列表&quot;</span>, () =&gt; _strList.toString());</span><br><span class="line">    <span class="comment">//7. 测试带回调自定义函数拼接列表</span></span><br><span class="line">    DoTest(<span class="string">&quot;带回调自定义函数拼接列表&quot;</span>, () =&gt; _strList.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8. 测试自定义函数拼接类类型</span></span><br><span class="line">    DoTest(<span class="string">&quot;自定义函数拼接类类型&quot;</span>, () =&gt; _strClassArray.toString(<span class="string">&quot;,&quot;</span>, data =&gt; data.GetDes()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//9. 测试自定义函数拼接字典</span></span><br><span class="line">    DoTest(<span class="string">&quot;自定义函数拼接字典&quot;</span>, () =&gt; _strDic.toString());</span><br><span class="line">    <span class="comment">//10. 测试自定义函数拼接字典</span></span><br><span class="line">    DoTest(<span class="string">&quot;自定义函数拼接字典(带回调操作)&quot;</span>, () =&gt; _strDic.toString(<span class="string">&quot;,&quot;</span>, (k, v) =&gt; k + v));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 执行一轮对 callback 运行测试</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoTest</span>(<span class="params"><span class="built_in">string</span> title, Action callback</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stopwatch stopwatch = Stopwatch.StartNew();</span><br><span class="line">    <span class="built_in">long</span> totalTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        stopwatch.Reset();</span><br><span class="line">        stopwatch.Start();</span><br><span class="line">        callback();</span><br><span class="line">        stopwatch.Stop();</span><br><span class="line">        totalTime += stopwatch.ElapsedTicks;</span><br><span class="line">    &#125;</span><br><span class="line">    TimeSpan span = <span class="keyword">new</span> TimeSpan(totalTime);</span><br><span class="line">    <span class="built_in">string</span> log = <span class="built_in">string</span>.Format(<span class="string">&quot;* &#123;0&#125;：&#123;1&#125;秒&#123;2&#125;毫秒\n&quot;</span>, title, span.Seconds, span.Milliseconds);</span><br><span class="line">    File.AppendAllText(_logPath, log);</span><br><span class="line">    UnityEngine.Debug.LogWarning(log);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回一个随机值字符串</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">GetRandomStr</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Intern(UnityEngine.Random.Range(<span class="number">0</span>, <span class="number">1000000</span>).ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><ul><li>string.concat 拼接数组：00:00:00.0099083</li><li>string.Join 拼接数组：00:00:00.0132115</li><li>自定义函数拼接数组：00:00:00.0179701</li><li>带回调自定义函数拼接数组：00:00:00.0175816</li><li>string.Join 拼接列表：00:00:00.0184016</li><li>自定义函数拼接列表：00:00:00.0185559</li><li>带回调自定义函数拼接列表：00:00:00.0180418</li><li>自定义函数拼接类类型：00:00:00.1013892</li><li>自定义函数拼接字典：00:00:00.0224806</li><li>自定义函数拼接字典(带回调操作)：00:00:00.0983786</li></ul><p>有点奇怪的是，在数组结构上，带回调自定义函数时间消耗反而比不带回调的低一点？</p><p>所以可以确定一下性能排序分别为：</p><blockquote><p>string.concat-&gt;string.Join-&gt;StringBuilder自定义拼接-&gt;+号拼接</p></blockquote><p>(其中 concat 之所以性能更高，除了因为少了一位『分隔符』的插入，看源码似乎还利用了创建一个最终大小字符串，通过内存拷贝方式复制进去实现)</p><p>这么看起来，还是内置拼接函数性能比较高。</p><p>不过 concat、Join 的局限性在于：只能用于数组类型，且只处理字符串——如果对象不是字符串，则直接通过 ToString 强转为字符串进行拼接。(要是有某个非字符串数组类型对象重载过 ToString 输出正确值也不是不能用)</p><h2 id="4-第二版优化"><a href="#4-第二版优化" class="headerlink" title="4. 第二版优化"></a>4. 第二版优化</h2><p>经过测试之后，大概性能也有点数了。</p><p>于是就有一些新的想法：例如无回调需求时使用 join 拼接、分隔符为空则采用 concat 拼接——虽然会增加一点判断，但是性能该是可以提升一点的。</p><p>另外在目前自定义扩展函数的使用方式上，感觉也还有点缺点：比如字典类型，如果别人想把 k、v 结构也拼接在一块，那么这里就不大好办了，让调用者在回调方法用 + 号拼接一次？这样可就又冗余了。所以最好也提供一个重载使其作为可选项。</p><p>最终形成以下方法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> StringBuilder _stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">32</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> _stringCacheLength;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> _stringCacheTopIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将数组组合为字符串</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toString</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> T[] arr, <span class="built_in">string</span> separator = <span class="string">&quot;,&quot;</span>, Func&lt;T, <span class="built_in">string</span>&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(separator) &amp;&amp; getStrCallback == <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">string</span>.Concat(arr);</span><br><span class="line">    <span class="comment">//if (getStrCallback == null) return string.Join(separator, arr);</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.Length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    _stringBuilder.Length = <span class="number">0</span>;</span><br><span class="line">    _stringCacheLength = arr.Length;</span><br><span class="line">    _stringCacheTopIndex = _stringCacheLength - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _stringCacheLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _stringBuilder.Append(CheckDeliverValue(arr[i], getStrCallback));</span><br><span class="line">        <span class="keyword">if</span> (i != _stringCacheTopIndex) _stringBuilder.Append(separator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _stringBuilder.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将列表组合为字符串</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toString</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> List&lt;T&gt; list, <span class="built_in">string</span> separator = <span class="string">&quot;,&quot;</span>, Func&lt;T, <span class="built_in">string</span>&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(separator) &amp;&amp; getStrCallback == <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">string</span>.Concat(list);</span><br><span class="line">    <span class="comment">//if (getStrCallback == null) return string.Join(separator, list);</span></span><br><span class="line">    <span class="keyword">if</span> (list == <span class="literal">null</span> || list.Count == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    _stringBuilder.Length = <span class="number">0</span>;</span><br><span class="line">    _stringCacheLength = list.Count;</span><br><span class="line">    _stringCacheTopIndex = _stringCacheLength - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _stringCacheLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _stringBuilder.Append(CheckDeliverValue(list[i], getStrCallback));</span><br><span class="line">        <span class="keyword">if</span> (i != _stringCacheTopIndex) _stringBuilder.Append(separator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _stringBuilder.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将字典的所有 value 组合为字符串，忽略字典的Key值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;separator&quot;&gt;</span>分隔符<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;getValueStrCallback&quot;&gt;</span>如果value转化为字符串需要其它接口，可使用回调返回调用后的值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>value,value,value,value,value......<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toString</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;(<span class="params"><span class="keyword">this</span> Dictionary&lt;K, V&gt; dic, <span class="built_in">string</span> separator = <span class="string">&quot;,&quot;</span>, Func&lt;V, <span class="built_in">string</span>&gt; getValueStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> toString(dic, separator, <span class="literal">null</span>, <span class="literal">null</span>, getValueStrCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将字典 key 和 value 成对组合为字符串，需要传入对应的分隔符</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;separator&quot;&gt;</span>每个对象之间分割符<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;separatorKV&quot;&gt;</span>key和value分隔符，传入空值拼接时将忽略key值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;getKeyStrCallback&quot;&gt;</span>如果key转化为字符串需要其它接口，可使用回调返回调用后的值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;getValueStrCallback&quot;&gt;</span>如果value转化为字符串需要其它接口，可使用回调返回调用后的值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>默认：key:value,key:value,key:value......<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toString</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;(<span class="params"><span class="keyword">this</span> Dictionary&lt;K, V&gt; dic, <span class="built_in">string</span> separator, <span class="built_in">string</span> separatorKV, Func&lt;K, <span class="built_in">string</span>&gt; getKeyStrCallback = <span class="literal">null</span>, Func&lt;V, <span class="built_in">string</span>&gt; getValueStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dic == <span class="literal">null</span> || dic.Count == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    _stringBuilder.Length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//kv分隔符为空，则当做表示不拼接key</span></span><br><span class="line">    <span class="built_in">bool</span> appendKey = !<span class="built_in">string</span>.IsNullOrEmpty(separatorKV);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> dic)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//附加字典key</span></span><br><span class="line">        <span class="keyword">if</span> (appendKey)</span><br><span class="line">        &#123;</span><br><span class="line">            _stringBuilder.Append(CheckDeliverValue(item.Key, getKeyStrCallback));</span><br><span class="line">            _stringBuilder.Append(separatorKV);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//附加字典值</span></span><br><span class="line">        _stringBuilder.Append(CheckDeliverValue(item.Value, getValueStrCallback));</span><br><span class="line">        <span class="comment">//分隔符</span></span><br><span class="line">        _stringBuilder.Append(separator);</span><br><span class="line">    &#125;</span><br><span class="line">    _stringBuilder.Remove(_stringBuilder.Length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> _stringBuilder.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将数组组合为字符串，换行分割</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toStringLine</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> T[] arr, Func&lt;T, <span class="built_in">string</span>&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.toString(Environment.NewLine, getStrCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将列表组合为字符串，换行分割</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toStringLine</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> List&lt;T&gt; list, Func&lt;T, <span class="built_in">string</span>&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> list.toString(Environment.NewLine, getStrCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将字典组合为字符串，换行分割(忽略key值)</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toStringLine</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;(<span class="params"><span class="keyword">this</span> Dictionary&lt;K, V&gt; dic, Func&lt;V, <span class="built_in">string</span>&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dic.toString(Environment.NewLine, getStrCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 检查是否对值进行回调处理（若 getValueStrCallback 不为空则返回调用后结果，参数为 value）</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">CheckDeliverValue</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span>, Func&lt;T, <span class="built_in">string</span>&gt; getValueStrCallback</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (getValueStrCallback == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">value</span>.ToString();</span><br><span class="line">    <span class="keyword">return</span> getValueStrCallback(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性能测试："><a href="#性能测试：" class="headerlink" title="性能测试："></a>性能测试：</h4><p>依然是 100000 个随机字符串，循环一百次拼接。</p><p>测试代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试内部函数 concat 拼接数组</span></span><br><span class="line">DoTest(<span class="string">&quot;string.concat 拼接数组&quot;</span>, () =&gt; <span class="built_in">string</span>.Concat(_strArray));</span><br><span class="line"><span class="comment">//2. 测试内部函数 join 拼接数组</span></span><br><span class="line">DoTest(<span class="string">&quot;string.Join 拼接数组&quot;</span>, () =&gt; <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, _strArray));</span><br><span class="line"><span class="comment">//3. 测试自定义函数拼接数组</span></span><br><span class="line">DoTest(<span class="string">&quot;自定义函数拼接数组&quot;</span>, () =&gt; _strArray.toString());</span><br><span class="line"><span class="comment">//4. 测试带回调自定义函数拼接数组</span></span><br><span class="line">DoTest(<span class="string">&quot;带回调自定义函数拼接数组&quot;</span>, () =&gt; _strArray.toString(<span class="string">&quot;,&quot;</span>, str =&gt; str));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 测试 join 函数拼接列表</span></span><br><span class="line">DoTest(<span class="string">&quot;string.Join 拼接列表&quot;</span>, () =&gt; _strList.toString());</span><br><span class="line"><span class="comment">//6. 测试自定义函数拼接列表</span></span><br><span class="line">DoTest(<span class="string">&quot;自定义函数拼接列表&quot;</span>, () =&gt; _strList.toString());</span><br><span class="line"><span class="comment">//7. 测试带回调自定义函数拼接列表</span></span><br><span class="line">DoTest(<span class="string">&quot;带回调自定义函数拼接列表&quot;</span>, () =&gt; _strList.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//8. 测试自定义函数拼接类类型</span></span><br><span class="line">DoTest(<span class="string">&quot;自定义函数拼接类类型&quot;</span>, () =&gt; _strClassArray.toString(<span class="string">&quot;,&quot;</span>, data =&gt; data.GetDes()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//9. 测试自定义函数拼接字典</span></span><br><span class="line">DoTest(<span class="string">&quot;自定义函数拼接字典&quot;</span>, () =&gt; _strDic.toString());</span><br><span class="line"><span class="comment">//10. 测试自定义函数拼接字典</span></span><br><span class="line"><span class="comment">//DoTest(&quot;自定义函数拼接字典(带回调操作)&quot;, () =&gt; _strDic.toString(&quot;,&quot;);</span></span><br><span class="line"></span><br><span class="line">DoTest(<span class="string">&quot;string.concat 拼接数组&quot;</span>, () =&gt; <span class="built_in">string</span>.Concat(_strArray));</span><br><span class="line">DoTest(<span class="string">&quot;string.join 拼接数组&quot;</span>, () =&gt; <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, _strArray));</span><br><span class="line"></span><br><span class="line">DoTest(<span class="string">&quot;拼接数组(无分隔符)&quot;</span>, () =&gt; _strArray.toString(<span class="built_in">string</span>.Empty));</span><br><span class="line">DoTest(<span class="string">&quot;拼接数组&quot;</span>, () =&gt; _strArray.toString());</span><br><span class="line">DoTest(<span class="string">&quot;拼接数组(带回调)&quot;</span>, () =&gt; _strArray.toString(<span class="string">&quot;,&quot;</span>, str =&gt; str));</span><br><span class="line"></span><br><span class="line">DoTest(<span class="string">&quot;拼接字典 Value&quot;</span>, () =&gt; _strDic.toString());</span><br><span class="line">DoTest(<span class="string">&quot;拼接字典(带 Value 回调)&quot;</span>, () =&gt; _strDic.toString(<span class="string">&quot;,&quot;</span>, v =&gt; v));</span><br><span class="line">DoTest(<span class="string">&quot;拼接字典 K、V&quot;</span>, () =&gt; _strDic.toString(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;:&quot;</span>));</span><br><span class="line">DoTest(<span class="string">&quot;拼接字典 K、V(带 Key 回调)&quot;</span>, () =&gt; _strDic.toString(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;:&quot;</span>, k =&gt; k.ToString()));</span><br><span class="line">DoTest(<span class="string">&quot;拼接字典 K、V(带 Key、Value 回调)&quot;</span>, () =&gt; _strDic.toString(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;:&quot;</span>, k =&gt; k.ToString(), v =&gt; v));</span><br><span class="line">DoTest(<span class="string">&quot;拼接字典(字典转数组拼接)&quot;</span>, () =&gt; _strDic.ToArray().toString());</span><br><span class="line">DoTest(<span class="string">&quot;拼接字典(字典转列表拼接)&quot;</span>, () =&gt; _strDic.ToList().toString());</span><br></pre></td></tr></table></figure><ul><li>string.concat 拼接数组：0秒937毫秒</li><li>string.Join 拼接数组：1秒282毫秒</li><li>自定义函数拼接数组：1秒837毫秒</li><li>带回调自定义函数拼接数组：1秒809毫秒</li><li>string.Join 拼接列表：1秒858毫秒</li><li>自定义函数拼接列表：1秒916毫秒</li><li>带回调自定义函数拼接列表：1秒847毫秒</li><li>自定义函数拼接类类型：10秒400毫秒</li><li>自定义函数拼接类类型(GetDes()无计算)：1秒870毫秒</li><li>自定义函数拼接字典：2秒316毫秒</li><li>string.concat 拼接数组：0秒910毫秒</li><li>string.join 拼接数组：1秒253毫秒</li><li>拼接数组(无分隔符)：1秒638毫秒</li><li>拼接数组：1秒764毫秒</li><li>拼接数组(带回调)：1秒794毫秒</li><li>拼接字典 Value：2秒332毫秒</li><li>拼接字典(带 Value 回调)：2秒356毫秒</li><li>拼接字典 K、V：8秒121毫秒</li><li>拼接字典 K、V(带 Key 回调)：8秒111毫秒</li><li>拼接字典 K、V(带 Key、Value 回调)：8秒335毫秒</li><li>拼接字典(字典转数组拼接)：14秒391毫秒</li><li>拼接字典(字典转列表拼接)：15秒655毫秒</li></ul><p>(低版本 C# 的 string.concat、string.Join 连列表都不支持，甚至只能用在字符串数组上，所以上边说检测到对应情况(没有分隔符或纯字符串数组)后执行系统拼接函数只能在高版本下使用)</p><blockquote><p>[concat 由于低版本 C# 不支持除纯字符串数组之外的对象且有 object 重载，泛型数组也是可以直接丢进去的，然而直接当做 object.ToString 返回了，测试时发现消耗时间短得不可思议，仔细看才发现不对，例如上述『拼接列表(无分隔符)』就是走进这个分支判断的情况，只能先注释掉]</p></blockquote><h2 id="5-StringBuilder-源码"><a href="#5-StringBuilder-源码" class="headerlink" title="5. StringBuilder 源码"></a>5. StringBuilder 源码</h2><p>另外稍微看了下源码，StringBuilder 默认初始化 16 个字符大小的数组：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token: 0x060065BB RID: 26043 RVA: 0x00155704 File Offset: 0x00153904</span></span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span>(<span class="params"></span>) : <span class="title">this</span>(<span class="params"><span class="number">16</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Token: 0x060065BC RID: 26044 RVA: 0x0015570E File Offset: 0x0015390E</span></span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span>(<span class="params"><span class="built_in">int</span> capacity</span>) : <span class="title">this</span>(<span class="params"><span class="built_in">string</span>.Empty, capacity</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Token: 0x060065D7 RID: 26071 RVA: 0x001561B8 File Offset: 0x001543B8</span></span><br><span class="line">[<span class="meta">ComVisible(false)</span>]</span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">AppendLine</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.Append(<span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.Append(Environment.NewLine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容量足够的情况下，通过 unsafe 方法进行指针及直接内存操作：</p><ol><li>获取添加的字符串指针</li><li>获取字符数组待添加下标指针</li><li>调用 Buffer.Memcpy 进行内存拷贝进字符数组</li></ol><p>如果后续容量不够，则进行动态扩容：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token: 0x060065D1 RID: 26065 RVA: 0x0015603C File Offset: 0x0015423C</span></span><br><span class="line">[<span class="meta">SecuritySafeCritical</span>]</span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">unsafe</span> StringBuilder <span class="title">Append</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span> != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">char</span>[] chunkChars = <span class="keyword">this</span>.m_ChunkChars;</span><br><span class="line">        <span class="built_in">int</span> chunkLength = <span class="keyword">this</span>.m_ChunkLength;</span><br><span class="line">        <span class="built_in">int</span> length = <span class="keyword">value</span>.Length;</span><br><span class="line">        <span class="built_in">int</span> num = chunkLength + length;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; chunkChars.Length)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//容量足够</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//走扩容</span></span><br><span class="line">            <span class="keyword">this</span>.AppendHelper(<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过动态扩容不是直接扩容字符数组，而是通过单向链表的方式：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token: 0x06006615 RID: 26133 RVA: 0x0015730C File Offset: 0x0015550C</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ExpandByABlock</span>(<span class="params"><span class="built_in">int</span> minBlockCharCount</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (minBlockCharCount + <span class="keyword">this</span>.Length &lt; minBlockCharCount || minBlockCharCount + <span class="keyword">this</span>.Length &gt; <span class="keyword">this</span>.m_MaxCapacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="string">&quot;requiredLength&quot;</span>, Environment.GetResourceString(<span class="string">&quot;ArgumentOutOfRange_SmallCapacity&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> num = Math.Max(minBlockCharCount, Math.Min(<span class="keyword">this</span>.Length, <span class="number">8000</span>));</span><br><span class="line">    <span class="keyword">this</span>.m_ChunkPrevious = <span class="keyword">new</span> StringBuilder(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.m_ChunkOffset += <span class="keyword">this</span>.m_ChunkLength;</span><br><span class="line">    <span class="keyword">this</span>.m_ChunkLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.m_ChunkOffset + num &lt; num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.m_ChunkChars = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.m_ChunkChars = <span class="keyword">new</span> <span class="built_in">char</span>[num];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将当前数据全部转移至『上一个』节点，然后自己创建一个新的字符数组进行处理。</p><p>除 StringBuilder 本身外，string 类提供的一些静态操作方法也再次利用 StringBuilder 对性能进行优化，如 join、format 底层都会调到那边去，还采用了 StringBuilderCache 对象池。</p><h2 id="6-Join-部分源码"><a href="#6-Join-部分源码" class="headerlink" title="6. Join 部分源码"></a>6. Join 部分源码</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token: 0x060004B8 RID: 1208 RVA: 0x00010B4C File Offset: 0x0000ED4C</span></span><br><span class="line">[<span class="meta">SecuritySafeCritical</span>]</span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">unsafe</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Join</span>(<span class="params"><span class="built_in">string</span> separator, <span class="built_in">string</span>[] <span class="keyword">value</span>, <span class="built_in">int</span> startIndex, <span class="built_in">int</span> count</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//=======省略判断================</span></span><br><span class="line"><span class="comment">//字符串类型数组，直接通过分配一大块字符串内存，通过 unsafe 内存拷贝实现</span></span><br><span class="line">    <span class="built_in">string</span> text = <span class="built_in">string</span>.FastAllocateString(num);</span><br><span class="line">    <span class="keyword">fixed</span> (<span class="built_in">char</span>* ptr = &amp;text.m_firstChar)</span><br><span class="line">    &#123;</span><br><span class="line">        UnSafeCharBuffer unSafeCharBuffer = <span class="keyword">new</span> UnSafeCharBuffer(ptr, num);</span><br><span class="line">        unSafeCharBuffer.AppendString(<span class="keyword">value</span>[startIndex]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = startIndex + <span class="number">1</span>; j &lt;= num2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            unSafeCharBuffer.AppendString(separator);</span><br><span class="line">            unSafeCharBuffer.AppendString(<span class="keyword">value</span>[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接迭代器(列表类型)通过 StringBuilder 进行</span></span><br><span class="line"><span class="comment">// Token: 0x060004B5 RID: 1205 RVA: 0x000109C4 File Offset: 0x0000EBC4</span></span><br><span class="line">[<span class="meta">ComVisible(false)</span>]</span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Join</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> separator, IEnumerable&lt;T&gt; values</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略部分处理代码</span></span><br><span class="line">result = StringBuilderCache.GetStringAndRelease(stringBuilder);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接 object 数组类型，通过 StringBuilderCache 对象池取 StringBuilder 进行拼接</span></span><br><span class="line"><span class="comment">// Token: 0x060004B4 RID: 1204 RVA: 0x0001093C File Offset: 0x0000EB3C</span></span><br><span class="line">[<span class="meta">ComVisible(false)</span>]</span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Join</span>(<span class="params"><span class="built_in">string</span> separator, <span class="keyword">params</span> <span class="built_in">object</span>[] values</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//省略</span></span><br><span class="line">    <span class="keyword">return</span> StringBuilderCache.GetStringAndRelease(stringBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-string-Concat"><a href="#7-string-Concat" class="headerlink" title="7. string.Concat"></a>7. string.Concat</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当连接数量级比较低时，参数为 string 则直接通过创建最终字符串内存连接</span></span><br><span class="line"><span class="comment">// Token: 0x06000556 RID: 1366 RVA: 0x00013524 File Offset: 0x00011724</span></span><br><span class="line">[<span class="meta">SecuritySafeCritical</span>]</span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Concat</span>(<span class="params"><span class="built_in">string</span> str0, <span class="built_in">string</span> str1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//部分判断代码省略===============</span></span><br><span class="line"><span class="built_in">int</span> length = str0.Length;</span><br><span class="line"><span class="built_in">string</span> text = <span class="built_in">string</span>.FastAllocateString(length + str1.Length);</span><br><span class="line"><span class="built_in">string</span>.FillStringChecked(text, <span class="number">0</span>, str0);</span><br><span class="line"><span class="built_in">string</span>.FillStringChecked(text, length, str1);</span><br><span class="line"><span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接迭代器(列表类型)通过 StringBuilder 进行</span></span><br><span class="line"><span class="comment">// Token: 0x06000555 RID: 1365 RVA: 0x000134B8 File Offset: 0x000116B8</span></span><br><span class="line">[<span class="meta">ComVisible(false)</span>]</span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Concat</span>(<span class="params">IEnumerable&lt;<span class="built_in">string</span>&gt; values</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//省略</span></span><br><span class="line"><span class="keyword">return</span> StringBuilderCache.GetStringAndRelease(stringBuilder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当连接数量级比较低时，参数为 object 则直接通过符号连接</span></span><br><span class="line"><span class="comment">// Token: 0x06000551 RID: 1361 RVA: 0x00013330 File Offset: 0x00011530</span></span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Concat</span>(<span class="params"><span class="built_in">object</span> arg0, <span class="built_in">object</span> arg1, <span class="built_in">object</span> arg2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断省略==========</span></span><br><span class="line">    <span class="keyword">return</span> arg0.ToString() + arg1.ToString() + arg2.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcatArray(当 string.Concat 超过三个 object 对象时调用)</span></span><br><span class="line"><span class="comment">//超出这个数量则通过内存分配进行</span></span><br><span class="line"><span class="comment">// Token: 0x06000559 RID: 1369 RVA: 0x000136AC File Offset: 0x000118AC</span></span><br><span class="line">[<span class="meta">SecuritySafeCritical</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ConcatArray</span>(<span class="params"><span class="built_in">string</span>[] values, <span class="built_in">int</span> totalLength</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> text = <span class="built_in">string</span>.FastAllocateString(totalLength);</span><br><span class="line">    <span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; values.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span>.FillStringChecked(text, num, values[i]);</span><br><span class="line">        num += values[i].Length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接分配指定字符串数组所有字符串长度大小的大块字符串，然后通过 wstrcpy-&gt;Buffer.Memcpy 对内存直接进行拷贝操作。</p><h2 id="8-Format"><a href="#8-Format" class="headerlink" title="8. Format"></a>8. Format</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">FormatHelper</span>(<span class="params">IFormatProvider provider, <span class="built_in">string</span> format, ParamsArray args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (format == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;format&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StringBuilderCache.GetStringAndRelease(StringBuilderCache.Acquire(format.Length + args.Length * <span class="number">8</span>).AppendFormatHelper(provider, format, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对-string-Format-与普通拼接的性能测试"><a href="#对-string-Format-与普通拼接的性能测试" class="headerlink" title="对 string.Format 与普通拼接的性能测试"></a>对 string.Format 与普通拼接的性能测试</h3><p>除了对数组一类数据结构类型的拼接之外，常用的估计就 2~3 个带参数的简单字符串拼接了。</p><p>这种通常见到的还是直接+号进行，也有使用 string.Format 的。</p><p>为了评估以后究竟以使用哪种方式为准，我想再加一点测试，测一测使用 + 号与 string.Format 拼接简单字符串两者的性能。</p><p>每一项进行 10000 次操作，测试结果如下：</p><ul><li>简单拼接测试（X+1）：0秒3毫秒</li><li>简单拼接测试（1+X）：0秒3毫秒</li><li>简单拼接测试（X+1+Y）：0秒4毫秒</li><li>简单拼接测试（X+1+Y+2）：0秒6毫秒</li><li>简单拼接测试（X+1+Y+2+Z+3）：0秒11毫秒</li><li>简单拼接测试（X+1+Y+2+Z+3+W+4）：0秒14毫秒</li><li>string.concat（X+1）：0秒3毫秒</li><li>string.concat（1+X）：0秒3毫秒</li><li>string.concat（X+1+Y）：0秒4毫秒</li><li>string.concat（X+1+Y+2）：0秒6毫秒</li><li>string.concat（X+1+Y+2+Z+3）：0秒26毫秒</li><li>string.concat（X+1+Y+2+Z+3+W+4）：0秒14毫秒</li><li>string.format 拼接测试（X{0}）：0秒7毫秒</li><li>string.format 拼接测试（{0}X）：0秒7毫秒</li><li>string.format 拼接测试（X{0}Y）：0秒7毫秒</li><li>string.format 拼接测试（X{0}Y{1}）：0秒11毫秒</li><li>string.format 拼接测试（X{0}Y{1}Z{2}）：0秒16毫秒</li><li>string.format 拼接测试（X{0}Y{1}Z{2}W{3}）：0秒35毫秒</li><li>StringBuilder 拼接测试（X+1）：0秒4毫秒</li><li>StringBuilder 拼接测试（1+X）：0秒4毫秒</li><li>StringBuilder 拼接测试（X+1+Y）：0秒5毫秒</li><li>StringBuilder 拼接测试（X+1+Y+2）：0秒8毫秒</li><li>StringBuilder 拼接测试（X+1+Y+2+Z+3）：0秒11毫秒</li><li>StringBuilder 拼接测试（X+1+Y+2+Z+3+W+4）：0秒14毫秒</li></ul><p>每一项进行 100000 次操作，去除随机参数，测试结果如下：</p><ul><li>简单拼接测试（X+1）：0秒16毫秒</li><li>简单拼接测试（1+X）：0秒15毫秒</li><li>简单拼接测试（X+1+Y）：0秒20毫秒</li><li>简单拼接测试（X+1+Y+2）：0秒25毫秒</li><li>简单拼接测试（X+1+Y+2+Z+3）：0秒66毫秒</li><li>简单拼接测试（X+1+Y+2+Z+3+W+4）：0秒77毫秒</li><li>string.concat（X+1）：0秒17毫秒</li><li>string.concat（1+X）：0秒16毫秒</li><li>string.concat（X+1+Y）：0秒35毫秒</li><li>string.concat（X+1+Y+2）：0秒24毫秒</li><li>string.concat（X+1+Y+2+Z+3）：0秒65毫秒</li><li>string.concat（X+1+Y+2+Z+3+W+4）：0秒64毫秒</li><li>string.format 拼接测试（X{0}）：0秒60毫秒</li><li>string.format 拼接测试（{0}X）：0秒66毫秒</li><li>string.format 拼接测试（X{0}Y）：0秒68毫秒</li><li>string.format 拼接测试（X{0}Y{1}）：0秒71毫秒</li><li>string.format 拼接测试（X{0}Y{1}Z{2}）：0秒106毫秒</li><li>string.format 拼接测试（X{0}Y{1}Z{2}W{3}）：0秒145毫秒</li><li>StringBuilder 拼接测试（X+1）：0秒28毫秒</li><li>StringBuilder 拼接测试（1+X）：0秒27毫秒</li><li>StringBuilder 拼接测试（X+1+Y）：0秒33毫秒</li><li>StringBuilder 拼接测试（X+1+Y+2）：0秒38毫秒</li><li>StringBuilder 拼接测试（X+1+Y+2+Z+3）：0秒67毫秒</li><li>StringBuilder 拼接测试（X+1+Y+2+Z+3+W+4）：0秒62毫秒</li></ul><p>结果非常出乎意料，原以为 string.format 性能应该是比较好的，没成想竟然是最费的…也许由于字符串内部占位符需要单独做解析，导致了大量消耗？</p><p>于是看了下源码，发现在 AppendFormatHelper 方法中，对整个字符串都做了一次遍历，去分析是否有 {} 这种占位符，这个确实是个会随字符串量级增加而增加消耗的一个操作——string.format 对于连接字符串存在多个参数的情况下，耗费时间也同样会随着参数增长而增加。</p><p>因此除了字符串数组类型拼接方法外，可以自己专门定义一个方法用于连接『散』字符串，以选择性能更好的拼接方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据上面的测试——虽然这种测试不一定很准确(毕竟 Unity 中 .Net 版本比较低)，以及对 string 源码本身的查看，基本上可以总结以下几个注意点：</p><p>连接纯字符串超过 3 个时，有分隔符可以选择 StringBuilder、string.join(数组)，否则使用 string.concat(数组)，至于 string.format——除了好看一点，能不用就不要用了，性能上完全没有优势。</p><p>其中 string.concat 及 string.join 的源码显示，其对不同类型选择了不同的处理方式。</p><p>共同点有：</p><ul><li>字符串类型数组，直接通过分配一大块字符串内存，通过 unsafe 内存拷贝实现</li><li>连接迭代器(列表类型)或者连接 object 数组均通过 StringBuilderCache 取 StringBuilder 进行</li></ul><p>string.Concat 特有：</p><ul><li>参数为 string，当连接数量级比较低时，直接通过分配一块最终字符串大小内存，通过 unsafe 内存拷贝实现</li><li>参数为 object，当连接数量级比较低时(3个以下)， 则直接通过符号连接，超过三个则创建临时数组变量将 object 转字符串，再走正常字符串数组连接方法</li></ul><h4 id="最终可以得出结论："><a href="#最终可以得出结论：" class="headerlink" title="最终可以得出结论："></a>最终可以得出结论：</h4><p>拼接数量在2个：可以使用 + 号<br>拼接数量在4个及以下：字符串可以使用 string.concat(非字符串3个或以下时直接+号拼接，4个或以上时会生成临时数组变量将object.tostring，然后调用字符串数组拼接函数处理——调用不定参数方法时也是如此处理)，否则最好 StringBuilder<br>拼接数量在超过4个：StringBuilder (不推荐 string.concat 是因为通过可变参数传参它会生成额外临时字符串数组，直接拼接数组时更有优势)<br>连接字符串数组、字符串列表类型：可以用 string.join 或 string.concat(无分隔符)，有特殊回调需求则自定义 StringBuilder (注：内部实际上也是用 StringBuilder 拼接的，不过看 DotNetCore 的源码实现不一样，是创建一个结构体 ValueStringBuilder，通过 stackalloc 在栈上分配 char 数组(Span)结构进行拼接)<br>连接其它容器(比如字典)：StringBuilder</p><p>再解释一下：</p><p>连接字符串在4个及以下时，可以通过 string.concat (强调：字符串类型，非字符串可以 toString 传入)<br>字符串数组和字符串列表都可以用 string.join 或 string.concat (内部 StringBuilder ，有对象池)<br>其它类型的数组、列表或字典容器以及超出4个单字符串的连接，采用自己 StringBuilder 进行，并且可以缓存这个 StringBuilder 进行重复使用。<br>只有两个字符串拼接，才允许使用符号+</p><p>(注：上述均表示一次性拼接的前提，若连续多次连接，则 StringBuilder 无疑是最好选择)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;在对组员代码进行审查时，经常碰到看着很不合理的字符串拼接操作，特别是对数组数据操作，也直接一个 for 循环，使用 + </summary>
      
    
    
    
    <category term="C#" scheme="https://cwhisme.github.io/categories/C/"/>
    
    
    <category term="性能优化" scheme="https://cwhisme.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>图片资源格式设置测试与总结</title>
    <link href="https://cwhisme.github.io/2022/10/26/%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E6%A0%BC%E5%BC%8F%E8%AE%BE%E7%BD%AE%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <id>https://cwhisme.github.io/2022/10/26/%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E6%A0%BC%E5%BC%8F%E8%AE%BE%E7%BD%AE%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%BB%E7%BB%93/</id>
    <published>2022-10-26T03:57:38.000Z</published>
    <updated>2022-12-11T02:01:22.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在今年10月份这次评审的时候，有问到图片设置相关的内容，当时感觉也是没回答多好。</p><p>例如，ETC1 与 ETC2 相比有什么差别？</p><p>回答的是 ETC1 不带 Alpha 通道，ETC2 带 Alpha 通道，其它就差不多(实际上压缩质量也会高一点)</p><p>有问到如果 ETC 质量不佳怎么办？回答的是用 RGBA 设置看效果，而且还被追问除此之外呢？是否直接就用 RGBA 了？</p><p>下来后才想明白，意思应该是想问 ASTC 的，然而当时不知是觉得这个格式项目没有实际普及还是什么，根本没回答这个点…甚至回答上都没提到 ASTC，虽然 ASTC 这格式肯定是知道，ios、android 新机型通用的一种图片压缩格式，估计也跟只在理论上了解、却没自己实践对比有关——就很难反应过来。</p><p>因此这里就对这些格式挨个进行尝试、对比，整理一下自己了解的差异，以期得到更好的理解。</p><h2 id="图片设置"><a href="#图片设置" class="headerlink" title="图片设置"></a>图片设置</h2><p>sRGB 选项，本身处于 gamma 颜色空间内时，勾选与否都不影响。<br>处于线性颜色空间内时，勾选后才会做校正。</p><p>Mipmap：UI肯定不能勾，3D模型勾不勾取决于有没有相机远近操作及内存平衡。</p><h2 id="图片压缩格式"><a href="#图片压缩格式" class="headerlink" title="图片压缩格式"></a>图片压缩格式</h2><p>为什么需要压缩？</p><blockquote><p>减少内存、减少数据传输带宽需求，压缩是有损的。</p></blockquote><h3 id="压缩格式"><a href="#压缩格式" class="headerlink" title="压缩格式"></a>压缩格式</h3><p>对此官方文档也有列表说明：</p><p><a href="https://docs.unity.cn/cn/2021.2/Manual/class-TextureImporterOverride.html">class-TextureImporterOverride</a></p><h4 id="一、RGBA"><a href="#一、RGBA" class="headerlink" title="一、RGBA"></a>一、RGBA</h4><p>RGBA 格式主要分为：</p><p>RGBA64：每个像素64位，每个通道16位<br>RGBA32：每个像素32位，每个通道8位<br>RGBA16：每个像素16位，每个通道4位</p><p>其中 RGBA64、RGBA32 均为无压缩，RGBA16 官方文档说是『量化』模式，可能是靠直接量化缩放减少像素精度以减少内存占用，不过这种模式质量损失其实感觉有点大，对比了下还不如 ASTC4x4 压缩。</p><p><img src="/blogimages/2022/2022-10-26/m_42dd7d724910306bfad9c502639914ee_r.gif"><br>分辨率 128x128，RGBA32-&gt;ASTC4x4，大小为 32kb-&gt;16kb(质量和大小都不占优)</p><p>RGBA64 高精度模式，图片本身不支持的情况下，设置了也只是浪费内存，所以基本上可以把 RGBA32 当做『原图』看待。</p><h4 id="二、ECT1"><a href="#二、ECT1" class="headerlink" title="二、ECT1"></a>二、ECT1</h4><p>安卓，不带 Alpha 通道，4bits/pixel<br>强行要求图片分辨率为 2N 次方。</p><h4 id="三、ETC2"><a href="#三、ETC2" class="headerlink" title="三、ETC2"></a>三、ETC2</h4><p>安卓，带 Alpha 通道 8bits/pixel，不带Alpha通道 4bits/pixel，质量比 ETC1 好。<br>强行要求图片分辨率为 2N 次方。</p><p>ETC1 与 ETC2 对比（128x128&amp;10.7kb）：<br><img src="/blogimages/2022/2022-10-26/m_c127eafb4fe2f0fd9f71884b89aa3b01_r.gif"></p><p>(字体边缘变化模糊度更低的就是 ETC2)</p><blockquote><p>ETC2 还有一种支持镂空图(无Alpha过度)的模式(RGB+1bit Alpha)，也是 4 bits/pixel，这个格式网上没有解释如何处理的，猜测是将 Alpha 0.5 为界限，完全透明或不透明。</p></blockquote><p>我用 PS 大概画了一张渐变图进行测试，设置后对比效果如下：<br><img src="/blogimages/2022/2022-10-26/m_a826a55fc92b56bcb2afebe58984bf6d_r.png"></p><p>例如：<br><img src="/blogimages/2022/2022-10-26/m_609ff492c0b942aa2caa9c7a78074344_r.png"><br>左边为 ETC2 RGB+1bit Alpha 4Bit(8KB)，右边为 ETC2 RGBA 8Bit(16KB)<br>整体质量相对会差一点，不过相比常规 ETC2 RGBA 省一半内存。感觉这种适合效果要求不是很高、小一些的无渐变的纯透明图标，不过边缘像素必须处理好，不然边缘可能会比较明显，或者存在锯齿。</p><p> 注：ETC 和 ETC2 在 Unity 还有种 Crunched 模式，可以自己选择压缩比(不过 ETC2 只有 RAGB Crunched)，这种模式会增加一定解压消耗，因为它会在 CPU 上将该纹理解压缩为 ETC 传给 GPU(虽然官方称解压过程『非常快』)，更多见 <a href="https://docs.unity.cn/cn/2021.1/Manual/texture-compression-formats.html">官方文档</a> 说明。</p><h4 id="四、ASTC"><a href="#四、ASTC" class="headerlink" title="四、ASTC"></a>四、ASTC</h4><p>文档表示同等压缩率下，效果比 ETC2 更好，其 blockSize 越大压缩率越高，压缩分块从 4x4 到 12x12 最终可以压缩到每个像素占用1bit以下</p><p>其原理是将图片分块，每块颜色固定为 16bytes，然后通过控制每块存放多少像素(4x4、6x6)来控制压缩率，所以存放颜色越多压缩率越高，效果就越差。</p><p>不像 ETC、PVRTC 强行要求分辨率 2N 次方，当然符合这个规则的图片最好。<br>参考：<a href="https://www.zhihu.com/question/376921536/answer/1063272336">https://www.zhihu.com/question/376921536/answer/1063272336</a></p><p>与 RGBA 格式相比：<br><img src="/blogimages/2022/2022-10-26/m_1cdadb33b2ad7d459502ea3928123fdb_r.png"></p><p>计算公式为：压缩后像素大小=16bytes/(分块宽高)x8bit</p><p>尝试计算一张 1024x1024 图片在 ASTC 10x10 下的大小：</p><p>压缩后每像素颜色占用：16/(10x10)x8=1.28bit<br>原本大小：1024x1024x32=4MB<br>4MB/(32/1.28)=1024x1024x1.28=1342177.28bit=163.84KB</p><p>ASTC 的 Alpha 通道是自动识别的(特指安卓平台，ios 倒是可以单独选择是否带Alpha通道格式)。如果带 Alpha 通道，可以设置更低的 block size，否则可以设置更高的 size。<br>例如，根据压缩率的对比，若将 4x4 作为带 Alpha 透明通道图片标准：</p><ul><li>4x4=8bit=RGBA(32bit)=压缩率4倍</li><li>不带 Alpha 通道 压缩率4倍=RGB(24bit)/4=6bit~5x5</li></ul><p>当然，换算也不绝对，还是要看实际图片效果进行确定，不过感觉一般通用可以按照这种规则来，若某些特定图片出现可见的损失则手动处理。</p><p>对比了一下：<br><img src="/blogimages/2022/2022-10-26/m_a3628ccb80bd4c4bf8a34d6efe7dfc91_r.gif"><br>分辨率 128x128，ETC2-&gt;ASTC4x4，大小为 16kb-&gt;16kb</p><p><img src="/blogimages/2022/2022-10-26/m_e08338c3627fd662eaebe5a10151a8c9_r.gif"><br>分辨率 128x128，ETC2-&gt;ASTC5x5，大小为 16kb-&gt;10.6kb</p><p><img src="/blogimages/2022/2022-10-26/m_dce12c80ae66fc19ac3437d779f5a89c_r.gif"><br>分辨率 128x128，ETC2-&gt;ASTC6x6，大小为 16kb-&gt;7.6kb</p><p><img src="/blogimages/2022/2022-10-26/m_5aa5d2788a135af160a24bf2a58eac85_r.gif"><br>分辨率 128x128，ETC2-&gt;ASTC8x8，大小为 16kb-&gt;4kb</p><p>同一张带 Alpha 通道的 Icon 图片，直到 ASTC8x8 的时候才与 ETC2 有了比较明显的差距(比之更糊点)，但是大小可是小了4倍！那怕 ASTC6x6 也小了一倍以上，且效果更好。</p><p>最后，再分别使用 ASTC4x4、ETC2 与 RGBA32(也就是原图) 进行对比：</p><p><img src="/blogimages/2022/2022-10-26/m_0725399211d37c2164d73402e59dc5f2_r.gif"><br>分辨率 128x128，RGBA32-&gt;ASTC4x4，大小为 64kb-&gt;16kb  ↑</p><p><img src="/blogimages/2022/2022-10-26/m_3e3bb61964458ed75820064d9196d2e1_r.gif"><br>分辨率 128x128，RGBA32-&gt;ETC2，大小为 64kb-&gt;16kb ↑</p><p>其中，RGBA32-&gt;ASTC4x4 损失的质量很少，RGBA32-&gt;ETC2 质量损失就比较明显了。</p><p>后续还测试了 RGBA32-&gt;ASTC5x5，虽然噪点更多，不过在宏观上来看，对于小图来说基本跟原图差别不是很大。</p><p>虽然按照文档所说，ASTC 效果会比 ETC2 更好，不过设置更高的 block 获得更高压缩率后效果肯定还是会降低，这是压缩率跟质量必然的取舍。不过大的 ASTC block 压缩率是真的高，而且 ios 和 android 都支持(除了非常非常老的设备——iPhone6以前、android OpenGLES3.0 部分及所有 OpenGLES3.1 GPU)。</p><h4 id="五、PVRTC"><a href="#五、PVRTC" class="headerlink" title="五、PVRTC"></a>五、PVRTC</h4><p>IOS(GPU) 专用，强行要求图片分辨率为 2N 次方的方形。</p><p><img src="/blogimages/2022/2022-10-26/m_cfd9379259a7046ae87bffb4e9f287ec_r.png"><br>从左自右分别是：ASTC4x4(16kb)-&gt;ASTC6x6(7.6kb)-&gt;ASTC8x8(4kb)-&gt;PVRTC_4bit(8kb)-&gt;PVRTC_2bit(4kb)</p><p>就实际结果而言，PVRTC 2bit 糊得基本没法看，而 PVRTC 4bit 实际效果，基本也就跟 ASTC8x8 差不多，细节上甚至还差一点——而 ASTC8x8 容量却比它低了一半。</p><p>PVRTC 4bit 只能说比 ASTC10x10 好些——但 ASTC10x10 都直接压缩到 2.6kb 了</p><p>所以 ASTC 在 ios 上的质量/压缩比优势比在 android 平台更大，如果目标机型不是 iPhone6(iPhone6支持) 以前的设备，最好就使用 ASTC 了。</p><h4 id="六、其它"><a href="#六、其它" class="headerlink" title="六、其它"></a>六、其它</h4><p>除此之外，还有部分『其它』格式，例如：</p><ul><li>R8：未压缩单通道 (R)</li><li>Alpha 8：未压缩单通道 (A)</li><li>EAC：与 ETC 类似，不过只有单通道或双通道。</li><li>R EAC 4 bit ：压缩单通道 (R)</li><li>RG EAC 8 bit ：压缩双通道 (RG)</li><li>等</li></ul><p>详细解释在官方文档 <a href="https://docs.unity.cn/cn/2021.2/Manual/class-TextureImporterOverride.html">class-TextureImporterOverride</a> 也都有说明，不过这些诸如拆分通道的格式，基本上不常用(或者说没见过用)，或许某些情况下，写 Shader 只需要单通道之类的可能会用到？</p><h2 id="压缩后对-AssetBundle-影响"><a href="#压缩后对-AssetBundle-影响" class="headerlink" title="压缩后对 AssetBundle 影响"></a>压缩后对 AssetBundle 影响</h2><p>在对图片格进行一堆测试之后，心里就冒出一个想法：</p><blockquote><p>既然图片本体进行了压缩，那么对最终资源大小有影响吗？如果图片本身压缩后，AssetBundle 打包无法减少更小，是否可以选择对图片采取不压缩，或者 LZ4 压缩模式？</p></blockquote><p>于是找了一张图进行测试，由于这张图片不是 POT 分辨率，因此以 ASTC与RGBA32(原图) 为例。</p><p>简单的测试代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;AssetBundleTest/PackSelect(LZMA)&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PackSelectLZMA</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PackSelect(BuildAssetBundleOptions.DeterministicAssetBundle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;AssetBundleTest/PackSelect(LZ4)&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PackSelectLZ4</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PackSelect(BuildAssetBundleOptions.DeterministicAssetBundle | BuildAssetBundleOptions.ChunkBasedCompression);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;AssetBundleTest/PackSelect(Uncompress)&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PackSelectUncompress</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PackSelect(BuildAssetBundleOptions.DeterministicAssetBundle | BuildAssetBundleOptions.UncompressedAssetBundle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PackSelect</span>(<span class="params">BuildAssetBundleOptions opt</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Object o = Selection.activeObject;</span><br><span class="line">    <span class="built_in">string</span> path = AssetDatabase.GetAssetPath(o);</span><br><span class="line">    AssetImporter importer = AssetImporter.GetAtPath(path);</span><br><span class="line">    <span class="keyword">if</span> (importer == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    AssetBundleBuild build = <span class="keyword">new</span> AssetBundleBuild();</span><br><span class="line">    build.assetBundleName = importer.assetBundleName;</span><br><span class="line">    build.assetNames = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; path &#125;;</span><br><span class="line"></span><br><span class="line">    BuildPipeline.BuildAssetBundles(Path.Combine(Application.dataPath, <span class="string">&quot;MyBundles&quot;</span>), <span class="keyword">new</span> AssetBundleBuild[] &#123; build &#125;, opt, EditorUserBuildSettings.activeBuildTarget);</span><br><span class="line">    AssetDatabase.Refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比结果：</p><p><img src="/blogimages/2022/2022-10-26/m_45ae9e30c0769a8bf06e42f270e4b5b0_r.png"><br>RGBA(1.8M)-&gt;LZMA(449kb[25%])-&gt;LZ4(755kb[41%])-&gt;不压缩(1.85M[102%])</p><p><img src="/blogimages/2022/2022-10-26/m_6cb8901537c88400d2f74a18cfbf539f_r.png"><br>ASTC4x4(462.2kb)-&gt;LZMA(273kb[59%])-&gt;LZ4(303kb[65%])-&gt;不压缩(467kb[101%])</p><p><img src="/blogimages/2022/2022-10-26/m_143d4ebe0f769145f38441f41cbbe99a_r.png"><br>ASTC12x12(52.1kb)-&gt;LZMA(33kb[63%])-&gt;LZ4(37kb[71%])-&gt;不压缩(57kb[109%])</p><p>ETC2 压缩模式对于 NPOT 的图片，勾选 ToNearest(正常被压缩) 以及不勾选(无法正常被压缩为ETC2) 的大小：<br><img src="/blogimages/2022/2022-10-26/m_7625bcb93b3ed36ae3f31571ecd2bf35_r.png"></p><p>根据结果可以得出结论：</p><blockquote><p>被压缩过的图片，最终打出来的 AssetBundle 包压缩率也会更低——当然无论如何，图片本身进行过压缩格式压缩后，最终资源包体会更小。<br>ETC 一类如果图片是 NPOT 分辨率，则压缩将会无效</p></blockquote><p>所以从空间占用来考虑，打包时『通常压缩』格式依然还是需要选择压缩模式的。</p><p>为什么『通常压缩』要打重点？</p><p>因为后面我在测试 ETC Crunched 压缩模式时，确认这种高压模式 AssetBundle 无法再作压缩了。</p><p>依然以上述图片为例，设置为 ETC Crunched 100% 质量：<br><img src="/blogimages/2022/2022-10-26/m_905a5cbc8b864c77f6b34a21e50bdef8_r.png"></p><p>打包的 AssetBundle 大小基本跟 Inspector 预览差异不大(多了一点 AssetBundle 数据)<br>所以要是选用了 ETC Crunched 模式，打包 AssetBundle 倒是可以采用『不压缩』或者『LZ4』来进一步节省加载时间。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>就算是 ASTC 压缩，如果选择开启了 Mipmap，则同样要求必须是 POT 的图，否则无法压缩——对此项 Unity 会有 Warning 提示。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据上述各种对比，可以得出结论：</p><ul><li><p>质量(由高到低)：RGBA32(64kb)-&gt;ASTC4x4(16kb)-&gt;ASTC5x5(10.6kb)-&gt;ASTC6x6(7.6kb)-&gt;ETC2(16kb)-&gt;ASTC8x8(4kb)~PVRTC4bit(8kb)-&gt;ASTC10x10(2.6kb)-&gt;PVRTC2bit(4kb)</p></li><li><p>大小(由高到低)：RGBA32(64kb)-&gt;ASTC4x4(16kb)-&gt;ETC2(16kb)-&gt;ASTC5x5(10.6kb)-&gt;PVRTC4bit(8kb)-&gt;ASTC6x6(7.6kb)-&gt;ASTC8x8(4kb)-&gt;PVRTC2bit(4kb)-&gt;ASTC10x10(2.6kb)</p></li></ul><p>所以，除非对非常老的机型也想支持，否则默认就可以使用 ASTC6x6 ，再视情况而定对 Block 进行增加或减少。</p><p>否则:</p><ul><li>安卓：不带 Alpha 使用 ETC2 RGB，带 Alpha 使用 ETC2 RGBA</li><li>IOS：不带 Alpha 使用 PVRTC RGB 4bit，带 Alpha 使用 PVRTC RGBA 4bit<br><font color=red>注1：ETC 要求图片为 2N 次方(长宽不强行要求一致)</font><br><font color=red>注2：PVRTC 要求图片为 2N 次方的方形(长宽强行要求一致)</font><br><font color=red>注3：IOS PVRTC 勾选 ToNearest 同样会被强行压缩为正方形，比安卓平台变形会更大(当长宽差距过大 ToNearest 也会失败)</font><br><font color=red>注4：勾选 ToNearest 时，缩放算法可以选 Bilinear ，个人对比后觉得这个细节明显更好点，默认的 Mitchell 更糊。</font></li></ul><p>另外，在实在无法启用 ASTC，但是又想减少包体大小的情况，可以考虑使用 ETC Crunched(有损压缩) 模式，该模式增加部分解压 CPU 消耗，以时间换存储空间，且对于运行时内存使用量没有影响(在<a href="https://forum.unity.com/threads/questions-about-compression-formats-etc2-crunch-etc.511560/">加载时被解压缩</a>，官方称 解压缩速度非常快)。<br>(由于压缩率很高，文件大小减少，变相减少了 IO，对整体加载时间的影响或许不会太大？)<br><font color=red>注1：ETC Crunched 无法再被 AssetBundle 进一步压缩</font><br><font color=red>注2：ETC Crunched 压缩比非常高，经过测试可能比 ASTC12x12 都小</font><br><font color=red>注3：实测 ETC2 Crunched 100% 质量也比普通 ETC2 更糊一些</font></p><ul><li>部分无法压缩的 NPOT 图片，勾选 ToNearest 会导致效果出现问题，或者使用的不规则图片然后调用了 SetNativeSize 的情况(一般出现于老项目，比如说我们汉室复兴)，也可以采取使用 RGB16 或 RGBA16 的格式，比 32 位减少一半大小。<br><font color=red>注：优化老项目时(例如我们的项目)，对于设置 ETC2 和 RGBA16 时可以评估考虑两者具体占用大小、效果。</font>例如带透明通道 RGBA16 某些大图可能会会产生『条纹』。部分情况(RGBA)下 ToNearest ETC2(8bit） 占用比 RGBA16 还要高(512x512x8&gt;300x300x16)，强行要求方形的 PVRTC(4bit) 极端情况下可能也有类似问题(512x512x4&gt;400x100x16)。可以写个工具计算两者哪个更划算再进行设置。</li></ul><p>其它还需要注意的是官方对平台不支持纹理的说明：</p><blockquote><p>当 Unity 加载的纹理具有设备不支持的压缩格式时，它会将纹理解压缩为该平台的默认未压缩格式，并将未压缩副本与原始压缩纹理一起存储在内存中。这会增加纹理加载时间并使用额外的内存。当 Unity 加载的纹理具有设备支持的压缩格式时，GPU 可以使用该数据而无需任何转换。</p></blockquote><p>最后：<br>因为 ETC 不支持 Alpha，一些老项目会出现单独分离透明通道的做法。<br>虽然 ASTC 已经不强行要求 2N次方了，不过 POT 最好也让美术遵守一下，对性能有一定好处，<a href="https://www.zhihu.com/question/376921536/answer/1063272336">参考</a>。</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>既然 ASTC 会根据 Alpha 自动计算压缩效果，Unity(2021.3.6f1) 为安卓平台提供的 ASTC 选项也是合并在一块的，为什么 IOS 平台又是分开设置的了？</p><blockquote><p>注：Unity2018.4.36f1 安卓也是分开的，分为 ASTC RGB 和 ASTC RGBA，推测高版本 Unity 安卓平台增加了 ASTC HDR 模式后，因为设置量太多而合并？</p></blockquote><p>参考文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/158740249">ASTC纹理压缩格式详解</a></li><li><a href="https://docs.unity.cn/cn/2021.1/Manual/texture-compression-formats.html">texture-compression-formats</a></li><li><a href="https://docs.unity.cn/cn/2021.1/Manual/class-TextureImporterOverride.html">class-TextureImporterOverride</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在今年10月份这次评审的时候，有问到图片设置相关的内容，当时感觉也是没回答多好。&lt;/p&gt;
&lt;p&gt;例如，ETC1 与 ETC2 相比有什么差别</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://cwhisme.github.io/categories/Unity3D/"/>
    
    
    <category term="性能优化" scheme="https://cwhisme.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>关于纪元项目Demo</title>
    <link href="https://cwhisme.github.io/2022/09/30/%E5%85%B3%E4%BA%8E%E7%BA%AA%E5%85%83%E9%A1%B9%E7%9B%AEDemo/"/>
    <id>https://cwhisme.github.io/2022/09/30/%E5%85%B3%E4%BA%8E%E7%BA%AA%E5%85%83%E9%A1%B9%E7%9B%AEDemo/</id>
    <published>2022-09-29T16:00:00.000Z</published>
    <updated>2022-12-11T02:01:22.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是以前制作人还在的时候，发起的一个Demo，不过由于没有最终定性，因此只是让我在空余时间搞一搞。</p><p>游戏背景之类这里就不做介绍了。</p><p>这个 Demo 主要实现有：</p><ol><li><p>利用腾讯地图 SDK 结合，实现定位+地图手动移动功能:</p><ul><li><a href="https://lbs.qq.com/mobile/unityGeo/unityGeoGuide/unityGeoOverview">TencentLocationSdk(定位)</a></li><li><a href="https://lbs.qq.com/mobile/unitySdk/unitySdkGuide/unityOverview">TencentMapSdk(地图)</a></li><li><a href="https://lbs.qq.com/service/webService/webServiceGuide/webServiceOverview">WebService API(路径信息)</a></li></ul></li><li><p>同时整合了汉室复兴的战斗系统逻辑层，并修改为实时操纵移动、战斗，嵌入新的表现层</p></li><li><p>一套简单的 UI 管理 (由于只是Demo，因此并未采用平移汉室复兴的UI框架，自己实现了一个以栈结构为基础的简单UI管理结构)</p></li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>地图：</p><p><img src="/blogimages/2022/2022-09-30/m_3638219618620ffbee8bee495860613a_r.gif" alt="地图"></p><p>信息：</p><p><img src="/blogimages/2022/2022-09-30/m_f2ed7a226ee4957d7f0b6983aeda3df0_r.gif"></p><p>信息上，复用了汉室复兴的配置表，这儿只是简单把所有道具都放了一个在包裹中。</p><p><img src="/blogimages/2022/2022-09-30/m_d6d6172695a9dfa7e8bed36f3ec5dc4c_r.gif"></p><p>战斗与之前不一样的主要是可以允许玩家手动移动、点选目标等，对于这种离线帧同步的战斗模式，所有玩家操作命令都必须作记录，以便后续 WebServer 搭建好了，可以与以前一样进行验算。</p><p>这里直接将这些项目作为外部操作命令新增，由于玩家可以不断点击，如果优化指令数量(因为一场战斗最多会有有5400帧[即3分钟])，可以通过增加移动间隔、压缩同类型指令进行，不过这里只是前期 Demo，因此暂未实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是以前制作人还在的时候，发起的一个Demo，不过由于没有最终定性，因此只是让我在空余时间搞一搞。&lt;/p&gt;
&lt;p&gt;游戏背景之类这里就不做介绍</summary>
      
    
    
    
    <category term="Demo" scheme="https://cwhisme.github.io/categories/Demo/"/>
    
    
    <category term="Demo" scheme="https://cwhisme.github.io/tags/Demo/"/>
    
  </entry>
  
  <entry>
    <title>解决守望项目刘海屏真机白屏问题记录</title>
    <link href="https://cwhisme.github.io/2022/09/28/%E8%A7%A3%E5%86%B3%E5%AE%88%E6%9C%9B%E9%A1%B9%E7%9B%AE%E5%88%98%E6%B5%B7%E5%B1%8F%E7%9C%9F%E6%9C%BA%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://cwhisme.github.io/2022/09/28/%E8%A7%A3%E5%86%B3%E5%AE%88%E6%9C%9B%E9%A1%B9%E7%9B%AE%E5%88%98%E6%B5%B7%E5%B1%8F%E7%9C%9F%E6%9C%BA%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2022-09-27T16:00:00.000Z</published>
    <updated>2022-12-11T02:01:22.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>注：该问题可能仅适用于项目，或者公司该项目衍生版本(该是没有了)</strong></p><p>在给对面出了新包之后，由于我方测试都只有低端机，连刘海都没有，因此没有测出该问题。</p><p>后续由运营同步过来，显示效果如下：</p><p><img src="/blogimages/2022/2022-09-28/m_a67c42c71cc70838d1f8a1081d9ec448_r.png"></p><p>描述的服务器问题可以忽略，那个是因为后台没开外网测试服导致。</p><p>然后我就看了下以前<font color=red>上一个项目组</font>出给对面的白包效果：</p><p><img src="/blogimages/2022/2022-09-28/m_b8f77ca2faa524d65d5da4d97b76443e_r.png"></p><p>这旧版本的刘海更大了！所以还是感觉新版如果把刘海也渲染进去，表现效果会更好一点，稍微查了一下，就得知刘海没有被渲染的原因是因为出包工程 Unity2018.4.36 这个版本没勾 『Render outside safe area』选项导致的，于是勾上重新出包。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>这时候真的问题就来了：</p><p>在我自己的刘海屏(红米K50G)真机安装后，会正常执行初始的 Loading 界面，后续立刻白屏！</p><p>表现效果如下：</p><p><img src="/blogimages/2022/2022-09-28/m_cf7b1733e5867c699e36082f5a3cb43f_r.gif"></p><p>看着这个表现，最开始怀疑过是Unity的问题：因为我拿到项目时，版本虽然是 Unity2018，但并不是 Unity2018 最新版本，后来给它升级到 Unity2018.4.36 了，就猜测是不是 Unity 出啥事了？</p><p>项目设置如下：</p><p><img src="/blogimages/2022/2022-09-28/m_c53c356eab861de7f5b7b9a6ba011e48_r.png"></p><p>2018.4 官方说明文档：</p><p><img src="/blogimages/2022/2022-09-28/m_05c3ec910acdc69b5899d43ad7cd8e72_r.png"></p><p>如上图所示，查询文档显示 Unity2018 文档上并没有 Render outside safe area 这选项，跟项目实际设置表现并不一致，该选项是否是 Unity2018 后续才更新上去的？导致出现了什么兼容性问题。</p><p>不过后边根据表现情况一想，也不对。</p><p>毕竟最开始 Loading 都能正常显示出来，那么说明 Render outside safe area 并没有让我们的真机整体的渲染出现问题。</p><p>根据发生情况地点：初始 Loading 界面完毕，UI框架接管之后——问题恐怕只可能出现在我们自己的 UI 框架作适配性的地方。</p><p>还有一个信息可以使得 100% 确定是项目的适配而非 Unity 的问题：</p><p>—— 可以打开日志界面！</p><p><img src="/blogimages/2022/2022-09-28/m_68a9dc72678952c375016e2d306ca555_r.png"></p><p>日志界面是可以正常显示的，因此出问题的只可能是项目 AorUISystem 中适配问题。</p><h2 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h2><p>对于项目中适配的地方，根据代码引用一步一步查询，大概可以找出两个可能会比较影响点：</p><ul><li>Main.cs 中 AdapteFullScreen() 判断刘海方法</li><li>AorUIManager.cs 中 ScaleMode-&gt;changeScaleMode()-&gt;updateStageSize()</li></ul><p>开始虽然基本可以定位是这两块的问题，但是并没有更详细的头绪。</p><p>并猜测：</p><ul><li>是否是 Stage 缩放大小被错误设置为0？因为 Stage scale 其实很小，而且根据分辨率不同还可能更小<br><img src="/blogimages/2022/2022-09-28/m_debc641d73c783234617782f0234fb8f_r.png"></li><li>是否由于读取到刘海，Stage 发生了严重的错误偏移？</li><li>是否是 MainLayer 层级有遮挡？</li></ul><h4 id="出包测试"><a href="#出包测试" class="headerlink" title="出包测试"></a>出包测试</h4><p>为了对上述猜测进验证，且由于是真机、特定机型问题，为了测试，基本上都是改一次代码，出一个包，导致时间消耗更加拉长。</p><h4 id="Injectfix-远程热更测试"><a href="#Injectfix-远程热更测试" class="headerlink" title="Injectfix 远程热更测试"></a>Injectfix 远程热更测试</h4><p>后来想着这样可不是办法，于是我把 Injectfix 远程热更调试功能给它整合了进去，然后才变得方便起来。</p><p>找到游戏点击屏幕处理方法，直接热更输出需要的详细信息，并操作对猜测进试验：</p><p><img src="/blogimages/2022/2022-09-28/m_a2038f3d25baa22c262b0fadcf7b7d68_r.png"></p><p>Loading 结束，进入正式 UI 管理后，其基本结构如下：</p><p><img src="/blogimages/2022/2022-09-28/m_4affba82fd8aabee3e1d63ae7452a1d6_r.png"></p><p>尝试使用排除法，操作结果反馈如下：</p><ul><li>隐藏 MainLayer：无变化</li><li>隐藏 AorUIStage# 所有子节点：无变化</li><li>隐藏 AorUIStage#：无变化</li><li>隐藏 AorUICanvas#：有明显变化，白屏变成黑屏</li><li>隐藏 AorUICanvas#所有子节点：同隐藏父类，有明显变化，白屏变成黑屏</li><li>在 AorUICanvas#、AorUIStage# 子节点动态创建色块，无变化</li><li>隐藏 AorUICanvas# 所有子节点，创建动态色块，能看到色块显示</li></ul><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>结合上面一通测试结果，以及输出信息。</p><p>可以基本确认，是 AorUICanvas# 下的某个子节点出了问题。</p><p>于是尝试：</p><ul><li>隐藏 AorUICanvas# 除 AorUIStage# 以外的所有子节点，登录界面正常展示！</li></ul><p>在 AorUIStage# 层级更高的节点中，ipx 这个节点就比较可疑，再次进行测试，仅隐藏 ipx，登录界面也正常显示，白屏消失。</p><p>此时基本可以定位问题原因。</p><p>于是查看代码，我很快在 AdapteFullScreen() 方法中发现了这么些处理方法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Application.platform == RuntimePlatform.Android &amp;&amp; Screen.width == <span class="number">2400</span> &amp;&amp; Screen.height == <span class="number">1080</span>)</span><br><span class="line">&#123;</span><br><span class="line">isTest = <span class="literal">true</span>;<span class="comment">//关键就这里！！！！！！</span></span><br><span class="line">YKApplication.Instance.IsIphoneX = <span class="literal">true</span>;</span><br><span class="line">CommonModel.Inst.IsLandscapeLeft = <span class="literal">true</span>;</span><br><span class="line">mIsFullAdapter = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=====代码省略=======</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器测试</span></span><br><span class="line"><span class="keyword">if</span> (isTest &amp;&amp; <span class="literal">null</span> == uiManger.mCanvasT.Find(<span class="string">&quot;ipx&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建 ipx 组件，该组件模拟 iphone 边框进显示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/blogimages/2022/2022-09-28/m_39da789ee4d022ce3dac2872115e7849_r.png"></p><p>大家看到了吗？</p><h5 id="EditorOnly！"><a href="#EditorOnly！" class="headerlink" title="EditorOnly！"></a>EditorOnly！</h5><p>也就是说，这张图片根本不会打进真机包里——然而代码却在实例化它？！</p><p>导致图片丢失，直接整个屏幕就是一块白色覆盖。</p><p>问题就是这样：代码执行了不应该真机生效的代码，错误地创建了一个根本不应该创建的东西，导致出现了这么一个很难让人一眼看出问题的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>问题是解决了，但是花了一天多时间调试。</p><p>造成的根本原因是，<font color=red>项目代码里面直接强行判断若『当前为安卓平台，且分辨率为 2400x1080』，就会实例化测试边框，看起来完全是为了测试用(特别是注释都写了编辑器测试的)，且图片又是被标记为 EditorOnly ——而真机执行，测试边框的图通常情况下根本不会打出去，那就坏了！</font><br>注：我拿到项目这张图片就是 EditorOnly，代码也是这个样子，出包工程也并不存在 Resources 中图片的软链接</p><p>看注释还写着『编译器测试』，测试代码，如果只是想测试生效，就不应该这样加入正常代码流程，再不济用完也应该注释吧？或者再加个编辑器生效判断也好。</p><p>折腾这么大一通，倒也也不算没有收获：为守望项目整合了远程代码热更调试工具用，并详细测了一波热更代码，拿到守望项目代码之后，热更结构我也是做过改动的，因此测试一波也是也有必要。</p><h3 id="另一种解决方案"><a href="#另一种解决方案" class="headerlink" title="另一种解决方案"></a>另一种解决方案</h3><p>但实际上还有另一个方法，要是使用的话，一开始就能很快定位并解决问题：</p><h4 id="FrameDebugger"><a href="#FrameDebugger" class="headerlink" title="FrameDebugger"></a>FrameDebugger</h4><p>虽然 Unity2018 的 FrameDebugger 连接真机并不怎么好用，渲染对象跟随真机老是闪来闪去。</p><p>不过使用 FrameDebugger 连接真机后，还是可以大概查询渲染目标，可以清晰看出来：原本登录界面是正常渲染了的，只是登录界面上更上一层，被白色的东西直接盖了个彻彻底底。</p><p>进而定位渲染没问题，而是覆盖问题导致。</p><p>可惜我也是在查出问题后，才想起用这个连接真机试试的，要不然肯定会少许多麻烦了。</p><p>除此之外 Renderdoc 应该也可以。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;注：该问题可能仅适用于项目，或者公司该项目衍生版本(该是没有了)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在给对面出了新包之后，由于</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://cwhisme.github.io/categories/Unity3D/"/>
    
    
    <category term="问题解决记录" scheme="https://cwhisme.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>关于从Unity2021降级为Unity2018的问题</title>
    <link href="https://cwhisme.github.io/2022/08/31/%E5%85%B3%E4%BA%8E%E4%BB%8EUnity2021%E9%99%8D%E7%BA%A7%E4%B8%BAUnity2018%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://cwhisme.github.io/2022/08/31/%E5%85%B3%E4%BA%8E%E4%BB%8EUnity2021%E9%99%8D%E7%BA%A7%E4%B8%BAUnity2018%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2022-08-30T16:00:00.000Z</published>
    <updated>2022-12-11T02:01:22.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前不是有写过 『关于汉室复兴升级Unity2021的问题记录』 这文章么，当时是为了将项目越南版本从 Unity2017 升级为 Unity2021。</p><p>主要考虑有三点：</p><ul><li>越南版本拖了一年多不止，新版可以拉开与其它版本差异，除此之外增加了一些越南特有优化，没准有助于提审</li><li>越南还未上线，先行升级可以先看相关兼容性</li><li>Hybridclr 若可以使用，只要提审成功一次，就可以像纯xlua项目一样更新，有助于运营</li></ul><p>越南还未上线，升级 Unity2021 之后测试也测了两个月了，包括真机我们这边和对面运营都跑过不少次，该有的问题页改得差不多了，目前唯一的问题就是还没有大规模地测试兼容性。</p><p>不过对于兼容性这一点，我也反复跟我们这边运营对过，后期会上 TestBird (真的能过审的话)。</p><p>不过本周周会的时候，前几次主程例会都提到过升级这个事，这一次上级反对意见比较大，大概就是得不求有功，但求无过。于是只能再作降级操作，后续研究计划也暂且放弃了。</p><p>虽然从低版本升级上去资源没有太大问题，但是反而降级操作，会造成大量资源问题，这里特记录一下。</p><p>目前发现主要有几个点：</p><ul><li>分散后的DLL重替换，Unity2018安装目录下也有分散DLL，直接替换即可</li><li>场景Unity组件丢失，例如挂载的UGUI相关 StandaloneInputModle、EventSystem</li><li>图集引用错乱，降级后，原有Prefab引用的图集中图片全乱了</li><li>所有在 Unity2021 修改过的Prefab都无法使用，Unity 组件，主要是UGUI出现 Missing</li></ul><p>后续再一一记录处理方式。</p><h2 id="场景Unity组件丢失"><a href="#场景Unity组件丢失" class="headerlink" title="场景Unity组件丢失"></a>场景Unity组件丢失</h2><p><img src="/blogimages/2022/2022-08-31/m_a40f0219e30bf832243a14d9802ac50e_r.png"></p><p>这个救不了，看修改记录引用 GUID 都有变化，而且降级之后 Unity 完全不会处理这一块，已被自动升级修改的也不会再自动改回去，Missing 了也不见怪，只能还原到升级之前。</p><h2 id="图集引用错乱"><a href="#图集引用错乱" class="headerlink" title="图集引用错乱"></a>图集引用错乱</h2><p><img src="/blogimages/2022/2022-08-31/m_1f4e876c1f2f9779eb9c917028000d99_r.png"></p><p>如上图所示，真的很恐怖，查看相关组件，部分为 Missing，部分为错误的精灵引用。</p><p><img src="/blogimages/2022/2022-08-31/m_04ade9c242f57b10fd6630e40b23c9fb_r.png"></p><p>经对比升级与现在降级后的修改记录，可以明显发现问题：ID对应的精灵名字已经发生了变化</p><p>这个同样救不了了，需要还原。</p><p>此时必须先关闭 Unity，然后Revert本地所有修改(因为使用Unity2018打开已经导致自动错误修改了大量 meta 了)，然后再针对之前升级提交记录进行还原。</p><p>在 SVN 上找到上次的提交记录，选择 『Revert changes from this version』，表示还原所有自此次提交的修改：</p><p><img src="/blogimages/2022/2022-08-31/m_f5e7234ddc313e2baff6c3a366cb9f56_r.png"></p><p>还原时会有大量冲突，由于这次提交还原的主要是 meta 文件，因此只需要选择 Accept incomming 即可，meta 文件会被重新修改。</p><p>当然实际上没这么简单就是了，在资源目录总提交上，有些冲突(例如DLL)会导致还原直接半途终止，因此最保险的方式还是从子目录开始，挨个检查是否涉及到需要还原的资源再进行还原。</p><p>图集还原之后，再将所有图集都重新打一遍就可以了。</p><blockquote><p>还好之前帮策划写过一个一键重打图集的工具！</p></blockquote><h2 id="高版本修改后的-Prefab-无法使用"><a href="#高版本修改后的-Prefab-无法使用" class="headerlink" title="高版本修改后的 Prefab 无法使用"></a>高版本修改后的 Prefab 无法使用</h2><p>关于这个，拿一个 Prefab Missing组件举例，此处为一个 Image 组件：</p><p>修改前的 Unity2017 版本：</p><p><img src="/blogimages/2022/2022-08-31/m_5afd85c5e555fbb8b1095b1db879c2cb_r.png"></p><p>从数据对比上来看，其中 Missing 的组件 ID 为 114414057906683420</p><p>然后搜索并对比修改前后两个组件的差异：</p><p><img src="/blogimages/2022/2022-08-31/m_98e244d2128270bb09b31b0bc60e0d18_r.png"></p><p>可以注意到，此处虽然高版本多了点东西、少了点啥，其实这些影响都不大，但是最关键的是 m_Scripts 字段 fileID、guid 全变了！</p><p>小心翼翼地手动将 fileID、guid 改回去，刷新一下：</p><p><img src="/blogimages/2022/2022-08-31/m_6563156f7f997661be21d505355c2c11_r.png"></p><p>已经 Missing 的组件变成正常了！</p><p>说明导致 Missing 的影响要素确实是这个问题。</p><p>注：<a href="https://docs.unity3d.com/cn/current/Manual/FormatDescription.html">官方meta文件描述</a></p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>经过上述尝试，可以发现有三种可供选择的方法：</p><ol><li>碰到一个修一个，手动修改 fileID、guid<blockquote><p>这个简直就是灾难，并且会花费大量时间，或许可以给实习生练手？但是没有必要</p></blockquote></li><li>直接还原这两个月的 Prefab 修改<blockquote><p>之前针对外服写过备份修改工具，可以一键重导入之前的修改。但是这涉及到部分工具无法处理，必须手动修改的 Prefab，可能出现遗漏</p></blockquote></li><li>写个工具，直接遍历所有 Prefab，并将指定 fileID、guid 作对应替换 <blockquote><p>手动改肯定不可能，不过就算写工具，也得一个个找出脚本新旧对应的 fileID、guid ，并改回去，但相比前两种方法，已经算是可以接受的程度了。</p></blockquote></li></ol><p>所以经过考虑，采用了第三种方法，首先对两个版本的组件 fileID、guid 进行对比：</p><ul><li><h4 id="Unity2018-4-36f1："><a href="#Unity2018-4-36f1：" class="headerlink" title="Unity2018.4.36f1："></a>Unity2018.4.36f1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Image：m_Script: &#123;fileID: -765806418, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">RawImage：m_Script: &#123;fileID: -98529514, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">Scroll View：m_Script: &#123;fileID: 1367256648, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">Scrollbar：m_Script: &#123;fileID: -2061169968, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">Slider：m_Script: &#123;fileID: -113659843, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">Toggle：m_Script: &#123;fileID: 2109663825, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">Text：m_Script: &#123;fileID: 708705254, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">Button：m_Script: &#123;fileID: 1392445389, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">Dropdown：m_Script: &#123;fileID: 853051423, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">InputField：m_Script: &#123;fileID: 575553740, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">ContentSizeFilter：m_Script: &#123;fileID: 1741964061, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">Mask：m_Script: &#123;fileID: -1200242548, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">GridLayoutGroup：m_Script: &#123;fileID: -2095666955, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">HorizontalLayouGroup：m_Script: &#123;fileID: -405508275, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">ToggleGroup：m_Script: &#123;fileID: -1184210157, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">CanvasScaler：m_Script: &#123;fileID: 1980459831, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">GraphicRaycaster：m_Script: &#123;fileID: 1301386320, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">Outline：m_Script: &#123;fileID: -900027084, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">EventTrigger：m_Script: &#123;fileID: -1862395651, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">LayoutElement：m_Script: &#123;fileID: 1679637790, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">VerticalLayoutGroup：m_Script: &#123;fileID: 1297475563, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br><span class="line">AspectRatioFitter：m_Script: &#123;fileID: -1254083943, guid: f70555f144d8491a825f0804e09c671c, type: 3&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="Unity2021-3-6f1："><a href="#Unity2021-3-6f1：" class="headerlink" title="Unity2021.3.6f1："></a>Unity2021.3.6f1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Image：m_Script: &#123;fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3&#125;</span><br><span class="line">RawImage：m_Script: &#123;fileID: 11500000, guid: 1344c3c82d62a2a41a3576d8abb8e3ea, type: 3&#125;</span><br><span class="line">Scroll View：m_Script: &#123;fileID: 11500000, guid: 1aa08ab6e0800fa44ae55d278d1423e3, type: 3&#125;</span><br><span class="line">Scrollbar：m_Script: &#123;fileID: 11500000, guid: 2a4db7a114972834c8e4117be1d82ba3, type: 3&#125;</span><br><span class="line">Slider：m_Script: &#123;fileID: 11500000, guid: 67db9e8f0e2ae9c40bc1e2b64352a6b4, type: 3&#125;</span><br><span class="line">Toggle：m_Script: &#123;fileID: 11500000, guid: 9085046f02f69544eb97fd06b6048fe2, type: 3&#125;</span><br><span class="line">Text (Legacy)：m_Script: &#123;fileID: 11500000, guid: 5f7201a12d95ffc409449d95f23cf332, type: 3&#125;</span><br><span class="line">Button (Legacy)：m_Script: &#123;fileID: 11500000, guid: 4e29b1a8efbd4b44bb3f3716e73f07ff, type: 3&#125;</span><br><span class="line">Dropdown (Legacy)：m_Script: &#123;fileID: 11500000, guid: 0d0b652f32a2cc243917e4028fa0f046, type: 3&#125;</span><br><span class="line">InputField (Legacy)：m_Script: &#123;fileID: 11500000, guid: d199490a83bb2b844b9695cbf13b01ef, type: 3&#125;</span><br><span class="line">ContentSizeFilter：m_Script: &#123;fileID: 11500000, guid: 3245ec927659c4140ac4f8d17403cc18, type: 3&#125;</span><br><span class="line">Mask：m_Script: &#123;fileID: 11500000, guid: 31a19414c41e5ae4aae2af33fee712f6, type: 3&#125;</span><br><span class="line">GridLayoutGroup：m_Script: &#123;fileID: 11500000, guid: 8a8695521f0d02e499659fee002a26c2, type: 3&#125;</span><br><span class="line">HorizontalLayouGroup：m_Script: &#123;fileID: 11500000, guid: 30649d3a9faa99c48a7b1166b86bf2a0, type: 3&#125;</span><br><span class="line">ToggleGroup：m_Script: &#123;fileID: 11500000, guid: 2fafe2cfe61f6974895a912c3755e8f1, type: 3&#125;</span><br><span class="line">CanvasScaler：m_Script: &#123;fileID: 11500000, guid: 0cd44c1031e13a943bb63640046fad76, type: 3&#125;</span><br><span class="line">GraphicRaycaster：m_Script: &#123;fileID: 11500000, guid: dc42784cf147c0c48a680349fa168899, type: 3&#125;</span><br><span class="line">Outline：m_Script: &#123;fileID: 11500000, guid: e19747de3f5aca642ab2be37e372fb86, type: 3&#125;</span><br><span class="line">EventTrigger：m_Script: &#123;fileID: 11500000, guid: d0b148fe25e99eb48b9724523833bab1, type: 3&#125;</span><br><span class="line">LayoutElement：m_Script: &#123;fileID: 11500000, guid: 306cc8c2b49d7114eaa3623786fc2126, type: 3&#125;</span><br><span class="line">VerticalLayoutGroup：m_Script: &#123;fileID: 11500000, guid: 59f8146938fff824cb5fd77236b75775, type: 3&#125;</span><br><span class="line">AspectRatioFitter：m_Script: &#123;fileID: 11500000, guid: 86710e43de46f6f4bac7c8e50813a599, type: 3&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/blogimages/2022/2022-08-31/m_022757aefd54eb580eb1ec28b1416276_r.png"></p><p><img src="/blogimages/2022/2022-08-31/m_672ea79241bf3928186395657de137a7_r.png"><br>(打印是后续调试进行过好几次的查漏补缺截图，因此数量才这么少)</p><p>另外需要注意千万不好混了，有一次就是复制重复了，导致组件上的脚本是有了，但却从 VerticalLayoutGroup 变成了 LayoutElement！</p><p>主要代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> resDir = Path.Combine(Application.dataPath, <span class="string">&quot;Resources&quot;</span>);</span><br><span class="line"><span class="built_in">string</span>[] prefabLists = Directory.GetFiles(resDir, <span class="string">&quot;*.prefab&quot;</span>, SearchOption.AllDirectories);</span><br><span class="line"><span class="built_in">int</span> num = prefabLists.Length;</span><br><span class="line"><span class="built_in">string</span>[] linesTemp;</span><br><span class="line"><span class="built_in">bool</span> doSave;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">&#123;</span><br><span class="line">    EditorUtility.DisplayProgressBar(<span class="string">&quot;降级修复中……&quot;</span>, <span class="string">$&quot;请等待，执行进度：<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;num&#125;</span>&quot;</span>, (<span class="built_in">float</span>)i / num);</span><br><span class="line">    doSave = <span class="literal">false</span>;</span><br><span class="line">    linesTemp = File.ReadAllLines(prefabLists[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> lineIndex = <span class="number">0</span>; lineIndex &lt; linesTemp.Length; lineIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历2021最新的id，检测每一行是否有对应数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> newIndex = <span class="number">0</span>; newIndex &lt; Unity2021.Length; newIndex++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (linesTemp[lineIndex].Contains(Unity2021[newIndex]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//2021替换为2018</span></span><br><span class="line">                linesTemp[lineIndex] = linesTemp[lineIndex].Replace(Unity2021[newIndex], Unity2018[newIndex]);</span><br><span class="line">                doSave = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (doSave)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;修复对象：<span class="subst">&#123;prefabLists[i]&#125;</span>&quot;</span>);</span><br><span class="line">        File.WriteAllLines(prefabLists[i], linesTemp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EditorUtility.ClearProgressBar();</span><br><span class="line">AssetDatabase.Refresh();</span><br><span class="line">AssetDatabase.SaveAssets();</span><br></pre></td></tr></table></figure><p>然后自己跑了下，出了真机包也试了一圈没什么问题，不过后续还是需要测试重新跑一次全量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前不是有写过 『关于汉室复兴升级Unity2021的问题记录』 这文章么，当时是为了将项目越南版本从 Unity2017 升级为 Unit</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://cwhisme.github.io/categories/Unity3D/"/>
    
    
    <category term="问题解决记录" scheme="https://cwhisme.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>处理Unity2019的UGUI顶点数据更新后的图文混排问题</title>
    <link href="https://cwhisme.github.io/2022/07/21/%E5%A4%84%E7%90%86Unity2019%E7%9A%84UGUI%E9%A1%B6%E7%82%B9%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E9%97%AE%E9%A2%98/"/>
    <id>https://cwhisme.github.io/2022/07/21/%E5%A4%84%E7%90%86Unity2019%E7%9A%84UGUI%E9%A1%B6%E7%82%B9%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E9%97%AE%E9%A2%98/</id>
    <published>2022-07-20T16:00:00.000Z</published>
    <updated>2022-12-11T02:01:22.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前听到运营那边报我们游戏可能会出现崩溃问题，主要是韩服，三星机器。</p><p>于是拿了日志来看，主要信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">2022-07-07 14:58:35.666 10105-11685/? E/Unity: Using memoryadresses from more that 16GB of memory</span><br><span class="line">     </span><br><span class="line">    (Filename:  Line: 120)</span><br><span class="line">2022-07-07 14:58:36.069 10105-11685/? E/CRASH: signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 00000000005ce87f</span><br><span class="line">2022-07-07 14:58:36.069 10105-11685/? E/CRASH: *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***</span><br><span class="line">2022-07-07 14:58:36.069 10105-11685/? E/CRASH: Build fingerprint: &#x27;samsung/d1xks/d1x:12/SP1A.210812.016/N971NKSU2HVE9:user/release-keys&#x27;</span><br><span class="line">2022-07-07 14:58:36.069 10105-11685/? E/CRASH: Revision: &#x27;23&#x27;</span><br><span class="line">2022-07-07 14:58:36.069 10105-11685/? E/CRASH: pid: 10105, tid: 11685, name: Thread-21  &gt;&gt;&gt; com.gamemorefun.sgztw &lt;&lt;&lt;</span><br><span class="line">2022-07-07 14:58:36.069 10105-11685/? E/CRASH:     x0   0000000000000000  x1   000000715477cf1c  x2   0000006ec75ced60  x3   0000006d857acc28</span><br><span class="line">2022-07-07 14:58:36.069 10105-11685/? E/CRASH:     x4   000000000000007c  x5   0000000000000000  x6   000000716ad1c000  x7   000000001fdcdd1e</span><br><span class="line">2022-07-07 14:58:36.069 10105-11685/? E/CRASH:     x8   0000000000000000  x9   00000000ffffffff  x10  0000000000000090  x11  0000000000000008</span><br><span class="line">2022-07-07 14:58:36.069 10105-11685/? E/CRASH:     x12  0000fffffffff3ff  x13  0000000000000020  x14  0000000000800000  x15  0000000000000001</span><br><span class="line">2022-07-07 14:58:36.069 10105-11685/? E/CRASH:     x16  0000006dad6574b0  x17  00000071546e0b70  x18  0000006d857ad0c4  x19  0000006dad6ff8b0</span><br><span class="line">2022-07-07 14:58:36.069 10105-11685/? E/CRASH:     x20  0000006cba745fe0  x21  0000006dad6ff8b0  x22  0000006dad6ff8e0  x23  000000000000005d</span><br><span class="line">2022-07-07 14:58:36.069 10105-11685/? E/CRASH:     x24  0000006dad6fd050  x25  00000000005ce597  x26  0000000000000018  x27  3fd1d9b7b46c74bd</span><br><span class="line">2022-07-07 14:58:36.069 10105-11685/? E/CRASH:     x28  00000000000027d4  x29  0000006d857ad000  x30  0000006dac83d4e4</span><br><span class="line">2022-07-07 14:58:36.069 10105-11685/? E/CRASH:     sp   0000006d857acfb0  pc   0000006dac83d53c  pstate 0000000060000000</span><br><span class="line">2022-07-07 14:58:36.069 10105-11685/? E/CRASH: backtrace:</span><br></pre></td></tr></table></figure><p>其中关键字就是 『Using memoryadresses from more that 16GB of memory』，通过查询，可以找到一些，例如官方论坛：<a href="https://developer.unity.cn/projects/622b33a7edbc2a001b6f7776">https://developer.unity.cn/projects/622b33a7edbc2a001b6f7776</a></p><p>这里解释得知，是由于安卓新版系统内存分配器更换导致 Unity 出现的BUG，并且 Unity 也在后续版本更新中同步解决了这个问题，然而修复版本并不包括2017：</p><ul><li>2018.4.30</li><li>2019.4.15</li><li>2020.1.14</li><li>2020.2.0b12</li><li>2021.1.0a4</li></ul><p>恰好我们项目使用的是 Unity2017，因此这种情况除更新 Unity之外恐怕也别无他法。</p><p>于是就想升级，个人就吭吭哧哧在自己电脑上进行版本升级的兼容性测试了，开始用 2018 打开瞧了瞧，并出了个PC包，感觉没啥大问题，后来索性又用 2019 打开了来看，点了点发现了这么个 UGUI 的图文混排以及超链接失效问题。</p><p>(注：开始还以为只2019被改了，事实证明，新版本Unity2018其实也有这问题，据说Unity2018从2018.4也改过了，Unity2019大概是从2019.2修改)</p><p>我们项目的图文混排以及超链接，都是通过一个叫 AorTextIncSprites 脚本实现，该脚本继承于 MaskableGraphic ，并复制了 Unity5.6 的 UGUI源码，在其基础上加入了超链接和表情的图文混排支持——相当古老的代码了，不过还能工作。</p><p>只是拿到 Unity2019 之后，这两个额外的功能都出现了些问题，例如超链接有的无法正确生成点击区域导致无法触发对应事件、图文混排直接糊掉——表现为绘制整个图集，大概就这么个样子：</p><p><img src="/blogimages/2022/2022-07-21/m_e7bf620f8dce19917458f506a2afeaa5_r.png"></p><h2 id="UGUI顶点数据"><a href="#UGUI顶点数据" class="headerlink" title="UGUI顶点数据"></a>UGUI顶点数据</h2><p>UGUI顶点数据中，据说从 2019.2、2018.4 开始，全都不再包含富文本数据，导致以往涉及到 UGUI顶点修改的相关代码，能够正常工作的都不再正常。</p><p>主要受影响的有：图文混排、超链接、竖行排行(VerticalText)</p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>超链接的问题，主要体现在聊天频道中，某些含有坐标的信息，无法点击坐标——经过检查，内部问题在于点击范围的错误处理，导致未能正确生成包围范围数据。</p><p>原代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取超链接解析后的最后输出文本</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">UpdateHrefInfo</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    s_TextBuilder.Length = <span class="number">0</span>;</span><br><span class="line">    m_HrefInfos.Clear();</span><br><span class="line">    <span class="keyword">var</span> indexText = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (Match match <span class="keyword">in</span> s_HrefRegex.Matches(originalText))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> replaceText = originalText.Substring(indexText, match.Index - indexText);</span><br><span class="line">        s_TextBuilder.Append(replaceText);</span><br><span class="line">        <span class="comment">//s_TextBuilder.Append(string.Format(&quot;&lt;color=&#123;0&#125;&gt;&quot;, _href_Color)); // 超链接颜色</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">group</span> = match.Groups[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">var</span> hrefInfo = <span class="keyword">new</span> HrefInfo</span><br><span class="line">        &#123;</span><br><span class="line">            startIndex = s_TextBuilder.Length * <span class="number">4</span>, <span class="comment">// 超链接里的文本起始顶点索引</span></span><br><span class="line">            endIndex = (s_TextBuilder.Length + match.Groups[<span class="number">2</span>].Length - <span class="number">1</span>) * <span class="number">4</span> + <span class="number">3</span>,</span><br><span class="line">            name = <span class="keyword">group</span>.Value</span><br><span class="line">        &#125;;</span><br><span class="line">        m_HrefInfos.Add(hrefInfo);</span><br><span class="line"></span><br><span class="line">        s_TextBuilder.Append(match.Groups[<span class="number">2</span>].Value);</span><br><span class="line">        <span class="comment">//s_TextBuilder.Append(&quot;&lt;/color&gt;&quot;);</span></span><br><span class="line">        indexText = match.Index + match.Length;</span><br><span class="line">    &#125;</span><br><span class="line">    s_TextBuilder.Append(originalText.Substring(indexText, originalText.Length - indexText));</span><br><span class="line">    <span class="comment">//return s_TextBuilder.ToString();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要问题在于，其中计算 『超链接里的文本起始顶点索引』中，直接拿原文进行计算，没有忽略富文本信息，上边提到过，新版 UGUI 已经不再包含富文本数据。</p><p>因此超链接问题修改相对比较简单，在此处筛除掉富文本信息，然后再取长度即可。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略=============</span></span><br><span class="line"><span class="built_in">int</span> length = ReplaceRichText(s_TextBuilder.ToString()).Length;</span><br><span class="line"><span class="keyword">var</span> hrefInfo = <span class="keyword">new</span> HrefInfo</span><br><span class="line">&#123;</span><br><span class="line">startIndex = length * <span class="number">4</span>, <span class="comment">// 超链接里的文本起始顶点索引</span></span><br><span class="line">endIndex = (length + match.Groups[<span class="number">2</span>].Length - <span class="number">1</span>) * <span class="number">4</span> + <span class="number">3</span>,</span><br><span class="line">name = <span class="keyword">group</span>.Value</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//省略=============</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Unity2019富文本什么的顶点信息都没了，计算长度时剔除富文本</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">ReplaceRichText</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">str = Regex.Replace(str, <span class="string">@&quot;&lt;color=(.+?)&gt;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">str = str.Replace(<span class="string">&quot;&lt;/color&gt;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">str = str.Replace(<span class="string">&quot;&lt;b&gt;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">str = str.Replace(<span class="string">&quot;&lt;/b&gt;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">str = str.Replace(<span class="string">&quot;&lt;i&gt;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">str = str.Replace(<span class="string">&quot;&lt;/i&gt;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">str = str.Replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">str = str.Replace(<span class="string">&quot;\t&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">str = str.Replace(<span class="string">&quot;\r&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">str = str.Replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图文混排"><a href="#图文混排" class="headerlink" title="图文混排"></a>图文混排</h2><p>这个问题跟超链接类似，都是由于 UGUI 不再记录富文本信息导致失效。</p><p>虽然知道了这点，但是由于图文混排操作更多，即使问题一样，修复图文混排还是要麻烦得多。</p><h3 id="基础修复"><a href="#基础修复" class="headerlink" title="基础修复"></a>基础修复</h3><p>来到绘制表情的方法，这儿位于 OnPopulateMesh，原本代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MatchCollection matches = Regex.Matches(text, <span class="string">&quot;&lt;quad.+?&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">int</span> diff = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; matches.Count; i++)</span><br><span class="line">&#123;</span><br><span class="line">    EmojiInfo info;</span><br><span class="line">    Match numberMatch = Regex.Match(matches[i].Value, <span class="string">&quot;[0-9]+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (EmojiIndex.TryGetValue(numberMatch.Value, <span class="keyword">out</span> info))</span><br><span class="line">    &#123;</span><br><span class="line">        info.len = matches[i].Length;</span><br><span class="line">        emojiDic.Add(matches[i].Index, info);</span><br><span class="line">        diff += info.len - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        info.len = matches[i].Length;</span><br><span class="line">        emojiDic.Add(matches[i].Index, EmojiIndex[<span class="string">&quot;0&quot;</span>]);</span><br><span class="line">        diff += info.len - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处处在正式绘制之前，通过正则表达式，解析原本的文字内容，将表情标签剔出来，并生成对应对应表情数据放在一个字典中，以备后用。</p><p>出现问题的主要原因就在于原本的这个 <code>matches[i].Index</code>——既然是正则表达式，那么获取到的下标，自然是没有排除用于表情占位标签长度的，之前 UGUI同样存储了对这些标签的处理数据还没事，现在 UGUI 数据中不在包含，获取的数据就会有问题。</p><p>因此，我合计了一下 <code>&lt;quad name = XX&gt;</code>的长度，计算了一下各种组合可能的长度：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅表情标签，不算表情id的长度</span></span><br><span class="line"><span class="string">&quot;&lt;quad name = &gt;&quot;</span>.Length</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="comment">//1位表情id的表情标签长度</span></span><br><span class="line"><span class="string">&quot;&lt;quad name = 2&gt;&quot;</span>.Length</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="comment">//两个连续2位表情，总共长度</span></span><br><span class="line"><span class="string">&quot;&lt;quad name = 22&gt;&lt;quad name = 22&gt;&quot;</span>.Length</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="comment">//两个连续表情，第二个表情坐标</span></span><br><span class="line"><span class="string">&quot;&lt;quad name = 22&gt;&lt;quad name = 8&gt;&quot;</span>.IndexOf(<span class="string">&quot;&lt;quad name = 8&gt;&quot;</span>)</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="comment">//一个2位表情标签长度</span></span><br><span class="line"><span class="string">&quot;&lt;quad name = 22&gt;&quot;</span>.Length</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="comment">//一个1位表情标签长度</span></span><br><span class="line"><span class="string">&quot;&lt;quad name = 8&gt;&quot;</span>.Length</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="comment">//确认Unicode空格符长度</span></span><br><span class="line"><span class="string">&quot;\u3000\u3000\u3000\u3000&quot;</span>.Length</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment">//混合表情，剔除第一个表情标签长度</span></span><br><span class="line"><span class="string">&quot;bbbbb&lt;quad name = 22&gt;aaaaaa&lt;quad name = 8&gt;&quot;</span>.Length<span class="number">-16</span></span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="comment">//混合表情，第二个表情标签坐标</span></span><br><span class="line"><span class="string">&quot;bbbbb&lt;quad name = 22&gt;aaaaaa&lt;quad name = 8&gt;&quot;</span>.IndexOf(<span class="string">&quot;&lt;quad name = 8&gt;&quot;</span>)<span class="number">-16</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="comment">//连续两个表情标签，剔除第一个表情标签后第二个表情标签坐标</span></span><br><span class="line"><span class="string">&quot;&lt;quad name = 22&gt;&lt;quad name = 8&gt;&quot;</span>.IndexOf(<span class="string">&quot;&lt;quad name = 8&gt;&quot;</span>)<span class="number">-16</span>  </span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>如此，找出一个比较共性的一点，使得计算时剔除<code>&lt;quad name = XX&gt;</code>的长度之后进行尝试性修改：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MatchCollection matches = Regex.Matches(ReplaceRichText(text), <span class="string">&quot;&lt;quad.+?&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">int</span> diff = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//表情富文本的长度(除表情id)</span></span><br><span class="line"><span class="built_in">int</span> richMarkLength = <span class="number">14</span>;</span><br><span class="line"><span class="comment">//上一个表情index</span></span><br><span class="line"><span class="built_in">int</span> lastEmojiIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; matches.Count; i++)</span><br><span class="line">&#123;</span><br><span class="line">EmojiInfo info;</span><br><span class="line">Match numberMatch = Regex.Match(matches[i].Value, <span class="string">&quot;[0-9]+&quot;</span>);</span><br><span class="line">    <span class="built_in">int</span> dicIndexId = matches[i].Index - lastEmojiIndex;</span><br><span class="line">    <span class="comment">//处理连续表情标签</span></span><br><span class="line">    <span class="keyword">while</span> (emojiDic.ContainsKey(dicIndexId)) dicIndexId += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (EmojiIndex.TryGetValue(numberMatch.Value, <span class="keyword">out</span> info))</span><br><span class="line">emojiDic.Add(dicIndexId, info);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">emojiDic.Add(dicIndexId, EmojiIndex[<span class="string">&quot;0&quot;</span>]);</span><br><span class="line">    info.len = matches[i].Length;</span><br><span class="line">    diff += info.len - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//处理多个表情，由于Unity2019去掉了富文本顶点之类信息，后续表情需要减去之前表情标签长度</span></span><br><span class="line">    lastEmojiIndex += (richMarkLength+ numberMatch.Value.Length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/blogimages/2022/2022-07-21/m_e9d161e6ad216065fb732a400cee7a62_r.png"></p><h3 id="最后一位缺失"><a href="#最后一位缺失" class="headerlink" title="最后一位缺失"></a>最后一位缺失</h3><p>最后，可能会发现最后一个表情(/文字)无法显示，关键代码如下，根据注释意思，删除减掉的4个顶点代码即可。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Last 4 verts are always a new line...</span></span><br><span class="line"><span class="built_in">int</span> vertCount = verts.Count<span class="number">-4</span>;</span><br></pre></td></tr></table></figure><p>按照上述规则，表现看起来貌似基本上正常了。</p><h3 id="包含额外富文本修复"><a href="#包含额外富文本修复" class="headerlink" title="包含额外富文本修复"></a>包含额外富文本修复</h3><p>但是后边发现，要是插入了其它富文本的信息，又会导致变成乱码了。</p><p><img src="/blogimages/2022/2022-07-21/m_5a74fd06cdaf1fd35da83e7e9eed5227_r.png"></p><p>原因是上述方式虽然排除了表情标签的影响，但貌似并未剔除其它富文本标签影响——说起来这个我还是后边才发觉。</p><p>为此可以在正式使用正则表达式，筛选表情标签之前，剔除富文本信息：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MatchCollection matches = Regex.Matches(ReplaceRichText(text), <span class="string">&quot;&lt;quad.+?&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><p>由于剔除也包括空格，因此这儿需要重新计算</p><p>以三个连续的表情为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//未剔除之前长度</span><br><span class="line">&quot;&lt;quad name = 21&gt;&lt;quad name = 22&gt;&lt;quad name = 23&gt;&quot;.Length  </span><br><span class="line">48</span><br><span class="line">//剔除所有富文本数据后内容</span><br><span class="line">ReplaceRichText(text) </span><br><span class="line">&quot;&lt;quadname=21&gt;&lt;quadname=22&gt;&lt;quadname=23&gt;&quot;</span><br><span class="line">//剔除所有富文本数据后长度</span><br><span class="line">ReplaceRichText(text).Length</span><br><span class="line">39</span><br><span class="line">//一个表情标签的长度</span><br><span class="line">&quot;&lt;quadname=23&gt;&quot;.Length</span><br><span class="line">13</span><br><span class="line">//取第二位表情坐标</span><br><span class="line">&quot;&lt;quadname=21&gt;&lt;quadname=22&gt;&lt;quadname=23&gt;&quot;.IndexOf(&quot;&lt;quadname=22&gt;&quot;)</span><br><span class="line">13</span><br><span class="line">//仅表情标签，不算表情id的长度</span><br><span class="line">&quot;&lt;quadname=&gt;&quot;.Length</span><br><span class="line">11</span><br></pre></td></tr></table></figure><p>可得出修改方式：</p><ul><li>将 text 进行正则表达式搜索之前，剔除富文本数据</li><li>将 richMarkLength 字段默认值改为 11</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MatchCollection matches = Regex.Matches(ReplaceRichText(text), <span class="string">&quot;&lt;quad.+?&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">int</span> diff = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//表情富文本的长度(除表情id)</span></span><br><span class="line"><span class="built_in">int</span> richMarkLength = <span class="number">11</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改代码后，以连续三个表情为例，正常聊天频道表现正常，主界面额外聊天信息展示文本内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&lt;color=#ffc800&gt;【世界】&lt;/color&gt;10:&lt;quad name = 21&gt;&lt;quad name = 22&gt;&lt;quad name = 23&gt;&quot;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/blogimages/2022/2022-07-21/m_da92c3ca6f573d9afc4a312cc15f2b9f_r.png"></p><h2 id="文字竖行排版功能问题"><a href="#文字竖行排版功能问题" class="headerlink" title="文字竖行排版功能问题"></a>文字竖行排版功能问题</h2><p>我们项目中叫做 『VirticalText』(感觉命名也错了，不是应该 VerticalText吗？)</p><p>这份代码是通过操作 Text 旋转顶点实现竖行排版的，这份代码直接没法跑，报错了。</p><p>经过检查，发现同样是新版Unity的 UGUI 顶点数据问题导致，而且虽然 UGUI内部不存储富文本数据了，但是这里非常不可思议的是，同样从 UGUI 系统内部获取的 UILineInfo 竟然包括了换行符!</p><p>然后使用 UILineInfo 给出的数据去调用 VertexHelper PopulateUIVertex 获取文字 UIVertex 就会报下标错误。</p><p>由于 UILineInfo 数据包括了换行符，顶点数据里边却不包括，就导致了最终的取值报错——都是 UGUI 的数据，这完全整得 UGUI 自己的内部数据都不一致了，不确定是 UGUI 更新漏了，还是故意这样设计。</p><p>反正我的处理方式是，直接把老的那坨以 UILineInfo 作为数据源的方法去掉，自己写了一块直接通过字符串解析来解决。</p><p><img src="/blogimages/2022/2022-07-21/m_11e5f18549940abf2a4ab5c75fccdd77_r.png"></p><p>首先，直接通过 『\n』 这个通用换行符进行 Split 获取文字行数，理论上跟 UILineInfo 数量一致。</p><p>然后循环修改，注意在取每一行文字的时候，同样增加筛除富文本数据判断即可。</p><p>效果如下：</p><p><img src="/blogimages/2022/2022-07-21/m_6024846ceddaf0a1df8ca1aa026afa47_r.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前听到运营那边报我们游戏可能会出现崩溃问题，主要是韩服，三星机器。&lt;/p&gt;
&lt;p&gt;于是拿了日志来看，主要信息如下：&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://cwhisme.github.io/categories/Unity3D/"/>
    
    
    <category term="问题解决记录" scheme="https://cwhisme.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>关于汉室复兴升级Unity2021的问题记录</title>
    <link href="https://cwhisme.github.io/2022/07/20/%E5%85%B3%E4%BA%8E%E6%B1%89%E5%AE%A4%E5%A4%8D%E5%85%B4%E5%8D%87%E7%BA%A7Unity2021%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://cwhisme.github.io/2022/07/20/%E5%85%B3%E4%BA%8E%E6%B1%89%E5%AE%A4%E5%A4%8D%E5%85%B4%E5%8D%87%E7%BA%A7Unity2021%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2022-07-19T16:00:00.000Z</published>
    <updated>2022-12-11T02:01:22.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、UGUI"><a href="#一、UGUI" class="headerlink" title="一、UGUI"></a>一、UGUI</h2><ol><li><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p> <font color=blue>已解决</font>，超链接点击返回剔除富文本信息</p><p> 详细可见另一篇文档：<a href="">处理Unity2019的UGUI顶点数据更新后的图文混排问题</a></p></li><li><h3 id="图文混排"><a href="#图文混排" class="headerlink" title="图文混排"></a>图文混排</h3><p> <font color=blue>已解决</font>，计算表情绘制下标时剔除表情标签、剔除富文本信息</p><p> 详细可见另一篇文档：<a href="">处理Unity2019的UGUI顶点数据更新后的图文混排问题</a></p></li><li><h3 id="竖行排版"><a href="#竖行排版" class="headerlink" title="竖行排版"></a>竖行排版</h3><p> 由于Unity本身提供的 UILineInfo 包含了换行符信息、而顶点数据并不包括导致。</p><p> <font color=blue>已解决</font>，自行通过『\n』 分割文本，并剔除富文本信息再作计算。</p><p> 详细可见另一篇文档：<a href="">处理Unity2019的UGUI顶点数据更新后的图文混排问题</a></p></li><li><h3 id="AorTextIncSprites-缺少最后一位内容"><a href="#AorTextIncSprites-缺少最后一位内容" class="headerlink" title="AorTextIncSprites 缺少最后一位内容"></a>AorTextIncSprites 缺少最后一位内容</h3><p> <img src="/blogimages/2022/2022-07-20/m_439c7a477ded75b326cac421a41d65fd_r.png"></p><p> 查看代码，并经过调试，最后发现是因为绘制时手动减掉了最后4位顶点，关键代码如下：</p> <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Last 4 verts are always a new line...</span></span><br><span class="line"><span class="built_in">int</span> vertCount = verts.Count<span class="number">-4</span>;</span><br></pre></td></tr></table></figure><p> 这里根据注释，就可以明白了，最后一位以前是当换行符去掉了，新版顶点并无这些信息，不再减去4个顶点即可。</p></li><li><h3 id="行军线绘制"><a href="#行军线绘制" class="headerlink" title="行军线绘制"></a>行军线绘制</h3><p> 使用 UGUI+自定义Shader实现</p><p> 由于自定义 UGUI 顶点绘制，新版 Unity无法正常工作，通过禁用 raycastTarget 可以避免报错，走上正常逻辑，但不可见。</p><ul><li>2022.7.22 打出来真机包可见，此时暂时可排除顶点绘制函数本身逻辑不兼容嫌疑</li><li>后进行调试，发现新新军线绘制代码 OnPopulateMesh 无调用</li><li>后查询 UGUI Graphic 源码，得知更新条件需要 CanvasRender<br>  <img src="/blogimages/2022/2022-07-20/m_d50be37f3cd0c49e815f66e70b787669_r.png"></li><li>并经调试查询，发现内部有缺失 CanvasRender 报错<br>  <img src="/blogimages/2022/2022-07-20/m_c943e0bf3357ca87f645cd426145353d_r.png"></li><li>由此可知 CanvasRender 是一个关键点</li><li>尝试运行时手动添加，无效</li><li>尝试按照源码规则调用，发现获取失败<br><img src="/blogimages/2022/2022-07-20/m_7ecd4aafe84f4752c9fe73b537f8d171_r.png"></li><li>且修改调用方式 <code>gameObject.GetComponent&lt;CanvasRenderer&gt;()</code> 可以获取<br><img src="/blogimages/2022/2022-07-20/m_d85b58ad27084a3c2efae6d069e95f63_r.png"></li><li>该类直接放置于另一个类脚本中，按理说挂载的脚本都是单独一个类，且类名需与代码文件名一致，怀疑是否因此问题导致(<font color=red>尝试后表明于此无关</font>)</li><li>试图添加此绘制组件前，先添加 CanvasRender，cull 置为false<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.AddComponent&lt;CanvasRenderer&gt;().cull = <span class="literal">false</span></span><br></pre></td></tr></table></figure><font color=blue>已解决</font><br><img src="/blogimages/2022/2022-07-20/m_33c2313e54dd4d1f7cb1dc921dec1a06_r.png"></li></ul><p> 注：其实 UGUI 源代码中，对于 CanvasRenderer 的获取，也是做了额外判断的，若获取空则会添加，不清楚是什么条件造成了添加代码无效的。<br> <img src="/blogimages/2022/2022-07-20/m_b47fe4fe20e60f187a188c892533a313_r.png"></p></li><li><h3 id="AorUIStage-自适应子节点长宽为-NaN"><a href="#AorUIStage-自适应子节点长宽为-NaN" class="headerlink" title="AorUIStage# 自适应子节点长宽为 NaN"></a>AorUIStage# 自适应子节点长宽为 NaN</h3><p> 可确定由 AorUiRuntimeUtility 动态创建 AorUIStage# 后，再动态创建可自适应大小的 MainLayer 子容器导致</p> <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AorUIStage</span></span><br><span class="line">GameObject stage = CreatePrefab_UIBase(canv.transform, <span class="number">0</span>, <span class="number">0</span>, <span class="number">512f</span>, <span class="number">512f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line">stage.name = <span class="string">&quot;AorUIStage#&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AorUIStage.mainLayer</span></span><br><span class="line">GameObject ml = CreatePrefab_UIBase(stage.transform);</span><br><span class="line">ml.name = <span class="string">&quot;MainLayer&quot;</span>;</span><br><span class="line"></span><br><span class="line">GameObject tl = CreatePrefab_UIBase(stage.transform);</span><br><span class="line">tl.name = <span class="string">&quot;TopLayer&quot;</span>;</span><br></pre></td></tr></table></figure><p> 修改 AorUIManager updateStageSize 方法，增加重置计算</p> <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateStageSize</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Application.isEditor &amp;&amp; !Application.isPlaying)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!isAwakeInit || !isInit)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (_scaleMode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ScaleModeType.widthBase:</span><br><span class="line">set2WidthBaseMode();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ScaleModeType.heightBase:</span><br><span class="line">set2HeightBaseMode();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ScaleModeType.fitScreen:</span><br><span class="line">set2FitScreenMode();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ScaleModeType.envelopeScreen:</span><br><span class="line">set2EnvelopeScreenMode();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="literal">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//升级2019后，自适应子节点会出现问题，这里强制重设一次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Stage.childCount; i++)</span><br><span class="line">&#123;</span><br><span class="line">RectTransform rt = Stage.GetChild(i) <span class="keyword">as</span> RectTransform;</span><br><span class="line">rt.anchoredPosition = Vector2.zero;</span><br><span class="line">rt.sizeDelta = Vector2.zero;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <font color=blue>已解决</font><br> 注：解决方式应当不止这种。</p></li></ol><h2 id="二、Socket-连接"><a href="#二、Socket-连接" class="headerlink" title="二、Socket 连接"></a>二、Socket 连接</h2><p>在编辑器/真机包 返回登录界面时触发。</p><p><img src="/blogimages/2022/2022-07-20/m_ed85e95c10d4bbb8684ab4b6b7720062_r.png"></p><p>查询是由于调用 <code>socket.Disconnect(true);</code> 导致，估计是以前想复用 Socket 实例，不过查了下代码，每次 open 实际上都是重新创建的一个，将 Disconnect 的调用替换为如下代码解决：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    socket.Shutdown(SocketShutdown.Both);</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Do Nothing</span></span><br><span class="line">&#125;</span><br><span class="line">socket.Close();</span><br><span class="line">socket = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="三、自定义DLL的库文件引用"><a href="#三、自定义DLL的库文件引用" class="headerlink" title="三、自定义DLL的库文件引用"></a>三、自定义DLL的库文件引用</h2><p><font color=blue>已解决</font></p><p>DLL 框架版本设置为 4.0 以上(我是 4.5)</p><p>并重新分散引用 Unity 内部 DLL，路径位于对应Unity安装目录</p><p><a href="">Unity 2021.3.0f1\Editor\Data\Managed\UnityEngine</a></p><p>注：重新引用后注意修改 DLL 复制本地 为 false</p><h2 id="四、打-Assetbundle-包出现资源反复Import问题"><a href="#四、打-Assetbundle-包出现资源反复Import问题" class="headerlink" title="四、打 Assetbundle 包出现资源反复Import问题"></a>四、打 Assetbundle 包出现资源反复Import问题</h2><p>表现为初始化环境时，还没轮到正式打 Assetbundle，每个prefab皆出现 Import 提示</p><p>经过调试，发现新版 Unity 在每次打包之前重设标签时，都会导致重新导入一次资源，增加大量额外时间消耗。</p><p>例如：</p><p><img src="/blogimages/2022/2022-07-20/m_84ff6d5065eaba746ae2036b355a1e39_r.png"></p><p><font color=blue>已解决</font>，重设标签时，判断旧标签是否与新标签一致。</p><p>代码位于 AssetBundleTool AddLabel</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddLabel</span>(<span class="params">Object obj, <span class="built_in">string</span> label</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//ClearLabel(obj);</span></span><br><span class="line">    UnityEngine.Object _object = obj;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != _object)</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;<span class="built_in">string</span>&gt; _labelList = AssetDatabase.GetLabels(obj).ToList();</span><br><span class="line">        <span class="comment">//对象目前已有标签与设置标签不一致，或者对象拥有多个标签(不合法)，则重设标签</span></span><br><span class="line">        <span class="keyword">if</span> (!_labelList.Contains(label) || _labelList.Count &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ClearLabel(obj);</span><br><span class="line">            AssetDatabase.SetLabels(obj, <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; label &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果这个物体本来就有指定的label，就不需要重复处理了</span></span><br><span class="line">        <span class="comment">//AssetDatabase.SetLabels(obj, _labelList.ToArray());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：方法开口有调用 ClearLabel，可知一个对象只会存在一个标签，因此此处直接判断设置标签是否相等即可。</p><h2 id="五、打-Assetbundle-包崩溃"><a href="#五、打-Assetbundle-包崩溃" class="headerlink" title="五、打 Assetbundle 包崩溃"></a>五、打 Assetbundle 包崩溃</h2><p>查询日志得出为栈溢出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Couldn&#x27;t extract exception string from exception of type StackOverflowException (another exception of class &#x27;StackOverflowException&#x27; was thrown while processing the stack trace)</span><br><span class="line"></span><br><span class="line">StackOverflowException: The requested operation caused a stack overflow.</span><br><span class="line">  at (wrapper managed-to-native) System.String.FastAllocateString(int)</span><br><span class="line">  at System.String.CreateStringFromEncoding (System.Byte* bytes, System.Int32 byteLength, System.Text.Encoding encoding) [0x00013] in &lt;6073cf49ed704e958b8a66d540dea948&gt;:0 </span><br><span class="line">  at System.Text.Encoding.GetString (System.Byte* bytes, System.Int32 byteCount) [0x00033] in &lt;6073cf49ed704e958b8a66d540dea948&gt;:0 </span><br><span class="line">  at System.Text.Encoding.GetString (System.ReadOnlySpan`1[T] bytes) [0x00013] in &lt;6073cf49ed704e958b8a66d540dea948&gt;:0 </span><br><span class="line">  at System.String.Ctor (System.SByte* value, System.Int32 startIndex, System.Int32 length, System.Text.Encoding enc) [0x0006d] in &lt;6073cf49ed704e958b8a66d540dea948&gt;:0 </span><br><span class="line">  at System.String.CreateString (System.SByte* value, System.Int32 startIndex, System.Int32 length, System.Text.Encoding enc) [0x00000] in &lt;6073cf49ed704e958b8a66d540dea948&gt;:0 </span><br><span class="line">  at (wrapper managed-to-managed) System.String..ctor(sbyte*,int,int,System.Text.Encoding)</span><br><span class="line">  at UnityEngine.StackTraceUtility.ExtractStackTrace () [0x0002c] in &lt;1332c534a8a44623b2e5cc943a0b790e&gt;:0 </span><br><span class="line">  at (wrapper managed-to-native) UnityEngine.DebugLogHandler.Internal_Log(UnityEngine.LogType,UnityEngine.LogOption,string,UnityEngine.Object)</span><br><span class="line">  at UnityEngine.DebugLogHandler.LogFormat (UnityEngine.LogType logType, UnityEngine.Object context, System.String format, System.Object[] args) [0x0000b] in &lt;1332c534a8a44623b2e5cc943a0b790e&gt;:0 </span><br><span class="line">  at UnityEngine.Logger.Log (UnityEngine.LogType logType, System.Object message) [0x00027] in &lt;1332c534a8a44623b2e5cc943a0b790e&gt;:0 </span><br><span class="line">  at UnityEngine.Debug.Log (System.Object message) [0x00006] in &lt;1332c534a8a44623b2e5cc943a0b790e&gt;:0 </span><br><span class="line">  at EditorAssetData.caculateTop () [0x00123] in D:\[Works]\sanguo_release\Unity\Assets\Scripts\Editor\AssetBundleTool\EditorAssetData.cs:184 </span><br><span class="line">  at EditorAssetData.caculateTop () [0x0013a] in D:\[Works]\sanguo_release\Unity\Assets\Scripts\Editor\AssetBundleTool\EditorAssetData.cs:185 </span><br><span class="line">  at EditorAssetData.caculateTop () [0x0013a] in D:\[Works]\sanguo_release\Unity\Assets\Scripts\Editor\AssetBundleTool\EditorAssetData.cs:185 </span><br><span class="line">//余下省略========================================================</span><br><span class="line">//余下省略========================================================</span><br><span class="line">//余下省略========================================================</span><br></pre></td></tr></table></figure><p>查询代码可知为递归获取上级引用问题。</p><p>经过调试可发现出现问题者，皆为名称与本身不一致的对象。</p><p>如图所示：</p><p><img src="/blogimages/2022/2022-07-20/m_139eb538f8271f47380e2d84617d883e_r.png"></p><p>出现问题的原因，多为美术(特效)，原因想来很简单，美术直接单纯复制对象，未做正确操作。</p><p>由此可以得出结论，老版本 Unity 可能直接有一套兼容机制处理，新版 Unity 直接崩掉了。</p><p><font color=blue>已解决</font>，通过检测递归层数，人为限制，数量超出上限则打印错误信息，以便修复：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> _stackOverflowCheck = <span class="number">0</span>;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 一直向上递归，直到上级资源的上级资源数为0或上级资源为BuildSingle</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;EditorAssetData&gt; <span class="title">caculateTop</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    _stackOverflowCheck++;</span><br><span class="line">    <span class="keyword">if</span> (_stackOverflowCheck &gt; <span class="number">50</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(LoadPath+ <span class="string">&quot; 超出递归限制上限，可能已经出现了问题！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> TopUpDependenceList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/blogimages/2022/2022-07-20/m_bf2570478c346c0d6c1a2d47ee5f736b_r.png"></p><h2 id="六、报-load-IL2CPP-失败"><a href="#六、报-load-IL2CPP-失败" class="headerlink" title="六、报 load IL2CPP 失败"></a>六、报 load IL2CPP 失败</h2><p><img src="/blogimages/2022/2022-07-20/m_8762aae7da2cb29ab3583dabea704121_r.png"></p><p>通过 ADB 拉取的日志查看，一堆 Could not load symbol XXX 的错误</p><p><img src="/blogimages/2022/2022-07-20/m_e8ed695b5fa9785369ba71cb85935c29_r.png"></p><p>经过对 Unity 导出资源的目录的对比，发现新版资源路径都已经不一样了，多了为两个目录 『Il2CppOutputProject』、『jniStaticLibs』,且 jniLibs 目录中少了 libil2cpp.so，</p><p><img src="/blogimages/2022/2022-07-20/m_96b794a490972af66945b171a97c4079_r.png"><br><img src="/blogimages/2022/2022-07-20/m_549ebbffb5d4210739a18c17ccf60f91_r.png"></p><p>经过查询信息表示，新版 Unity 导出的 AndroidStudio 工程，不再编译 libil2cpp.so ，而是直接提供源码，得自己处理编译的功能。</p><p>打开导出的资源 unityLibrary 目录下的 build.gradle，其中就有编译的代码：</p><p>//省略</p><p>将其复制到我们的 SDK 下 build.gradle 中对应位置，并依照我们项目作出部分修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">//已有代码</span><br><span class="line">//省略</span><br><span class="line">//省略</span><br><span class="line"></span><br><span class="line">    aaptOptions &#123;</span><br><span class="line">        noCompress = [&#x27;.unity3d&#x27;, &#x27;.ress&#x27;, &#x27;.resource&#x27;, &#x27;.obb&#x27;, &#x27;.bundle&#x27;, &#x27;.unityexp&#x27;,&#x27;.assetbundle&#x27;]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    packagingOptions &#123;</span><br><span class="line">        doNotStrip &#x27;*/armeabi-v7a/*.so&#x27;</span><br><span class="line">        doNotStrip &#x27;*/arm64-v8a/*.so&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task BuildIl2CppTask &#123;</span><br><span class="line">        doLast &#123;</span><br><span class="line">            BuildIl2Cpp(project(&#x27;:UnitySdk&#x27;).projectDir.toString().replaceAll(&#x27;\\\\&#x27;, &#x27;/&#x27;), &#x27;Release&#x27;, &#x27;armv7&#x27;, &#x27;armeabi-v7a&#x27;, [  ] as String[]);</span><br><span class="line">            BuildIl2Cpp(project(&#x27;:UnitySdk&#x27;).projectDir.toString().replaceAll(&#x27;\\\\&#x27;, &#x27;/&#x27;), &#x27;Release&#x27;, &#x27;arm64&#x27;, &#x27;arm64-v8a&#x27;, [  ] as String[]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    afterEvaluate &#123;</span><br><span class="line">        if (project(&#x27;:UnitySdk&#x27;).tasks.findByName(&#x27;mergeDebugJniLibFolders&#x27;))</span><br><span class="line">            project(&#x27;:UnitySdk&#x27;).mergeDebugJniLibFolders.dependsOn BuildIl2CppTask</span><br><span class="line">        if (project(&#x27;:UnitySdk&#x27;).tasks.findByName(&#x27;mergeReleaseJniLibFolders&#x27;))</span><br><span class="line">            project(&#x27;:UnitySdk&#x27;).mergeReleaseJniLibFolders.dependsOn BuildIl2CppTask</span><br><span class="line">    &#125;</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            jni.srcDirs = [&quot;src/main/Il2CppOutputProject&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def getSdkDir() &#123;</span><br><span class="line">    Properties local = new Properties()</span><br><span class="line">    local.load(new FileInputStream(&quot;$&#123;rootDir&#125;/local.properties&quot;))</span><br><span class="line">    return local.getProperty(&#x27;sdk.dir&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def BuildIl2Cpp(String workingDir, String configuration, String architecture, String abi, String[] staticLibraries) &#123;</span><br><span class="line">    def commandLineArgs = []</span><br><span class="line">    commandLineArgs.add(&quot;--compile-cpp&quot;)</span><br><span class="line">    commandLineArgs.add(&quot;--platform=Android&quot;)</span><br><span class="line">    commandLineArgs.add(&quot;--architecture=&quot; + architecture)</span><br><span class="line">    commandLineArgs.add(&quot;--outputpath=&quot; + workingDir + &quot;/src/main/jniLibs/&quot; + abi + &quot;/libil2cpp.so&quot;)</span><br><span class="line">    commandLineArgs.add(&quot;--libil2cpp-static&quot;)</span><br><span class="line">    commandLineArgs.add(&quot;--baselib-directory=&quot; + workingDir + &quot;/src/main/jniStaticLibs/&quot; + abi)</span><br><span class="line">    commandLineArgs.add(&quot;--incremental-g-c-time-slice=3&quot;)</span><br><span class="line">    commandLineArgs.add(&quot;--configuration=&quot; + configuration)</span><br><span class="line">    commandLineArgs.add(&quot;--dotnetprofile=unityaot-linux&quot;)</span><br><span class="line">    commandLineArgs.add(&quot;--profiler-report&quot;)</span><br><span class="line">    commandLineArgs.add(&quot;--profiler-output-file=&quot; + workingDir + &quot;/build/il2cpp_&quot;+ abi + &quot;_&quot; + configuration + &quot;/il2cpp_conv.traceevents&quot;)</span><br><span class="line">    commandLineArgs.add(&quot;--print-command-line&quot;)</span><br><span class="line">    commandLineArgs.add(&quot;--generatedcppdir=&quot; + workingDir + &quot;/src/main/Il2CppOutputProject/Source/il2cppOutput&quot;)</span><br><span class="line">    commandLineArgs.add(&quot;--cachedirectory=&quot; + workingDir + &quot;/build/il2cpp_&quot;+ abi + &quot;_&quot; + configuration + &quot;/il2cpp_cache&quot;)</span><br><span class="line">    commandLineArgs.add(&quot;--tool-chain-path=&quot; + android.ndkDirectory)</span><br><span class="line">    staticLibraries.eachWithIndex &#123;fileName, i-&gt;</span><br><span class="line">        commandLineArgs.add(&quot;--additional-libraries=&quot; + workingDir + &quot;/src/main/jniStaticLibs/&quot; + abi + &quot;/&quot; + fileName)</span><br><span class="line">    &#125;</span><br><span class="line">    def executableExtension = &quot;&quot;</span><br><span class="line">    if (org.gradle.internal.os.OperatingSystem.current().isWindows())</span><br><span class="line">        executableExtension = &quot;.exe&quot;</span><br><span class="line">    exec &#123;</span><br><span class="line">        executable workingDir + &quot;/src/main/Il2CppOutputProject/IL2CPP/build/deploy/il2cpp&quot; + executableExtension</span><br><span class="line">        args commandLineArgs</span><br><span class="line">        environment &quot;ANDROID_SDK_ROOT&quot;, getSdkDir()</span><br><span class="line">    &#125;</span><br><span class="line">    delete workingDir + &quot;/src/main/jniLibs/&quot; + abi + &quot;/libil2cpp.sym.so&quot;</span><br><span class="line">    ant.move(file: workingDir + &quot;/src/main/jniLibs/&quot; + abi + &quot;/libil2cpp.dbg.so&quot;, tofile: workingDir + &quot;/symbols/&quot; + abi + &quot;/libil2cpp.so&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新执行 AS 打包操作——发现 jniLibs 根本没有生成对应的 libil2cpp.so 文件，导致最终出来的包还是有问题。</p><p>经过与SDK同学一块检查，发现我这边是出包的时候根本没执行 BuildIl2CppTask 代码：</p><p><img src="/blogimages/2022/2022-07-20/m_14c2730fb3ca0de83e909f8f7ae89491_r.png"></p><p>也就是说，就算如果增加了上述代码，要是按照正常流程打包，BuildIl2CppTask会不执行，后边经过研究，只能手动执行 BuildIl2CppTask，手动执行输出也是正常的(经过与SDK同学讨论，暂时也没发现为何没有自动执行的原因)。</p><p><img src="/blogimages/2022/2022-07-20/m_569e2fc7995ead8fe321bcc78db6033f_r.png"></p><p>这一步尝试成功后，就出了新包测试，确认无误后——如此第一个能跑的包终于出来了!</p><h3 id="无法正常调用-BuildIl2Cpp-编译-libil2cpp-so"><a href="#无法正常调用-BuildIl2Cpp-编译-libil2cpp-so" class="headerlink" title="无法正常调用 BuildIl2Cpp 编译 libil2cpp.so"></a>无法正常调用 BuildIl2Cpp 编译 libil2cpp.so</h3><p>上文提到了直接出包，AS 根本没有执行附加的 BuildIl2CppTask 这条任务</p><p>这一步操作肯定不可能手动执行的，而且有时候涉及到旧资源出包，就算能够成功执行，反复编译也是费时间的麻烦事</p><p>于是向 SDK 同学要了命令『./gradlew BuildIl2CppTask』，修改了打包工具，直接在向 AS 复制资源之前，执行一次 il2cpp 的检查及编译的操作，并将生成的 libil2cpp.so 复制回来作资源缓存：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=====编译il2cpp======</span></span><br><span class="line"><span class="built_in">string</span> packil2CppSources = Path.Combine(packResRootPath, <span class="string">&quot;Il2CppOutputProject&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> packjniStaticLibsPath = Path.Combine(packResRootPath, <span class="string">&quot;jniStaticLibs&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> sdkil2CppSources = Path.Combine(sdkMainPath, <span class="string">&quot;Il2CppOutputProject&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> sdkjniStaticLibsPath = Path.Combine(sdkMainPath, <span class="string">&quot;jniStaticLibs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//libil2cpp.so 文件</span></span><br><span class="line"><span class="built_in">string</span> packIl2cppv8Files = Path.Combine(packJniPath, <span class="string">&quot;arm64-v8a/libil2cpp.so&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> packIl2cppv7Files = Path.Combine(packJniPath, <span class="string">&quot;armeabi-v7a/libil2cpp.so&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> sdkIl2cppv8Files = Path.Combine(sdkJniPath, <span class="string">&quot;arm64-v8a/libil2cpp.so&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> sdkIl2cppv7Files = Path.Combine(sdkJniPath, <span class="string">&quot;armeabi-v7a/libil2cpp.so&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (File.Exists(sdkIl2cppv8Files)) File.Delete(sdkIl2cppv8Files);</span><br><span class="line"><span class="keyword">if</span> (File.Exists(sdkIl2cppv7Files)) File.Delete(sdkIl2cppv7Files);</span><br><span class="line"><span class="comment">//不存在，编译</span></span><br><span class="line"><span class="keyword">if</span> (!File.Exists(packIl2cppv8Files) || !File.Exists(packIl2cppv7Files))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//清理可能存在的旧文件</span></span><br><span class="line">    <span class="keyword">if</span> (Directory.Exists(sdkil2CppSources)) Directory.Delete(sdkil2CppSources, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (Directory.Exists(sdkjniStaticLibsPath)) Directory.Delete(sdkjniStaticLibsPath, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//复制 il2cpp 源码过去</span></span><br><span class="line">    FileCompare.Copy(packil2CppSources, sdkil2CppSources);</span><br><span class="line">    FileCompare.Copy(packjniStaticLibsPath, sdkjniStaticLibsPath);</span><br><span class="line">    <span class="comment">//正式编译</span></span><br><span class="line">    <span class="built_in">string</span> rootSdkDir = Path.GetDirectoryName(Info.AndroidSDKPath);</span><br><span class="line">    <span class="comment">//刷新</span></span><br><span class="line">    DoCmd(rootSdkDir, <span class="string">&quot;gradlew&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//编译</span></span><br><span class="line">    DoCmd(rootSdkDir, <span class="string">&quot;gradlew&quot;</span>, <span class="string">&quot;BuildIl2CppTask&quot;</span>);</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//复制回来，避免第二次复用时打包重复编译</span></span><br><span class="line">    <span class="keyword">if</span> (File.Exists(sdkIl2cppv8Files)) FileCompare.Copy(sdkIl2cppv8Files, packIl2cppv8Files);</span><br><span class="line">    <span class="keyword">if</span> (File.Exists(sdkIl2cppv7Files)) FileCompare.Copy(sdkIl2cppv7Files, packIl2cppv7Files);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//================</span></span><br></pre></td></tr></table></figure><p>经测试新流程可以跑通。</p><p>注：此处调用的 AS 命令其实也是调用外部进程编译，所以不走 AS ，直接新开一个控制台命令也是可以的，这样还可以省下复制源码至 AS 的消耗，后边可以考虑优化。</p><h2 id="七、安卓加载-StreamingAsset-目录资源失败"><a href="#七、安卓加载-StreamingAsset-目录资源失败" class="headerlink" title="七、安卓加载 StreamingAsset 目录资源失败"></a>七、安卓加载 StreamingAsset 目录资源失败</h2><p><img src="/blogimages/2022/2022-07-20/m_8e73d862fa40a1c3bee9af2218e13568_r.png"></p><p>查询官方文档看到如下说明：</p><blockquote><p>Unity 会将放置在 Unity 项目中名为 StreamingAssets__（区分大小写）的文件夹中的所有文件逐字复制到目标计算机上的特定文件夹。要获取此文件夹，请使用 Application.streamingAssetsPath 属性。在任何情况下，最好使用 Application.streamingAssetsPath 来获取 StreamingAssets__ 文件夹的位置，因为它总是指向运行应用程序的平台上的正确位置。</p></blockquote><blockquote><p>Application.streamingAssetsPath 返回的位置因平台而异：</p></blockquote><ul><li>大多数平台（Unity Editor、Windows、Linux 播放器、PS4、Xbox One、Switch）使用 Application.dataPath + “/StreamingAssets”。</li><li>macOS 播放器使用 Application.dataPath + “/Resources/Data/StreamingAssets”。</li><li>iOS 使用 Application.dataPath + “/Raw”。</li><li>Android 使用经过压缩的 APK/JAR 文件中的文件：”jar:file://“ + Application.dataPath + “!/assets”。</li></ul><p>其中安卓的路径，与日志输出并不一致，怀疑是否此处引起了差异，于是查询我们项目内相关代码，发现对获取 StreamingAssets 有如下组合：</p><ul><li>FResourceCommon GetStreamingAssetsPath 方法</li><li>LauncherLoading GetStreamingAssetsPath 方法</li></ul><p>原初始化 streamingAssetsPath 路径的代码，判断为安卓没有直接取系统 Application.streamingAssetsPath，而且自己组合的路径，新版 Unity 可能不再对此作兼容性判断，导致无法再使用。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Application.platform == RuntimePlatform.Android)</span><br><span class="line">&#123;</span><br><span class="line">    STREAMING_ASSET_PATH = Application.dataPath + <span class="string">&quot;!assets&quot;</span>;   <span class="comment">// 安卓平台</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    STREAMING_ASSET_PATH = Application.streamingAssetsPath;  <span class="comment">// 其他平台</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将其修改为直接取 Application.streamingAssetsPath 后，加载正常。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STREAMING_ASSET_PATH = Application.streamingAssetsPath;  <span class="comment">//新版本所有平台均使用 streamingAssetsPath</span></span><br></pre></td></tr></table></figure><p><img src="/blogimages/2022/2022-07-20/m_61eb0f83a4730a6fbe37afb9aedcf0cd_r.png"></p><h2 id="八、无法调试问题"><a href="#八、无法调试问题" class="headerlink" title="八、无法调试问题"></a>八、无法调试问题</h2><p>将 DLL 设置中，高级生成设置-&gt;调试信息 设置为可移植，并删除项目中 DLL 已有的 MDB 文件，重新编译。</p><p><img src="/blogimages/2022/2022-07-20/m_1796df03e51bcdc557248e52a4afd5fe_r.png"></p><h2 id="九、Google-包黑屏问题"><a href="#九、Google-包黑屏问题" class="headerlink" title="九、Google 包黑屏问题"></a>九、Google 包黑屏问题</h2><p>表现为闪屏后黑屏，且有 Debug 且存在部分 Unity 输出</p><p><img src="/blogimages/2022/2022-07-20/m_7691ecd1cd62499ab0bd4d3f7d6aaa78_r.png"></p><p>增加打印并检查日志：</p><p><img src="/blogimages/2022/2022-07-20/m_6da6afa2a09a767f8f68adf0363529e2_r.png"></p><p>从日志中及对应代码推测，可以推测主要有两个问题：</p><ul><li><h3 id="打-Google-包-UseOBB选项未生效"><a href="#打-Google-包-UseOBB选项未生效" class="headerlink" title="打 Google 包 UseOBB选项未生效"></a>打 Google 包 UseOBB选项未生效</h3></li></ul><p>其中涉及代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        Debug.Log(<span class="string">&quot;Launcher Awake + &quot;</span>+ UseOBB);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_ANDROID &amp;&amp; !UNITY_EDITOR</span></span><br><span class="line">        SDKManager.Inst.SendMsg(SDKManager.SEND_HAVE_CUTOUT);</span><br><span class="line">        <span class="keyword">if</span>(UseOBB)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Launcher Awake + UseOBB&quot;</span>);</span><br><span class="line">            InitGoogleOBBResources(ShowUI);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;                </span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> UNITY_IPHONE &amp;&amp; !UNITY_EDITOR</span></span><br><span class="line">        SDKManager.Inst.AddEvent(eSDKMngEvent.GetDynamicUpdateStateSuccess, OnGetDynamicUpdateStateSuccess);</span><br><span class="line">        SDKManager.Inst.SendMsg(SDKManager.SEND_GET_DYNAMIC_UPDATE_NO);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在场景的 Launcher 上，就有 UseOBB 这个选项，用于控制我们游戏内是否能够正确识别为 Google 包</p><p><img src="/blogimages/2022/2022-07-20/m_c7e9f51fd6518929d6a9a8174df05d06_r.png"></p><p>增加打印后，此处开始为 false（<font color=red>注：上述日志截图为解决后的表现，因此显示为 true</font>）</p><p>这个 UseOBB 选项，之前是在出 Google 包时，通过代码直接设置的。</p><p>但是经过个人反复测试，发现新版 Unity 在代码设置场景物体属性后，该项不会正常生效!</p><p>最简单的重现方式为：代码修改场景物体属性后，重启Unity，物体属性被还原(即使修改后调用保存场景及资源的接口，依然无效)。</p><p>解决方式为：将出包时自动设置 UseOBB 属性处修改为一个判断，若出包类型为 Google OBB模式，且 UseOBB 未勾选，弹出提示需要手动勾选保存。</p><ul><li><h3 id="OBB-无法被主应用正确识别"><a href="#OBB-无法被主应用正确识别" class="headerlink" title="OBB 无法被主应用正确识别"></a>OBB 无法被主应用正确识别</h3></li></ul><p>还是根据上述日志分析，看着像是没有正确识别 OBB，导致资源未能成功加载而报空。</p><p>在之前我们 Unity2017 出包的时候，导出的 AS 项目资源中，其中 AndroidManifest.xml 文件存在一个 build-id 的字段。</p><p>不过新版 Unity 导出资源中，AndroidManifest.xml 已经没有了，所以开始是直接打的包。</p><p>2021升级文档： <a href="https://docs.unity3d.com/Manual/UpgradeGuide2021LTS.html#Android">Upgrading to Unity 2021 LTS</a></p><p>其中有这么一个描述：</p><blockquote><p>Changed how Unity checks to see if an obb is compatible with an apk<br>. Both the apk and obb now have unity_obb_guid file inside them and if the contents match between them, Unity treats them as being compatible.</p></blockquote><p>意思是现在 Unity 通过 APK 及 OBB 包中的一个名为 unity_obb_guid 文件来确认  APK 与 OBB 是否一致。</p><p>也就是说，从 Unity2021 开始，OBB 识别机制不走 build-id ，而是走另外文件对比了。</p><p>解包 OBB 后，果然发现了这个东西：</p><p><img src="/blogimages/2022/2022-07-20/m_f2c167f2345b8c1745c81e089d5570bd_r.png"></p><p>同时检查打包出来的 APK，发现缺失，通过搜索 Unity 导出资源目录，可发现 APK 中该文件位于 unityLibrary\src\main\assets\unity_obb_guid</p><p>在之前我们的打包工具中，对 assets 目录的内容只复制其子目录，导致缺了文件，修改打包工具代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assetPaths = Directory.GetDirectories(packAssetsPath);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; assetPaths.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    FileCompare.Copy(assetPaths[i], (sdkAssetsPath + assetPaths[i].Replace(packAssetsPath, <span class="string">&quot;&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//复制 unity_obb_guid 文件</span></span><br><span class="line"><span class="built_in">string</span> packObbGuidFile = Path.Combine(packAssetsPath, <span class="string">&quot;unity_obb_guid&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> sdkObbGuidFile = Path.Combine(sdkAssetsPath, <span class="string">&quot;unity_obb_guid&quot;</span>);</span><br><span class="line">FileCompare.Copy(packObbGuidFile, sdkObbGuidFile);</span><br></pre></td></tr></table></figure><p>这时候果然就可以了：</p><p><img src="/blogimages/2022/2022-07-20/m_410dbb6736ddf63920ea3aa14242adb1_r.png"></p><h2 id="十、进出战斗崩溃"><a href="#十、进出战斗崩溃" class="headerlink" title="十、进出战斗崩溃"></a>十、进出战斗崩溃</h2><p>最初表现为打开引导时，概率发生于进入战斗时崩溃。</p><p>第一次查询的崩溃日志如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Received signal SIGSEGV</span><br><span class="line">Obtained 50 stack frames</span><br><span class="line">0x00007ff7b5c0aceb (Unity) GameObject::SendMessageAny</span><br><span class="line">0x00007ff7b607e835 (Unity) Transform::BroadcastMessageAny</span><br><span class="line">0x00007ff7b607e899 (Unity) Transform::BroadcastMessageAny</span><br><span class="line">0x00007ff7b607e899 (Unity) Transform::BroadcastMessageAny</span><br><span class="line">0x00007ff7b688d7f6 (Unity) UI::Canvas::WillDestroyComponent</span><br><span class="line">0x00007ff7b5c0d3a1 (Unity) GameObject::WillDestroyGameObject</span><br><span class="line">0x00007ff7b5f18901 (Unity) PreDestroyRecursive</span><br><span class="line">0x00007ff7b5f16927 (Unity) DestroyObjectHighLevel_Internal</span><br><span class="line">0x00007ff7b5f16564 (Unity) DestroyObjectHighLevel</span><br><span class="line">0x00007ff7b626638f (Unity) Scripting::DestroyObjectFromScriptingImmediate</span><br><span class="line">0x00007ff7b54dd663 (Unity) Object_CUSTOM_DestroyImmediate</span><br><span class="line">0x0000018b373dcb35 (Mono JIT Code) (wrapper managed-to-native) UnityEngine.Object:DestroyImmediate (UnityEngine.Object,bool)</span><br><span class="line">0x0000018b373dca53 (Mono JIT Code) UnityEngine.Object:DestroyImmediate (UnityEngine.Object)</span><br><span class="line">0x0000018c1010bae3 (Mono JIT Code) YoukiaUnity.Resource.PoolManager:CleanPool (string)</span><br><span class="line">0x0000018c1219f07b (Mono JIT Code) [BattleStage.cs:85] Demo.Stage.BattleStage:CleanPool () </span><br><span class="line">0x0000018c100fabab (Mono JIT Code) [BattleStage.cs:79] Demo.Stage.BattleStage:OnAsyncHandle () </span><br><span class="line">0x0000018c1219efbb (Mono JIT Code) [BattleStage.cs:116] Demo.Stage.BattleStage:&lt;OnSceneLoaded&gt;b__10_0 () </span><br><span class="line">0x0000018c1219ef76 (Mono JIT Code) [BattleManager.cs:1798] BattleManager:_onCreateFinish () </span><br><span class="line">0x0000018b3af83c05 (Mono JIT Code) YoukiaCore.AsyncCombiner:RefreshAsyncHandles ()</span><br><span class="line">0x0000018b3af8d2c3 (Mono JIT Code) YoukiaCore.AsyncCombiner/AsyncHandle:Finish ()</span><br><span class="line">0x0000018c1011fbdb (Mono JIT Code) [BattleManager.cs:2004] BattleManager/&lt;&gt;c__DisplayClass139_0:&lt;_onRoleAdd&gt;b__0 () </span><br><span class="line">0x0000018c1219dd26 (Mono JIT Code) [ModelChiefView.cs:147] Demo.ModelChiefView/&lt;&gt;c__DisplayClass10_0:&lt;Create&gt;b__2 () </span><br><span class="line">0x0000018c1219db21 (Mono JIT Code) [ModelChiefView.cs:193] Demo.ModelChiefView/&lt;&gt;c__DisplayClass13_0:&lt;AddMountSkillClip&gt;b__0 (object) </span><br><span class="line">0x0000018b3af41b1c (Mono JIT Code) FrameWork.FProcess:allDone ()</span><br><span class="line">0x0000018b3af41573 (Mono JIT Code) FrameWork.FProcess:AssetLoaded (object[])</span><br><span class="line">0x0000018b3af40fff (Mono JIT Code) FrameWork.FGameEvent:DispatchEvent (System.Enum,object[])</span><br><span class="line">0x0000018b3af40e43 (Mono JIT Code) FrameWork.FEventManager:DispatchEvent (System.Enum,object[])</span><br><span class="line">0x0000018b3af40d33 (Mono JIT Code) FrameWork.FProcess:ProcessComplete ()</span><br><span class="line">0x0000018b3af3a9ab (Mono JIT Code) FrameWork.FProcess/&lt;_load&gt;d__18:MoveNext ()</span><br><span class="line">0x0000018b3862cff0 (Mono JIT Code) UnityEngine.SetupCoroutine:InvokeMoveNext (System.Collections.IEnumerator,intptr)</span><br><span class="line">0x0000018b3862d11f (Mono JIT Code) (wrapper runtime-invoke) &lt;Module&gt;:runtime_invoke_void_object_intptr (object,intptr,intptr,intptr)</span><br><span class="line">0x00007ffdf5e6e4b4 (mono-2.0-bdwgc) [mini-runtime.c:3445] mono_jit_runtime_invoke </span><br><span class="line">0x00007ffdf5dae764 (mono-2.0-bdwgc) [object.c:3066] do_runtime_invoke </span><br><span class="line">0x00007ffdf5dae8fc (mono-2.0-bdwgc) [object.c:3113] mono_runtime_invoke </span><br><span class="line">0x00007ff7b626dac4 (Unity) scripting_method_invoke</span><br><span class="line">0x00007ff7b6268644 (Unity) ScriptingInvocation::Invoke</span><br><span class="line">0x00007ff7b621a1df (Unity) Coroutine::Run</span><br><span class="line">0x00007ff7b6217c1c (Unity) Coroutine::ContinueCoroutine</span><br><span class="line">0x00007ff7b5d35344 (Unity) DelayedCallManager::Update</span><br><span class="line">0x00007ff7b5f45d29 (Unity) `InitPlayerLoopCallbacks&#x27;::`2&#x27;::UpdateScriptRunDelayedDynamicFrameRateRegistrator::Forward</span><br><span class="line">0x00007ff7b5f2c89c (Unity) ExecutePlayerLoop</span><br><span class="line">0x00007ff7b5f2c973 (Unity) ExecutePlayerLoop</span><br><span class="line">0x00007ff7b5f325d9 (Unity) PlayerLoop</span><br><span class="line">0x00007ff7b6e7993f (Unity) PlayerLoopController::UpdateScene</span><br><span class="line">0x00007ff7b6e77bdf (Unity) Application::TickTimer</span><br><span class="line">0x00007ff7b72c37aa (Unity) MainMessageLoop</span><br><span class="line">0x00007ff7b72c805b (Unity) WinMain</span><br><span class="line">0x00007ff7b864b42e (Unity) __scrt_common_main_seh</span><br><span class="line">0x00007ffe3a797034 (KERNEL32) BaseThreadInitThunk</span><br><span class="line">0x00007ffe3b5c2651 (ntdll) RtlUserThreadStart</span><br></pre></td></tr></table></figure><p>对比代码发现，我们游戏在进入战斗时，会强制清理一次对象池，而清理方式则是直接调用 <code>GameObject.DestroyImmediate</code></p><p>GameObject.DestroyImmediate 和 GameObject.Destroy 一直是有区别的，记得很早以前官方都推荐正式环境用 Destroy 而非 DestroyImmediate。</p><p>为了确认看了下文档：</p><blockquote><p>立即销毁对象 /obj/。强烈建议您改用 Destroy。</p></blockquote><blockquote><p>该函数应只在编写 Editor 代码时使用，因为在编辑模式下， 永远不会调用延迟销毁。 在游戏代码中，您应该改用 Object.Destroy。Destroy 始终延迟进行 （但在同一帧内执行）。 使用该函数时要务必小心，因为它可以永久销毁资源！ 另请注意，切勿循环访问数组并销毁正在迭代的元素。这会导致严重的问题（这是一条通用的编程实践，而不仅仅是在 Unity 中）。</p></blockquote><p>说明 DestroyImmediate 肯定是有一定风险的，特别是 CleanPool 中的代码，还正好是一个循环调用的 DestroyImmediate。</p><p>于是怀疑是否这里的影响，尝试将其修改为 Destroy。</p><p>如此之后————还是崩溃了，日志变成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Asset Pipeline Refresh: Total: 0.027 seconds - Initiated by RefreshV2(AllowForceSynchronousImport)</span><br><span class="line">Received signal SIGSEGV</span><br><span class="line">Obtained 22 stack frames</span><br><span class="line">0x00007ff7b5c0aceb (Unity) GameObject::SendMessageAny</span><br><span class="line">0x00007ff7b607e835 (Unity) Transform::BroadcastMessageAny</span><br><span class="line">0x00007ff7b607e899 (Unity) Transform::BroadcastMessageAny</span><br><span class="line">0x00007ff7b607e899 (Unity) Transform::BroadcastMessageAny</span><br><span class="line">0x00007ff7b688d7f6 (Unity) UI::Canvas::WillDestroyComponent</span><br><span class="line">0x00007ff7b5c0d3a1 (Unity) GameObject::WillDestroyGameObject</span><br><span class="line">0x00007ff7b5f18901 (Unity) PreDestroyRecursive</span><br><span class="line">0x00007ff7b5f16927 (Unity) DestroyObjectHighLevel_Internal</span><br><span class="line">0x00007ff7b5f16564 (Unity) DestroyObjectHighLevel</span><br><span class="line">0x00007ff7b5d3345b (Unity) DelayedDestroyCallback</span><br><span class="line">0x00007ff7b5d35344 (Unity) DelayedCallManager::Update</span><br><span class="line">0x00007ff7b5f457b9 (Unity) `InitPlayerLoopCallbacks&#x27;::`2&#x27;::PostLateUpdateScriptRunDelayedDynamicFrameRateRegistrator::Forward</span><br><span class="line">0x00007ff7b5f2c89c (Unity) ExecutePlayerLoop</span><br><span class="line">0x00007ff7b5f2c973 (Unity) ExecutePlayerLoop</span><br><span class="line">0x00007ff7b5f325d9 (Unity) PlayerLoop</span><br><span class="line">0x00007ff7b6e7993f (Unity) PlayerLoopController::UpdateScene</span><br><span class="line">0x00007ff7b6e77bdf (Unity) Application::TickTimer</span><br><span class="line">0x00007ff7b72c37aa (Unity) MainMessageLoop</span><br><span class="line">0x00007ff7b72c805b (Unity) WinMain</span><br><span class="line">0x00007ff7b864b42e (Unity) __scrt_common_main_seh</span><br><span class="line">0x00007ffe3a797034 (KERNEL32) BaseThreadInitThunk</span><br><span class="line">0x00007ffe3b5c2651 (ntdll) RtlUserThreadStart</span><br></pre></td></tr></table></figure><p>由于这次属于延时销毁，所以不再有实际调用销毁的堆栈打印，不过最终走到的崩溃位置还是一样: <code>GameObject::SendMessageAny</code></p><p>在此处增加对应销毁物体打印，只看到一个 TS_MainButtomView</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;color=lightblue&gt;1660365391&lt;/color&gt; Debug:销毁：TS_MainButtomView </span><br></pre></td></tr></table></figure><p>造成崩溃对象可能就是这个 Prefab，在我们项目是一个 UI 组件。</p><p>并且后续经过尝试，若不销毁该对象，同样有可能崩溃，且会发生于退出战斗时也可能崩溃。</p><p>这时候基本上已经相当怀疑这个对象了，只是由于每次碰到的崩溃最终堆栈信息都还不尽相同，所以无法定性，常见有：</p><ul><li>销毁</li><li>创建</li><li>刷新精灵Sprite <blockquote><p>tlsf_free<br>  DynamicHeapAllocator::Deallocate</p></blockquote></li></ul><p>正准备试试官方文档介绍的 <a href="https://docs.unity3d.com/Manual/WindowsDebugging.html">Debug方式</a> 的时候，后续测试同学竟还找到了一个稳定复现之处，再经个人反复尝试和查询，最终得到如下指向比较清晰一点日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Received signal SIGSEGV</span><br><span class="line">Obtained 51 stack frames</span><br><span class="line">0x00007ff7e8a5f2a4 (Unity) UI::CanvasManager::AddCanvas</span><br><span class="line">0x00007ff7e8a73633 (Unity) UI::Canvas::AddToManager</span><br><span class="line">0x00007ff7e8a73c65 (Unity) UI::Canvas::AwakeFromLoad</span><br><span class="line">0x00007ff7e8512fe7 (Unity) AwakeFromLoadQueue::InvokeAwakeFromLoad</span><br><span class="line">0x00007ff7e850e003 (Unity) AwakeFromLoadQueue::AwakeFromLoadAllQueues</span><br><span class="line">0x00007ff7e7df417a (Unity) GameObject::ActivateAwakeRecursively</span><br><span class="line">0x00007ff7e7dfb719 (Unity) GameObject::SetSelfActive</span><br><span class="line">0x00007ff7e767fd9b (Unity) GameObject_CUSTOM_SetActive</span><br><span class="line">0x00000126e405c104 (Mono JIT Code) (wrapper managed-to-native) UnityEngine.GameObject:SetActive (UnityEngine.GameObject,bool)</span><br><span class="line">0x00000126f84444fb (Mono JIT Code) [MainButtomView.cs:1442] MainButtomView/&lt;&gt;c__DisplayClass115_0:&lt;OpenView&gt;b__0 (object) </span><br></pre></td></tr></table></figure><p>崩溃结果指向，界面的子节点挂载的 Canvas，该对象(TS_MainButtomView)属于主界面 Aorpage 的一个 子节点 Prefab，且自身挂载了 Canvas。</p><p>这里经过尝试，表明该组件并非是必须的。</p><p>于是移除之后就真的好了..</p><h2 id="十一、重打图集混乱"><a href="#十一、重打图集混乱" class="headerlink" title="十一、重打图集混乱"></a>十一、重打图集混乱</h2><p>例如，更改图集大小，最明显的一个错误表现如下：</p><p><img src="/blogimages/2022/2022-07-20/m_3dc46ec72951416efa3db5e39d72cf52_r.png"></p><p>如果现在点击提交，发现meta文件都未被修改：</p><p><img src="/blogimages/2022/2022-07-20/m_1a847eda1a12e0c8d768a4f928876577_r.png"></p><p>而且编辑器中也可以明显看出 Position 依然是旧的——经过分析调试，在编辑器工具生成新的图集数据时，确实也是赋值了新的数据的：</p><p><img src="/blogimages/2022/2022-07-20/m_37d6afb2f1f694e23da5f116b33d1fb9_r.png"></p><p>于怀疑是不是 Unity 内部又出啥事了。</p><p>经过查询关键字 textureImporter.spritesheet，有找到一篇可能有所关联的博客 <a href="https://blog.csdn.net/rcfalcon/article/details/49743715">unity 2D Sprite网格Slice工具</a></p><p>这篇文章描述了 Unity 的 textureImporter.spritesheet 大约存在一个 BUG，当图集中图片未被修改，仅发生位置表动时，将导致其数据无法正常更新。虽然这篇博文已经早是 2015 年的东西了，不过本着尝试一下的感觉，没成想真是这个问题！</p><p>末尾给加上</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">textureImporter.mipmapEnabled = !textureImporter.mipmapEnabled;</span><br><span class="line">textureImporter.SaveAndReimport();</span><br><span class="line">textureImporter.mipmapEnabled = <span class="literal">false</span>;</span><br><span class="line">textureImporter.SaveAndReimport();</span><br></pre></td></tr></table></figure><p>就正常了，关键是这个在之前 Unity2017 还能正常工作的。</p><h2 id="十二、正式包"><a href="#十二、正式包" class="headerlink" title="十二、正式包"></a>十二、正式包</h2><p>其它比较简单一点、或者一些功能上的的升级问题，这里就不作记录了，最终正式包如下：</p><p><img src="/blogimages/2022/2022-07-20/m_01c6a4b39b61c4c75075e6451fd2968e_r.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、UGUI&quot;&gt;&lt;a href=&quot;#一、UGUI&quot; class=&quot;headerlink&quot; title=&quot;一、UGUI&quot;&gt;&lt;/a&gt;一、UGUI&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;超链接&quot;&gt;&lt;a href=&quot;#超链接&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://cwhisme.github.io/categories/Unity3D/"/>
    
    
    <category term="问题解决记录" scheme="https://cwhisme.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>利用JIRA的RichFilterStatistics统计BUG率等信息</title>
    <link href="https://cwhisme.github.io/2022/07/01/%E5%88%A9%E7%94%A8JIRA%E7%9A%84RichFilterStatistics%E7%BB%9F%E8%AE%A1BUG%E7%8E%87%E7%AD%89%E4%BF%A1%E6%81%AF/"/>
    <id>https://cwhisme.github.io/2022/07/01/%E5%88%A9%E7%94%A8JIRA%E7%9A%84RichFilterStatistics%E7%BB%9F%E8%AE%A1BUG%E7%8E%87%E7%AD%89%E4%BF%A1%E6%81%AF/</id>
    <published>2022-07-01T09:40:15.000Z</published>
    <updated>2022-12-11T02:01:22.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在思考如何客观对大家的 BUG率 和 Reopen率 的评分问题，本来公司有个统计平台的，但是那个统计平台只会统计大单，小的BUG、任务根本没记录的，而且关于 “最近一周” 之类的信息的时间条件也没啥统计来支持，于是想到利用 JIRA 来统计。</p><p>众所周知，在我们的 JIRA 中，我们经常会用到一个问题过滤器，以统计当前任务信息：</p><p><img src="/blogimages/2022/2022-07-01/m_362028b3455ab338a511e052153eeee3_r.png"></p><p>但是自带的问题统计比较简单，基本上只支持选择一个自定义的过滤器，以及部分固定的字段设置：</p><p><img src="/blogimages/2022/2022-07-01/m_00bd1944d47eff69ab3f4694b34f6cfa_r.png"></p><p>效果如下：</p><p><img src="/blogimages/2022/2022-07-01/m_6777086955245f41d5cf7a7510c040a7_r.png"></p><p>统计类型都是固定的，你选择了哪个类型，在问题统计中，就会以某个类型为准将过滤器中满足条件的任务进行排列。</p><p>例如展示当前前台所有的BUG单</p><p>然后就产生了一个问题：BUG单测试都不会填 开发者 或者 BUG产生者之类的字段，最多标记模块为 前台，然后分给对应产生BUG功能的人身上。</p><p>此时根据自定义过滤器筛选，当前BUG统计单是可以看到的，但是当这个任务被解决，返回给测试之后，就难以查出对应对象了——至少从统计类型中，是没有这个分类的。</p><p>查了一下，于是想到自定义过滤器可以指定对应的解决问题者，可以通过如下代码筛出上周完结的BUG：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component = 前台 AND status != Suspend AND type = Sub-bug AND status changed from Open to resolved during (startOfWeek(-1), endOfWeek(-1)) </span><br></pre></td></tr></table></figure><p>上述代码以过去一周内，前台所有状态变更为已解决，且目前非挂起状态为条件，筛选出</p><p>数据是有了，但要是这时候将该过滤器拿到问题统计来，由于统计类型中根本没有“经手人”信息，也是无法得到正确的结果的， 顶多展示当前挂在测试身上的一堆“上周BUG”：</p><p><img src="/blogimages/2022/2022-07-01/m_50504f276542b578a9970a8bf7ff18f8_r.png"></p><h2 id="迂回的尝试"><a href="#迂回的尝试" class="headerlink" title="迂回的尝试"></a>迂回的尝试</h2><p>这时候，一开始多次尝试不行之后，没办法就想手动挨个去创建过滤器来展示，大概的想法是：</p><ul><li>创建一个 上周完结的BUG 总过滤器，创建一个问题统计仅展示总BUG数量</li><li>创建一个 当前用户上周完结的BUG 过滤器，创建一个问题统计展示“自己”上周BUG数量</li></ul><p>以及后边 Reopen 啥的也都如此，大概效果如下：</p><p><img src="/blogimages/2022/2022-07-01/m_956edaf03cf9709df541ae22be97af05_r.png"></p><p>不用质疑，非常的繁琐、效果也差，展示的内容基本上是分离的，无法链接在一块。<br>如果想计算某人在上周所有BUG量中的占比，更是还需要计算一番。</p><p>于是在刚创建了这么两个问题统计之后，就感觉不大行——这样一个个排列是能看，但是并不好用，于是就在添加小工具里边翻着页找，看到了这么个东西，听名字和图标，感觉有那么点意味：</p><p><img src="/blogimages/2022/2022-07-01/m_665ff8f93c1990ac2ca124ba6cd5b2bc_r.png"></p><p>关于这个小工具，以前开始自定义 JIRA 面板的时候其实也看到过，不过那会需求没这么多，而且创建之后随便点了点那些选项，因为也不会用，就没管了。这次就想着稍微研究下。</p><h2 id="使用-Rich-Filter-Statistics"><a href="#使用-Rich-Filter-Statistics" class="headerlink" title="使用 Rich Filter Statistics"></a>使用 Rich Filter Statistics</h2><p>点击创建之后，会是这么个样子：</p><p><img src="/blogimages/2022/2022-07-01/m_f347e2411f6f1a3b7b21ec7be39ec500_r.png"></p><p>默认情况下，Rich filter 是没任何可选项的，因此在这之前，必须点红框的超链接，创建一个自己的 Rich filter。这里直接先上之前的自己尝试的流程：</p><ol><li>点击右上角，创建一个新的 Rich filter<br><img src="/blogimages/2022/2022-07-01/m_38f40fa9e64fb5744b17fdb46a054eaa_r.png"></li><li>在通用面板中选择之前自己已经创建好的普通过滤器<br><img src="/blogimages/2022/2022-07-01/m_18432576ca7c450f19164369ea591eef_r.png"><br>注：这里可能需要手动复制，因为搜索功能相当不好使，东西太多了</li><li>选择完毕之后，下方还会直接展示过滤器的代码<br><img src="/blogimages/2022/2022-07-01/m_5dd395d567e8c97a953e36dac123f921_r.png"></li><li>此时，在 JIRA 面板中，已经可以选择该Rich filter了，不过要是就这样，那它跟通常的统计器也一样，只能选择系统内置的那几个变量，因此还必须得切到 Smart filters 页签：<br><img src="/blogimages/2022/2022-07-01/m_7a35880194f18678b65d476adfafcdc7_r.png"><br>依然是首先创建一个 Smart filters ，标注好名字<br>现在，相当于有了一个自定义的分类，在JIRA面板中就可以通过Statistic type选择了：<br><img src="/blogimages/2022/2022-07-01/m_4e14db5387eb11834cf8f6d44b210916_r.png"><br>但是这样是不够的，如此只会把所有的过滤器结果全展示为一条，跟最初的想法完全不符</li><li>回到 Smart filters，可以看到新创建的下方有这么个东西<br><img src="/blogimages/2022/2022-07-01/m_302bb48b5ca0b25945e4835b2cc27784_r.png"><br>可以接受输入类型(名字)[如果创建时选了颜色，还可以设置颜色]，以及 JQL 筛选代码，输入完毕点旁边的加号就可以添加，筛选的结果基于创建整个Rich Filter Statistics 最初的那个过滤器，因此可以省略掉已经筛过的判断，例如，直接筛选指定的名字。</li></ol><p>最后结果如下：<br><img src="/blogimages/2022/2022-07-01/m_b7bbfe6bd20430a1ea1fb41644dbc610_r.png"></p><p>回到 JIRA 面板，Statistic type 选择新创建的这个，效果如下：</p><p><img src="/blogimages/2022/2022-07-01/m_89050bb6883cd5917ac952cc8054bc04_r.png"></p><h2 id="综合统计功能"><a href="#综合统计功能" class="headerlink" title="综合统计功能"></a>综合统计功能</h2><p>上述就是 Rich Filter Statistics 统计最基本或者最简单的使用方法。</p><p>不过后边又想到，既然 Rich Filter Statistics 统计可以有手工筛选器，那么可不可以把本周已完成BUG，或者其它数据一块放这儿呢？又或者整个结合一起，毕竟看创建小工具的图标显示，它貌似还可以支持类表格的统计展示的。</p><p>而且额外那么多标签页和选项，理论上都是有用的。</p><h3 id="添加-Reopen-统计"><a href="#添加-Reopen-统计" class="headerlink" title="添加 Reopen 统计"></a>添加 Reopen 统计</h3><p>于是尝试了一番，标签页的 Custom values 可以生成二维过滤条件：</p><p><img src="/blogimages/2022/2022-07-01/m_1df8e0ab20f9a7a19871e3bac3a1fcca_r.png"></p><p>这里我创建了一条筛选 Reopen 单子的 Custom values，之后在 JIRA 面板就可以添加自定义的展示值：</p><p><img src="/blogimages/2022/2022-07-01/m_951be46016e09fd3301502edcc95ba76_r.png"></p><p>之后效果如下：</p><p><img src="/blogimages/2022/2022-07-01/m_a4ecc4645a100127ccd9d557c2bc3f76_r.png"></p><h4 id="Rich-Filter-Controller"><a href="#Rich-Filter-Controller" class="headerlink" title="Rich Filter Controller"></a>Rich Filter Controller</h4><p>这个也是在工具面板里边偶然看到的，创建出来试了一下，可以作为动态控制显示的额外筛选条件。<br>所以也简单介绍下。</p><p><img src="/blogimages/2022/2022-07-01/m_014d0b01ec03f554635cca171fb6d69b_r.png"></p><p>这个可以看做是 Rich Filter Statistics 的一个动态控制器，简单来说，目前我发现的用处是就是可以通过指定额外的 JQL 语句再作一次筛选。</p><p>JQL 语句支持事先定义好的，也可以实时填写。</p><ul><li><p>事先定义好的筛选选项，其实就是之前创建 Rich Filter 就看见的 Static filters 页签：<br><img src="/blogimages/2022/2022-07-01/m_01bccc1d2847ccda40efe20654704e53_r.png"><br>这儿定义的内容对 Rich Filter Statistics 本身其实是没用的(至少试了下没有)，不过可以通过 Rich Filter Controller 小工具直接影响 Rich Filter Statistics 的展示效果<br>创建方式很简单，名字+JQL 语句即可：<br><img src="/blogimages/2022/2022-07-01/m_1c057f599ec9ed4a857c4b1a700b6e96_r.png"></p></li><li><p>实时添加 JQL 来筛选的话，创建面板时需要勾选 Enable additional JQL filtering<br>选项，如图所示：<br><img src="/blogimages/2022/2022-07-01/m_66acca903d6e3e5e657fb453031c2760_r.png"></p></li></ul><p>动态筛选效果如下：</p><p><img src="/blogimages/2022/2022-07-01/m_c64152846299252b532932d3af57adaa_r.png"></p><p>点击选项时，可以实时获得对应筛选分类结果。</p><h3 id="完善-Rich-Filter-Statistics"><a href="#完善-Rich-Filter-Statistics" class="headerlink" title="完善 Rich Filter Statistics"></a>完善 Rich Filter Statistics</h3><p>理论上上述的统计条件已经可以用了，例如将过去一周改成本周，BUG 筛选改成任务、优化单筛选就可以统计本周工作量，要说其实跟上一个 Rich Filter 合并都可以。</p><h2 id="1-将无BUG产生者的BUG指定为任务单"><a href="#1-将无BUG产生者的BUG指定为任务单" class="headerlink" title="1.将无BUG产生者的BUG指定为任务单"></a>1.将无BUG产生者的BUG指定为任务单</h2><p>其次，有时候我们可能需要将一些『老BUG』、即已经找不着BUG产生者的问题，分配给新的人解决，这时候我们可能就需要区分一下，避免BUG被直接统计到新人头上。<br>这里我想的方式是：分配单子时增加一个指定的备注，然后在另一边的 jql 筛选时，将增加了指定备注的单子移除BUG统计单，并将其统计为任务单。</p><p>例如，我这儿选择用 『任务单』 这个关键字进行指定，统计为BUG单核任务分别可以作如下修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//任务单</span><br><span class="line">type = Main-Task OR type = Improvement OR type = Sub-task OR type = Task OR type = Sub-suggestion or comment ~ 任务单</span><br></pre></td></tr></table></figure><p>填写效果如下：<br><img src="/blogimages/2022/2022-07-01/m_b291f2fdf05af973af31b79e3bc42576_r.png"></p><p>使用效果如下：</p><p><img src="/blogimages/2022/2022-07-01/m_5a777f0aeeb8c309cbd8552c162a46fc_r.png"></p><p>但是这里还有一个问题就是，备注的搜索只支持搜索指定文本，但是不支持筛选结果取反——比如『不包括』指定文本就无法工作，例如以下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//筛选BUG单，且备注没有注明为 任务单的</span><br><span class="line">type = Sub-bug and comment !~ 任务单</span><br></pre></td></tr></table></figure><p>经过后续研究，发现是由于备注为空的话，则同样会被直接排除掉!也即是说 <FONT COLOR=RED>comment 搜索不支持无备注的单子！无备注的单子无论是包含还是不包含都会被直接排除掉!</FONT></p><p>最终导致得不到正常的结果，因此虽然可以将 BUG 单统计为任务，但是同样也还是会计算到BUG单中。</p><h2 id="2-统一使用一个筛选器"><a href="#2-统一使用一个筛选器" class="headerlink" title="2. 统一使用一个筛选器"></a>2. 统一使用一个筛选器</h2><p>为了方便多时间周期的统计，例如 上周、上个月、本月 这种，最简单的方式是直接在一系列配置完成后，在基础上复制一份即可 Rich Filter。</p><p>后来我重新建立了一个普通的基础筛选器，其作用是筛选所有前台任务。基础筛选器中不包括时间判断，然后在此基础上进行进一步筛选。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status != Suspend AND status changed from Open to resolved by (chenzhihao, wanghan, wangjiaying, huangdong, renjun, chensihao, jiangyunfei, gaozirui) OR status in (Open, &quot;In Progress&quot;, Reopened) AND assignee in (chenzhihao, wanghan, wangjiaying, huangdong, renjun, chensihao, jiangyunfei, gaozirui)</span><br></pre></td></tr></table></figure><p>注：删除了 <code>during (startOfWeek(), endOfWeek())</code>判断</p><p>里边有任务统计，也有已经完成的 BUG 单，还包括当前身上存在的其它各种单子。</p><p>并且由于还会统计除了 BUG 单之外的单子，然后这些单子有的可能是策划或者运营建的，有时候连模块都不会填前台，但是却又交给前台解决，所以在无法确定那些单子是否真是由前台完成的情况下，只有用最笨的方式——直接筛选所有前台开发的名字，以保证统计万无一失，避免遗漏。</p><p>基础筛选完毕后，后续操作基本就跟上述 上周的BUG统计 一致了。</p><p>不过，由于时间参数被去掉了，因此如果直接展示，效果就会包括所有历史记录，例如：</p><p><img src="/blogimages/2022/2022-07-01/m_aa5d84371e4df635e3d949a1ba5c3ea5_r.png"></p><p>这时候有两种方式可以解决。</p><ul><li><h4 id="配合-Rich-Filter-Controller-控制时间显示"><a href="#配合-Rich-Filter-Controller-控制时间显示" class="headerlink" title="配合 Rich Filter Controller 控制时间显示"></a>配合 Rich Filter Controller 控制时间显示</h4><p>Static filters 参数如下：<br><img src="/blogimages/2022/2022-07-01/m_84b681d6cc8e052afd9ab5a59fc97f5a_r.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//本周统计</span><br><span class="line">(status = Open or status changed from Open to resolved during (startOfWeek(), endOfWeek()) )</span><br><span class="line">//上周统计</span><br><span class="line">status != Suspend AND status changed from Open to resolved during (startOfWeek(-1), endOfWeek(-1)) </span><br><span class="line">//本月统计</span><br><span class="line">status != Suspend AND status changed from Open to resolved during (startOfMonth(), endOfMonth()) </span><br><span class="line">//上月统计</span><br><span class="line">status != Suspend AND status changed from Open to resolved during (startOfMonth(-1), endOfMonth(-1)) </span><br></pre></td></tr></table></figure><p>然后就可以通过 Rich Filter Controller 控制：<br><img src="/blogimages/2022/2022-07-01/m_0cefb1ba377ddd4714ec154a86a98b77_r.png"><br>不过这种方式有个缺点，就是控制器修改后会影响所有使用这一条 Rich Filter 的小工。<br>其次，其它成员第一次进入该页面时，默认无任何控制器生效(即显示所有结果)<br>鉴于此，另外一个选择相比就好用些了。</p></li><li><h4 id="利用组件的-Working-query-参数"><a href="#利用组件的-Working-query-参数" class="headerlink" title="利用组件的 Working query 参数"></a>利用组件的 Working query 参数</h4><p><img src="/blogimages/2022/2022-07-01/m_1841119ed158ad959636358999e52830_r.png"><br>如上图所示，我们在创建 Rich Filter Statistics 面板时，可以发现编辑器页有一个 Working query 的参数。<br>这个参数可以对筛选的结果再作一次最终筛选，跟上一种方式理论一致。<br>因此可以直接复制上述代码，分别创建对应统计面板时按照需求粘上去，效果也是一样的。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以统计上周，也可以统计本周，以及本周做过的优化、任务，目前需求暂且算是可以了。</p><p>后边准备再研究试试其它采用 Rich Filter 的面板，毕竟看着有些参数，在 Rich Filter Statistics 根本没有体现出来，例如 Views 之类的选项。</p><ul><li>参考文档：<ul><li><a href="https://confluence.atlassian.com/jirasoftwareserver080/advanced-searching-967899646.html">基本文档</a></li><li><a href="https://confluence.atlassian.com/jirasoftwareserver080/search-syntax-for-text-fields-967899664.html">搜索帮助</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在思考如何客观对大家的 BUG率 和 Reopen率 的评分问题，本来公司有个统计平台的，但是那个统计平台只会统计大单，小的BUG、任务</summary>
      
    
    
    
    <category term="其它" scheme="https://cwhisme.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    
  </entry>
  
  <entry>
    <title>新出的Huatuo热更的一点尝试</title>
    <link href="https://cwhisme.github.io/2022/06/14/%E6%96%B0%E5%87%BA%E7%9A%84Huatuo%E7%83%AD%E6%9B%B4%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%9D%E8%AF%95/"/>
    <id>https://cwhisme.github.io/2022/06/14/%E6%96%B0%E5%87%BA%E7%9A%84Huatuo%E7%83%AD%E6%9B%B4%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%9D%E8%AF%95/</id>
    <published>2022-06-14T09:39:16.000Z</published>
    <updated>2022-12-11T02:01:22.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/focus-creative-games/huatuo">Huatuo</a> 是前一阵子就听说过的新的热更框架，其原理基于对 Unity il2cpp 的扩展。可以使我们目前直接打包出来的 纯 “AOT Runtime” 变成 “AOT+Interpreter” 混合Runtime.</p><p>官方即自称为 划时代 的热更新框架，更详细的原理解释可以直接参考官方文档，这里可以简单概括两点让人感觉比较厉害的：</p><ul><li>不像 XLua、ILruntime 等由于采用 VM 执行热更代码，导致需要事先做好各种处理，Huatuo 借助 il2cpp 及自己的一套指令集直接解释执行。因此可以随意调用C#各项特性，不需要生成代码或者写适配器。</li><li>Huatuo 中 Unity 工作流与原生几乎完全相同，与非热更代码开发方式基本一致，非常方便。</li></ul><p>根据官方介绍，瞬间感觉就被吸引了，于是下载下来简单试了一下。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>按照目前了解的信息，Huatuo修改的 il2cpp 底层在加载代码之后，会判断执行的代码是否是属于 AOT，如果不是，则通过 Huatuo 解释执行——而这一切都是底层的判断，而且解释执行模式又基于 il2cpp ，因此性能上理论上不用怀疑，具体性能测试相关可以查看 <a href="https://focus-creative-games.github.io/huatuo/performance/benchmark/#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A">性能测试报告</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用的Unity版本为 Unity 2021.3.0f1 ,对于 Huatuo 的安装方式，采用了方法三：使用Unity Package Manager 安装</p><p>简单步骤如下：</p><ol><li>在Unity中，点击 Edit-&gt;Project Settings，选择 Package Manager</li><li>在Scoped Registries中添加下面信息<ul><li>Name: package.openupm.cn</li><li>URL: <a href="https://package.openupm.cn/">https://package.openupm.cn</a></li><li>Scope(s): com.focus-creative-games.huatuo<br><img src="/blogimages/2022/2022-06-14/step1.png"></li></ul></li><li>点击Apply</li><li>打开 Edit-&gt;Project Settings-&gt;Package Manager界面，切换到Window-&gt;Package Manager-&gt;Packages: My Registries 中将看到名为huatuo Tookit for Unity的包，直接安装即可。<br><img src="/blogimages/2022/2022-06-14/step2.png"></li></ol><p>注：安装并非一次性的，Huatuo 这个编辑器工具，并非 Huatuo 本身，因为 Hutuo 是直接修改替换的我们安装的 Unity编辑器 目录下 il2cpp 文件</p><p>例如我的路径位于：Unity 2021.3.0f1\Editor\Data\il2cpp\libil2cpp</p><p>因此，安装之后可以跨项目使用，在一个项目安装之后，其它项目也会受到影响。<br>不过工具会自动创建 il2cpp 备份就是了，如果哪天不想用了，可以用备份还原为原始版本。</p><p>备份目录就在 Unity安装目录下的il2cpp同级，例如我的是：Unity 2021.3.0f1\Editor\Data\il2cpp\libil2cpp_original_unity</p><h2 id="测试-huatuo-trial-项目"><a href="#测试-huatuo-trial-项目" class="headerlink" title="测试 huatuo_trial 项目"></a>测试 huatuo_trial 项目</h2><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><p>huatuo_trial 是 Huatuo 官方提供的一个示例项目。</p><p>安装完毕之后，为了先进一步认识一下，因此并没有说自己直接尝试使用，而且准备先看看官方示例项目的用法，果不其然，还是了解到有些注意点的。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>官方示例项目中，所有代码都是直接放在项目中的，不过通过创建不同的 *.asmdef 程序集描述文件，将其分类成了三个程序集，分别是：</p><ul><li>Main</li><li>HotFix</li><li>HotFix2</li></ul><p>其中，Main 负责作为加载 HotFix 及 HotFix2 两个程序集的入口，也就是说 Main 就类似于一般游戏的 Launcher，主要用于加载、不可热更。</p><p>其中为什么在测试项目中热更 DLL 分为了两个程序集，可以看 HuaTuo_BuildProcessor_2020_1_OR_NEWER.cs 的代码，这一份貌似是作为 “配置” 存在的，里边分别标记了两者的作用：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 需要在Prefab上挂脚本的热更dll名称列表，不需要挂到Prefab上的脚本可以不放在这里</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 但放在这里的dll即使勾选了 AnyPlatform 也会在打包过程中被排除</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 另外请务必注意！： 需要挂脚本的dll的名字最好别改，因为这个列表无法热更（上线后删除或添加某些非挂脚本dll没问题）</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">List</span>&lt;<span class="title">string</span>&gt; s_monoHotUpdateDllNames</span> = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;HotFix.dll&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 所有热更新dll列表</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="built_in">string</span>&gt; s_allHotUpdateDllNames = s_monoHotUpdateDllNames.Concat(<span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里放除了s_monoHotUpdateDllNames以外的脚本不需要挂到资源上的dll列表</span></span><br><span class="line">    <span class="string">&quot;HotFix2.dll&quot;</span>,</span><br><span class="line">&#125;).ToList();</span><br></pre></td></tr></table></figure><p>需要注意的是，在配置类中 OnFilterAssemblies 方法默认排除了热更程序集，如果是自己创建 DLL 文件作为游戏逻辑需要热更且放在项目中的，可能需要修改，当然跟官方一样不用额外 DLL 也可以。</p><p>根据注释说明，表示 HotFix 可以允许在Prefab上挂载脚本，HotFix2 则不允许，除此之外两者使用方式都是一致的，添加、删除组件都是允许的。</p><p>示例项目就展示了这一点：在 HotFix2 中创建了一个空物体，并添加了 HotFix 中的脚本。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试其实很简单，用 Unity 将示例项目打开之后只要不报错，只需要出包，然后随便改 HotFix、HotFix2 程序集中的代码，完了点击菜单的 Huatuo-&gt;BuildBundles-&gt;ActiveBuiuldTarget 即可。</p><p><img src="/blogimages/2022/2022-06-14/step3.png"></p><p>菜单这个编辑器工具会将 Prefabs 目录下的预制体以及上述两个程序集的代码，共同打成一个叫 common 的Bundle文件，放在 StreamingAssets 下。</p><p>将 common 替换掉真机包的文件就可以看出效果了。</p><p><img src="/blogimages/2022/2022-06-14/step4.png"></p><p>此处我在 HotFix2 App.cs、HotFix CreateByHotFix2.cs,PrintHello.cs 都随便修改了一波，基础的热更表现上都没啥问题。</p><p>虽然配置代码有注释说明，允许挂载预制体删的脚本程序集是在 AddBackHotFixAssembliesToJson 方法中打包时做了特殊处理的，<br>不过后边还是头铁试了下在 HotFix2 创建了一个新的 MonoBehaviour 脚本，给它直接挂载到原有的那个 HotUpdatePrefab 上，果不其然是不行的：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewBehaviourScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;HotFix 热更 MonoBehaviour！PrefabName:&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/blogimages/2022/2022-06-14/step5.png"></p><p>不过直接将其挪到 HotFix 目录下，重新出一下就可以了：</p><p><img src="/blogimages/2022/2022-06-14/step6.png"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>从以上可以看出，官方将其分类为 逻辑程序集 和 Mono程序集，估计也是像这样推荐。</p><p>使用了一下这个热更方式之后，最大的感受就是使用方式简单、接入方便，且热更代码开发方式对于开发者来说非常无感，不像其它专为热更而生的 InjectFix 或 ILRuntime，接入以及开发过程中都有不少要注意的。要不是目前官方最多支持到 Unity2019，还真想来实际试试。</p><p>要是项目可以真的推广使用就好了，因为实在不喜欢 Xlua 那些弱类型语言。</p><hr><p>Huatuo 在知乎还开了一个<a href="https://www.zhihu.com/column/c_1489549396035870720">知乎专栏</a>，虽然目前文章挺少</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/focus-creative-games/huatuo&quot;&gt;Huatuo&lt;/a&gt; 是前</summary>
      
    
    
    
    <category term="热更" scheme="https://cwhisme.github.io/categories/%E7%83%AD%E6%9B%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>使用CE指针扫描查找基址</title>
    <link href="https://cwhisme.github.io/2021/12/28/%E4%BD%BF%E7%94%A8CE%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F%E6%9F%A5%E6%89%BE%E5%9F%BA%E5%9D%80/"/>
    <id>https://cwhisme.github.io/2021/12/28/%E4%BD%BF%E7%94%A8CE%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F%E6%9F%A5%E6%89%BE%E5%9F%BA%E5%9D%80/</id>
    <published>2021-12-28T03:10:35.000Z</published>
    <updated>2022-12-11T02:01:22.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前文提到过，想要修改一个进程内指定内存地址的数据，首先得取得『基址』。</p><p>个人感觉，『基址』可以看做一个应用在内存中某个值的『锚点』，取得锚点之后，只要该应用没有进行大的更新，无论如何更换设备、系统，其地址都能直接通过计算『确定』。</p><p>反之若没有基址，采用手动方法获取了某个值的地址，可能关闭应用再打开就没效果了。</p><p>最找出来的这个锚点，一般是某个  exe 、或者 dll 结尾的模块名，在 CE 中一般表现为绿色。</p><p>根据目前了解，通过 CE 找锚点的方式，主要有两种：</p><ul><li>人工搜索，通过找指向地址值的指针，再找指向指针的指针….循环往复知直到绿色的基址</li><li>通过指针烧扫描自动查找</li></ul><p>第一个方式适合基址偏移量不高的地址，例如 CE 自带的示例，若是偏移层数比较高，这就是一项大工程了。</p><p>何况现在真正的游戏偏移一般都不可能低，找的过程中还得一边分析逻辑，稍微不注意，可能要重找，总之就是非常繁琐麻烦。</p><p>除此之外，最大的问题就是，真实游戏的基址，甚至是无法通过这种引用关系找出的，因为找个一两层、或许就终止在了某个 esp、ebp 函数调用之类，单纯通过 CE 无法查找下去的地方了。</p><p>这时候就需要借用 ollydbg 之类的工具继续进行了。</p><p>相比手动查找方式，指针扫描我自己用了下，感觉着实方便，只需要扫描-&gt;更新地址-&gt;再扫描排除，就可以把基址给剩下来了。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>还是以 CE 的示例为例吧，打开 CE 的教程游戏，第二关，此处以血量为例，首先查找当前血量地址：</p><p><img src="/blogimages/2021/2021-12-28/step1.png"></p><p>然后右键地址-&gt;指针扫描：</p><p><img src="/blogimages/2021/2021-12-28/step2.png"></p><p>最大级别，一般5级或以下就行了，通常一个地址指针不至于偏6级以上，当然最后实在找不到可以尝试高级别的设置，因为级别越高，需要搜素的数据量和产生的结果也越多。</p><p>记得保存好搜索结果，以免下次搜索不对，可以随时回退。</p><p><img src="/blogimages/2021/2021-12-28/step3.png"></p><p>第一次搜索，5级偏移，产生了 68090 个结果。</p><p>现在将游戏关闭，再打开，可以看见，之前我们搜索出来的血量地址，现在已经作废了：</p><p><img src="/blogimages/2021/2021-12-28/step4.png"></p><p>删除这些作废的地址列表，按照通常找值的方式再次找到血量。</p><p><img src="/blogimages/2021/2021-12-28/step5.png"></p><p>可以看到，血量新的地址已经变成 0163A2A0 ，复制这个地址。</p><p>回到上一步指针扫描界面，选择菜单的 指针扫描器-&gt;重新扫描内存：</p><p><img src="/blogimages/2021/2021-12-28/step6.png"></p><p>将新的地址填入，点击扫描(记得保存为新的数据文件，避免错误时无法回退)。</p><p>这时结果变成了 65538 个，继续上述步骤。</p><ul><li>得到地址 0158C730，结果变成 60922</li><li>得到地址 015AA8F0，结果还是 60922</li></ul><p>若此时与上一次指针结果数值一致，后面就有两个选择：</p><ol><li>挑几个顺眼的加入地址列表，重启游戏查看地址是否指向正确的数值</li><li>重启电脑，将内存完全重置，再进行一次查找</li></ol><p>保险当然是是重启一次电脑比较好，此时不管列表还剩多少项，既然重启电脑都无法影响其指向正确性，那么也就可以直接当做基址使用了。</p><p>挑选也有一些规则，例如优先运行主模块为主。</p><h2 id="加载扫描结果"><a href="#加载扫描结果" class="headerlink" title="加载扫描结果"></a>加载扫描结果</h2><p>上文提到，每次指针扫描后，CE 都会提示我们保存，保存的文件就是扫描结果。</p><p>正确保存后，可以随便加载其中某一步的扫描结果。</p><p>加载方式为：</p><p>随便扫描一个数值-&gt;右键地址-&gt;反汇编此内存区域-&gt;工具-&gt;指针扫描器-&gt;文件-&gt;打开-&gt;选择保存文件</p><p>路径藏得稍微有一点深，不过不影响。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上便是指针扫描器扫基址的方式，个人感觉比手工的方式简单和准确。</p><p>此处作一点记录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前文提到过，想要修改一个进程内指定内存地址的数据，首先得取得『基址』。&lt;/p&gt;
&lt;p&gt;个人感觉，『基址』可以看做一个应用在内存中某个值的『锚</summary>
      
    
    
    
    <category term="HackerSkills" scheme="https://cwhisme.github.io/categories/HackerSkills/"/>
    
    
  </entry>
  
  <entry>
    <title>跨进程读写内存数据</title>
    <link href="https://cwhisme.github.io/2021/12/22/%E8%B7%A8%E8%BF%9B%E7%A8%8B%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE/"/>
    <id>https://cwhisme.github.io/2021/12/22/%E8%B7%A8%E8%BF%9B%E7%A8%8B%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE/</id>
    <published>2021-12-22T06:45:25.000Z</published>
    <updated>2022-12-11T02:01:22.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前不是提到最近在玩一个游戏《无限世界》——其实是十几年前的游戏了。<br>然后里面有个副本有比较好的奖励，然后需要花费大量时间去进行操作、跑路，非常累。<br>另外之前实现的 AHK 自动战斗，在设置不同分辨率后也有写问题，毕竟识图的方式实现逻辑，比较受外部因素影响，于是想找找其它提升精确度和便捷性的方式。</p><p>经过观察， 发现这个游戏的移动方式，应当是采用前端本地移动，服务器转发实现。</p><p>这样，如果可以修改到本地的移动数据，那么岂不是就可以实现瞬移之类的了？</p><p>于是就研究了几天，其它先不论，本文主要说说，在取得对应数据基址之后，使用 C# 改写值的方式。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这里虽说是使用 C#，但实际上，也是调用系统函数来实现。</p><p>有个术语叫 PInvoke，好像也叫 Win32 调用。</p><p>其效果类似于：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="meta-string">&quot;Kernel32.dll&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">CloseHandle</span>(<span class="params">IntPtr hObject</span>)</span>;</span><br></pre></td></tr></table></figure><p>以前我看到这种， 都是感觉非常非常麻烦的，因为此前也是也没用过，不理解对面所需的参数，跟我们这边定义的类型关联是什么？</p><p>例如上述方法，可以在微软API <a href="https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> 看到函数介绍，然而想使用，如何转化为上述代码？</p><p>昨天研究的时候，偶然在一个个文章链接上，找到了一个专门搜集 C# PInvoke 函数的网站：</p><p><a href="https://www.pinvoke.net/index.aspx">pinvoke.net</a></p><p> 上面不但有索引、搜索，每个函数还都列出来了 C# 这边调用方式。</p><p> 想使用的，甚至只需要复制下来，然后按照正常方法调用就行了！</p><p> 昨天试了一下，立刻惊为天人，加入了收藏列表。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>好了，回到主题，有了系统函数可供我们调用之后，就可以找到几个跨进程操作内存的方法了：</p><ul><li>一个读取 <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory">ReadProcessMemory</a></li><li>一个写入 <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory">WriteProcessMemory</a></li></ul><p>有了这两个，然后对面的应用又没有作加密的话，再找到一个对应数据的地址，就可以使用了。</p><p>找基址一般可以用 CE、OD据说也可以，暂时不在本文讨论范围。</p><p>找到基址一般格式如下：</p><p>模块名+基础偏移+指针偏移</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IWClient.exe+00042184-&gt;1C-&gt;8-&gt;40-&gt;110-&gt;4C</span><br></pre></td></tr></table></figure><p>这样，我们根据对应基址和偏移，就可以一路取到该数据在应用当前运行时的真实地址了。</p><p>按照上述规则，取实际地址代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 得到实际操作地址</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;BaseADDR&quot;&gt;</span>基址<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;Deviations&quot;&gt;</span>指针偏移<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Get_RealityADDR</span>(<span class="params"><span class="built_in">string</span> BaseADDR, <span class="built_in">string</span>[] Deviations</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> RealityADDR = Read_MemoryInt(BaseADDR);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Deviations.Length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        RealityADDR = Read_MemoryInt(AddAddress(RealityADDR, Deviations[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    RealityADDR = CalcAddressFromString(AddAddress(RealityADDR, Deviations.Last()));</span><br><span class="line">    <span class="keyword">return</span> RealityADDR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在取真实地址最后一位之前中断，是因为最后一个真实地址直接就是地址+偏移量，此时该地址已经不是指向下一个地址的指针，其值直接就是数据，数据值留待后续获取，因此直接返回前一个地址值(指针)+偏移即可。</p><p>在取得真实地址之后，由于 ReadProcessMemory 获取到的数据是一个字节数组，因此我们需要根据对应地址值进行读取——相信都到这里了，指定地址存放的值的类型，应该都是有数的。</p><p>例如，若地址为指针或Int类型数据，则可以如此解析：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 读取内存内容（以Int类型）</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;BaseADDR&quot;&gt;</span>内存地址<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Read_MemoryInt</span>(<span class="params"><span class="built_in">int</span> ADDR</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Read_MemoryValue(ADDR, <span class="keyword">ref</span> _bufferLittle))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BitConverter.ToInt32(_bufferLittle, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它类型则同理。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>为了测试方便，这里直接拿 CE 的示例吧。</p><p>在菜单选择步骤二，即第一关：</p><p><img src="/blogimages/2021/2021-12-22/1.png"></p><p>经过简单的查找，我们可以找到第一关的存放血量地址为：</p><p>Tutorial-x86_64.exe+325A70-&gt;7F8</p><p>如图所示：</p><p><img src="/blogimages/2021/2021-12-22/2.png"></p><p>其模块名为  Tutorial-x86_64.exe，基础偏移为 325A70，后续偏移一次为 7F8</p><p>如此，根据上述接口，就可以写一个简单的读取及改写的代码了。</p><p>首先，这里定义一个Adapter类，用于改写内存的处理逻辑层，大约代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Memory _memery;</span><br><span class="line"><span class="keyword">private</span> IntPtr _valueAddr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InfinityWorldAdapter</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _memery = <span class="keyword">new</span> Memory();</span><br><span class="line">    _memery.BindProcess(<span class="string">&quot;Tutorial-x86_64&quot;</span>);</span><br><span class="line">    _valueAddr = _memery.Get_RealityADDR(<span class="string">&quot;Tutorial-x86_64.exe&quot;</span>, <span class="string">&quot;325A70&quot;</span>, <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;7F8&quot;</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ReadHP</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _memery.Read_MemoryInt(_valueAddr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteHP</span>(<span class="params"><span class="built_in">int</span> hp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _memery.Write_MemoryValue(_valueAddr, hp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，在界面进行调用测试：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    hpLabel.Content = InfinityWorldAdapter.GetInstance.ReadHP();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button_Click</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    InfinityWorldAdapter.GetInstance.WriteHP(InfinityWorldAdapter.GetInstance.ReadHP() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Button_Click_1</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    InfinityWorldAdapter.GetInstance.WriteHP(InfinityWorldAdapter.GetInstance.ReadHP() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，你可能会碰到如下错误：</p><p><img src="/blogimages/2021/2021-12-22/3.png"></p><p>这是因为我们的程序进程可能与目标不匹配，例如，我们打开的是 CE 64位示例，然后我们的应用勾选了『首选32位』就会出现不匹配导致的报错问题。</p><p>若出现如上情况，可以在项目设置中，将平台目标是修改为与其一致的 32位/64位 即可。</p><p>最终效果如下：</p><p><img src="/blogimages/2021/2021-12-22/GIF-2021-12-23-11-52-55.gif"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>这里仅展示核心代码，示例所用就不贴了：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="comment">//********************************************************************</span></span><br><span class="line"><span class="comment">// Author：CWHISME</span></span><br><span class="line"><span class="comment">// QQ：785300468</span></span><br><span class="line"><span class="comment">// 描述：个人用跨进程内存操作类</span></span><br><span class="line"><span class="comment">// 参考：</span></span><br><span class="line"><span class="comment">// https://www.pinvoke.net/default.aspx/user32/ReadProcessMemory.html</span></span><br><span class="line"><span class="comment">// https://www.seeull.com/archives/80.html</span></span><br><span class="line"><span class="comment">// https://zhuanlan.zhihu.com/p/35005383</span></span><br><span class="line"><span class="comment">//********************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>读写内存</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Memory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 从内存中读取字节集</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;hProcess&quot;&gt;</span>进程句柄<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;lpBaseAddress&quot;&gt;</span>内存基址<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;lpBuffer&quot;&gt;</span>读取到缓存区的指针<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;nSize&quot;&gt;</span>缓存区大小<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;lpNumberOfBytesRead&quot;&gt;</span>读取长度<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">&quot;kernel32.dll&quot;</span>, SetLastError = true)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">bool</span> <span class="title">ReadProcessMemory</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">       IntPtr hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">       IntPtr lpBaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="built_in">byte</span>[] lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">       Int32 nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">out</span> IntPtr lpNumberOfBytesRead</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 从内存中写入字节集</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;hProcess&quot;&gt;</span>进程句柄<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;lpBaseAddress&quot;&gt;</span>内存地址<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;lpBuffer&quot;&gt;</span>需要写入的数据<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;nSize&quot;&gt;</span>写入字节大小,比如int32是4个字节<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;lpNumberOfBytesWritten&quot;&gt;</span>写入长度<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">&quot;kernel32.dll&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">bool</span> <span class="title">WriteProcessMemory</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">         IntPtr hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">         IntPtr lpBaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="built_in">byte</span>[] lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">         Int32 nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="keyword">out</span> IntPtr lpNumberOfBytesWritten</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/以现有进程获取句柄</span></span><br><span class="line">    <span class="comment">//[DllImport(&quot;kernel32.dll&quot;)]</span></span><br><span class="line">    <span class="comment">//private static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭句柄</span></span><br><span class="line">    <span class="comment">//[DllImport(&quot;Kernel32.dll&quot;)]</span></span><br><span class="line">    <span class="comment">//private static extern void CloseHandle(IntPtr hObject);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓冲区大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">byte</span>[] _bufferLittle = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Process _currentProcess;</span><br><span class="line">    <span class="keyword">public</span> Process CurrentProcess &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _currentProcess; &#125; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BindProcess</span>(<span class="params"><span class="built_in">string</span> pName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _currentProcess = GetProcess(pName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 得到模块基址</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;DllName&quot;&gt;</span>动态链接库名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IntPtr <span class="title">GetModuleHandle</span>(<span class="params"><span class="built_in">string</span> DllName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; CurrentProcess.Modules.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (CurrentProcess.Modules[i].ModuleName == DllName)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> CurrentProcess.Modules[i].BaseAddress;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (IntPtr)<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以进程名得到进程ID</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Process <span class="title">GetProcess</span>(<span class="params"><span class="built_in">string</span> PName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> process = Process.GetProcessesByName(PName);</span><br><span class="line">            <span class="keyword">return</span> process[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        catch</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 得到实际操作地址</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;moduleName&quot;&gt;</span>模块名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;BaseADDR&quot;&gt;</span>基址<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;Deviations&quot;&gt;</span>指针偏移<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IntPtr <span class="title">Get_RealityADDR</span>(<span class="params"><span class="built_in">string</span> moduleName, <span class="built_in">string</span> BaseADDR, <span class="built_in">string</span>[] Deviations</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Get_RealityADDR(AddAddress(GetModuleHandle(moduleName), BaseADDR), Deviations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 得到实际操作地址</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;BaseADDR&quot;&gt;</span>基址<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;Deviations&quot;&gt;</span>指针偏移<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IntPtr <span class="title">Get_RealityADDR</span>(<span class="params"><span class="built_in">string</span> BaseADDR, <span class="built_in">string</span>[] Deviations</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> RealityADDR = Read_MemoryInt(BaseADDR);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Deviations.Length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RealityADDR = Read_MemoryInt(AddAddress(RealityADDR, Deviations[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (IntPtr)CalcAddressFromString(AddAddress(RealityADDR, Deviations.Last()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 16进制字符串转long</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;addr&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Int64 <span class="title">CalcAddressFromString</span>(<span class="params"><span class="built_in">string</span> addr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Convert.ToInt64(addr, <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 16进制字符串转int</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;addr&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">CalcAddressOffset</span>(<span class="params"><span class="built_in">string</span> addr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Convert.ToInt32(addr, <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">AddAddress</span>(<span class="params"><span class="built_in">string</span> baseAddr, <span class="built_in">string</span> offset</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (CalcAddressFromString(baseAddr) + CalcAddressOffset(offset)).ToString(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">AddAddress</span>(<span class="params">IntPtr baseAddr, <span class="built_in">string</span> offset</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (baseAddr + CalcAddressOffset(offset)).ToString(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">AddAddress</span>(<span class="params">Int64 baseAddr, <span class="built_in">string</span> offset</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (baseAddr + CalcAddressOffset(offset)).ToString(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">region</span> Read</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 读取内存内容（以Int类型）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;BaseADDR&quot;&gt;</span>内存地址<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Read_MemoryInt</span>(<span class="params"><span class="built_in">string</span> ADDR</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Read_MemoryInt((IntPtr)CalcAddressFromString(ADDR));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 读取内存内容（以Int类型）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;BaseADDR&quot;&gt;</span>内存地址<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Read_MemoryInt</span>(<span class="params">IntPtr ADDR</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BitConverter.ToInt32(Read_MemoryValue(ADDR), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 读取内存内容（以long类型）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;BaseADDR&quot;&gt;</span>内存地址<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Int64 <span class="title">Read_MemoryLong</span>(<span class="params"><span class="built_in">string</span> ADDR</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Read_MemoryLong((IntPtr)CalcAddressFromString(ADDR));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 读取内存内容（以long类型）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;BaseADDR&quot;&gt;</span>内存地址<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Int64 <span class="title">Read_MemoryLong</span>(<span class="params">IntPtr ADDR</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BitConverter.ToInt64(Read_MemoryValue(ADDR), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 读取内存内容（以Float类型）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">Read_MemoryFloat</span>(<span class="params"><span class="built_in">string</span> ADDR</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Read_MemoryFloat((IntPtr)CalcAddressFromString(ADDR));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 读取内存内容（以Float类型）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">Read_MemoryFloat</span>(<span class="params">IntPtr ADDR</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BitConverter.ToSingle(Read_MemoryValue(ADDR), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 读取内存内容，需求其值为8位或以下</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;BaseADDR&quot;&gt;</span>内存地址<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">byte</span>[] <span class="title">Read_MemoryValue</span>(<span class="params">IntPtr ADDR</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Read_MemoryValue(ADDR, <span class="keyword">ref</span> _bufferLittle))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _bufferLittle;</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Print(<span class="built_in">string</span>.Format(<span class="string">&quot;读取地址 &#123;0&#125; 数据失败！&quot;</span>, ADDR));</span><br><span class="line">        Array.Clear(_bufferLittle, <span class="number">0</span>, _bufferLittle.Length);</span><br><span class="line">        <span class="keyword">return</span> _bufferLittle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 读取内存内容</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;ADDR&quot;&gt;</span>地址<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;buff&quot;&gt;</span>缓冲数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>是否读取成功<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Read_MemoryValue</span>(<span class="params">IntPtr ADDR, <span class="keyword">ref</span> <span class="built_in">byte</span>[] buff</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IntPtr length;</span><br><span class="line">        <span class="keyword">var</span> Rs = ReadProcessMemory(CurrentProcess.Handle, ADDR, buff, buff.Length, <span class="keyword">out</span> length);</span><br><span class="line">        <span class="keyword">return</span> Rs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">region</span> Write</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">region</span> 写入 int 数据</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 将数值写入内存地址</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;ADDR&quot;&gt;</span>内存地址<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;Value&quot;&gt;</span>待写入数值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Write_MemoryValue</span>(<span class="params"><span class="built_in">string</span> ADDR, <span class="built_in">int</span> Value</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Write_MemoryValue((IntPtr)CalcAddressFromString(ADDR), Value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Write_MemoryValue</span>(<span class="params">Int64 ADDR, <span class="built_in">int</span> Value</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Write_MemoryValue((IntPtr)ADDR, Value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Write_MemoryValue</span>(<span class="params">IntPtr ADDR, <span class="built_in">int</span> Value</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Write_MemoryValue(ADDR, BitConverter.GetBytes(Value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">region</span> 写入 float 数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Write_MemoryValue</span>(<span class="params">Int64 ADDR, <span class="built_in">float</span> Value</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Write_MemoryValue((IntPtr)ADDR, Value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Write_MemoryValue</span>(<span class="params">IntPtr ADDR, <span class="built_in">float</span> Value</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Write_MemoryValue(ADDR, BitConverter.GetBytes(Value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 最终写入方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;ADDR&quot;&gt;</span>地址<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;bytes&quot;&gt;</span>字节数据<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Write_MemoryValue</span>(<span class="params">IntPtr ADDR, <span class="built_in">byte</span>[] bytes</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        IntPtr wLength;</span><br><span class="line">        <span class="keyword">var</span> Rs = WriteProcessMemory(CurrentProcess.Handle, ADDR, bytes, bytes.Length, <span class="keyword">out</span> wLength);</span><br><span class="line">        <span class="keyword">return</span> Rs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>一通研究和实际操作下来，明白的东西还是不少，因此决定记录一下。</p><p>在上述操作中， 64位进程的起始地址，可能是超出32位int上限的，一开始我使用int作为指针地址，然后在测试读写 CE 64 这个示例就出现了问题，修修改改，将其统一为了64位Int。</p><p>修改为 64位 是因为猜测(并在控制台进行了简单测试) 64位 读写方式其实也支持32位进程的，并在后续实际测试了 CE 32位 示例，确认了该猜测。</p><p>下一步，就是应用在游戏中实际体验下了。</p><p>参考文章：</p><blockquote><p><a href="https://www.pinvoke.net/default.aspx/user32/ReadProcessMemory.html">pinvoke.net</a><br><a href="https://www.seeull.com/archives/80.html">C#跨进程内存读写(PVZ修改器简单实例)</a><br><a href="https://zhuanlan.zhihu.com/p/35005383">用C#制作游戏修改器的最佳做法</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前不是提到最近在玩一个游戏《无限世界》——其实是十几年前的游戏了。&lt;br&gt;然后里面有个副本有比较好的奖励，然后需要花费大量时间去进行操作、</summary>
      
    
    
    
    <category term="HackerSkills" scheme="https://cwhisme.github.io/categories/HackerSkills/"/>
    
    
  </entry>
  
  <entry>
    <title>AHK屏幕颜色采样在不同分辨率显示器下的处理</title>
    <link href="https://cwhisme.github.io/2021/11/23/AHK%E5%B1%8F%E5%B9%95%E9%A2%9C%E8%89%B2%E9%87%87%E6%A0%B7%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%88%86%E8%BE%A8%E7%8E%87%E6%98%BE%E7%A4%BA%E5%99%A8%E4%B8%8B%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>https://cwhisme.github.io/2021/11/23/AHK%E5%B1%8F%E5%B9%95%E9%A2%9C%E8%89%B2%E9%87%87%E6%A0%B7%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%88%86%E8%BE%A8%E7%8E%87%E6%98%BE%E7%A4%BA%E5%99%A8%E4%B8%8B%E7%9A%84%E5%A4%84%E7%90%86/</id>
    <published>2021-11-23T04:13:05.000Z</published>
    <updated>2022-12-11T02:01:22.613Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>似乎好久没写东西了，之前一是在公司忙起来了，还有就是感觉 Github 国内变得越来越难用，经常网都连不上的，作为托管 Git 的博客，点个提交十几次都不一定能成功，修改起来也变得实在麻烦。</p></blockquote><p>最近在玩一个游戏，玩起来非常『费手』，于是后面就在找有没有减轻操作的方法，查到了 AHK，然后自己鼓捣起来了。</p><p>开始是简单地不断让它自动按键，后面看文档看到 PixelGetColor ，查了用法之后，就加上了更复杂的操作逻辑。</p><p>而在这之间，家里的显示器的杂牌2K，公司电脑显示器是 1080P，取色函数取值出现了差异，一边能够工作一边不行。</p><p>于是找寻解决方式。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>首先，感觉 AHK 的限制其实不少，特别是针对游戏，至少在我玩的这个游戏中，问题还是一堆，例如：</p><ul><li>无法后台操作，查到的 ControlSend、ControlClick 毫无作用</li><li>直接 Send 按键在公司电脑有效，自己家里的笔记本无效，得用 <figure class="highlight ahk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Send,</span> &#123;<span class="variable">%key%</span> down&#125;</span><br><span class="line">Sleep KeyDownTime</span><br><span class="line"><span class="built_in">Send,</span> &#123;<span class="variable">%key%</span> Up&#125;</span><br><span class="line">Sleep KeyUpTime</span><br></pre></td></tr></table></figure>这种代码才行</li><li>MouseGetPos、PixelGetColor 等坐标采样函数跟屏幕的物理分辨率有关，跟界面设置的分辨率无关。<br>例如，一个2K的显示器和一个1080P的显示器，开启同一个游戏，游戏分辨率同样设置为1080P，实际采样的同一个点，其坐标都不一样。</li><li>ImageSearch 确实有用，但是只针对2D情况，且2D界面不能透明，稍微有点差异就不行了。</li></ul><h3 id="解决-PixelGetColor-对比颜色值屏幕差异问题"><a href="#解决-PixelGetColor-对比颜色值屏幕差异问题" class="headerlink" title="解决 PixelGetColor 对比颜色值屏幕差异问题"></a>解决 PixelGetColor 对比颜色值屏幕差异问题</h3><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>这里其它问题先不论，先说说第三个问题的个人解决方式。</p><p>由于自己目前了解 AHK ，纯靠官方文档和 Bing，因此或许解决方式并非最优，不过那就待以后再说了。</p><p>首先，为何需要用到 PixelGetColor 呢？</p><p>大家都知道，游戏技能都是有CD(冷却时间)的，一般情况下，一个技能处『冷却中』以及『可释放』状态时，都会有不同的表现。</p><p>如此，就可以考虑采样一个正常的颜色值进行比较，如当前颜色值与正常颜色值相等，那么说明该技能已经冷却完成，可以释放了。</p><p>这种比较方式不仅用于技能，还可以用来判断当前血量比例，然后增加对应的逻辑，再考虑释放某些已经可以释放的治疗技能等。</p><p>然后如同上面说的问题一样，同一个位置在不同分辨率屏幕下会是完全不同的两个坐标，或许在1080P屏幕下坐标点是一个技能，但在2K分辨率下实际上什么都没有。</p><p>于是根据表现，猜测 MouseGetPos、PixelGetColor 与显示器的物理像素点相关，跟系统或功能逻辑上设置的分辨率并不一致。</p><p>如图所示：</p><p><img src="/blogimages/2021/2021-11-23/diff.png" alt="图片"></p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>刚开始我还试图各采样一套坐标点，但是由于那会也没写工具，全靠手动对比较：具体就是打开 WindowSpy ，查看坐标，然后运行代码采样正常坐标颜色，然后再复制出来。</p><p>总之事情非常麻烦，采样一套就够呛了，于是就查不同分辨率下坐标颜色采样问题。</p><p>然而网上并没有找到什么好方法，基本上是搜索不到相关信息，看别人用于游戏的代码，都没做什么坐标处理的。</p><p>后来，偶然查到 AHK 内置提供的一个变量 A_ScreenDPI ，打印出来显示，公司的屏幕该值为 96，自己的笔记本外接显示器为 120。</p><p>于是就想到，可不可以按照一个比例将其转换一下，然后在同一的转换坐标下采样？</p><p>采样代码：</p><figure class="highlight ahk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MouseGetPos,</span> MouseRawX, MouseRawY</span><br><span class="line"><span class="built_in">PixelGetColor,</span> LastValueColor, MouseX/<span class="number">96</span>*<span class="built_in">A_ScreenDPI</span>, MouseY/<span class="number">96</span>*<span class="built_in">A_ScreenDPI</span>,</span><br></pre></td></tr></table></figure><p>后续搜索代码：</p><figure class="highlight ahk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X1:=x/<span class="number">96</span>*<span class="built_in">A_ScreenDPI</span></span><br><span class="line">Y1:=y/<span class="number">96</span>*<span class="built_in">A_ScreenDPI</span></span><br><span class="line"><span class="built_in">PixelSearch,</span> OutputVarX, OutputVarY,X1-<span class="number">5</span>,Y1-<span class="number">5</span>,X1+<span class="number">5</span>,Y1+<span class="number">5</span>,colorValue,<span class="number">10</span>,Fast</span><br></pre></td></tr></table></figure><p>采样代码将鼠标位置转换为以 96DPI 为准的坐标进行采样，搜索代码则将以 96DPI 为准的坐标转化为当前 DPI 分辨率下的坐标点进行搜索。</p><p>由于这种转化必然存在小的误差，因此允许正负5个像素区域的差异，同时允许10个像素值的渐变。</p><p>经测试后，自己的和在公司的时候逻辑都运行良好。</p><p>(注：以上所述均为 Client 坐标系坐标)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="取色代码"><a href="#取色代码" class="headerlink" title="取色代码"></a>取色代码</h4><figure class="highlight ahk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CoordMode,</span> Pixel|Mouse,Client</span><br><span class="line"></span><br><span class="line"><span class="comment">; =======用于在Clentm模式下的坐标及颜色快捷获取===============</span></span><br><span class="line"><span class="comment">; Control+Alt+Z 热键 开启 p键固定坐标，按下c键复制，Esc退出</span></span><br><span class="line"><span class="comment">; Author:cwhisme</span></span><br><span class="line"><span class="comment">; qq:785300468</span></span><br><span class="line"><span class="comment">;==========================================================</span></span><br><span class="line"></span><br><span class="line">IsRun:=<span class="literal">false</span></span><br><span class="line"><span class="title">^!z::</span> <span class="comment">; Control+Alt+Z 热键.</span></span><br><span class="line">    FixedPos:=<span class="literal">False</span></span><br><span class="line">    IsRun:=<span class="literal">True</span></span><br><span class="line">    Loop&#123;</span><br><span class="line">        if(!IsRun) </span><br><span class="line">            <span class="keyword">Break</span></span><br><span class="line">        <span class="comment">; ControlSend, ,1,ahk_class iworld</span></span><br><span class="line">        if(!FixedPos)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">            MouseGetPos,</span> MouseRawX, MouseRawY</span><br><span class="line">            MouseRawX:=MouseRawX+<span class="number">1</span></span><br><span class="line">            MouseRawY:=MouseRawY+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">        PixelGetColor,</span> RawValueColor, MouseRawX, MouseRawY,</span><br><span class="line">        MouseX:=MouseRawX/<span class="built_in">A_ScreenDPI</span>*<span class="number">96</span></span><br><span class="line">        MouseY:=MouseRawY/<span class="built_in">A_ScreenDPI</span>*<span class="number">96</span></span><br><span class="line"><span class="built_in">        PixelGetColor,</span> LastValueColor, MouseX/<span class="number">96</span>*<span class="built_in">A_ScreenDPI</span>, MouseY/<span class="number">96</span>*<span class="built_in">A_ScreenDPI</span>,</span><br><span class="line"><span class="built_in">        ToolTip,</span> <span class="variable">%MouseX%</span> <span class="variable">%MouseY%</span>(<span class="variable">%MouseRawX%</span> <span class="variable">%MouseRawY%</span>) <span class="variable">%A_ScreenDPI%</span> <span class="variable">%A_ScreenWidth%</span> <span class="variable">%A_ScreenHeight%</span> RawValueColor:<span class="variable">%RawValueColor%</span> LastValueColor:<span class="variable">%LastValueColor%</span> (p键固定坐标，按下c键复制，Esc退出[固定：<span class="variable">%FixedPos%</span>]),MouseX+<span class="number">30</span>, MouseY-<span class="number">30</span> </span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">    ToolTip,</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="title">p::</span></span><br><span class="line">    FixedPos:=!FixedPos</span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="title">c::</span></span><br><span class="line">    <span class="built_in">Clipboard</span>=<span class="variable">%MouseX%</span>,<span class="variable">%MouseY%</span>,<span class="variable">%LastValueColor%</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="title">Stop:</span></span><br><span class="line">    IsRun:=<span class="literal">False</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 停止执行</span></span><br><span class="line"><span class="title">esc::</span>IsRun:=<span class="literal">False</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="搜索代码"><a href="#搜索代码" class="headerlink" title="搜索代码"></a>搜索代码</h4><figure class="highlight ahk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CheckClick(x,y,colorValue,key)</span><br><span class="line">&#123;</span><br><span class="line">    X1:=x/<span class="number">96</span>*<span class="built_in">A_ScreenDPI</span></span><br><span class="line">    Y1:=y/<span class="number">96</span>*<span class="built_in">A_ScreenDPI</span></span><br><span class="line"><span class="built_in">    PixelSearch,</span> OutputVarX, OutputVarY,X1-<span class="number">5</span>,Y1-<span class="number">5</span>,X1+<span class="number">5</span>,Y1+<span class="number">5</span>,colorValue,<span class="number">10</span>,Fast</span><br><span class="line">    if(!<span class="built_in">ErrorLevel</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        if(key)</span><br><span class="line">        &#123;</span><br><span class="line">            SendKey(key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Return</span> <span class="literal">True</span></span><br><span class="line">    &#125; else <span class="keyword">Return</span> <span class="literal">False</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>如此记录一下，以后或许也有用到的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;似乎好久没写东西了，之前一是在公司忙起来了，还有就是感觉 Github 国内变得越来越难用，经常网都连不上的，作为</summary>
      
    
    
    
    <category term="HackerSkills" scheme="https://cwhisme.github.io/categories/HackerSkills/"/>
    
    
  </entry>
  
  <entry>
    <title>上架检测提示有Unity广告服务</title>
    <link href="https://cwhisme.github.io/2021/10/25/%E4%B8%8A%E6%9E%B6%E6%A3%80%E6%B5%8B%E6%8F%90%E7%A4%BA%E6%9C%89Unity%E5%B9%BF%E5%91%8A%E6%9C%8D%E5%8A%A1/"/>
    <id>https://cwhisme.github.io/2021/10/25/%E4%B8%8A%E6%9E%B6%E6%A3%80%E6%B5%8B%E6%8F%90%E7%A4%BA%E6%9C%89Unity%E5%B9%BF%E5%91%8A%E6%9C%8D%E5%8A%A1/</id>
    <published>2021-10-24T16:00:00.000Z</published>
    <updated>2022-12-11T02:01:22.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如图所示，运营那边拿了母包进行合规检测，，检测出说有使用Unity广告服务。</p><p><img src="/blogimages/2021/2021-10-25/m_4a1b4b6609f8a47424e8ab16eb2a2a1a_r.png"></p><p><img src="/blogimages/2021/2021-10-25/m_86908f87e5ea972ebc8497d1fb31e067_r.png"></p><p>主要是说存在隐私合规问题：由于在用户同意隐私协议之前，获取了 androidid 以及调用了 com.unity3d.player.UnityPlayer.addPhoneCallListener(监听呼入电话) 操作。</p><p>然后被识别为了 『Unity广告服务』，然后我们项目并没有任何地方需要使用到相关功能。且也没有进行过相关操作。</p><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p><img src="/blogimages/2021/2021-10-25/m_0624b8d1668c469a3f26d28294811954_r.png"></p><p>根据堆栈调用信息查询，发现 addPhoneCallListener 属于 Unity 底层库的方法，开始怀疑这个有没有可能是unity注册事件用来处理电话呼入游戏暂停之类的？然后被识别成了广告。</p><p><img src="/blogimages/2021/2021-10-25/m_14c9e56a59304b2b41e2324f5b3d6008_r.png"></p><p>因为反编译相关库，发现 『unity-classes.jar』 与Unity安装目录下 classes.jar 文件一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unity2017_4.28F1\Editor\Data\PlaybackEngines\AndroidPlayer\Variations\mono\Release\Classes\classes.jar</span><br></pre></td></tr></table></figure><p>作为底层库，要么在上层有某种设置，要么一定会调用，在经过一些网上一些查询和讨论之后，大概有两个怀疑点：</p><ul><li><p>怀疑是否是 Unity 内置广告组件开关引起。<br>如图所示：<br><img src="/blogimages/2021/2021-10-25/m_27a5409951c5b79ede572eed12b44cb5_r.png"><br>不过，由于我们项目国服打包机并未登录，因此尝试修改项目根目录下 ProjectSettings/UnityConnectSettings.asset 文件，将如下字段值都改为0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m_Enabled: 0</span><br><span class="line">m_InitializeOnStartup: 0</span><br></pre></td></tr></table></figure></li><li><p>Disable HW Statistics 设置<br><img src="/blogimages/2021/2021-10-25/m_f57d7b920b40a2607ee19a11dee5a9c4_r.png"><br>根据官方说明，该选项如果不勾的话，会向Unity发送匿名硬件统计信息，因此也可以算一点。</p></li></ul><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>等待反馈</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;如图所示，运营那边拿了母包进行合规检测，，检测出说有使用Unity广告服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blogimages/20</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://cwhisme.github.io/categories/Unity3D/"/>
    
    
  </entry>
  
</feed>
