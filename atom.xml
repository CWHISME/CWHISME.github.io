<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CWHISME</title>
  
  <subtitle>人不能没有梦想，也要有足够的敬畏</subtitle>
  <link href="https://wangjiaying.top/atom.xml" rel="self"/>
  
  <link href="https://wangjiaying.top/"/>
  <updated>2025-09-07T05:36:03.278Z</updated>
  <id>https://wangjiaying.top/</id>
  
  <author>
    <name>WangJiaYing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UE5编辑器开发-资源创建菜单</title>
    <link href="https://wangjiaying.top/2025/09/07/UE5%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91-%E8%B5%84%E6%BA%90%E5%88%9B%E5%BB%BA%E8%8F%9C%E5%8D%95/"/>
    <id>https://wangjiaying.top/2025/09/07/UE5%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91-%E8%B5%84%E6%BA%90%E5%88%9B%E5%BB%BA%E8%8F%9C%E5%8D%95/</id>
    <published>2025-09-07T02:02:14.000Z</published>
    <updated>2025-09-07T05:36:03.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>最近研究了下虚幻的编辑器扩展，记录一下一个需求：我有一个 UUserWidget 子类，后续想要所有可以直接打开的界面，都基于该类创建蓝图。</p><p>然后就想将其放在内容浏览器的右键空白区域的资源创建菜单上，以便快速创建该类的蓝图。</p><h1 id="方法"><a class="anchor" href="#方法">#</a> 方法</h1><p>虚幻的编辑器也就最近开始研究了下，不大熟悉，折腾了半天，结果发现不下于三种添加资源创建菜单的方法：</p><ol><li>通过 AssetTypeActions 配合自定义 Factory</li><li>通过 UAssetDefinitionDefault 配合自定义 Factory</li><li>自定义添加编辑器菜单</li><li>直接将类型添加到 UUMGEditorProjectSettings-&gt;FavoriteWidgetParentClasses (这种方式会出现在创建用户控件蓝图的界面中)</li></ol><p>其中第四种方法是最简单的方法，只需要将 UUserWidget 子类添加到 FavoriteWidgetParentClasses<br /> 列表中即可。当然其表现与其它方式会有所不同，但是也大差不大。下面一一介绍。</p><h1 id="自定义添加编辑器菜单"><a class="anchor" href="#自定义添加编辑器菜单">#</a> 自定义添加编辑器菜单</h1><p>这种方式是最开始想到的方式，因为从概念上讲，也是最容易想到的：直接手动扩展编辑器，添加一个菜单项：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">FContentBrowserExtensionBase</span><span class="token double-colon punctuation">::</span><span class="token function">OnInitialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>FContentBrowserModule<span class="token operator">&amp;</span> ContentBrowserModule <span class="token operator">=</span> FModuleManager<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">LoadModuleChecked</span><span class="token generic class-name"><span class="token operator">&lt;</span>FContentBrowserModule<span class="token operator">></span></span></span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token string">"ContentBrowser"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">auto</span><span class="token operator">&amp;</span> MenuExtenders <span class="token operator">=</span> ContentBrowserModule<span class="token punctuation">.</span><span class="token function">GetAllAssetContextMenuExtenders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 创建扩展委托</span></pre></td></tr><tr><td data-num="8"></td><td><pre>FContentBrowserMenuExtender_SelectedPaths MenuExtenderDelegate <span class="token operator">=</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token class-name">FContentBrowserMenuExtender_SelectedPaths</span><span class="token double-colon punctuation">::</span><span class="token function">CreateLambda</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> TArray<span class="token operator">&lt;</span>FString<span class="token operator">></span><span class="token operator">&amp;</span> SelectedPaths<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>TSharedRef<span class="token operator">&lt;</span>FExtender<span class="token operator">></span> MenuExtender <span class="token operator">=</span> <span class="token generic-function"><span class="token function">MakeShared</span><span class="token generic class-name"><span class="token operator">&lt;</span>FExtender<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>MenuExtender<span class="token operator">-></span><span class="token function">AddMenuExtension</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token string">"ContentBrowserNewAdvancedAsset"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="14"></td><td><pre>EExtensionHook<span class="token double-colon punctuation">::</span>After<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">nullptr</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token class-name">FMenuExtensionDelegate</span><span class="token double-colon punctuation">::</span><span class="token function">CreateRaw</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>FContentBrowserExtensionBase<span class="token double-colon punctuation">::</span>AddMenuExtensions<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">return</span> MenuExtender<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>ExtensionHandle <span class="token operator">=</span> MenuExtenderDelegate<span class="token punctuation">.</span><span class="token function">GetHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>MenuExtenders<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>MenuExtenderDelegate<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">FContentBrowserExtensionBase</span><span class="token double-colon punctuation">::</span><span class="token function">AddMenuExtensions</span><span class="token punctuation">(</span>FMenuBuilder<span class="token operator">&amp;</span> MenuBuilder<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>MenuBuilder<span class="token punctuation">.</span><span class="token function">AddMenuEntry</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token class-name">FText</span><span class="token double-colon punctuation">::</span><span class="token function">FromString</span><span class="token punctuation">(</span><span class="token string">"My Custom Widget"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token class-name">FText</span><span class="token double-colon punctuation">::</span><span class="token function">FromString</span><span class="token punctuation">(</span><span class="token string">"Create Widget based on MyBaseUserWidget"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token function">FSlateIcon</span><span class="token punctuation">(</span><span class="token class-name">FAppStyle</span><span class="token double-colon punctuation">::</span><span class="token function">GetAppStyleSetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Icons.Plus"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token function">FUIAction</span><span class="token punctuation">(</span><span class="token class-name">FExecuteAction</span><span class="token double-colon punctuation">::</span><span class="token function">CreateLambda</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>UWidgetBlueprintFactory<span class="token operator">*</span> Factory <span class="token operator">=</span> <span class="token generic-function"><span class="token function">NewObject</span><span class="token generic class-name"><span class="token operator">&lt;</span>UWidgetBlueprintFactory<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>Factory<span class="token operator">-></span>ParentClass <span class="token operator">=</span> <span class="token class-name">UCryPageBase</span><span class="token double-colon punctuation">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token class-name">FAssetToolsModule</span><span class="token double-colon punctuation">::</span><span class="token function">GetModule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">CreateAssetWithDialog</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token class-name">UWidgetBlueprint</span><span class="token double-colon punctuation">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="36"></td><td><pre>Factory</pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>常规通过扩展挂点的形式挂到创建菜单中，不过没找到怎么挂到专门的创建用户界面的子菜单中... 所以只是简单实现了一下。</p><p>效果如下：</p><p><img data-src="/blogimages/2025/2025-09-07/Uiharu_2025-09-07_12-08-45.webp" alt="" /></p><blockquote><p>注：SelectedPaths 可以获取路径的，这个实现会有个保存资源弹窗，如果有路径的话，也可以直接创建资源。</p></blockquote><h1 id="assettypeactions-扩展资源创建菜单"><a class="anchor" href="#assettypeactions-扩展资源创建菜单">#</a> AssetTypeActions 扩展资源创建菜单</h1><p>也就是直接继承 FAssetTypeActions_Base，然后填充参数。</p><blockquote><p>注意：该方法需要手动在模块的 StartupModule 中注册，否则不会生效。</p></blockquote><p>官方 Lyra 示例就是采用的这种方法，具体可以参考 Lyra 的 FAssetTypeActions_LyraContextEffectsLibrary 及<br /> ULyraContextEffectsLibraryFactory 类：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">FAssetTypeActions_LyraContextEffectsLibrary</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">FAssetTypeActions_Base</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// IAssetTypeActions Implementation</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">virtual</span> FText <span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">NSLOCTEXT</span><span class="token punctuation">(</span><span class="token string">"AssetTypeActions"</span><span class="token punctuation">,</span> <span class="token string">"AssetTypeActions_LyraContextEffectsLibrary"</span><span class="token punctuation">,</span> <span class="token string">"LyraContextEffectsLibrary"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">virtual</span> FColor <span class="token function">GetTypeColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">FColor</span><span class="token punctuation">(</span><span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">virtual</span> UClass<span class="token operator">*</span> <span class="token function">GetSupportedClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">virtual</span> uint32 <span class="token function">GetCategories</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> EAssetTypeCategories<span class="token double-colon punctuation">::</span>Gameplay<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>ULyraContextEffectsLibraryFactory 类是用来创建蓝图的工厂类，源码就不单独贴了，有兴趣查一下应该很多信息。</p><p>我最开始也是按照这个方法来做的，结果不小心了翻到了下引擎中其它使用 FAssetTypeActions_Base 的地方的源码，例如：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// UE_DEPRECATED(5.2, "The AssetDefinition system is replacing AssetTypeActions and this was replaced by AssetDefinition_ClassTypeBase.  Please see the Conversion Guide in AssetDefinition.h")</span></pre></td></tr><tr><td data-num="3"></td><td><pre>ASSETTOOLS_API FAssetTypeActions_ClassTypeBase <span class="token operator">:</span> <span class="token keyword">public</span> FAssetTypeActions_Base</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>目前已经过时，摆明了就是不推荐使用了。</p><p>于是根据注释所说，查了下 AssetDefinition。</p><h1 id="assetdefinition-扩展资源创建菜单"><a class="anchor" href="#assetdefinition-扩展资源创建菜单">#</a> AssetDefinition 扩展资源创建菜单</h1><p>就如同前面所说，因为不小心发现 AssetTypeActions 已经过时，所以就开始研究 AssetDefinition。</p><p>不像 AssetTypeActions 的方式，AssetDefinition 会自动扫描并注册，所以不用手动注册，确实省心不少，加之 Factory 也是自动扫描，那就更方便了。</p><p>另外查看 UFactory 源码可以发现：像 GetDisplayName ()、GetMenuCategories () 等方法，依然还是在依赖 AssetTypeActions，所以目前如果是通过<br /> AssetDefinition 配合 Factory 来扩展资源创建菜单，必须重写 UFactory::GetMenuCategories () 等依赖 AssetTypeActions 的方法。</p><p>不然引擎去找这个资源对应的 AssetTypeActions 就会找不到，导致无法显示菜单。如下所示：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>uint32 <span class="token class-name">UFactory</span><span class="token double-colon punctuation">::</span><span class="token function">GetMenuCategories</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>FAssetToolsModule<span class="token operator">&amp;</span> AssetToolsModule <span class="token operator">=</span> FModuleManager<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">LoadModuleChecked</span><span class="token generic class-name"><span class="token operator">&lt;</span>FAssetToolsModule<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"AssetTools"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>UClass<span class="token operator">*</span> LocalSupportedClass <span class="token operator">=</span> <span class="token function">GetSupportedClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>LocalSupportedClass<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>TWeakPtr<span class="token operator">&lt;</span>IAssetTypeActions<span class="token operator">></span> AssetTypeActions <span class="token operator">=</span> AssetToolsModule<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetAssetTypeActionsForClass</span><span class="token punctuation">(</span>LocalSupportedClass<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>AssetTypeActions<span class="token punctuation">.</span><span class="token function">IsValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">return</span> AssetTypeActions<span class="token punctuation">.</span><span class="token function">Pin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">GetCategories</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// Factories whose classes do not have asset type actions fall in the misc category</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">return</span> EAssetTypeCategories<span class="token double-colon punctuation">::</span>Misc<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>所以，如果要通过 AssetDefinition 扩展资源创建菜单，必须重写 UFactory::GetMenuCategories () 等方法。</p><p>Factory 整体实现：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">UCLASS</span><span class="token punctuation">(</span>hidecategories <span class="token operator">=</span> Object<span class="token punctuation">,</span> MinimalAPI<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">UPageWidgetFactory</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">UFactory</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">GENERATED_BODY</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">UPageWidgetFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">//~ Begin UFactory Interface</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">virtual</span> <span class="token keyword">bool</span> <span class="token function">ShouldShowInNewMenu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">virtual</span> FText <span class="token function">GetDisplayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">virtual</span> uint32 <span class="token function">GetMenuCategories</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">virtual</span> FText <span class="token function">GetToolTip</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">virtual</span> FString <span class="token function">GetDefaultNewAssetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">virtual</span> UObject<span class="token operator">*</span> <span class="token function">FactoryCreateNew</span><span class="token punctuation">(</span>UClass<span class="token operator">*</span> Class<span class="token punctuation">,</span> UObject<span class="token operator">*</span> InParent<span class="token punctuation">,</span> FName Name<span class="token punctuation">,</span> EObjectFlags Flags<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                                  UObject<span class="token operator">*</span> Context<span class="token punctuation">,</span> FFeedbackContext<span class="token operator">*</span> Warn<span class="token punctuation">,</span> FName CallingContext<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">virtual</span> UObject<span class="token operator">*</span> <span class="token function">FactoryCreateNew</span><span class="token punctuation">(</span>UClass<span class="token operator">*</span> Class<span class="token punctuation">,</span> UObject<span class="token operator">*</span> InParent<span class="token punctuation">,</span> FName Name<span class="token punctuation">,</span> EObjectFlags Flags<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                                  UObject<span class="token operator">*</span> Context<span class="token punctuation">,</span> FFeedbackContext<span class="token operator">*</span> Warn<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment">//~ End UFactory Interface</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">UPageWidgetFactory</span><span class="token double-colon punctuation">::</span><span class="token function">UPageWidgetFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>SupportedClass <span class="token operator">=</span> <span class="token class-name">UWidgetBlueprint</span><span class="token double-colon punctuation">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// ParentClass = UCryPageBase::StaticClass();</span></pre></td></tr><tr><td data-num="6"></td><td><pre>bCreateNew <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>bEditAfterNew <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>FText <span class="token class-name">UPageWidgetFactory</span><span class="token double-colon punctuation">::</span><span class="token function">GetDisplayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">return</span> <span class="token class-name">FText</span><span class="token double-colon punctuation">::</span><span class="token function">FromString</span><span class="token punctuation">(</span><span class="token string">"Create New Page"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>uint32 <span class="token class-name">UPageWidgetFactory</span><span class="token double-colon punctuation">::</span><span class="token function">GetMenuCategories</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">return</span> EAssetTypeCategories<span class="token double-colon punctuation">::</span>UI<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>FText <span class="token class-name">UPageWidgetFactory</span><span class="token double-colon punctuation">::</span><span class="token function">GetToolTip</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token keyword">return</span> <span class="token class-name">FText</span><span class="token double-colon punctuation">::</span><span class="token function">FromString</span><span class="token punctuation">(</span><span class="token string">"Creates a new Page widget blueprint"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>FString <span class="token class-name">UPageWidgetFactory</span><span class="token double-colon punctuation">::</span><span class="token function">GetDefaultNewAssetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">return</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"PageNew"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>UObject<span class="token operator">*</span> <span class="token class-name">UPageWidgetFactory</span><span class="token double-colon punctuation">::</span><span class="token function">FactoryCreateNew</span><span class="token punctuation">(</span>UClass<span class="token operator">*</span> Class<span class="token punctuation">,</span> UObject<span class="token operator">*</span> InParent<span class="token punctuation">,</span> FName Name<span class="token punctuation">,</span> EObjectFlags Flags<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                                              UObject<span class="token operator">*</span> Context<span class="token punctuation">,</span> FFeedbackContext<span class="token operator">*</span> Warn<span class="token punctuation">,</span> FName CallingContext<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>UWidgetBlueprint<span class="token operator">*</span> NewBP <span class="token operator">=</span> <span class="token generic-function"><span class="token function">CastChecked</span><span class="token generic class-name"><span class="token operator">&lt;</span>UWidgetBlueprint<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token class-name">FKismetEditorUtilities</span><span class="token double-colon punctuation">::</span><span class="token function">CreateBlueprint</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token class-name">UCryPageBase</span><span class="token double-colon punctuation">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> InParent<span class="token punctuation">,</span> Name<span class="token punctuation">,</span> EBlueprintType<span class="token double-colon punctuation">::</span>BPTYPE_Normal<span class="token punctuation">,</span> <span class="token class-name">UWidgetBlueprint</span><span class="token double-colon punctuation">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token class-name">UWidgetBlueprintGeneratedClass</span><span class="token double-colon punctuation">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> CallingContext<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token comment">// 编译蓝图（可选）</span></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token comment">// FKismetEditorUtilities::CompileBlueprint(NewBP);</span></pre></td></tr><tr><td data-num="39"></td><td><pre></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>NewBP<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token class-name">FKismetEditorUtilities</span><span class="token double-colon punctuation">::</span><span class="token function">BringKismetToFocusAttentionOnObject</span><span class="token punctuation">(</span>NewBP<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre></pre></td></tr><tr><td data-num="45"></td><td><pre><span class="token keyword">return</span> NewBP<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="47"></td><td><pre></pre></td></tr><tr><td data-num="48"></td><td><pre>UObject<span class="token operator">*</span> <span class="token class-name">UPageWidgetFactory</span><span class="token double-colon punctuation">::</span><span class="token function">FactoryCreateNew</span><span class="token punctuation">(</span>UClass<span class="token operator">*</span> Class<span class="token punctuation">,</span> UObject<span class="token operator">*</span> InParent<span class="token punctuation">,</span> FName Name<span class="token punctuation">,</span> EObjectFlags Flags<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="49"></td><td><pre>                                              UObject<span class="token operator">*</span> Context<span class="token punctuation">,</span> FFeedbackContext<span class="token operator">*</span> Warn<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="50"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="51"></td><td><pre><span class="token keyword">return</span> <span class="token function">FactoryCreateNew</span><span class="token punctuation">(</span>Class<span class="token punctuation">,</span> InParent<span class="token punctuation">,</span> Name<span class="token punctuation">,</span> Flags<span class="token punctuation">,</span> Context<span class="token punctuation">,</span> Warn<span class="token punctuation">,</span> NAME_None<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>AssetDefinition 实现：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">UCLASS</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">UCryPageAssetDefinition</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">UAssetDefinitionDefault</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">GENERATED_BODY</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">//~UAssetDefinition interface</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">virtual</span> TConstArrayView<span class="token operator">&lt;</span>FAssetCategoryPath<span class="token operator">></span> <span class="token function">GetAssetCategories</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">virtual</span> TSoftClassPtr<span class="token operator">&lt;</span>UObject<span class="token operator">></span> <span class="token function">GetAssetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">virtual</span> FText <span class="token function">GetAssetDisplayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">virtual</span> FText <span class="token function">GetAssetDisplayName</span><span class="token punctuation">(</span><span class="token keyword">const</span> FAssetData<span class="token operator">&amp;</span> AssetData<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">virtual</span> FLinearColor <span class="token function">GetAssetColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> FLinearColor<span class="token double-colon punctuation">::</span>Yellow<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">virtual</span> <span class="token keyword">const</span> FSlateBrush<span class="token operator">*</span> <span class="token function">GetIconBrush</span><span class="token punctuation">(</span><span class="token keyword">const</span> FAssetData<span class="token operator">&amp;</span> InAssetData<span class="token punctuation">,</span> <span class="token keyword">const</span> FName InClassName<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">virtual</span> EAssetCommandResult <span class="token function">OpenAssets</span><span class="token punctuation">(</span><span class="token keyword">const</span> FAssetOpenArgs<span class="token operator">&amp;</span> OpenArgs<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">//~End of UAssetDefinition interface</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>TConstArrayView<span class="token operator">&lt;</span>FAssetCategoryPath<span class="token operator">></span> <span class="token class-name">UCryPageAssetDefinition</span><span class="token double-colon punctuation">::</span><span class="token function">GetAssetCategories</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 自定义分类：static const auto Categories = &#123;FAssetCategoryPath (LOCTEXT ("MyCustomAssetsCategoryName", "MyCustom")) &#125;;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">auto</span> Categories <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token function">FAssetCategoryPath</span><span class="token punctuation">(</span>EAssetCategoryPaths<span class="token double-colon punctuation">::</span>UI<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">return</span> Categories<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>TSoftClassPtr<span class="token operator">&lt;</span>UObject<span class="token operator">></span> <span class="token class-name">UCryPageAssetDefinition</span><span class="token double-colon punctuation">::</span><span class="token function">GetAssetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">return</span> <span class="token class-name">UCryPageBase</span><span class="token double-colon punctuation">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>FText <span class="token class-name">UCryPageAssetDefinition</span><span class="token double-colon punctuation">::</span><span class="token function">GetAssetDisplayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">return</span> <span class="token class-name">UCryPageBase</span><span class="token double-colon punctuation">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">GetDisplayNameText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>FText <span class="token class-name">UCryPageAssetDefinition</span><span class="token double-colon punctuation">::</span><span class="token function">GetAssetDisplayName</span><span class="token punctuation">(</span><span class="token keyword">const</span> FAssetData<span class="token operator">&amp;</span> AssetData<span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>AssetData<span class="token punctuation">.</span><span class="token function">IsValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> Class <span class="token operator">=</span> AssetData<span class="token punctuation">.</span><span class="token function">GetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>Class<span class="token operator">-></span><span class="token function">HasMetaData</span><span class="token punctuation">(</span><span class="token string">"DisplayName"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token keyword">return</span> <span class="token class-name">FText</span><span class="token double-colon punctuation">::</span><span class="token function">FromString</span><span class="token punctuation">(</span>Class<span class="token operator">-></span><span class="token function">GetMetaData</span><span class="token punctuation">(</span><span class="token string">"DisplayName"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token keyword">return</span> <span class="token class-name">FText</span><span class="token double-colon punctuation">::</span><span class="token function">FromString</span><span class="token punctuation">(</span><span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"Custom CryPageWidget"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token keyword">const</span> FSlateBrush<span class="token operator">*</span> <span class="token class-name">UCryPageAssetDefinition</span><span class="token double-colon punctuation">::</span><span class="token function">GetIconBrush</span><span class="token punctuation">(</span><span class="token keyword">const</span> FAssetData<span class="token operator">&amp;</span> InAssetData<span class="token punctuation">,</span> <span class="token keyword">const</span> FName InClassName<span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token keyword">return</span> <span class="token class-name">Super</span><span class="token double-colon punctuation">::</span><span class="token function">GetIconBrush</span><span class="token punctuation">(</span>InAssetData<span class="token punctuation">,</span> InClassName<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre></pre></td></tr><tr><td data-num="38"></td><td><pre>EAssetCommandResult <span class="token class-name">UCryPageAssetDefinition</span><span class="token double-colon punctuation">::</span><span class="token function">OpenAssets</span><span class="token punctuation">(</span><span class="token keyword">const</span> FAssetOpenArgs<span class="token operator">&amp;</span> OpenArgs<span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> FAssetData<span class="token operator">&amp;</span> AssetData <span class="token operator">:</span> OpenArgs<span class="token punctuation">.</span>Assets<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>UBlueprint<span class="token operator">*</span> Blueprint <span class="token operator">=</span> <span class="token generic-function"><span class="token function">Cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>UBlueprint<span class="token operator">></span></span></span><span class="token punctuation">(</span>AssetData<span class="token punctuation">.</span><span class="token function">GetAsset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="44"></td><td><pre><span class="token class-name">FKismetEditorUtilities</span><span class="token double-colon punctuation">::</span><span class="token function">BringKismetToFocusAttentionOnObject</span><span class="token punctuation">(</span>Blueprint<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="46"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="47"></td><td><pre><span class="token keyword">return</span> EAssetCommandResult<span class="token double-colon punctuation">::</span>Handled<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>效果如下：</p><p><img data-src="/blogimages/2025/2025-09-07/Uiharu_2025-09-07_12-11-08.webp" alt="" /></p><h1 id="通过-favoritewidgetparentclasses-扩展资源创建菜单"><a class="anchor" href="#通过-favoritewidgetparentclasses-扩展资源创建菜单">#</a> 通过 FavoriteWidgetParentClasses 扩展资源创建菜单</h1><p>这种方式是最简单的方法，只需要将 UUserWidget 子类添加到 FavoriteWidgetParentClasses 即可。</p><p>理论上编辑器中应该有设置方式，就算没有，直接修改 Config 文件也行。</p><p>不过由于我是直接从源码看到的，加上正好在做编辑器扩展，因此就直接通过代码设置了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token class-name">UCryPageCreator</span><span class="token double-colon punctuation">::</span><span class="token function">OnInitialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>TSoftClassPtr<span class="token operator">&lt;</span>UUserWidget<span class="token operator">></span> NewClassRef <span class="token operator">=</span> <span class="token class-name">UCryPageBase</span><span class="token double-colon punctuation">::</span><span class="token function">StaticClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token generic-function"><span class="token function">GetMutableDefault</span><span class="token generic class-name"><span class="token operator">&lt;</span>UUMGEditorProjectSettings<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>FavoriteWidgetParentClasses<span class="token punctuation">.</span><span class="token function">AddUnique</span><span class="token punctuation">(</span>NewClassRef<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>嗯.. 没错，就两行代码 (甚至可以直接一行解决)。</p><p>效果如下：</p><p><img data-src="/blogimages/2025/2025-09-07/Uiharu_2025-09-07_12-16-12.webp" alt="" /></p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><ol><li>自定义添加编辑器菜单：可以用，但是只是用于添加新资源创建就不推荐使用了。</li><li>AssetTypeActions 扩展资源创建菜单：过时，不推荐使用。</li><li>AssetDefinition 扩展资源创建菜单：新版方法，推荐使用。</li><li>通过 FavoriteWidgetParentClasses 扩展资源创建菜单：最简单的方法，可以用。</li></ol><p>以上就是我自己发现的几种扩展编辑器资源创建菜单的方法，虽然第四种仅适用于 UserWidget 蓝图，不过如果其它类型的蓝图系统本身带了类似的创建界面，应该都可以找找有没有差不多的扩展方式 —— 实在不行，貌似貌似还可以直接实现一个这种界面，不过那就走远了。</p><p>另外也许还有其它方式，不过暂时没有深入了解就不清楚了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;最近研究了下虚幻的编辑器扩展，记录一下一个需求：我有一个 UUserWidget 子类，后续想要所有可以直接打开的界面，都基于该类创建蓝图。&lt;/p&gt;
&lt;p&gt;然后就想</summary>
      
    
    
    
    <category term="虚幻引擎" scheme="https://wangjiaying.top/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="虚幻引擎" scheme="https://wangjiaying.top/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>UiharuMind 工具使用指南</title>
    <link href="https://wangjiaying.top/2025/02/16/UiharuMind%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://wangjiaying.top/2025/02/16/UiharuMind%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2025-02-16T03:44:58.000Z</published>
    <updated>2025-03-16T13:57:22.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>这是去年 5 月份左右开始搞的一个 AI 工具应用，支持 Mac、Windows 平台 (但是目前只在自己的电脑测试过)。</p><p>最初是想做一个方便截图使用 (带 OCR) 的软件，不过当时一度沉迷研究 AI，特别是本地化部署的 AI 模型之类的。后边就想着直接做一个适配个人使用的工具，当时也没什么系统级的应用，感觉自己有需要的功能有时间就搞一搞加一下，直到现在，基本功能至少应该都差不多了，所以最近将项目开源了出来。</p><p>就目前来介绍，大概可以这样说：</p><blockquote><p>UiharuMind 是一个开源的 AI 大模型工具，支持在本地部署自己的 AI 模型 (通过 llama.cpp)，并通过 UiharuMind 的界面进行交互，支持角色配置、快捷操作 (截图、翻译)、本地知识库聊天等。同时也可以设置远程模型调用。<br />支持 Mac、Windows 平台。（Linux 应该也行，但是有一些平台化适配需要做，因为用不上就没弄了）。</p></blockquote><h1 id="功能介绍"><a class="anchor" href="#功能介绍">#</a> 功能介绍</h1><p>UiharuMind 目前支持的功能有：</p><ol><li>本地化部署 AI 模型：可以将本地的 AI 模型部署到本地，后端通过调用 llama.cpp 实现本地模型运行：因此支持格式也与其保持一致：GGUF，这些都可以直接在<span class="exturl" data-url="aHR0cHM6Ly9odWdnaW5nZmFjZS5jby9tb2RlbHM/bGlicmFyeT1nZ3VmJmFtcDtzb3J0PXRyZW5kaW5n">抱抱脸</span>下载。</li><li>远程模型调用：也支持远程模型调用，可以通过 UiharuMind 添加对远程 AI 模型的调用。</li><li>常规聊天：支持工具人、角色扮演两种类型的聊天模式，也支持 DeepSeekR1 Thinking 输出。</li><li>快捷功能：通过一些快捷键调出快速操作，例如复制文字、图片后快速操作。</li><li>截图：多模态 AI OCR、截图聊天</li><li>知识库聊天 (支持文件、文本、文件夹、网址)，需要运行本地嵌入模型。</li></ol><blockquote><p>注：<br />因为本地部署的 AI 模型后端是使用 llama-server 开启了一个兼容 OpenAI 格式的本地服务器，因此其实也可以作为其它应用需要的远程 AI 的后端 (本地部署)。<br />默认端口为 1369，连接时直接填入 IP:1369 即可。<br />例如：<span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMToxMzY5">http://127.0.0.1:1369</span></p></blockquote><h2 id="剪切板文字"><a class="anchor" href="#剪切板文字">#</a> 剪切板文字</h2><p>当复制某些文字时，会在鼠标位置处出现一本书的图标，鼠标移动上去会弹出更多可选操作：</p><ul><li>解释：要求 AI 解释复制的文字的意思。</li><li>翻译：将复制的文字翻译为本地语言。</li><li>思考：要求 AI 思考复制的文字的意义。</li><li>询问：针对复制的文字进行额外的输入询问。</li></ul><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_19-40-54.webp" alt="img.webp" /></p><p>回复时会自动打开一个简单的结果窗口：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_19-41-32.webp" alt="img.webp" /></p><p>如果还想针对问题进行进一步的询问，可以点击右下角 “转为临时对话” 按钮：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_19-43-55.webp" alt="img.webp" /></p><p>选择转为临时对话后，继续对话的内容会自动保存到聊天列表中，但是请注意：</p><blockquote><p>临时对话的聊天记录只有最后一个，开启同一个功能的临时对话会覆盖之前的聊天记录。</p></blockquote><h2 id="快捷键"><a class="anchor" href="#快捷键">#</a> 快捷键</h2><ul><li>截图 (Alt+Shift+Z)</li><li>快捷询问 (Alt+Shift+A)</li><li>剪切板历史 (Alt+Shift+S)</li><li>翻译 (Alt+Shift+Q)</li></ul><blockquote><p>注：使用快捷功能时，若当前没有主动加载模型，那么会自动检测合适的远程模型调用。</p></blockquote><p>主要功能可能只有截图和翻译，需要额外说一下：</p><h3 id="翻译功能"><a class="anchor" href="#翻译功能">#</a> 翻译功能</h3><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_19-24-55.webp" alt="img.webp" /></p><p>通过快捷键可以直接打开翻译界面。</p><h3 id="截图功能"><a class="anchor" href="#截图功能">#</a> 截图功能</h3><p>当截图成功后，会自动固定在显示器上：</p><blockquote><p>目前的操作逻辑为：双击关闭。</p></blockquote><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_19-20-46.webp" alt="img.webp" /></p><p>上述截图中，红框中的为 OCR 功能，可以将图片中的文字识别出来，以它为中心的按钮功能分别是：</p><ul><li>左侧按钮分别为：图片编辑、图片编辑后会出现的切换回原始图片的按钮。</li><li>带图片对话 (可以针对图片询问问题)、复制截图到剪切板、保存截图</li></ul><p>图片对话：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_19-51-41.webp" alt="img.webp" /></p><p>继续追问：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_19-53-57.webp" alt="img.webp" /></p><blockquote><p>当模型支持多模态时，对话输入框顶部会额外显示 “上传图片” 按钮，可以直接上传图片进行对话。</p></blockquote><h1 id="本地模型部署"><a class="anchor" href="#本地模型部署">#</a> 本地模型部署</h1><h2 id="准备工作"><a class="anchor" href="#准备工作">#</a> 准备工作</h2><h3 id="1-首先需要准备好你的-ai-模型并将其转换为-gguf-格式太麻烦一般人应该都不会搞-或直接下载已转换好的模型如抱抱脸"><a class="anchor" href="#1-首先需要准备好你的-ai-模型并将其转换为-gguf-格式太麻烦一般人应该都不会搞-或直接下载已转换好的模型如抱抱脸">#</a> 1. <s>首先需要准备好你的 AI 模型，并将其转换为 GGUF 格式 (太麻烦一般人应该都不会搞)。</s>，或直接下载已转换好的模型，如：<span class="exturl" data-url="aHR0cHM6Ly9odWdnaW5nZmFjZS5jby9tb2RlbHM/bGlicmFyeT1nZ3VmJmFtcDtzb3J0PXRyZW5kaW5n">抱抱脸</span>。</h3><h3 id="2-确认本地执行后端"><a class="anchor" href="#2-确认本地执行后端">#</a> 2. 确认本地执行后端</h3><p>在设置界面 -&gt; 后端 -&gt; 选择本地后端，并确认路径正确。</p><p><img data-src="/blogimages/2025/2025-02-16/Setting.webp" alt="img.webp" /></p><p>如果不存在，可以选择点击更新，会检测目前最新的运行后端：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_12-36-10.webp" alt="img.webp" /></p><p>之后选择合适的后端版本，并点击下载即可。程序会自动下载并解压到指定目录：</p><blockquote><p>注意：AMD 显卡专用的 ROCM 版本是带 hip 的，具体需要更具自己 GPU 型号下载，或者直接下载 Vulkan 或 OpenCL 版本。</p></blockquote><ul><li>gfx1030(RX6800-RX6950XT)</li><li>gfx1100（RX7900XTX 和 RX7900XT）</li><li>gfx1101（RX7700XT 和 RX7800XT）</li></ul><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_15-16-01.webp" alt="img.webp" /></p><p>这里简单以 Vulkan 版本为例：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_15-18-39.webp" alt="img.webp" /></p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_15-19-31.webp" alt="img.webp" /></p><p>之后，进入模型界面，在模型界面左上角有本地模型目录设置，以及快捷打开模型目录的按钮：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_15-22-06.webp" alt="img.webp" /></p><p>如果想保持默认，可以直接将下载的模型放在默认目录下，否则可以点击更换按钮选择自己的模型目录。</p><blockquote><p>好像现在忘了做文件即时监控刷新了，因此只有在更换模型目录后才会刷新，如果列表没有更新，可以试试更换一下目录，或者直接重启软件试一下。</p></blockquote><p>如果操作正确，应该可以看到模型列表：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_16-11-50.webp" alt="img.webp" /></p><h3 id="3-加载模型"><a class="anchor" href="#3-加载模型">#</a> 3. 加载模型</h3><p>在对话页签中，界面顶部有选择加载模型的列表，点击模型名称即可加载模型：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_16-18-48.webp" alt="img.webp" /></p><p>另外，对话右侧的 “本地模型设置” 中，可以设置模型的一些参数，例如：</p><ul><li>GPU Layer：运行时需要卸载至 GPU 的层数，GPU 运行的层数越多，运行越快。但是请注意不要爆显存了，那同样会导致运行变得很慢。</li><li>Context Size：加载模型时的最大上下文大小，默认为 0 时将从模型读取最大支持大小。请注意：上下文越大，要求的 RAM 越多。</li></ul><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_18-28-26.webp" alt="img.webp" /></p><blockquote><p>如果有需要可以进行调整，例如 GPU Layer，不调整就是纯粹运行在 CPU 上了，起不到加速效果。</p></blockquote><h3 id="4-对话"><a class="anchor" href="#4-对话">#</a> 4. 对话</h3><p>在对话页签中，可以进行对话，输入文字即可：</p><p>目前也简单适配了下 think 标签，后面有时间也会整个设置 (支持直接排除 think 内容之类的)：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_18-20-50.webp" alt="img.webp" /></p><h3 id="5-llamacpp-全局设置"><a class="anchor" href="#5-llamacpp-全局设置">#</a> 5. llama.cpp 全局设置</h3><p>在主设置页面，还可以对 llama.cpp 一些其它参数，有需要也可以进行一定调整：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_16-27-09.webp" alt="img.webp" /></p><h1 id="远程模型调用"><a class="anchor" href="#远程模型调用">#</a> 远程模型调用</h1><p>UiharuMind 还支持远程模型调用，可以通过模型设置界面添加远程 AI 模型：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_19-06-03.webp" alt="img.webp" /></p><p>预配置的定义有智谱、混元模型，这两家都有免费 API 可以调用：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_19-06-38.webp" alt="img.webp" /></p><p>如果不在这个列表，也可以选择自定义配置，手动输入模型地址：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_19-09-04.webp" alt="img.webp" /></p><p>远程配置添加完毕后，列表同样会出现对应模型，同时名字上会标记为 “远程模型”：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_19-10-59.webp" alt="img.webp" /></p><p>之后与本地模型一样使用，正常选择即可：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_19-12-02.webp" alt="img.webp" /></p><h1 id="提示词等功能"><a class="anchor" href="#提示词等功能">#</a> 提示词等功能</h1><p>UiharuMind 还支持一些提示词功能，简单的提示这儿称为工具人，复合的提示称为角色扮演，角色扮演的角色可以挂载工具人 (复用提示)<br />，创建角色时可以选择性的设置：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_19-28-32.webp" alt="img.webp" /></p><p>另外，适用于角色扮演的角色，支持导入 SillyTavern 角色卡：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_20-02-43.webp" alt="img.webp" /></p><blockquote><p>当然这个肯定没 SillyTavern 本身完善，只能说有这么个功能。</p></blockquote><p>主页中会显示当前的已存在角色：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_19-26-40.webp" alt="img.webp" /></p><p>其中快捷工具使用的系统角色，勾选 “显示隐藏” 后也会显示在菜单中，描述中都有说明具体对应什么样的系统工具，可以视个人情况对其进行调整。</p><h1 id="最后"><a class="anchor" href="#最后">#</a> 最后</h1><p>还有个小提示，默认关闭主界面只是隐藏界面，如果想完全退出程序需要在系统托盘中右键退出：</p><p><img data-src="/blogimages/2025/2025-02-16/Uiharu_2025-02-16_20-10-48.webp" alt="img.webp" /></p><p>开源地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NXSElTTUUvVWloYXJ1TWluZA==">UiharuMind</span><br /> 百度网盘：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMVFNRWo2VGRqTlZNckVyVzNzM0R4UFE/cHdkPWF1M3A=">https://pan.baidu.com/s/1QMEj6TdjNVMrErW3s3DxPQ?pwd=au3p</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;这是去年 5 月份左右开始搞的一个 AI 工具应用，支持 Mac、Windows 平台 (但是目前只在自己的电脑测试过)。&lt;/p&gt;
&lt;p&gt;最初是想做一个方便截图使用</summary>
      
    
    
    
    <category term="工具" scheme="https://wangjiaying.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://wangjiaying.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Avalonia" scheme="https://wangjiaying.top/tags/Avalonia/"/>
    
  </entry>
  
  <entry>
    <title>UiharuMind 国庆开发笔记</title>
    <link href="https://wangjiaying.top/2024/10/20/UiharuMind%E5%9B%BD%E5%BA%86%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>https://wangjiaying.top/2024/10/20/UiharuMind%E5%9B%BD%E5%BA%86%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</id>
    <published>2024-10-20T11:24:47.000Z</published>
    <updated>2024-10-20T12:02:11.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2024年10月1日"><a class="anchor" href="#2024年10月1日">#</a> 2024 年 10 月 1 日</h1><p>接入实际的 llamacpp 根据配置的调用使用，重构了一波异步计算信息，将简单的快捷解释界面基本弄好了</p><h1 id="2024年10月2日"><a class="anchor" href="#2024年10月2日">#</a> 2024 年 10 月 2 日</h1><p>今天主要是优化了各个界面排版，特别是聊天界面整体都重构了下。</p><p>还有之前感觉在 UI 涉及数据更新的时候卡顿问题，最后加了更新延迟：特别是 LLM 流式传输，打字机效果一样显示的情况，调整了 UI 更新频率感觉好些了。</p><h1 id="2024年10月3日"><a class="anchor" href="#2024年10月3日">#</a> 2024 年 10 月 3 日</h1><p>搞了一天加 Markdown 渲染效果，开始以为很简单，头一天晚上都想好了：</p><ul><li>先用 Markdig 配合 Markdown.ColorCode.CSharpToColoredHtml 渲染成 HTML</li><li>然后使用 Avalonia.HtmlRenderer 渲染显示</li></ul><p>怎么样？想着是不是很简单呢？</p><p>结果... 先是发现显示很有问题：Avalonia.HtmlRenderer 显示起来，感觉很怪，跟现在的主题完全对不上号。其次渲染感觉也有问题。其次流式更新性能也很糟糕....</p><p>然后中途就查另外一个 Avalonia.Markdown，换成这个也有不少坑，比如代码高亮都没有，最后到处查，查 issue，结果最后在它自己的 wiki... 最后一篇才写着：代码用的 TextEditor，得 Fluent 主题才支持！</p><p>于是又研究来研究去的... 最后得出结论：</p><ul><li>可以给 MarkdownScrollViewer 指定 FluentTheme，然后内联指定 SimpleTheme 配合 avares://AvaloniaEdit/Themes/Simple/AvaloniaEdit.xaml 勉强正常显示</li><li>之所以说勉强，是因为有些显示不对：文字选择、代码高亮都没有了</li><li>代码高亮可以强行指定语言，比如 C#，不过其它的，纯文字看着还行，手动选择一下就不对劲了，而且有时候生成的代码是纯粹的 TextBlock 模式，选也没法选</li></ul><p>设置代码如下：</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mdxaml:</span>MarkdownScrollViewer</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token attr-name">Name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>MarkdownScrollViewer<span class="token punctuation">"</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token attr-name">MarkdownStyleName</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>FluentTheme<span class="token punctuation">"</span></span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token attr-name">SelectionEnabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>True<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mdxaml:</span>MarkdownScrollViewer.Plugins</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mdxaml:</span>MdAvPlugins</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">avalonia:</span>ChatAISetup</span> <span class="token punctuation">/></span></span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mdxaml:</span>MdAvPlugins</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mdxaml:</span>MarkdownScrollViewer.Plugins</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mdxaml:</span>MarkdownScrollViewer.Styles</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">&lt;!-- &lt;FluentTheme /> --></span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">&lt;!-- &lt;StyleInclude Source="avares://AvaloniaEdit/Themes/Fluent/AvaloniaEdit.xaml" /> --></span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>SimpleTheme</span> <span class="token punctuation">/></span></span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>StyleInclude</span> <span class="token attr-name">Source</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>avares://AvaloniaEdit/Themes/Simple/AvaloniaEdit.xaml<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Style</span> <span class="token attr-name">Selector</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Button.CopyButton TextBlock<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Setter</span> <span class="token attr-name">Property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Text<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>📋<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Style</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Style</span> <span class="token attr-name">Selector</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.CodeBlock avedit|TextEditor<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="19"></td><td><pre>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Setter</span> <span class="token attr-name">Property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ShowLineNumbers<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>True<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></pre></td></tr><tr><td data-num="20"></td><td><pre>      <span class="token comment">&lt;!-- 强行写死 C#，因为目前 MarkdownScrollViewer 有问题，使用 FluentTheme 代码高亮是有了，但是内容会丢失，而且闪烁 --></span></pre></td></tr><tr><td data-num="21"></td><td><pre>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Setter</span> <span class="token attr-name">Property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SyntaxHighlighting<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>C#<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Style</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="23"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mdxaml:</span>MarkdownScrollViewer.Styles</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mdxaml:</span>MarkdownScrollViewer</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><p>太晚了，最后无奈先用着这一版，后面再看吧。</p><h1 id="2024年10月4日"><a class="anchor" href="#2024年10月4日">#</a> 2024 年 10 月 4 日</h1><p>昨天晚上也是，睡不着觉，今天早上 5 点多就醒了，翻来覆去到 8 点，然后开始搞。</p><p>本来计划把突然想到的剪切板历史记录给搞出来，而且以为会很快 —— 左右估计不过几个小时，结果调各种效果啥的，愣是又花了一天，今天已经时 4 号了，国庆竟然连 B 站都基本还没打开看过什么....</p><p>选择快八点了，刚炒了菜准备吃饭，于是想先记录一下。</p><p>最后效果这样：</p><p><img data-src="/blogimages/2024/2024-10-20/image1.png" alt="" /></p><p>虽然也搞了些其它东西，比如又重构了下 SK 发送给 LLM 的方式。从下午开始搞的，但是搞这么久也真的是....</p><p>不行啊，国庆都连肝 4 天了，这可是一年才有一次的大假期！！！今天还计划把角色、工具人的设置及界面搞了，结果也没时间弄、还有优化流式显示，想着先纯文本流式打字机显示，完了再统一渲染成 Markdown，也是没时间搞了.... 我不想国庆都费再这.... 之前说的 UE5 教程也还没看...</p><h1 id="2024年10月5日"><a class="anchor" href="#2024年10月5日">#</a> 2024 年 10 月 5 日</h1><p>昨天晚上就发现 Avalonia.Markdown 渲染又出问题了，今天早上试了下，存在它的页面切换都要挂。</p><p>最后调到中午，发现还是绑出来的问题：</p><ul><li>我创建了一个 SimpleMarkdownViewer 封装这一系列设置，SimpleMarkdownViewer 本身挂了一些绑定属性：</li></ul><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">readonly</span> <span class="token class-name">StyledProperty<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">></span></span> MarkdownTextProperty <span class="token operator">=</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    AvaloniaProperty<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Register</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>SimpleMarkdownViewer<span class="token punctuation">,</span> <span class="token keyword">string</span><span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">nameof</span><span class="token punctuation">(</span>MarkdownText<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">readonly</span> <span class="token class-name">StyledProperty<span class="token punctuation">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">></span></span> IsPlaintextProperty <span class="token operator">=</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    AvaloniaProperty<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Register</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>SimpleMarkdownViewer<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">nameof</span><span class="token punctuation">(</span>IsPlaintext<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> MarkdownText</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">get</span> <span class="token operator">=></span> <span class="token function">GetValue</span><span class="token punctuation">(</span>MarkdownTextProperty<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">set</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// Log.Debug(_stopwatch.ElapsedMilliseconds + "       Setting Markdown to: ");</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token function">SetValue</span><span class="token punctuation">(</span>MarkdownTextProperty<span class="token punctuation">,</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// _stopwatch.Restart();</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> HtmlText</pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">get</span> <span class="token operator">=></span> MarkdownUtils<span class="token punctuation">.</span><span class="token function">ToHtml</span><span class="token punctuation">(</span>MarkdownText<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> IsPlaintext</pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">get</span> <span class="token operator">=></span> <span class="token function">GetValue</span><span class="token punctuation">(</span>IsPlaintextProperty<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">set</span> <span class="token operator">=></span> <span class="token function">SetValue</span><span class="token punctuation">(</span>IsPlaintextProperty<span class="token punctuation">,</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在其它地方使用时，会直接绑定这些属性，然后在它的页面中，本身的 MarkdownScrollViewer 也会绑定它：</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">&lt;!-- Avalonia.Markdown 渲染显示 --></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">avalonia:</span>MarkdownScrollViewer</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token attr-name">IsVisible</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&#123;Binding !IsPlaintext, RelativeSource=&#123;RelativeSource AncestorType=&#123;x:Type common:SimpleMarkdownViewer&#125;&#125;&#125;<span class="token punctuation">"</span></span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token attr-name">SelectionEnabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>True<span class="token punctuation">"</span></span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token attr-name">Markdown</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&#123;Binding MarkdownText, RelativeSource=&#123;RelativeSource AncestorType=&#123;x:Type common:SimpleMarkdownViewer&#125;&#125;&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">avalonia:</span>MarkdownScrollViewer.Plugins</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">avalonia:</span>MdAvPlugins</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">avalonia:</span>ChatAISetup</span> <span class="token punctuation">/></span></span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">avalonia:</span>MdAvPlugins</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">avalonia:</span>MarkdownScrollViewer.Plugins</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">avalonia:</span>MarkdownScrollViewer.Styles</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FluentTheme</span> <span class="token punctuation">/></span></span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>StyleInclude</span> <span class="token attr-name">Source</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>avares://AvaloniaEdit/Themes/Fluent/AvaloniaEdit.xaml<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">&lt;!-- &lt;SimpleTheme /> --></span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">&lt;!-- &lt;StyleInclude Source="avares://AvaloniaEdit/Themes/Simple/AvaloniaEdit.xaml" /> --></span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Style</span> <span class="token attr-name">Selector</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Button.CopyButton TextBlock<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="17"></td><td><pre>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Setter</span> <span class="token attr-name">Property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Text<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>📋<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Style</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Style</span> <span class="token attr-name">Selector</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.CodeBlock avedit|TextEditor<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="20"></td><td><pre>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Setter</span> <span class="token attr-name">Property</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ShowLineNumbers<span class="token punctuation">"</span></span> <span class="token attr-name">Value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>True<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></pre></td></tr><tr><td data-num="21"></td><td><pre>      <span class="token comment">&lt;!-- 强行写死 C#，因为目前 MarkdownScrollViewer 有问题，使用 FluentTheme 代码高亮是有了，但是内容会丢失，而且闪烁 --></span></pre></td></tr><tr><td data-num="22"></td><td><pre>      <span class="token comment">&lt;!-- &lt;Setter Property="SyntaxHighlighting" Value="C#" /> --></span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Style</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">avalonia:</span>MarkdownScrollViewer.Styles</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">avalonia:</span>MarkdownScrollViewer</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><p>结果不知道是不是这样中转导致渲染引擎出问题了，反正就是不报错，单纯就是切换页面的时候，整个页面卸载不掉，然后崩溃。</p><p>果然还是太好高骛远了，想着用方便的高级特性，这下栽跟头了.... 白费时间，还不如用最常规、简单的方法：代码中转复制，什么事都没了。毕竟通常事情都是有代价的。</p><hr /><p>自定义控件定义的组件，其绑定属性跟随的是 DataContext 。</p><p>另外，自定义的绑定数据，Set 方法是不会被调用的！！！</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">readonly</span> <span class="token class-name">StyledProperty<span class="token punctuation">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">?</span><span class="token punctuation">></span></span> IsPlaintextProperty <span class="token operator">=</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    AvaloniaProperty<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Register</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>SimpleMarkdownViewer<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">?</span><span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">nameof</span><span class="token punctuation">(</span>IsPlaintext<span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>                                                           <span class="token named-parameter punctuation">defaultBindingMode</span><span class="token punctuation">:</span> BindingMode<span class="token punctuation">.</span>TwoWay<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">bool</span><span class="token punctuation">?</span></span> IsPlaintext</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">get</span> <span class="token operator">=></span> <span class="token function">GetValue</span><span class="token punctuation">(</span>IsPlaintextProperty<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">set</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token function">SetValue</span><span class="token punctuation">(</span>IsPlaintextProperty<span class="token punctuation">,</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        MarkdownScrollViewer<span class="token punctuation">.</span>IsVisible <span class="token operator">=</span> <span class="token operator">!</span>IsPlaintext <span class="token operator">??</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        BlockTextScrollViewer<span class="token punctuation">.</span>IsVisible <span class="token operator">=</span> IsPlaintext <span class="token operator">??</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果想要在 Set 的时候做点什么，必须通过重载来额外判断：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">OnPropertyChanged</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">AvaloniaPropertyChangedEventArgs<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> change<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">OnPropertyChanged</span><span class="token punctuation">(</span>change<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>change<span class="token punctuation">.</span>Property <span class="token operator">==</span> IsPlaintextProperty<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 在这里处理 IsPlaintext 属性的变化</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name"><span class="token keyword">var</span></span> newValue <span class="token operator">=</span> change<span class="token punctuation">.</span>NewValue<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetValueOrDefault</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        MarkdownScrollViewer<span class="token punctuation">.</span>IsVisible <span class="token operator">=</span> <span class="token operator">!</span>newValue<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        BlockTextScrollViewer<span class="token punctuation">.</span>IsVisible <span class="token operator">=</span> newValue<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><hr /><p>鉴于上面使用 Avalonia.Markdown 的一些问题 (最主要还是配合 Fluent 主题渲染直接报错、配合 Simple 主题也显示难看)，而且 Demo 源码也跑不了。</p><p>所以折腾半晌，就又把 Avalonia.HtmlRenderer 拿来试了下，效果有，但是不大好，感觉画风都不是一套的了.... 而且真的卡，放几个对话记录就感觉有点吃不消了 —— 也许可以考虑统一封装到 SimpleMarkdownViewer，由设置项控制用哪个渲染。</p><hr /><p>搞 Avalonia.HtmlRenderer 又折腾到晚上了... 这东西默认会给文本上下加上 20 像素的空白长度..... 字体也不对劲.... 另外排版上最后觉得还是做分页吧，现在这种 Scroll 套 Scroll 进度条变来变去，体验也不好：</p><p><img data-src="/blogimages/2024/2024-10-20/image2.png" alt="" /></p><p><img data-src="/blogimages/2024/2024-10-20/image3.png" alt="" /></p><p>今天最后决定还是用 Avalonia.HtmlRenderer 了，因为跟着追源码，一边追一边调，已经发现正确修改这些问题 (包括字体、边距、自适应宽、高) 的方法了。</p><ul><li>字体：可以生效，只是里面通过系统文字名字映射的，得完全一致，很不稳定对不上就花了，所以决定自定义字体，全都用一套。</li><li>边距：可以考虑 Markdown 渲染成 Html 的时候在就加上 markgin 上下 20px，当然，仅限于第一个 <p> 标签和最后一个。</li><li>自适应宽高：重载容器 (SimpleMarkdownViewer) MeasureOverride 方法，对 HtmlLabel 做 AutoSize 下的 MaxWidth 限制。</li><li>文字色根据主题切换：渲染 Html 时加上对于主题颜色，OnThemeChanged 事件中重新渲染 Html。</li></ul><p>至于 Avalonia.Markdown，代码高亮强依赖 AvaloniaEdit，AvaloniaEdit 强依赖 FluntTheme，而 Avalonia.Markdown 不能使用 FluntTheme，渲染要直接报错.... 只能用 Avalonia.Markdown.FluntTheme 配合 SimpleTheme 主题才能正常渲染，但是代码高亮啥的都炸了，连文字选中表现都不对劲， 一环套一环。</p><p>而且源码 Demo 拉下来一堆报错，跑不了。目前就是是之前折腾了一天多的结论，看看维护时间好像也已经没维护了，上面说的渲染报错问题，git issue 有人 push commit 好像也没看到反应，只能先放弃。</p><p>结果一通折腾下来，又是 11 点多，国庆还是太肝了... 明天先把字体问题解决了，然后计划：</p><ul><li>去掉聊天页面的动态虚拟化 (体验下来，对于存在不固定 Item 的情况下，简直是负优化)</li><li>把分页做了</li><li>加点工具设置的东西、优化下设置排版</li><li>优化下日志排版，现在也是虚拟化， Scroll 体验不对劲，要么改成 Item 固定高度，要么用内联文字？</li></ul><h1 id="2024年10月6日"><a class="anchor" href="#2024年10月6日">#</a> 2024 年 10 月 6 日</h1><p>早上起床就开始找开源字体，准备将应用字体与 Avalonia.HtmlRenderer 保持一致。</p><ul><li>注：看代码 HtmlRenderer 只支持一个字体，因此在 html style 定义多个字体的情况不行，找到第一个字体存在就直接用了，不会检测文字是否适合</li></ul><p>字体的坑：</p><ul><li>Avalonia 的字体加载，是依靠字体内部的 FamilyName，一般都看不到....</li><li>所以文件路径是不行的，注意连空格都得有，直接打开字体看到的中文名字是不行的！</li></ul><hr /><p>Avalonia.HtmlRenderer 好像也不行啊，中英文混排巨坑：</p><p><img data-src="/blogimages/2024/2024-10-20/image4.png" alt="" /></p><p>搞半天发现这个又坏了... 还是是因为我自己编译导致的？因为现在 nuget 上的版本很旧，自定义字体貌似都不支持，所以才拉下来自己编译了个....</p><hr /><p>测试了下还真是... 看来最新版本还没发布也是有一定原因的... 看记录今年都有不少修改，但是 nuget 已经是去年的版本了。</p><hr /><p>反编译查了下 nuget 版本，找到添加字体的入口了，在 HtmlRender 里面，直接是静态方法了，之前还以为可能得反射去查了呢 —— 这不是比改版后的方便么？AvaloniaAdapter nuget 版本是个单例，而且改版后还变成成员了。这样不是还得看啥时候添加、或者每次创建要给都得单独加一次.... 虽然是字典没关系。</p><p>反正既然老版本有设置字体的地方，那就直接换回 nuget 版本了，直接在 SimpleMarkdownViewer 静态构造函数里面初始化一次。</p><p>我就说今天又忙活了一天，之前好像也没感觉，怎么排版就挂了？差点吓惨了，因为立刻在官方 Demo 上试了下中英文混排也是乱的，都在想是不是要把 Avalonia.Markdown 也加进来，然后整个设置可选项了....</p><p>换回 nuget 版本果然没渲染问题，字体看着也 OK：</p><p><img data-src="/blogimages/2024/2024-10-20/image5.png" alt="" /></p><h1 id="2024年10月7日"><a class="anchor" href="#2024年10月7日">#</a> 2024 年 10 月 7 日</h1><p>添加 OpenAI 模式 BPE 分词器计算。 解决聊天 UI 抖动问题，见 <a href="/2024/10/07/%E4%BD%BF%E7%94%A8Avalonia%E7%9A%84%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-ItemsControl/" title="使用Avalonia的踩坑记录:ItemsControl">使用Avalonia的踩坑记录:ItemsControl</a>，晚上还单独写了篇这个研究记录，导致本篇日志也没时间弄了。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>记录有点乱，像流水账... 之所以没当天就写完是因为本来想整理下的，但是如今过了两周发现又不知道写啥好，就先这样吧。</p><p>毕竟考虑到确实折腾了这么久，不记录一下就没有意义了：没想到国庆肝了七天，抠细节想搞好的话，什么东西都难搞... 本来想国庆研究 UE5 的，结果全搞这个 Avalonia 和 AI 去了。后面上班了甚至感觉好像连续一个月都在上班一样，有点顶不住，接下来准备先缓一缓了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2024年10月1日&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#2024年10月1日&quot;&gt;#&lt;/a&gt; 2024 年 10 月 1 日&lt;/h1&gt;
&lt;p&gt;接入实际的 llamacpp 根据配置的调用使用，重构了一波异步计算信息，将简单的快捷解释界面基本弄好了&lt;</summary>
      
    
    
    
    <category term="Avalonia" scheme="https://wangjiaying.top/categories/Avalonia/"/>
    
    
    <category term="Avalonia" scheme="https://wangjiaying.top/tags/Avalonia/"/>
    
  </entry>
  
  <entry>
    <title>使用Avalonia的踩坑记录:ItemsControl</title>
    <link href="https://wangjiaying.top/2024/10/07/%E4%BD%BF%E7%94%A8Avalonia%E7%9A%84%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-ItemsControl/"/>
    <id>https://wangjiaying.top/2024/10/07/%E4%BD%BF%E7%94%A8Avalonia%E7%9A%84%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-ItemsControl/</id>
    <published>2024-10-07T13:53:03.000Z</published>
    <updated>2024-10-07T14:25:33.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>事情的起因是这样的：</p><p>昨天刚把 Chat 页面的 ItemsControl VirtualizingStackPanel 换成了固定的 (不然由于子级的复用，会导致 Scroller<br /> 的滑动条变来变去)。</p><p>然后今天就突然发现，在页面从隐藏变为显示、或者发送新消息的时候，容器中的 Item 对象会产生抖动表现。</p><p>经过调试发现，原因是 ItemsControl 内部的子级发生了变化，从而导致 ItemsControl 内部大小变化造成整体的布局更新：</p><ul><li>很简单的一个表现就是：比如本来是 1000px 变成 800px，然后又变回 1000px，这就导致进度闪烁、内容闪烁、抖动。</li><li>因为我的内容是 Wrap 的，所以容器大小也会随着其中内容变化而变化，这就是根源。</li><li>而且一连串的反应还会导致自动 Scroll Down 功能也产生一些问题</li></ul><p>但是就在想这么基础的容器，这种用法应该不是特例，怎么会出现这种问题，难道是我哪里用错了吗？</p><p>于是就开始继续排查问题。</p><h1 id="问题排查"><a class="anchor" href="#问题排查">#</a> 问题排查</h1><p>实际布局是这样的：</p><p><img data-src="/blogimages/2024/2024-10-07/2024-10-07-03.webp" alt="img_3.png" /></p><p>省略无关代码，主体大概是以下这段：</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ItemsControl</span> <span class="token attr-name">ItemsSource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&#123;Binding ChatItems&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ItemsControl.ItemTemplate</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>DataTemplate</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>CustomTextBlock</span> <span class="token attr-name">Text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&#123;Binding Text&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>DataTemplate</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ItemsControl.ItemTemplate</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ItemsControl</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><p>其中的 Text 可以当作会自适应 Wrap 的设置。<br />很简单的逻辑是吧？<br />但就是出问题了。</p><p>于是先手动排查 CustomTextBlock 的问题，中间的过程也挺曲折的：<br />先是试图在各种重载打印、加断点，但始终无法找到问题。</p><p>检查了一下 TextBlock 的值，竟然发现每次刚进来还是有值的状态，结果初始化一半反而变成空了，然后又走重新赋值的流程：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnLoaded</span><span class="token punctuation">(</span><span class="token class-name">RoutedEventArgs</span> e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">OnLoaded</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    _isLoaded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">CheckUpdateValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    Log<span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"SimpleMarkdownViewer loaded"</span><span class="token operator">+</span>PlainTextBlock<span class="token punctuation">?.</span>Text<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnUnloaded</span><span class="token punctuation">(</span><span class="token class-name">RoutedEventArgs</span> e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">OnUnloaded</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    _isLoaded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    Log<span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"SimpleMarkdownViewer unloaded"</span><span class="token operator">+</span>PlainTextBlock<span class="token punctuation">?.</span>Text<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnDetachedFromVisualTree</span><span class="token punctuation">(</span><span class="token class-name">VisualTreeAttachmentEventArgs</span> e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">OnDetachedFromVisualTree</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    Log<span class="token punctuation">.</span><span class="token function">Debug</span><span class="token punctuation">(</span><span class="token string">"SimpleMarkdownViewer detached"</span><span class="token operator">+</span>PlainTextBlock<span class="token punctuation">?.</span>Text<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>就这么又调了一阵子，不得结果。最后灵机一动，直接在 CustomTextBlock 构造函数打了个断点和调试，竟然还真每次都进来了！</p><p><img data-src="/blogimages/2024/2024-10-07/2024-10-07-01.webp" alt="img_1.png" /></p><p>一堆重新初始化的日志。</p><p>然后就是追源码的过程了。</p><h1 id="源码追踪"><a class="anchor" href="#源码追踪">#</a> 源码追踪</h1><p>在激活页面的时候，会调到 Layouable MeasureCore (Size availableSize) 方法，这里倒是看着没啥问题，目前已知的是涉及页面刷新都会走到这。<br />但下面的继续调用的方法就不对了：<br />其中 ApplyTemplate () 会走到 ContentPresenter 里面：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ApplyTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_createdChild <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ILogical<span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span>IsAttachedToLogicalTree<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token function">UpdateChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里会检查更新子级，注意 createdChild 是在 OnAttachedToLogicalTree 就设置为 false 了，也就是重新进来的时候肯定为 false：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnAttachedToLogicalTree</span><span class="token punctuation">(</span><span class="token class-name">LogicalTreeAttachmentEventArgs</span> e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">OnAttachedToLogicalTree</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    _recyclingDataTemplate <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    _createdChild <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">InvalidateMeasure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>所以又一定会走到 UpdateChild：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">UpdateChild</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">?</span></span> content<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name"><span class="token keyword">var</span></span> contentTemplate <span class="token operator">=</span> ContentTemplate<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name"><span class="token keyword">var</span></span> oldChild <span class="token operator">=</span> Child<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name"><span class="token keyword">var</span></span> newChild <span class="token operator">=</span> <span class="token function">CreateChild</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> oldChild<span class="token punctuation">,</span> contentTemplate<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token class-name"><span class="token keyword">var</span></span> logicalChildren <span class="token operator">=</span> <span class="token function">GetEffectiveLogicalChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 其它后续处理，不重要</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里取到的 Child 是有值的，也就是子级在这确实还存在，也就是说 oldChild 也肯定有值。<br />问题就出在 CreateChild 方法里面：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name">Control<span class="token punctuation">?</span></span> <span class="token function">CreateChild</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">?</span></span> content<span class="token punctuation">,</span> <span class="token class-name">Control<span class="token punctuation">?</span></span> oldChild<span class="token punctuation">,</span> <span class="token class-name">IDataTemplate<span class="token punctuation">?</span></span> template<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span>            </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name"><span class="token keyword">var</span></span> newChild <span class="token operator">=</span> content <span class="token keyword">as</span> <span class="token class-name">Control</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// We want to allow creating Child from the Template, if Content is null.</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// But it's important to not use DataTemplates, otherwise we will break content presenters in many places,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// otherwise it will blow up every ContentPresenter without Content set.</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newChild <span class="token operator">==</span> <span class="token keyword">null</span> </pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>content <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> template <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>newChild <span class="token keyword">is</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span> <span class="token operator">&amp;&amp;</span> template <span class="token keyword">is</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token class-name"><span class="token keyword">var</span></span> dataTemplate <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">FindDataTemplate</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> template<span class="token punctuation">)</span> <span class="token operator">??</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                RecognizesAccessKey</pre></td></tr><tr><td data-num="14"></td><td><pre>                    <span class="token punctuation">?</span> FuncDataTemplate<span class="token punctuation">.</span>Access</pre></td></tr><tr><td data-num="15"></td><td><pre>                    <span class="token punctuation">:</span> FuncDataTemplate<span class="token punctuation">.</span>Default</pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dataTemplate <span class="token keyword">is</span> <span class="token class-name">IRecyclingDataTemplate</span> rdt<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token class-name"><span class="token keyword">var</span></span> toRecycle <span class="token operator">=</span> rdt <span class="token operator">==</span> <span class="token class-name">_recyclingDataTemplate <span class="token punctuation">?</span></span> oldChild <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            newChild <span class="token operator">=</span> rdt<span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> toRecycle<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            _recyclingDataTemplate <span class="token operator">=</span> rdt<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">else</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            newChild <span class="token operator">=</span> dataTemplate<span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            _recyclingDataTemplate <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token keyword">else</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        _recyclingDataTemplate <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token keyword">return</span> newChild<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>其中我用的是 DataTemplate，它实现了 IRecyclingDataTemplate 接口，所以会走到 IRecyclingDataTemplate 分支：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>dataTemplate <span class="token keyword">is</span> <span class="token class-name">IRecyclingDataTemplate</span> rdt<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name"><span class="token keyword">var</span></span> toRecycle <span class="token operator">=</span> rdt <span class="token operator">==</span> <span class="token class-name">_recyclingDataTemplate <span class="token punctuation">?</span></span> oldChild <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    newChild <span class="token operator">=</span> rdt<span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> toRecycle<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    _recyclingDataTemplate <span class="token operator">=</span> rdt<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里关键就来了：recyclingDataTemplate 根本就没值！<br />甚至我翻来覆去检查了几次，通篇都只有对 recyclingDataTemplate 赋值为 null 的，就是没有赋实际值的设置。</p><p>而且这东西定义的还是个 private 变量：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">IRecyclingDataTemplate<span class="token punctuation">?</span></span> _recyclingDataTemplate<span class="token punctuation">;</span></pre></td></tr></table></figure><p>所以也不存在子级。</p><p>再看看 DataTemplate 实现的 IRecyclingDataTemplate 接口：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">Control<span class="token punctuation">?</span></span> <span class="token function">Build</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">?</span></span> data<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Build</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">Control<span class="token punctuation">?</span></span> <span class="token function">Build</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">?</span></span> data<span class="token punctuation">,</span> <span class="token class-name">Control<span class="token punctuation">?</span></span> existing<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">return</span> existing <span class="token operator">??</span> TemplateContent<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span>Content<span class="token punctuation">)</span><span class="token punctuation">?.</span>Result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>上面的代码是 rdt == _recyclingDataTemplate 才会传入 oldChild，否则就返回 null。<br />但这里的 _recyclingDataTemplate 根本就没值，所以肯定是 null。</p><p>那么传进来的结果就显而易见，就是 null，也就是说会调用 TemplateContent.Load (Content) 去创建新的子级。</p><p>至于旧的，后面就有重复检测，会直接再给删除掉。</p><p>所以问题就来了：同一个对象，从隐藏变为显示，会重新创建子级，但却实际没有赋予 _recyclingDataTemplate<br /> 值，导致后面又会重新创建子级，这就导致了子级的重复创建。</p><p>我也不知道为什么会怎样？是代码有点问题，还是有其它考虑？</p><p>为了解决这个问题：</p><ul><li>要么继承 DataTemplate 重写 Build 方法，要么看能不能继承 ContentPresenter 接口，在 OnAttachedToLogicalTree<br /> 之类的里面设置 _recyclingDataTemplate 值把这些逻辑补全。</li><li>或者自己实现 IRecyclingDataTemplate 接口，自己管理缓存试试能不能解决这个问题。</li></ul><p>看来下逻辑结构，感觉还是自己实现 IRecyclingDataTemplate 接口比较简单，而且也能更精确地控制缓存逻辑。</p><p>于是就开始动手了。</p><h1 id="解决方案"><a class="anchor" href="#解决方案">#</a> 解决方案</h1><p>首先，实现 DataTemplate 实现过的两个，接口，重写 Build 之类的方法：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReuseDataTemplate</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IRecyclingDataTemplate</span><span class="token punctuation">,</span> <span class="token class-name">ITypedDataTemplate</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">Dictionary<span class="token punctuation">&lt;</span><span class="token keyword">object</span><span class="token punctuation">,</span> Control<span class="token punctuation">></span></span> _cacheDictionary <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">DataType</span></span><span class="token punctuation">]</span> <span class="token keyword">public</span> <span class="token return-type class-name">Type<span class="token punctuation">?</span></span> DataType <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Content</span></span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">TemplateContent</span></span><span class="token punctuation">]</span> <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">object</span><span class="token punctuation">?</span></span> Content <span class="token punctuation">&#123;</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> <span class="token function">Match</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">?</span></span> data<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>DataType <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">return</span> DataType<span class="token punctuation">.</span><span class="token function">IsInstanceOfType</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name">Control</span> <span class="token function">Build</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">?</span></span> data<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Build</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name">Control</span> <span class="token function">Build</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">?</span></span> data<span class="token punctuation">,</span> <span class="token class-name">Control<span class="token punctuation">?</span></span> existing<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">return</span> existing <span class="token operator">??</span> <span class="token function">FindControl</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">private</span> <span class="token return-type class-name">Control</span> <span class="token function">FindControl</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">?</span></span> data<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TextBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Text <span class="token operator">=</span> <span class="token string">"Null Data"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>_cacheDictionary<span class="token punctuation">.</span><span class="token function">TryGetValue</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token keyword">out</span> <span class="token class-name"><span class="token keyword">var</span></span> template<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> template<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token class-name"><span class="token keyword">var</span></span> control <span class="token operator">=</span> TemplateContent<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span>Content<span class="token punctuation">)</span><span class="token punctuation">?.</span>Result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>control <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TextBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Text <span class="token operator">=</span> <span class="token string">"Null Control"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        _cacheDictionary<span class="token punctuation">[</span>data<span class="token punctuation">]</span> <span class="token operator">=</span> control<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token keyword">return</span> control<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>然后在使用的地方换成 ReuseDataTemplate 即可：</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ItemsControl</span> <span class="token attr-name">ItemsSource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&#123;Binding ChatItems&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ItemsControl.ItemTemplate</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ReuseDataTemplate</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>CustomTextBlock</span> <span class="token attr-name">Text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&#123;Binding Text&#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ReuseDataTemplate</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ItemsControl.ItemTemplate</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ItemsControl</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><p>如试想的一样，表现上就好了。</p><p>继续跟了一下调试，方法中也没走第二次创建之类的：</p><p><img data-src="/blogimages/2024/2024-10-07/2024-10-07-02.webp" alt="img_2.png" /></p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>改完后感觉流式更新内容的时候，界面都好多了，之前输出的时候可能还会卡卡的，当时也是调好久觉得是不是我功能逻辑层有啥问题？于是各种优化、加延迟、防抖机制。</p><p>果然，对于不熟悉的领域，没有一定经验的情况下，总是得踩不少坑。 比如本文这问题，虽然解决了，但是甚至都不知道这个解决方案是不是正常的：</p><p>因为作为最基础的 ItemsControl ，如果真有这问题，那么肯定早就有方案了才对。</p><p>另外这个解决方案不知道会不会有后遗症，现在缓存写的也比较暴力，后面估计也需要修改下实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;事情的起因是这样的：&lt;/p&gt;
&lt;p&gt;昨天刚把 Chat 页面的 ItemsControl VirtualizingStackPanel 换成了固定的 (不然由于子级</summary>
      
    
    
    
    <category term="Avalonia" scheme="https://wangjiaying.top/categories/Avalonia/"/>
    
    
    <category term="Avalonia" scheme="https://wangjiaying.top/tags/Avalonia/"/>
    
  </entry>
  
  <entry>
    <title>Avalonia一些记录</title>
    <link href="https://wangjiaying.top/2024/05/26/Avalonia%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/"/>
    <id>https://wangjiaying.top/2024/05/26/Avalonia%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</id>
    <published>2024-05-26T13:29:56.000Z</published>
    <updated>2024-05-26T14:09:29.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>之前提到过想在 llamap.cpp 基础上搞一个方便自己用的程序，但是又担心跨平台，毕竟现在公司使用 Mac，家里是 Windows 系统，就不好只想着单平台了，所以需要一个跨平台的框架。</p><p>开始想着先直接上控制台，找到两个控制台 UI 框架：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NwZWN0cmVjb25zb2xlL3NwZWN0cmUuY29uc29sZQ==">Terminal.Gui</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2d1aS1jcy9UZXJtaW5hbC5HdWk=">spectre.console</span></li></ul><p>其中 spectre.console 自带的一个 spectre.console.cli 做控制台应用还挺方便的，Terminal.Gui 没怎么研究过。<br />但是控制台一般只适合单线程显示信息，启用 llamap.cpp server 同时需要输出日志的话，就不够用了，虽然其中的 Terminal.Gui 似乎可以支持这种模式，但是感觉不大好看...</p><p>最后决定还是上正常的 GUI ，跨平台的 C# GUI 主要的似乎也就是 MAUI、Avalonia、Uno 了（开始还考虑过 Unity，但是 Unity 似乎太重了）</p><p>Avalonia 还有个 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0F2YWxvbmlhQ29tbXVuaXR5L2F3ZXNvbWUtYXZhbG9uaWE=">awesome-avalonia</span> 项目</p><p>MAUI 基本上不考虑，虽然是微软官方支持，但是风评和支持似乎都不大好，加上官方一直有放弃老项目的历史</p><p>于是准备从 avalonia、uno 两者选择，结果好不容易一个双休（指 2024 年 05 月 19 日，恰逢五一后连续上班之后），周末的第一天，也就是周六基本上一天都是对比测试 Avalonia、Uno 两者。最后选了 Avalonia。</p><p>主要原因：</p><ul><li>启动：因为 uno 启动时有个控制台，而且有一闪而过的黑屏，感觉启动体感比 avalonia 还，这个信息官方文档好像也没看到说明</li><li>发布：avalonia 的程序集明显要干净一些，而 uno 则带了很大一堆官方的其它程序集。可能这跟 uno 倾向于复用有关</li></ul><p>于是继续研究了一番，整理了一些知识记录了一番。</p><h1 id="样式选择器"><a class="anchor" href="#样式选择器">#</a> 样式选择器</h1><p>在 Avalonia 中，样式选择器有点类似 CSS，可以根据类型、名字、类选择器来应用样式，不像 WPF，选择器是定义在外边而不是控件内部。</p><h2 id="类型选择器"><a class="anchor" href="#类型选择器">#</a> 类型选择器</h2><ul><li><code>&lt;Style Selector=&quot;Button&quot;&gt;</code></li><li>默认为类型的精确选择</li><li>如果想应用于子类，则可使用 &quot;is:(Button)&quot;</li></ul><h2 id="名字选择器"><a class="anchor" href="#名字选择器">#</a> 名字选择器</h2><ul><li><code>&lt;Style Selector=&quot;Button#customTargetName&quot;&gt;</code></li><li>应用于指定类型，且设置了指定名字的对象，即定义了属性 Name=&quot;customTargetName&quot;</li></ul><h2 id="classes-选择器"><a class="anchor" href="#classes-选择器">#</a> Classes 选择器</h2><ul><li><code>&lt;Style Selector=&quot;Button.Red&quot;&gt;</code></li><li>即生效于制定了 Classes=&quot;Red&quot; 的对象</li><li>可以在控制在拥有指定 Classes 属性后生效的样式</li></ul><h1 id="mvvm"><a class="anchor" href="#mvvm">#</a> MVVM</h1><h2 id="简介"><a class="anchor" href="#简介">#</a> 简介</h2><p>在 MVVM 中按钮事件貌似是用的 Command，Click 事件和 Command 区别：</p><ul><li>Click：界面本身中的指定方法，适用于简单的事件处理</li><li>Command：数据源中注册的指定方法，用于 MVVM 模式，适用于复杂的交互逻辑；Command 还可以通过 CommandParameter 属性传递参数</li></ul><h3 id="主要功能"><a class="anchor" href="#主要功能">#</a> 主要功能</h3><ul><li>ObservableObject：一个基类，实现了 INotifyPropertyChanged 接口，简化了属性更改通知。</li><li>RelayCommand 和 AsyncRelayCommand：用于处理同步和异步命令。</li><li>ObservableCollection：一个集合类型，当其内容发生变化时会通知视图。</li><li>属性生成器：通过使用 ObservableProperty 特性，可以自动生成属性更改通知代码。</li></ul><h3 id="command"><a class="anchor" href="#command">#</a> Command</h3><p>内置主要有三个 Command：</p><ul><li>RelayCommand：最常见的同步处理，还带了 CanExcute 在接收事件时检测</li><li>RelayCommand<T>：同步处理命令，带参数</li><li>AsyncRelayCommand：异步方法处理的命令，使用 AsyncRelayCommand 处理异步操作，可以避免阻塞 UI 线程。</li></ul><p>在 Model (ObservableObject) 中，绑定对象变动自动通知 UI，需要使用 SetProperty 设置值<br />同里，可产生通知的列表为：ObservableCollection</p><h3 id="commandparameter"><a class="anchor" href="#commandparameter">#</a> CommandParameter</h3><ul><li>传递值，可传递固定值、动态值，或 xaml 选定值</li><li>允许在 XAML 中指定绑定源相对于当前元素的位置。通常用于在控件层次结构中查找特定的祖先或同级元素，并从这些元素中获取数据进行绑定。<ul><li>查找特定类型的祖先元素：例如，从某个控件向上查找最近的 Window 或 UserControl。</li><li>查找同级元素：例如，在 DataTemplate 中查找同级元素的数据上下文。</li><li>查找自身：例如，绑定到自身的属性。</li></ul></li></ul><h2 id="高级用法"><a class="anchor" href="#高级用法">#</a> 高级用法</h2><h3 id="observableproperty"><a class="anchor" href="#observableproperty">#</a> ObservableProperty</h3><p>使用 ObservableProperty 特性可以自动生成属性和属性更改通知代码。</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">partial</span> <span class="token keyword">class</span> <span class="token class-name">MainViewModel</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ObservableObject</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">ObservableProperty</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">string</span></span> _title<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">ObservableProperty</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">bool</span></span> _isBusy<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>注：如果需要配合 RelayCommand CanExcute，可额外使用 NotifyCanExecuteChangeFor 特性</p><h3 id="notifycanexecutechangedfornameoftitle"><a class="anchor" href="#notifycanexecutechangedfornameoftitle">#</a> [NotifyCanExecuteChangedFor(nameof(Title))]</h3><p>调用命令的 NotifyCanExecuteChanged 方法，使其重新验证是否可以在当前上下文中执行命令，但是暂时没试出来干啥的</p><ul><li>更新：似乎需要命令设置过 CanExecute 方法才有效，否则不会生成代码</li></ul><h3 id="notifypropertychangedfornameoftitle"><a class="anchor" href="#notifypropertychangedfornameoftitle">#</a> [NotifyPropertyChangedFor(nameof(Title))]</h3><p>一个特性，通知某个属性发生改变时，同时可以指定通知另外一个属性发生变化</p><h3 id="observablerecipient"><a class="anchor" href="#observablerecipient">#</a> ObservableRecipient</h3><ul><li>继承自 ObservableObject，增加了消息接收功能。</li><li>可以与 IMessenger 一起使用，简化组件之间的通信。</li></ul><h3 id="messenger"><a class="anchor" href="#messenger">#</a> Messenger</h3><ul><li>实现了松耦合的消息传递机制，简化组件之间的通信。</li><li>一般实例为：WeakReferenceMessenger.Default</li></ul><h3 id="relaycommand-特性"><a class="anchor" href="#relaycommand-特性">#</a> RelayCommand 特性</h3><ul><li>在方法上添加该特性，自动生成 RelayCommand 代码</li><li>参数 CanExcute，可以作为特性参数，例如：[RelayCommand (CanExcute=nameof (方法))]<ul><li>异步方法甚至会在执行时，自动将 CanExcute 方法设置为 false</li><li>Command.IsRunning 代表是否处于运行中</li></ul></li><li>参数 IncludeCancelCommand<ul><li>当设置为 True 时，它会自动生成一个带有所有必要样板的取消命令。唯一的要求是用 ICommand 属性修饰的方法需要有一个 CancellationToken 参数，该参数是取消异步任务所必需的</li></ul></li></ul><hr /><p>参考文档</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9jb21tdW5pdHl0b29sa2l0L212dm0vb2JzZXJ2YWJsZXJlY2lwaWVudA==">https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/observablerecipient</span></li></ul><h1 id="数据绑定"><a class="anchor" href="#数据绑定">#</a> 数据绑定</h1><ul><li>Mode=OneWay<ul><li>单向绑定：数据从源（通常是 ViewModel 中的属性）流向目标（通常是视图中的控件），但不会反向更新。</li><li>典型场景：用于只读数据展示，例如标签、文本块等不需要用户输入的控件。</li></ul></li><li>Mode=TwoWay<ul><li>双向绑定：数据在源和目标之间双向流动。当源属性改变时，目标会更新；当目标（例如用户输入）改变时，源属性也会更新。</li><li>典型场景：用于需要用户输入的控件，如文本框、复选框等。</li></ul></li><li>OneTime<ul><li>数据仅在绑定初始化时从源流向目标，不会再进行后续更新。</li><li>适用于静态或初始加载的数据。</li></ul></li><li>OneWayToSource<ul><li>数据从目标流向源，但不会反向更新。</li><li>适用于需要将用户输入的数据传递回 ViewModel，但不需要 ViewModel 更新视图的场景。</li></ul></li><li>Default<ul><li>取决于目标属性的默认绑定行为。如果目标属性没有特定的默认行为，则与 OneWay 类似。</li></ul></li></ul><h1 id="navmenuursa"><a class="anchor" href="#navmenuursa">#</a> NavMenu(Ursa)</h1><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">&lt;</span>u:NavMenu <span class="token assign-left variable">Name</span><span class="token operator">=</span><span class="token string">"menu"</span> <span class="token assign-left variable">ItemsSource</span><span class="token operator">=</span><span class="token string">"&#123;Binding Menus.MenuItems&#125;"</span></pre></td></tr><tr><td data-num="2"></td><td><pre>                   <span class="token assign-left variable">ExpandWidth</span><span class="token operator">=</span><span class="token string">"300"</span></pre></td></tr><tr><td data-num="3"></td><td><pre>                   <span class="token assign-left variable">CommandBinding</span><span class="token operator">=</span><span class="token string">"&#123;Binding ActivateCommand&#125;"</span></pre></td></tr><tr><td data-num="4"></td><td><pre>                   <span class="token assign-left variable">IsHorizontalCollapsed</span><span class="token operator">=</span><span class="token string">"True"</span></pre></td></tr><tr><td data-num="5"></td><td><pre>                   <span class="token assign-left variable">HeaderBinding</span><span class="token operator">=</span><span class="token string">"&#123;Bindin&#125;"</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                   <span class="token assign-left variable">IconBinding</span><span class="token operator">=</span><span class="token string">"&#123;Binding MenuHeader&#125;"</span><span class="token operator">></span></pre></td></tr></table></figure><ul><li>HeaderBinding=&quot;{Binding Header}&quot;：表示绑定数据结构中的指定名字字段</li><li>HeaderBinding=&quot;{Binding}&quot;：绑定当前自定义模板<ul><li>这个绑定后，自定义模板中传入数据类型为 MenuItems 中的一项</li><li>注：应该是因为数据源设置的  ItemsSource=&quot;{Binding Menus.MenuItems}&quot;</li></ul></li><li>HeaderBinding 如果不设置，会直接显示类的全名</li></ul><h1 id="图标"><a class="anchor" href="#图标">#</a> 图标</h1><p>普通的图片类型可以直接放 Assets 目录，然后通过  <code>&lt;Image Source=&quot;../Assets/avalonia-logo.ico&quot; /&gt;</code>  类似代码使用。<br />如果是 StreamGeometry 类型的，则可以新建 Style 样式的 axaml ：</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Style</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Style.Resources</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>StreamGeometry</span> <span class="token attr-name"><span class="token namespace">x:</span>Key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Sticker<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>StreamGeometry</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Style.Resources</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Style</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><p>然后可通过  <code>Data=&quot;&#123;StaticResource Sticker&#125;&quot;</code>  在其它地方引用。</p><blockquote><p>注 1：代码中可通过  <code>Application.Current!.TryFindResource(&quot;Sticker&quot;, out var res)</code>  查找指定 key 的资源<br />注 2：StreamGeometry 也可以通过代码 StreamGeometry.Parse 动态创建</p></blockquote><hr /><p>Fluent 样式的 Icon：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9hdmFsb25pYXVpLmdpdGh1Yi5pby9pY29ucy5odG1s">https://avaloniaui.github.io/icons.html</span></li></ul><hr />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;之前提到过想在 llamap.cpp 基础上搞一个方便自己用的程序，但是又担心跨平台，毕竟现在公司使用 Mac，家里是 Windows 系统，就不好只想着单平台了，</summary>
      
    
    
    
    <category term="Avalonia" scheme="https://wangjiaying.top/categories/Avalonia/"/>
    
    
    <category term="Avalonia" scheme="https://wangjiaying.top/tags/Avalonia/"/>
    
  </entry>
  
  <entry>
    <title>关于llama.cpp一些尝试</title>
    <link href="https://wangjiaying.top/2024/05/02/%E5%85%B3%E4%BA%8Ellama-cpp%E4%B8%80%E4%BA%9B%E5%B0%9D%E8%AF%95/"/>
    <id>https://wangjiaying.top/2024/05/02/%E5%85%B3%E4%BA%8Ellama-cpp%E4%B8%80%E4%BA%9B%E5%B0%9D%E8%AF%95/</id>
    <published>2024-05-01T16:00:00.000Z</published>
    <updated>2024-05-12T11:44:48.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>2024 年 5 月 1 日：研究 Python 绿色化执行环境，安装 OpenInterpreter，各种折腾了一天。</p><p>今天 (2024 年 5 月 2 日) 开始想试试下 llama.cpp，之前 LMStudio 用了一阵子了，感觉虽然挺方便，但毕竟又套了一层，而且有些参数也是不直接提供的。<br />另外 koboldcpp 也试用了下，UI 界面其实挺简单，但竟然没提供设置自动保存 (需要手动存储，然后手动加载才能恢复设置 -- 特指客户端的界面，它提供的 Web 端会自动存储在浏览器)。</p><p>所以想了下，既然大家都是从 llama.cpp 上发展过来的，还不如直接上 llama.cpp。</p><p>llama.cpp 项目几乎是目前所有本地运行 GGUF LLM 模型的源头，同时虽然不像 LMStudio 那样直接提供 Rocm 版本运行程序，但貌似也可以直接编译，而且还有 Vulkan 一类一样可以被 AMD GPU 加速运行 (虽然可能效率比不上 ROCM)，但是试用了下，感觉速度还蛮可以的。于是今天就开始鼓捣起流程。</p><h1 id="尝试"><a class="anchor" href="#尝试">#</a> 尝试</h1><p>llama.cpp 毕竟是纯命令行，所以就想着写些命令行脚本，然后放环境变量，方便随时执行。</p><p>昨天通过研究非安装的 Python 环境 (也就是完全不影响主机端，相当于做成绿色软件模式)，然后完全独立地安装了 OpenInterpreter，试用下来感觉命令行有时候还是挺方便的。</p><p>于是今天的想法也是通过写命令行批处理来试试，然后一键执行。<br />期间有许多模型涉及到不同参数，又研究如何传递，另外还有 llama.cpp 的 server 模式等。</p><p>然后一路看文档，一路实验和研究。<br />最后脚本写好了，执行起来才发现 llama.cpp 的 server 其实也还是个 WIP 版，用起来跟相比 LMStudio 的 Server 还挺多问题。</p><p>例如，尝试了下 SillyTavern 完全没法用，生成一堆乱码一样的东西，而且 SillyTavern 一乱，其它地方的客户端再去请求这个 Server，收到的也是乱码了！<br />也就是说 llama.cpp 的 server 不同客户端连过去执行还会混掉？</p><h1 id="系统提示"><a class="anchor" href="#系统提示">#</a> 系统提示</h1><p>先是怀疑指令提示的问题 (也即是 --chat-template)，比如模型的指令提示不兼容，于是查了文档，发现目前版本的指令提示已经会自动从模型取了：<br /><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dnZXJnYW5vdi9sbGFtYS5jcHAvd2lraS9UZW1wbGF0ZXMtc3VwcG9ydGVkLWJ5LWxsYW1hX2NoYXRfYXBwbHlfdGVtcGxhdGU=">https://github.com/ggerganov/llama.cpp/wiki/Templates-supported-by-llama_chat_apply_template</span><br /><img data-src="/blogimages/2024/2024-05-12/1.png" alt="image.png" /><br /> 而且只支持预定义模板。<br />反正研究了下，感觉没啥用。<br />然后在文档上找到个 system_prompt 的描述，也就是 --system-prompt-file FNAME 命令，于是猜测是不是系统提示被盖掉了的原因？(感觉又不像，客户端怎么会)<br /> 不过试了下似乎有改善，也就是好像不会混了：即 SillyTavern  请求了乱码之后，其它客户端再请求也会是好的，但尝试去掉 --system-prompt-file 之后，貌似也是好了.... 所以想不通。<br />SillyTavern 反正也还是乱码，有的模型在 llama.cpp server 本身输出是好的，但是在 ChatGPT Sidebar 里边输出最后还老跟一个 &quot;&lt;|im_end|&gt;&quot; 符号，不知道咋回事。</p><h1 id="反提示"><a class="anchor" href="#反提示">#</a> 反提示</h1><p>结果查询，LLM 回答的最后跟一个 &quot;&lt;|im_end|&gt;&quot; 可能跟反提示有关。<br /><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FiZXRsZW4vbGxhbWEtY3BwLXB5dGhvbi9pc3N1ZXMvNzU5">https://github.com/abetlen/llama-cpp-python/issues/759</span><br /><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2gyb2FpL2gyb2dwdC9pc3N1ZXMvMTIwMA==">https://github.com/h2oai/h2ogpt/issues/1200</span><br /> 打开 LMStudio 的 Preset 目录，以 ChatML 为例：</p><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ChatML"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token property">"system_prompt"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token property">"input_prefix"</span><span class="token operator">:</span> <span class="token string">"&lt;|im_end|>\n&lt;|im_start|>user\n"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token property">"input_suffix"</span><span class="token operator">:</span> <span class="token string">"&lt;|im_end|>\n&lt;|im_start|>assistant\n"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token property">"antiprompt"</span><span class="token operator">:</span> <span class="token punctuation">[</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token string">"&lt;|im_start|>"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token string">"&lt;|im_end|>"</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">]</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token property">"pre_prompt_prefix"</span><span class="token operator">:</span> <span class="token string">"&lt;|im_start|>system\n"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token property">"pre_prompt_suffix"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token property">"pre_prompt"</span><span class="token operator">:</span> <span class="token string">"Perform the task to the best of your ability."</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>其中 antiprompt 应该就是反提示了，听说这个字段主要是用于停止搜索使用。<br />我测试出问题的模型 (SOVL_Llama3_8B-Q8_0-imat.gguf) 是基于 llama3 基础上训练的，怀疑微调训练的时候用了 ChatML 格式的提示，导致如上截图，llama.cpp 读取内嵌提示信息不匹配导致。<br />于是把 LMStudio ChatML 预设拷贝了一份出来，改了下然后加入加载模型参数的命令 system_prompt 上：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token string">"%LLAMACPP_PATH%/server"</span> <span class="token parameter variable">--mlock</span> <span class="token parameter variable">-c</span> <span class="token number">4096</span> <span class="token parameter variable">-ngl</span> %GPU_LAYER_COUNT% <span class="token parameter variable">-m</span> %FILE_NAME% <span class="token parameter variable">-spf</span> preset/minipreset.json --log-format text <span class="token parameter variable">--port</span> <span class="token number">1357</span></pre></td></tr></table></figure><p>运行之后，作为 llama3 竟然直接回答中文了：<br /><img data-src="/blogimages/2024/2024-05-12/2.png" alt="image.png" /><br />... 虽然在 slider 上，回答最后还是会加上 &quot;&lt;|im_end|&gt;&quot; .....<br />SillyTavern 也还是乱码：<br /><img data-src="/blogimages/2024/2024-05-12/3.png" alt="image.png" /></p><h1 id="原因"><a class="anchor" href="#原因">#</a> 原因</h1><p>后来偶然又用 LMStudio 试了下，结果发现如果不手动选取 llama3 的提示， LMStudio 同样会有这个输出问题.....<br /><img data-src="/blogimages/2024/2024-05-12/4.png" alt="image.png" /><br /> 于是再次使用 --chat-template llama3 加载，结果竟然好了..... 再仔细一看上面的日志截图， llama.cpp 默认加载的模板，可不就是 ChatML 格式的吗.... 这应该是训练的时候用了 ChatML 的提示，导致被量化到量化文件里了。<br />我怀疑基座模型和指令模型的还有一个区别就是，在于是否把提示也炼进去了？<br />这里又出现一个问题：没法解释为什么 llama.cpp server 自带的 web 是好的？<br />反正换成 llama3 模板后， Slider 就好了，llama.cpp server 日志也可以看到 build_in 变量变成了 false：<br /><img data-src="/blogimages/2024/2024-05-12/5.png" alt="image.png" /></p><p>然后 SillyTavern 还是不行，而且乱码之后经常还是会影响到其它客户端，最后在 llama.cpp server 文档上注意到这句话：<br /><img data-src="/blogimages/2024/2024-05-12/6.png" alt="image.png" /><br /><s> 搞半天别人客户端难道还可以直接修改系统提示，而且是公共的？！</s><br />试了下 koboldcpp Vulkan 加速也是乱码.... 这是后端的就有问题？！<br />最后在文档上看到一张图：<br /><img data-src="/blogimages/2024/2024-05-12/7.png" alt="image.png" /><br />Vulkan 兼容性倒数第二....<br /> 乱码的，换成 CPU 模式，至少就能跑了。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>五一节花时间研究这个，最后灰溜溜的.... 不愧是急速开发中的项目，这东西真的还不能直接用啊... 要不然还是算了。<br />前两天，Ubuntu24.04 在 4 月 25 号发布之后，也是还兴冲冲地装了 Linux 系统，结果早上装上，当天就又换回去了 —— 装个输入法都费劲，特别是由于系统比较新，一堆依赖直接已经都没了...... 本来都不留后路地想换系统，把原本 Windows 系统盘直接格掉重装的，结果还是... 唉，最后也是导致折腾得厉害.... 所以有时候还是得留点后路 —— 虽然系统重装之后，发现比之前带了一堆陈旧软件的时候似乎快了些，特别是开关机的时候 (估计是因为没装那么多驱动，比如华硕的奥创中心)。</p><hr /><p>更新 (2024 年 5 月 3 日)：</p><ul><li>SillyTavern 有 Stop words，也就是说可以规避系统提示问题 (因为是在高级设置所以之前没发现...)，也有自定义 System Prompt 的功能，也是在高级设置里面...</li><li>llama.cpp 本身 Vulkan 兼容性不提，关于正常情况是好的的模型，SillyTavern 发出的消息计算后是乱码的原因倒也有些线索了，llama3 仅在 SillyTavern 请求时回复一堆乱码，应该也算是破案了一点了：</li><li><img data-src="/blogimages/2024/2024-05-12/8.png" alt="image.png" /></li><li>开启 verbose 模式，可以看到，接收端已经乱了，估摸着还是编码问题导致，至于究竟是 llama.cpp server 解析端有问题还是 SillyTavern 发送端有问题，个人倾向于解析端 —— 毕竟其它第三方 server 测试至少正常对话的模型，SillyTavern 也是好的，估计 llama.cpp 用纯 C 实现的解析方式对编码兼容性可能还有点问题。</li><li>不止是中文，默认的英文提示也会出现问题：</li><li><img data-src="/blogimages/2024/2024-05-12/9.png" alt="image.png" /></li><li>对比下原文：</li><li><img data-src="/blogimages/2024/2024-05-12/10.png" alt="image.png" /></li></ul><hr /><p>继续更新：</p><ul><li>又仔细研究了下 llama.cpp server 的文档，最后把怀疑的目光指向了两个参数：<ul><li>-cb, --cont-batching: Enable continuous batching (a.k.a dynamic batching). Default: disabled</li><li>--slots-endpoint-disable: To disable slots state monitoring endpoint. Slots state may contain user data, prompts included.</li></ul></li><li>这两个参数看起来都非常可疑：<ul><li>第一个动态连续批处理，看解释好像是说提高吞吐量的，怀疑是不是导致不同客户端请求混淆的原因？而且文档说是默认关闭，实际上运行程序帮助信息又显示是默认开启：<img data-src="/blogimages/2024/2024-05-12/11.png" alt="image.png" /></li><li>第二个参数是禁用 slots 功能，官方文档没有更多解释，只这样说可能包含一些用户数据、提示什么的，不过看其它地方好像是指 “某个端点上提供的扩展接口，允许用户插入额外的设备或功能来增强端点的性能或功能” 这种意思。那么，是否就是这个功能导致 SillyTavern 一些额外参数将其影响到了？</li></ul></li><li>应该确认了，连续处理确实对不同客户端都有影响，新鲜出炉的 BUG (也不能说新鲜出炉，应该还是有一阵子了)：<ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dnZXJnYW5vdi9sbGFtYS5jcHAvaXNzdWVzLzcwNTI=">https://github.com/ggerganov/llama.cpp/issues/7052</span></li><li><img data-src="/blogimages/2024/2024-05-12/12.png" alt="image.png" /></li></ul></li></ul><hr /><ul><li>再次尝试 --slots-endpoint-disable ，该参数对于乱码情况无效。</li><li>实测如果仅仅只是开场少数几个 Token，能够正常回答，当 Token 量较大时，无论如何都会乱码。或者新开几个对话，直接就炸了，疯狂输出乱码，还有可能导致整个 Server 持续 100% GPU 占用停不下来......</li></ul><h1 id="更新"><a class="anchor" href="#更新">#</a> 更新</h1><p>2024 年 5 月 12 日更新：</p><ul><li>llama.cpp server b2860 已经修复上述问题</li><li>所以上述猜测可能也不正确</li></ul><p>那么就顺便帖一下之前写的 bat 代码，主要分为两部分，一部分是作为工作的核心，另外一个作为简单参数的调用：<br />llamacpp.bat (核心)：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre>@echo off</pre></td></tr><tr><td data-num="2"></td><td><pre>setlocal enabledelayedexpansion</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>rem 第一个参数是相对路径</pre></td></tr><tr><td data-num="5"></td><td><pre>rem 第二个参数是 GPU 卸载层数</pre></td></tr><tr><td data-num="6"></td><td><pre>rem 可选参数为 <span class="token builtin class-name">set</span> <span class="token assign-left variable">CHAT_TEMPLATE</span><span class="token operator">=</span>llama3</pre></td></tr><tr><td data-num="7"></td><td><pre>rem -    是否有强制聊天模板参数，没有就走默认，否则走强制；这是因为默认的受量化内嵌参数影响，可能解析出错</pre></td></tr><tr><td data-num="8"></td><td><pre>rem -    chatml,llama2,llama3,monarch,gemma,orion,openchat,vicuna,vicuna-orca,deepseek,command-r,zephyr</pre></td></tr><tr><td data-num="9"></td><td><pre>rem -    CHAT_TEMPLATE 模板参见：https://github.com/ggerganov/llama.cpp/wiki/Templates-supported-by-llama_chat_apply_template</pre></td></tr><tr><td data-num="10"></td><td><pre>rem 其它额外参数：</pre></td></tr><tr><td data-num="11"></td><td><pre>rem -   上下文长度<span class="token punctuation">(</span>默认4096<span class="token punctuation">)</span>：CONTEXT_SIZE<span class="token operator">=</span><span class="token number">4096</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token builtin class-name">set</span> <span class="token assign-left variable">FILE_NAME</span><span class="token operator">=</span>%~dp0<span class="token punctuation">..</span>/LLM_Models/%1</pre></td></tr><tr><td data-num="14"></td><td><pre>@REM <span class="token builtin class-name">set</span> <span class="token string">"SYSTEM_PROMPT=-spf config-presets/chatml.preset.json"</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>echo.</pre></td></tr><tr><td data-num="17"></td><td><pre>echo.</pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token builtin class-name">echo</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token builtin class-name">echo</span> <span class="token assign-left variable">model</span><span class="token operator">=</span>%1</pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token keyword">if</span> not exist <span class="token string">"%FILE_NAME%"</span> <span class="token punctuation">(</span> </pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token builtin class-name">echo</span> The <span class="token function">file</span> %FILE_NAME% does not exist.</pre></td></tr><tr><td data-num="23"></td><td><pre>    goto :end</pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>rem 主要用来检测卸载 GPU 层的参数的</pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">if</span> <span class="token string">"%2"</span><span class="token operator">==</span><span class="token string">""</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    rem 没传就全卸载</pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token builtin class-name">set</span> <span class="token string">"GPU_LAYER_COUNT=10000"</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token builtin class-name">echo</span> Using gpu layers: <span class="token number">100</span>%%</pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token builtin class-name">set</span> <span class="token string">"GPU_LAYER_COUNT=%2"</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token builtin class-name">echo</span> Using gpu layers: %2</pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre>rem 获取文件目录路径</pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token keyword">for</span> /F <span class="token string">"tokens=* delims="</span> %%a <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token string">"%FILE_NAME%"</span><span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token builtin class-name">set</span> <span class="token string">"FILE_PATH=%%~dpa"</span> </pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token builtin class-name">break</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="41"></td><td><pre></pre></td></tr><tr><td data-num="42"></td><td><pre>rem <span class="token builtin class-name">echo</span> File Path: %FILE_PATH%</pre></td></tr><tr><td data-num="43"></td><td><pre></pre></td></tr><tr><td data-num="44"></td><td><pre>rem 检查文件路径是否同时存在多模态文件</pre></td></tr><tr><td data-num="45"></td><td><pre><span class="token keyword">if</span> defined FILE_PATH <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="46"></td><td><pre>    <span class="token keyword">for</span> /F <span class="token string">"tokens=*"</span> %%i <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token string">'dir /B /A:-D "%FILE_PATH%\"'</span><span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="47"></td><td><pre>        <span class="token builtin class-name">echo</span> %%i <span class="token operator">|</span> <span class="token function">find</span> <span class="token string">"mmproj"</span> <span class="token operator">></span>nul</pre></td></tr><tr><td data-num="48"></td><td><pre>        <span class="token keyword">if</span> not errorlevel <span class="token number">1</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="49"></td><td><pre>            <span class="token builtin class-name">set</span> <span class="token string">"MMPROJ_PATH=%FILE_PATH%%%i"</span></pre></td></tr><tr><td data-num="50"></td><td><pre>            <span class="token builtin class-name">echo</span> found mmproj: %FILE_PATH%%%i</pre></td></tr><tr><td data-num="51"></td><td><pre>            <span class="token builtin class-name">break</span></pre></td></tr><tr><td data-num="52"></td><td><pre>        <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="53"></td><td><pre>    <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="54"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="55"></td><td><pre></pre></td></tr><tr><td data-num="56"></td><td><pre>rem <span class="token builtin class-name">echo</span> <span class="token assign-left variable">mmproj</span><span class="token operator">=</span>%MMPROJ_PATH%</pre></td></tr><tr><td data-num="57"></td><td><pre><span class="token builtin class-name">echo</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span></pre></td></tr><tr><td data-num="58"></td><td><pre>echo.</pre></td></tr><tr><td data-num="59"></td><td><pre>echo.</pre></td></tr><tr><td data-num="60"></td><td><pre></pre></td></tr><tr><td data-num="61"></td><td><pre>rem 搜索 llama.cpp 路径</pre></td></tr><tr><td data-num="62"></td><td><pre><span class="token keyword">for</span> /D /r <span class="token string">"%~dp0/.."</span> %%d <span class="token keyword">in</span> <span class="token punctuation">(</span>llama-*<span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="63"></td><td><pre>    <span class="token builtin class-name">set</span> <span class="token string">"LLAMACPP_PATH=%%d"</span></pre></td></tr><tr><td data-num="64"></td><td><pre>    goto :found</pre></td></tr><tr><td data-num="65"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="66"></td><td><pre></pre></td></tr><tr><td data-num="67"></td><td><pre>:found</pre></td></tr><tr><td data-num="68"></td><td><pre>rem 是否有强制聊天模板参数，没有就走默认，否则走强制；这是因为默认的受量化内嵌参数影响，可能解析出错</pre></td></tr><tr><td data-num="69"></td><td><pre>rem <span class="token builtin class-name">echo</span> %CHAT_TEMPLATE%</pre></td></tr><tr><td data-num="70"></td><td><pre><span class="token keyword">if</span> defined CHAT_TEMPLATE <span class="token builtin class-name">set</span> <span class="token string">"CHAT_TEMPLATE=--chat-template %CHAT_TEMPLATE%"</span></pre></td></tr><tr><td data-num="71"></td><td><pre>rem <span class="token builtin class-name">echo</span> %CHAT_TEMPLATE%</pre></td></tr><tr><td data-num="72"></td><td><pre>rem <span class="token keyword">else</span> <span class="token builtin class-name">set</span> %CHAT_TEMPLATE<span class="token operator">=</span><span class="token string">""</span>%</pre></td></tr><tr><td data-num="73"></td><td><pre>@REM 上下文长度</pre></td></tr><tr><td data-num="74"></td><td><pre><span class="token builtin class-name">echo</span> %CONTEXT_SIZE%</pre></td></tr><tr><td data-num="75"></td><td><pre><span class="token keyword">if</span> defined CONTEXT_SIZE <span class="token punctuation">(</span> </pre></td></tr><tr><td data-num="76"></td><td><pre>    <span class="token builtin class-name">set</span> <span class="token string">"CONTEXT_SIZE=-c %CONTEXT_SIZE%"</span></pre></td></tr><tr><td data-num="77"></td><td><pre><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="78"></td><td><pre><span class="token builtin class-name">set</span> <span class="token string">"CONTEXT_SIZE=-c 4096"</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="79"></td><td><pre><span class="token builtin class-name">echo</span> %CONTEXT_SIZE%</pre></td></tr><tr><td data-num="80"></td><td><pre></pre></td></tr><tr><td data-num="81"></td><td><pre><span class="token keyword">if</span> defined LLAMACPP_PATH <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="82"></td><td><pre>    <span class="token builtin class-name">echo</span> found llamacpp: %LLAMACPP_PATH%</pre></td></tr><tr><td data-num="83"></td><td><pre>    rem powershell <span class="token parameter variable">-Command</span> Write-Host Found directory: %FOUND_DIR% <span class="token parameter variable">-ForegroundColor</span> Red</pre></td></tr><tr><td data-num="84"></td><td><pre>    <span class="token keyword">if</span> defined MMPROJ_PATH <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="85"></td><td><pre>        <span class="token builtin class-name">echo</span> auto with multimodal projector<span class="token punctuation">[</span>mmproj<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="86"></td><td><pre>        <span class="token string">"%LLAMACPP_PATH%/server"</span> <span class="token parameter variable">--mlock</span> <span class="token parameter variable">-c</span> <span class="token number">4096</span> <span class="token parameter variable">-ngl</span> %GPU_LAYER_COUNT% <span class="token parameter variable">-m</span> %FILE_NAME% <span class="token parameter variable">--port</span> <span class="token number">1357</span> <span class="token punctuation">;</span>--mmproj %MMPROJ_PATH% </pre></td></tr><tr><td data-num="87"></td><td><pre>    <span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="88"></td><td><pre>        <span class="token builtin class-name">echo</span> <span class="token keyword">in</span> regular mode because not found multimodal projector<span class="token punctuation">[</span>mmproj<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="89"></td><td><pre>        <span class="token string">"%LLAMACPP_PATH%/server"</span> <span class="token parameter variable">--mlock</span> %CONTEXT_SIZE% <span class="token parameter variable">-ngl</span> %GPU_LAYER_COUNT% <span class="token parameter variable">-m</span> %FILE_NAME% %CHAT_TEMPLATE% %SYSTEM_PROMPT% <span class="token parameter variable">--port</span> <span class="token number">1357</span> --slots-endpoint-disable --log-disable --no-kv-offload</pre></td></tr><tr><td data-num="90"></td><td><pre>        @REM  <span class="token parameter variable">-v</span> --ubatch-size <span class="token number">64</span> </pre></td></tr><tr><td data-num="91"></td><td><pre>        @REM --no-kv-offload :默认 KV Cahche 卸载到 CPU，加上这个就会一直处于 GPU，内存要求更高</pre></td></tr><tr><td data-num="92"></td><td><pre>    <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="93"></td><td><pre>    rem call <span class="token string">"%FOUND_DIR%\script.bat"</span></pre></td></tr><tr><td data-num="94"></td><td><pre>    goto :end</pre></td></tr><tr><td data-num="95"></td><td><pre><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="96"></td><td><pre>    <span class="token builtin class-name">echo</span> No matching LLAMACPP directory found.</pre></td></tr><tr><td data-num="97"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="98"></td><td><pre></pre></td></tr><tr><td data-num="99"></td><td><pre>:end</pre></td></tr></table></figure><p>调用，例如：</p><figure class="highlight basic"><figcaption data-lang="BASIC"></figcaption><table><tr><td data-num="1"></td><td><pre>@echo <span class="token keyword">off</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">set</span> CONTEXT_SIZE<span class="token operator">=</span><span class="token number">8000</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">call</span> llamacpp.bat Meta\Llama3\Hermes<span class="token operator">-</span><span class="token number">2</span><span class="token operator">-</span>Pro<span class="token operator">-</span>Llama<span class="token operator">-</span><span class="token number">3</span><span class="token operator">-</span><span class="token number">8</span>B<span class="token operator">-</span>Q8_0.gguf</pre></td></tr></table></figure><hr /><p>所以最后准备自己写代码了，直接调 llama.cpp 来用。</p><h1 id="参考文档"><a class="anchor" href="#参考文档">#</a> 参考文档</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dnZXJnYW5vdi9sbGFtYS5jcHAvdHJlZS9tYXN0ZXIvZXhhbXBsZXMvc2VydmVyI2NoYW5nZS1zeXN0ZW0tcHJvbXB0LW9uLXJ1bnRpbWU=">https://github.com/ggerganov/llama.cpp/tree/master/examples/server#change-system-prompt-on-runtime</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dnZXJnYW5vdi9sbGFtYS5jcHAvd2lraS9UZW1wbGF0ZXMtc3VwcG9ydGVkLWJ5LWxsYW1hX2NoYXRfYXBwbHlfdGVtcGxhdGU=">https://github.com/ggerganov/llama.cpp/wiki/Templates-supported-by-llama_chat_apply_template</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FiZXRsZW4vbGxhbWEtY3BwLXB5dGhvbi9pc3N1ZXMvNzU5">https://github.com/abetlen/llama-cpp-python/issues/759</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2gyb2FpL2gyb2dwdC9pc3N1ZXMvMTIwMA==">https://github.com/h2oai/h2ogpt/issues/1200</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0Bhbm1vbHRhbHdhci9wcm9tcHQtcHJlLWZpeGluZy1mb3ItbGxtLWVmZmljaWVudC16ZXJvLXNob3QtcHJvbXB0aW5nLWZhNGM3NzNlNDM3NQ==">https://medium.com/@anmoltalwar/prompt-pre-fixing-for-llm-efficient-zero-shot-prompting-fa4c773e4375</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dnZXJnYW5vdi9sbGFtYS5jcHAvaXNzdWVzLzYzOTE=">https://github.com/ggerganov/llama.cpp/issues/6391</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dnZXJnYW5vdi9sbGFtYS5jcHAvaXNzdWVzLzcwNTI=">https://github.com/ggerganov/llama.cpp/issues/7052</span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;2024 年 5 月 1 日：研究 Python 绿色化执行环境，安装 OpenInterpreter，各种折腾了一天。&lt;/p&gt;
&lt;p&gt;今天 (2024 年 5 月</summary>
      
    
    
    
    <category term="AI" scheme="https://wangjiaying.top/categories/AI/"/>
    
    
    <category term="AI" scheme="https://wangjiaying.top/tags/AI/"/>
    
    <category term="llama.cpp" scheme="https://wangjiaying.top/tags/llama-cpp/"/>
    
  </entry>
  
  <entry>
    <title>使用Mac系统需要做的一点配置记录</title>
    <link href="https://wangjiaying.top/2023/12/24/%E4%BD%BF%E7%94%A8Mac%E7%B3%BB%E7%BB%9F%E4%B8%8D%E5%BE%97%E4%B8%8D%E5%81%9A%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>https://wangjiaying.top/2023/12/24/%E4%BD%BF%E7%94%A8Mac%E7%B3%BB%E7%BB%9F%E4%B8%8D%E5%BE%97%E4%B8%8D%E5%81%9A%E7%9A%84%E9%85%8D%E7%BD%AE/</id>
    <published>2023-12-24T02:59:14.000Z</published>
    <updated>2024-01-21T06:17:32.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>这应该算是第一次正式使用 Mac 系统 —— 如果不算早在当年大学时候，往自己笔记本上装『黑苹果』的经历的话，那会其实也因为软件生态、黑苹果兼容性问题，仅仅只是简单试用了一番罢了。<br />说来，当年大学时倒是三天两头把自己笔记本的系统重装掉：双系统、三系统都搞过，不知为啥，反而工作之后，不再想折腾了。</p><p>所以，对于 Mac 本身，我自己当然不可能主动体验，一是没必要，二是 Mac 本身对个人来说还是太奢侈了... 只是最近换了工作之后，新公司竟然直接就是 Mac 作为开发机，也算是体验了一把。</p><p>回溯到以前使用 Linux 系统的时代：大学时候？早已快 10 年以前的了吧？</p><p>因此开始还是适应了两天，比如开发环境配置等、然后按照自己使用 (Windows) 习惯，自定义了一波。<br />于是想把过程记录一下，要是哪天换了系统或者找找工具，还可参考一下。</p><h1 id="系统配置"><a class="anchor" href="#系统配置">#</a> 系统配置</h1><h2 id="输入"><a class="anchor" href="#输入">#</a> 输入</h2><h3 id="交换-ctrl-和-command-键"><a class="anchor" href="#交换-ctrl-和-command-键">#</a> 交换 Ctrl 和 Command 键</h3><p>Mac 上的的组合快捷键以 Command 键为准，例如 Windows 上的 『Ctrl+C、Ctrl+V』，在 Mac 上对应是 『Command+C、Command+V』，为了避免体验割裂，最好还是保持一致的好：</p><ul><li>设置 -&gt; 键盘 -&gt; 键盘快捷键 -&gt; 修饰键：</li><li><img data-src="/blogimages/2023/2023-12-24/key.jpg" alt="" /></li></ul><p>(注：只是适用于习惯 Windows 操作的，如果能适应 Mac 本身也可以不用改)</p><h3 id="鼠标滚动方向"><a class="anchor" href="#鼠标滚动方向">#</a> 鼠标滚动方向</h3><p>默认情况下，鼠标自然滚动 (往上滑内容是往下、往下滑内容往上)，需要将</p><ul><li>鼠标 -&gt; 自然滚动关闭<br />才是跟正常情况一致。</li></ul><h3 id="快捷操作"><a class="anchor" href="#快捷操作">#</a> 快捷操作</h3><ul><li>Command+Shift+. ：显示 / 隐藏文件</li></ul><p>注：还有显示文件名后缀，也可以在设置找到</p><h1 id="开发软件"><a class="anchor" href="#开发软件">#</a> 开发软件</h1><p>当然，这里主要是指个人工作相关的了。</p><ul><li>Rider<ul><li>Mac 就没有 VisualStudio 了 (VisualStudio for mac 例外，不过那个更像以前 Unity 自带的 MonoDevelp ，不是很好用，而且听说官方都准备放弃了)</li><li>不过以目前使用情况来看， Rider 比 VS 还好用，各种智能提示，语法优化，感觉用来起来比 VS 还强</li><li>快捷键可以选择 VS (Mac) 版本，如果之前更换过装饰键，智能提示快捷键可能需要稍微调一下</li></ul></li><li>CSharpRepl<ul><li>交互式命令行执行 C# 的工具，测试很方便</li></ul></li><li>SourceTree<ul><li>GIT 前端图形管理用的这个，用习惯了感觉也还挺不错</li></ul><ul><li>SourceTree 配置 BeyoudCompare<ul><li>ln -s /Applications/Beyond\ Compare.app/Contents/MacOS/bcomp /usr/local/bin/</li><li>注意：/usr/local/bin/ 目录本身可能不存在，需要手动创建</li></ul></li></ul></li><li>VSCode<ul><li>懂得都懂，一般都会装一个</li></ul></li></ul><h1 id="功能软件"><a class="anchor" href="#功能软件">#</a> 功能软件</h1><ul><li>Mos<ul><li>平滑滚动，Mac 上鼠标滚动完全没有触摸板那样流畅，这个可以提升效果的</li><li>当然本身做一些效果的时候建议还是关掉... 不然自己这边流畅，拿到别人那边看就卡了</li></ul></li><li>AltTab<ul><li>Alt+Tab 切换程序的功能</li><li>没注意 Mac 上切换程序是哪个快捷键，不过无所谓了，换成 Window 的切换模式还是比较方便的</li></ul></li><li>性能监控<ul><li>腾讯柠檬清理：显示网速、清理等 (可以安装一个把自启动关了，Mac 卸载软件残留比较厉害，还是可以装一个备着)</li><li>Stats for Mac (个人就在用这个做状态栏监控)</li><li>eul (没用过，听说可以)</li></ul></li><li>解压缩：Keka</li><li>截图工具：<ul><li>Snipaste (跨平台的，Win 也是在用这个)</li></ul></li><li>运行 Win app：<ul><li>Whisky：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1doaXNreS1BcHAvV2hpc2t5">https://github.com/Whisky-App/Whisky</span></li><li>GPTK</li><li>Parrallels Desktop (收费)</li><li>注：个人还没试用过，只是简单收集了下</li></ul></li><li>录屏工具<ul><li>Kap：也支持导出 GIF</li><li>GIF 录制：giphy</li><li>Obs 录屏工具</li><li>CleanShotX</li><li>ScreenFlow</li><li>注：个人还没试用过，只是收集了下，另外如果安装了 QQ 也自带了录屏 (这个用过)</li></ul></li><li>录音工具：Piezo</li><li>OCR 文字识别<ul><li>Mac 系统自带 (打开某张图片即可)</li></ul></li><li>隐藏过多状态栏：HidenBar</li><li>U 盘写入：Mounty for NTFS (未使用)</li><li>图床管理：PicGo (未使用)</li><li>视频播放：IINA (未使用)</li><li>图片除水印：Inpaint (未使用)</li></ul><p>其它参考：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MjA1NDk1ODg/dXRtX3Bzbj0xNzE2MzgyNzYxNTU0Njk0MTQ1">Mac 软件清单和使用技巧推荐</span></p><h1 id="github-ssh"><a class="anchor" href="#github-ssh">#</a> GITHUB SSH</h1><p>注：应使用 “账户名” 而非 “用户名”</p><ol><li><p>生成秘钥</p><ul><li>ssh-keygen -t ed25519 -C &quot;<span class="exturl" data-url="bWFpbHRvOnlvdXJfZW1haWxAZXhhbXBsZS5jb20=">your_email@example.com</span>&quot;</li><li>旧系统： ssh-keygen -t rsa -b 4096 -C &quot;<span class="exturl" data-url="bWFpbHRvOnlvdXJfZW1haWxAZXhhbXBsZS5jb20=">your_email@example.com</span>&quot;</li><li>注：上面的方式只用过一次，忘了行不行了，若使用 Sourcetree 可以直接由 Sourcetree 自动生成：</li><li><img data-src="/blogimages/2023/2023-12-24/ssh_sourcetree.jpg" alt="" /></li></ul></li><li><p>添加私钥</p><ul><li>ssh-add -K ~/.ssh/jiayingwang-GitHub</li><li>ssh-add ~/.ssh/jiayingwang-GitHub</li><li>ssh-add --apple-use-keychain ~/.ssh/ 私钥名字</li></ul></li><li><p>测试是否有效 (或初始化连接)</p><ul><li>ssh -T <span class="exturl" data-url="bWFpbHRvOmdpdEBnaXRodWIuY29t">git@github.com</span></li><li>(执行完毕后，如果秘钥正确会提示是否连接，输入 yes 即可)</li><li>检查秘钥是否正在使用<ul><li>ssh -vT <span class="exturl" data-url="bWFpbHRvOmdpdEBnaXRodWIuY29t">git@github.com</span></li></ul></li><li>查看本地 SSH SHA256 (公钥指纹)<ul><li>ssh-add -l -E sha256</li></ul></li></ul></li><li><p>启动 SSH 代理</p><ul><li>注：一般不需要主动执行该步骤，理论上上面测试连接连接成功就可以了</li><li>eval &quot;$(ssh-agent -s)&quot;</li></ul></li></ol><p>SSH 更多参考：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vZW4vYXV0aGVudGljYXRpb24vdHJvdWJsZXNob290aW5nLXNzaC9lcnJvci1wZXJtaXNzaW9uLWRlbmllZC1wdWJsaWNrZXk=">https://docs.github.com/en/authentication/troubleshooting-ssh/error-permission-denied-publickey</span></li></ul><hr /><p>手动配置 git 代理</p><ul><li>git config --global http.proxy <span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMTo3ODkw">http://127.0.0.1:7890</span></li><li>git config --global https.proxy <span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMTo3ODkw">http://127.0.0.1:7890</span></li></ul><p>扩展信息 - 取消代理：</p><ul><li>git config --global --unset http.proxy</li><li>git config --global --unset https.proxy</li></ul><p>使用 SSH 代理</p><ul><li><img data-src="/blogimages/2023/2023-12-24/ssh.jpg" alt="" /></li><li>在 .ssh 目录 config 文件添加：ProxyCommand nc -X connect -x 127.0.0.1:7890 % h % p</li><li>注 1：# SSH 代理可能出现 kex_exchange_identification: Connection closed by remote host Connection closed by UNKNOWN port 65535 这种错误</li><li>注 2：直接用 HTTPS 拉取可能会更好点 (反正后来我是换回来了)</li></ul><h1 id="软件类型"><a class="anchor" href="#软件类型">#</a> 软件类型</h1><p>Mac 自从出了自己的 M 芯片 (也就是 ARM 架构) 后，由于指令集与 X86 不同，因此新版的 M 芯片有专门的 Silicon 版本编译软件。</p><p>否则如果直接安装普通 (Intel X86) 软件，运行时会以 Rostta 转译模式运行，性能上相对会差一筹，因此建议如果是 M 芯片的机器看到软件提供了 Silicon 版本一定要选择 Silicon 版本。</p><p>Slicon 版本在性能、能耗上都有更大提升 —— 其实这也是令人惊讶的一点：作为 ARM 架构 CPU 的笔记本，效率竟然这么高了。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>目前也差不多工作使用快两个月了，感觉 Mac 虽然作为笔记本，但工作使用上感觉比以前公司的 Window 台式还强，当然... 也可能是以前台式机配置问题......</p><p>另外，最近好像都没怎么写文章了，因此还是稍微总结下系统使用，记录记录。</p><p>总体看了下，记录的似乎更多是使用软件层面的了，平时应该还有一些操作，没有记录就被我忘了... 先这样吧，后续有再补充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;这应该算是第一次正式使用 Mac 系统 —— 如果不算早在当年大学时候，往自己笔记本上装『黑苹果』的经历的话，那会其实也因为软件生态、黑苹果兼容性问题，仅仅只是简单</summary>
      
    
    
    
    <category term="其它" scheme="https://wangjiaying.top/categories/%E5%85%B6%E5%AE%83/"/>
    
    
  </entry>
  
  <entry>
    <title>JobSystem 的简单使用</title>
    <link href="https://wangjiaying.top/2023/11/18/JobSystem%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://wangjiaying.top/2023/11/18/JobSystem%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2023-11-18T10:05:32.000Z</published>
    <updated>2023-11-18T10:22:31.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>最近一直在忙着在新公司项目的事，从 0 到 1 设计，也是挺考验脑袋的，而且各种有用的技术都想着能不能有所帮助，然后用一用，感觉能写的还是不少，但又似乎感觉没有可成文的深入 (时间) 程度。</p><p>不过好像也都有段时间没写点成文的文章了，趁周末稍微整理下 JobSystem 的东西记一记吧 —— ECS 直接用到项目可能存在能不能把握住的问题，现在也不大敢用，JobSystem 这东西后面倒是可以整一整。</p><p>而且单独用似乎也挺简单的，用到重要的地方也不会对架构本身产生过大影响 (不像 GPU Driven 类的优化，ComputeShader 还要担心可能存在的兼容性问题)。</p><h1 id="基础"><a class="anchor" href="#基础">#</a> 基础</h1><h2 id="job-调度方式"><a class="anchor" href="#job-调度方式">#</a> Job 调度方式</h2><ul><li>Run：直接在主线程执行 (立即)</li><li>Schedule：单个 Worker 线程或主线程执行</li><li>ScheduleParallel：多个 Worker 线程同时执行 (有数据竟态问题)</li></ul><p>第一种 Run 方式不提，一般来说用到 Job 的话，就不会仅使用 Run 了，主要执行还是靠后两个接口。</p><h3 id="计划"><a class="anchor" href="#计划">#</a> 计划</h3><p>Schedule 或 ScheduleParallel，可以称为 『计划』：</p><ul><li>表示分配一个工作线程<ul><li>JobHandler handle=job.Schedule()</li></ul></li></ul><h3 id="执行"><a class="anchor" href="#执行">#</a> 执行</h3><p>计划之后则称为执行：</p><ul><li>实际执行<ul><li>handle.Compelete()</li></ul></li></ul><h2 id="job-依赖"><a class="anchor" href="#job-依赖">#</a> Job 依赖</h2><p>保证后者可以在被依赖 Job 执行完毕后再执行<br />可以分为 单个依赖、链式依赖、多个依赖</p><h3 id="单个依赖"><a class="anchor" href="#单个依赖">#</a> 单个依赖</h3><ul><li>例如：</li></ul><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">JobHandle</span> handle1<span class="token operator">=</span>job1<span class="token punctuation">.</span><span class="token function">Schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">JobHandle</span> handle2<span class="token operator">=</span>job2<span class="token punctuation">.</span><span class="token function">Schedule</span><span class="token punctuation">(</span>handle1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="链式依赖"><a class="anchor" href="#链式依赖">#</a> 链式依赖</h3><ul><li>依赖可以将 Job 组织成链式依赖结构，使其按照依赖顺序执行<ul><li>注：若两个 Job 同时依赖一个 Job1，当 Job1 执行完毕，不影响后两个 Job 的并行执行</li></ul></li></ul><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">JobHandle</span> handle1<span class="token operator">=</span>job1<span class="token punctuation">.</span><span class="token function">Schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">JobHandle</span> handle2<span class="token operator">=</span>job2<span class="token punctuation">.</span><span class="token function">Schedule</span><span class="token punctuation">(</span>handle1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">JobHandle</span> handle3<span class="token operator">=</span>job3<span class="token punctuation">.</span><span class="token function">Schedule</span><span class="token punctuation">(</span>handle1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="多个依赖"><a class="anchor" href="#多个依赖">#</a> 多个依赖</h3><ul><li>依赖还可以组织成一个 Job 同时依赖多个 Job 的情况</li><li>例如：</li></ul><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">MyJob</span> job1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MyJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">MyJob</span> job2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MyJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">JobHandle</span> handle1 <span class="token operator">=</span> job1<span class="token punctuation">.</span><span class="token function">Schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">JobHandle</span> handle2 <span class="token operator">=</span> job2<span class="token punctuation">.</span><span class="token function">Schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">JobHandle</span> handleCombine <span class="token operator">=</span> JobHandle<span class="token punctuation">.</span><span class="token function">CombineDependencies</span><span class="token punctuation">(</span>handle1<span class="token punctuation">,</span> handle2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token class-name">MyJob</span> job3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MyJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>job3<span class="token punctuation">.</span><span class="token function">Schedule</span><span class="token punctuation">(</span>handleCombine<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>最终甚至可以组合成依赖关系网，不过必须保证依赖关系网是无环的，否则 Job 的安全检查会报错。</p><h2 id="数据竟态安全检查"><a class="anchor" href="#数据竟态安全检查">#</a> 数据竟态 (安全检查)</h2><p>Unity 在检测到发生 Job 访问数据冲突时会抛出异常（仅编辑器生效，可开关，为谨慎性而提供，并不智能）<br />代码有两种方式使其不进行检查：</p><ul><li>[ReadOnly]：为结构体内字段添加该特性后，表示仅读取，可以同时在多个 Job 中共享</li><li>[NativeDisableContainerSafetyRestriction]：为字段添加该特性，关闭对指定数据安全检查，使其允许多个 Job 同时对一个数据进行读写 (可能会导致有常规的多线程数据不一致问题)</li></ul><p>其次可以在编辑器关闭：</p><p><img data-src="/blogimages/2023/2023-11-18/image.png" alt="" /></p><h2 id="数据类型"><a class="anchor" href="#数据类型">#</a> 数据类型</h2><p>JobSystem 用的也是结构体，配合 NativeArray<T> 一类的本机数据结构，因此推荐采用 Blitable 类型作为数据。<br />Blitable：在 C++ 下与 C# 下内存表述一致的类型</p><ul><li>Jobs 只能使用 值类型 或 非托管堆数据</li><li>C# Bool 值可能被转换为 1、2 或 4 字节的值，不一致 (所以注意 Bool 也不是哦 —— 虽然作为 C# 值类型也可以允许在 NativeArray 使用)</li></ul><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL3poLWNuL2RvdG5ldC9mcmFtZXdvcmsvaW50ZXJvcC9ibGl0dGFibGUtYW5kLW5vbi1ibGl0dGFibGUtdHlwZXM=">可直接复制到本机结构中的类型和非直接复制到本机结构中的类型 - .NET Framework</span></p><ul><li>Blitable 数据类型：<ul><li>System.Byte</li><li>System.SByte</li><li>System.Int16</li><li>System.UInt16</li><li>System.Int32</li><li>System.UInt32</li><li>System.Int64</li><li>System.UInt64</li><li>System.IntPtr</li><li>System.UIntPtr</li><li>System.Single</li><li>System.Double</li></ul></li><li>非 Blitable 数据类型：<ul><li>System.Array</li><li>System.Boolean</li><li>System.Char</li><li>System.Class</li><li>System.Object</li><li>System.String</li><li>System.Valuetype</li></ul></li></ul><h2 id="数据分配"><a class="anchor" href="#数据分配">#</a> 数据分配</h2><ul><li>Allocation Types<ul><li>Allocator.Persistent：长生命周期内存</li><li>Allocator.TempJob：只在 Job 中存在的短生命周期，4 帧以上会收到警告</li><li>Allocator.Temp：一个函数返回前的短生命周期</li></ul></li><li>例如<ul><li>NativeArray<int> nativeArray = new NativeArray<int>(arrays,Allocator.TempJob);</li></ul></li></ul><h1 id="使用方式"><a class="anchor" href="#使用方式">#</a> 使用方式</h1><p>主要是 4 个接口，其它还有一些</p><h2 id="ijob"><a class="anchor" href="#ijob">#</a> IJob</h2><p>最基础方式就是实现 IJob 接口的结构体：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">struct</span> <span class="token class-name">MyJob</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IJob</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">NativeArray<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> _native<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">NativeArray<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> _native2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>使用方式也比较简单，先分配 NativeArray：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> dataArray<span class="token operator">=</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">int</span></span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">NativeArray<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> data<span class="token operator">=</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">NativeArray<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>dataArray<span class="token punctuation">,</span>Allocator<span class="token punctuation">.</span>TempJob<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>然后创建 Job 并赋值数据 (或再次进行计划、设置依赖)：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">MyJob</span> target1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">MyJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>source<span class="token operator">=</span>dataArray<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">MyJob</span> target2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">MyJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>source<span class="token operator">=</span>dataArray<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">JobHandler</span> handle1<span class="token operator">=</span>target1<span class="token punctuation">.</span><span class="token function">Schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token class-name">JobHandler</span> handle2<span class="token operator">=</span>target2<span class="token punctuation">.</span><span class="token function">Schedule</span><span class="token punctuation">(</span>handle1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>最后执行：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>handle1<span class="token punctuation">.</span><span class="token function">Compelte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>handle2<span class="token punctuation">.</span><span class="token function">Compelte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 最后数据需要拷贝回来 (如果不是直接使用 NativeArray 的话)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>data<span class="token punctuation">.</span><span class="token function">CopyTo</span><span class="token punctuation">(</span>dataArray<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="ijobfor"><a class="anchor" href="#ijobfor">#</a> IJobFor</h2><p>上面实现 IJob 接口的，实际上只是分配给另外一个线程 (或主线程空闲时由主线程) 执行，如果想同时多个线程并行执行，则是实现 IJobFor 接口。<br />在一个线程上执行指定次数</p><ul><li>jobTarget.Run (arrayLength) // 立刻在主线程执行 arrayLength 次</li><li>jobTarget.Schedule (arrayLength,default) // 在单个 worker 线程执行 arrayLength 次</li><li>jobTarget.ScheduleParallel (arrayLength,innerloopBatchCount,default) // 在多个 worker 线程执行 arrayLength 次，innerloopBatchCount 表示每个线程最多可以执行多少次<ul><li>innerloopBatchCount 批次：任务比较轻量，使用 32 或 64，任务比较重使用 1</li></ul></li></ul><h2 id="ijobparallelfor"><a class="anchor" href="#ijobparallelfor">#</a> IJobParallelFor</h2><p>类似 IJobFor，不过这个接口只提供了 Schedule 方法用于在多个 worker 线程并行执行。<br />也就是说，它跟 IJob 的区别，大概就在于是否允许仅单个线程执行了吧？</p><h2 id="ijobparallelfortransform"><a class="anchor" href="#ijobparallelfortransform">#</a> IJobParallelForTransform</h2><p>可访问 Transform，使用 TransformAccessArray 添加对 Transform 的引用<br />改了下官方 IJobParallelFor  的示例：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">TransformJobTest</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">VelocityJob</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IJobParallelForTransform</span></span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">ReadOnly</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">public</span> <span class="token class-name">NativeArray<span class="token punctuation">&lt;</span>Vector3<span class="token punctuation">></span></span> velocity<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">float</span></span> deltaTime<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Execute</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> index<span class="token punctuation">,</span> <span class="token class-name">TransformAccess</span> transform<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            transform<span class="token punctuation">.</span>position <span class="token operator">+=</span> velocity<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">*</span> deltaTime<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">const</span> <span class="token class-name"><span class="token keyword">int</span></span> _count <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">NativeArray<span class="token punctuation">&lt;</span>Vector3<span class="token punctuation">></span></span> _velocity <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">NativeArray<span class="token punctuation">&lt;</span>Vector3<span class="token punctuation">></span></span><span class="token punctuation">(</span>_count<span class="token punctuation">,</span> Allocator<span class="token punctuation">.</span>Persistent<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">TransformAccessArray</span> _transformAccessArray<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _velocity<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            _velocity<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Random<span class="token punctuation">.</span>insideUnitCircle<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token class-name">GameObject</span> o <span class="token operator">=</span> GameObject<span class="token punctuation">.</span><span class="token function">CreatePrimitive</span><span class="token punctuation">(</span>PrimitiveType<span class="token punctuation">.</span>Cube<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        _transformAccessArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TransformAccessArray</span><span class="token punctuation">(</span>_count<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _transformAccessArray<span class="token punctuation">.</span>capacity<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            _transformAccessArray<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>GameObject<span class="token punctuation">.</span><span class="token function">Instantiate</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">.</span>transform<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token class-name"><span class="token keyword">var</span></span> job <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">VelocityJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>            deltaTime <span class="token operator">=</span> Time<span class="token punctuation">.</span>deltaTime<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="40"></td><td><pre>            velocity <span class="token operator">=</span> _velocity</pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre>        <span class="token class-name">JobHandle</span> jobHandle <span class="token operator">=</span> job<span class="token punctuation">.</span><span class="token function">Schedule</span><span class="token punctuation">(</span>_transformAccessArray<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre></pre></td></tr><tr><td data-num="45"></td><td><pre>        jobHandle<span class="token punctuation">.</span><span class="token function">Complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="47"></td><td><pre></pre></td></tr><tr><td data-num="48"></td><td><pre>    <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="49"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>        _velocity<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>        _transformAccessArray<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="53"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h1 id="burstcompiler"><a class="anchor" href="#burstcompiler">#</a> BurstCompiler</h1><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5idXJzdEAxLjgvbWFudWFsL2NzaGFycC10eXBlLXN1cHBvcnQuaHRtbA==">C#/.NET type support | Burst | 1.8.10</span><br /> 根据官方说法，这个主要就是用来配合 JobSystem 的</p><ul><li>注意数学库使用：Unity.Mathematics 中提供的</li></ul><p>支持的内置类型：</p><ul><li>bool</li><li>byte/sbyte</li><li>double</li><li>float</li><li>int/uint</li><li>long/ulong</li><li>short/ushort</li></ul><p>不支持：char、decimal、string<br /> 向量类型 (Unity.Mathematics SIMD)：</p><ul><li>bool2/bool3/bool4</li><li>uint2/uint3/uint4</li><li>int2/int3/int4</li><li>float2/float3/float4</li></ul><h1 id="其它"><a class="anchor" href="#其它">#</a> 其它</h1><p>Job 中使用的数学库：Unity.Mathmatics</p><ul><li>例如随机等常用都有提供</li></ul><p>在 Job 中获取执行的线程 Index：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">NativeSetThreadIndex</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">int</span></span> _threadIndex<span class="token punctuation">;</span></pre></td></tr></table></figure><p>获取 Job 线程最大数量：JobsUtility.MaxJobThreadCount</p><h1 id="参考文档"><a class="anchor" href="#参考文档">#</a> 参考文档</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL3poLWNuL2RvdG5ldC9mcmFtZXdvcmsvaW50ZXJvcC9ibGl0dGFibGUtYW5kLW5vbi1ibGl0dGFibGUtdHlwZXM=">可直接复制到本机结构中的类型和非直接复制到本机结构中的类型 - .NET Framework</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5idXJzdEAxLjgvbWFudWFsL2NzaGFycC10eXBlLXN1cHBvcnQuaHRtbA==">C#/.NET type support | Burst | 1.8.10</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMjAuMy9TY3JpcHRSZWZlcmVuY2UvVW5pdHkuSm9icy5JSm9iRm9yLmh0bWw=">https://docs.unity.cn/cn/2020.3/ScriptReference/Unity.Jobs.IJobFor.html</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUVWNHkxZzdpeA==">https://www.bilibili.com/video/BV1EV4y1g7ix</span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;最近一直在忙着在新公司项目的事，从 0 到 1 设计，也是挺考验脑袋的，而且各种有用的技术都想着能不能有所帮助，然后用一用，感觉能写的还是不少，但又似乎感觉没有可成</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/categories/Unity3D/"/>
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/tags/Unity3D/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer(第五版)》-笔记(2)</title>
    <link href="https://wangjiaying.top/2023/10/22/CPP-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%AC%94%E8%AE%B0-2/"/>
    <id>https://wangjiaying.top/2023/10/22/CPP-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%AC%94%E8%AE%B0-2/</id>
    <published>2023-10-22T07:57:06.000Z</published>
    <updated>2023-10-22T09:57:56.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本篇笔记从原书第二部分开始，到第三部分第十四章重载运算与类型转换结束，不过对于 第八章 (IO 库)、第九章 (顺序容器)、第十一章 (关联容器) 基本略过。<br />因为这几章个人也只是粗略翻过，考虑到就算 UE5 里边，容器算法这些估计也都是全套 UE 系列自定义的模板，所以对于标准库提供的感觉目前大概了解下、有个印象就行了。<br />同理，第十章泛型算法也是如此，不过还是记录了部分思想。</p><hr /><p>本来之前还计划国庆节把这本书看完，结果因为国庆身体中招了，加上研究了下其它 (UE5 C++ 及其动画、AI 等)，国庆后又忙于工作交接，导致现在其实也还剩了三分之一，因此觉得还是分一下阶段比较好... 可能还是得分成三份了。</p><h1 id="第九章-顺序容器"><a class="anchor" href="#第九章-顺序容器">#</a> 第九章 顺序容器</h1><ul><li><code>vector</code> ：可变大小数组，具有 size 和 capacity，当添加元素导致 size 超出 capacity 则翻倍扩容。</li><li><code>deque</code> ：双端队列，支持快速随机访问，在 头 (尾) 插入 (删除) 元素很快。</li><li><code>list</code> ：双向链表</li><li><code>forward_lis</code> t：单链表</li><li><code>array</code> ：固定大小数组，与内置数组相比更安全、更容易使用</li><li><code>string</code> ：与 vector 类似，保存字符容器</li></ul><p>容器适配器</p><ul><li><code>stack</code> ：栈，默认基于 deque 实现。</li><li><code>queue</code> ：队列，默认基于 deque 实现。</li><li><code>priority_queue</code> ：优先级队列，默认基于 vector 实现。</li></ul><h1 id="第十章-泛型算法"><a class="anchor" href="#第十章-泛型算法">#</a> 第十章 泛型算法</h1><p>标准库并未给每个容器都定义成员函数来实现各种操作，而是定义了一组 泛型算法。</p><ul><li>这组算法实现了一些经典算法的公共接口 (如排序、搜索)</li><li>一般情况这些算法不直接操作容器，而是遍历由两个迭代器指定的元素范围</li><li>迭代器令算法不依赖于容器：泛型算法本身不执行容器的操作，而是运行于迭代器之上，执行迭代器操作</li></ul><h2 id="lamda-表达式"><a class="anchor" href="#lamda-表达式">#</a> lamda 表达式</h2><p>对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它为可调用的。</p><ul><li>函数和函数指针</li><li>重载了函数调用运算符的类</li><li>lambda 表达式</li></ul><p>一个 lambda 表达式表示一个可调用的代码单元，可理解为一个未命名的内联函数。</p><ul><li><code>[捕获列表](参数列表)-&gt;返回类型&#123;函数体&#125;</code></li><li>参数列表和返回类型可被忽略： <code>auto f=[]&#123;return 42;&#125;</code></li><li>注：捕获列表只用于局部非 static 变量，lambda 可直接使用局部 static 变量和它所在函数之外声明的名字。</li></ul><p>lambda 捕获和返回</p><ul><li>当定义一个 lambda 时，编译器生成一个与 lambda 对应的新的 (未命名的) 类类型。</li><li>默认情况下，从 lambda 生成的类都包含一个对应该 lambda 所捕获的变量的数据成员 (类似任何普通类的数据成员)，lambda 数据成员也在 lambda 对象创建时被初始化。</li></ul><p>值捕获</p><ul><li><code>auto f=[v1]&#123;return v1;&#125;</code></li><li>与传值参数类似，采用值拷贝的前提是变量可以拷贝，与参数不同，被捕获的变量在 lambda 创建时被拷贝 (进 lambda 数据成员)。</li></ul><p>引用捕获</p><ul><li><code>auto f=[&amp;v1]&#123;return v1;&#125;</code></li><li>以引用捕获方式与其它任何类型的引用的行为类似，当在 lambda 内使用时，实际操作的是引用所绑定对象。</li><li>引用捕获与返回引用有相同问题和限制：必须确保执行时被引用对象依然存在。</li></ul><p>隐式捕获</p><ul><li>让编译器根据 lambda 体中的代码来推断需要使用哪些变量</li><li>捕获列表：&amp;(引用捕获) 或 =(值捕获)</li><li>可混合使用： <code>[&amp;,c]xxxx、[=,&amp;c]xxxx</code> ，捕获列表中第一个元素 (&amp; 或 =) 指定了默认捕获方式为引用或值。</li></ul><p>可变 lambda</p><ul><li>默认情况下，值捕获的被拷贝的变量，lambda 不会改变其值</li><li>若想改变需要加上 mutable 关键字</li><li><code>[v1]()mutable &#123;return ++v1;&#125;</code></li></ul><h2 id="标准库-bind-函数"><a class="anchor" href="#标准库-bind-函数">#</a> 标准库 bind 函数</h2><p><code>auto newCallable=bind(callable,arg_list);</code></p><ul><li>arg_list：参数列表， 形如『 <code>_n</code> 』，n 表示参数占位符</li><li>可看作一个通用函数适配器</li><li>接受一个可调用对象，生成一个新的可调用对象来 适配 原对象的参数列表</li><li>可用 bind 修正参数的值、调整顺序等</li></ul><p>绑定引用参数</p><ul><li>引用：ref (val)，ref 返回一个对象，包含给定的引用</li><li>常量引用：cref (val)，cref 生成一个保存 const 引用的类</li><li>例：bind (print,ref (os),_1,' ')</li></ul><h2 id="再探迭代器"><a class="anchor" href="#再探迭代器">#</a> 再探迭代器</h2><p>额外迭代器：</p><ul><li>插入迭代器：绑定于容器，用于插入元素</li><li>流迭代器：绑定到输入或输出流，用于遍历关联 IO 流</li><li>反向迭代器：向后而不是向前移动，除 forward_list 均有</li><li>移动迭代器：移动元素</li></ul><h1 id="第十一章-关联容器"><a class="anchor" href="#第十一章-关联容器">#</a> 第十一章 关联容器</h1><p>按关键字有序保存元素</p><ul><li><code>map</code> ：关联数组，保存关键字 - 值对<ul><li>如果关键字还未在 map 中，下标运算会添加一个新元素</li></ul></li><li><code>set</code> ：关键字即值</li><li><code>multimap</code> ：关键字可重复出现的 map</li><li><code>multiset</code> ：关键字可重复出现的 set</li></ul><p>无序集合</p><ul><li><code>unorderd_map</code> ：哈希函数组织的 map</li><li><code>unorderd_set</code> ：哈希函数组织的 set</li><li><code>unorderd_multimap</code></li><li><code>unorderd_multiset</code></li></ul><h2 id="pair-类型"><a class="anchor" href="#pair-类型">#</a> pair 类型</h2><p>一个 pair 保存两个数据成员</p><ul><li><code>make_pair</code></li></ul><h1 id="第十二章-动态内存"><a class="anchor" href="#第十二章-动态内存">#</a> 第十二章 动态内存</h1><p>动态分配的对象生存期与它们在哪里创建无关，只有显示释放才会销毁。<br />在 C++ 中，动态内存管理运算符 new 和 delete 完成。</p><ul><li>在自由空间分配的内存是无名的，new 运算符返回指向该对象的指针</li><li><code>int *pi1=new int; //默认初始化，*pi1 的值未定义</code></li><li><code>int *pi2=new int() //值初始化为 0，*pi2 为 0</code></li><li>注：对于定义了自己构造函数的类类型来说，不管采用哪种方式都会通过默认构造函数来初始化。默认初始化和值初始化仅影响内置类型成员。</li><li>const 对象使用 new 分配是合法的 (也可以 delete)</li><li>内存耗尽时，new 表达式就会失败</li><li>由内置指针 (而非智能指针) 管理的动态内存在被显式释放前一直都会存在。</li></ul><p>空悬指针：指向一块曾经保存数据对象但现在已经无效的内存的指针。</p><h2 id="智能指针"><a class="anchor" href="#智能指针">#</a> 智能指针</h2><p>智能指针也是模板。<br />默认初始化的智能指针中保存着一个空指针，如果在一个条件判断语句中使用智能指针，效果就是检测其是否为空。</p><ul><li>解引用一个智能指针返回它指向的对象</li></ul><p>即使发生异常，(由于局部对象会被销毁) 智能指针也会释放其对象。</p><h3 id="类型"><a class="anchor" href="#类型">#</a> 类型</h3><p><code>shared_ptr</code></p><ul><li>允许多个指针指向同一个对象。</li><li>通过引用计数器记录，当我们拷贝 shared_ptr 时计数递增，被拷贝对象离开作用域被销毁递减</li><li>计数器归零则自动释放所管理对象 (通过析构函数)</li></ul><p><code>unique_ptr</code></p><ul><li>『独占』所指向的对象</li></ul><p><code>weak_ptr</code></p><ul><li>一种弱引用，指向 shared_ptr 所管理的对象</li></ul><h3 id="make_shared-函数"><a class="anchor" href="#make_shared-函数">#</a> make_shared 函数</h3><p>此函数在动态内存分配一个对象并初始化，返回指向对象的 shared_ptr</p><ul><li>可传递匹配对应对象构造函数的参数</li><li>若不传递任何参数，对象会被进行值初始化</li></ul><h3 id="shared_ptr-和-new-结合使用"><a class="anchor" href="#shared_ptr-和-new-结合使用">#</a> shared_ptr 和 new 结合使用</h3><p>这两者允许结合使用，使用 new 返回的指针初始化智能指针 (但必须使用直接初始化方式)：</p><ul><li><code>shared_ptr&lt;int&gt; p(new int(1024))</code></li><li>另外 shared_ptr 提供了 get 函数返回普通指针</li><li>reset：<ul><li>释放绑定的普通指针</li><li>或重新绑定智能指针维护的普通指针</li><li>(会更新引用计数)</li></ul></li></ul><p>注 1：默认情况下初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用 delete 释放关联对象。可使用 shared_ptr<T> p (q,d) (d 为可调用对象) 接管释放对象操作。<br />注 2：但是不要混合使用智能指针和普通指针</p><h3 id="自定义-shared_ptr-释放操作"><a class="anchor" href="#自定义-shared_ptr-释放操作">#</a> 自定义 shared_ptr 释放操作</h3><p>可以传递一个可选的指向删除器函数的参数</p><h3 id="智能指针使用注意"><a class="anchor" href="#智能指针使用注意">#</a> 智能指针使用注意</h3><ul><li>不使用相同的内置指针初始化 (或 reset) 多个智能指针</li><li>不 delete get () 返回的内置指针</li><li>不使用 get () 返回的内置指针初始化或 reset 另外一个智能指针</li><li>使用 get () 返回的内置指针时，注意智能指针自动释放后，该内置指针指向内存也会无效</li><li>如果智能指针不是管理的 new 操作符分配的动态内存，注意需要传递一个删除器以使其正确释放对象</li></ul><h3 id="unique_ptr"><a class="anchor" href="#unique_ptr">#</a> unique_ptr</h3><p>某个时刻只有一个 unique_ptr 指向一个给定对象<br />因此 unique_ptr 不支持普通的拷贝或赋值操作，只能采用直接初始化方式：</p><ul><li><code>unique_ptr&lt;int&gt; p(new int(1024))</code></li><li>注：拷贝限制的例外之处在于即将销毁时，例如允许从函数返回一个 unique_ptr</li></ul><p>需要注意的是 release 操作：</p><ul><li>该操作会切断 unique_ptr 与其管理的对象间的联系，返回对象内置指针 (不会释放对象内存)</li><li>返回的内置指针需要我们自己维护 (释放)，或转移至另外一个智能指针管理</li><li>(会导致释放对象的操作与 shared_ptr 一样，是 reset)</li></ul><h3 id="weak_ptr"><a class="anchor" href="#weak_ptr">#</a> weak_ptr</h3><p>一种不控制所指向对象生存期的智能指针，其指向一个 shared_ptr，即使有 weak_ptr 指向，当其它指向 shared_ptr 销毁时对象就会被 shared_ptr 销毁。<br />主要操作</p><ul><li>expired ()：若 shared_ptr 数量为 0 (对象可能已释放)，返回 true，否则 false</li><li>lock ()：若 expired () 为 true，返回空，否则返回 shared_ptr</li><li>use_count ()：shared_ptr 共享数量</li></ul><p>使用： <code>if(shared_ptr&lt;int&gt; p=wp.lock())&#123;&#125;</code></p><h2 id="动态数组"><a class="anchor" href="#动态数组">#</a> 动态数组</h2><ul><li>new T []，返回一个数组元素类型的指针</li><li>delete [] array，释放</li><li>或使用智能指针管理：<ul><li><code>unique_ptr&lt;int[]&gt; array(new int[10])</code></li><li><code>array.release()</code></li><li>对于 unique_ptr 指向的数组不能使用点或箭头成员运算符，但可以使用下标访问元素</li><li>注：shared_ptr 不直接支持动态数组，如果想使用 shared_ptr 管理动态数组，需要提供自定义的删除器且访问也更麻烦 (通过获取内置指针)</li></ul></li><li>注：动态数组并不是数组类型，也不能使用 begin 或 end 获取迭代器</li></ul><p>建议：大多数应用应该使用标准库容器而不是动态分配的数组。标准库容器更简单、安全，性能也更好。</p><h2 id="allocator-类"><a class="anchor" href="#allocator-类">#</a> allocator 类</h2><p>new 将内存分配和对象构造组合在了一起，灵活性更有局限。<br />allocator 类将内存分配和对象构造分离开来，其分配的内存是原始的、未构造的。<br />操作</p><ul><li><code>allocator&lt;T&gt; a</code> ：定义一个可以为类型 T 分配内存的 allocator 对象</li><li><code>allocate(n)</code> ：分配可以存储 n 个对象的原始内存</li><li><code>deallocate(p,n)</code> ：释放，调用之前必须对每个对象先调用过 destroy</li><li><code>construct(p,args)</code> ：实际构造对象</li><li><code>destroy(p)</code> ：对 p 指针指向对象执行析构函数</li></ul><p>注：为使用 allocate 返回的内存，必须用 construct 构造对象。<br />另外还提供了可以拷贝和填充未初始化内存算法：</p><ul><li><code>uninitialized_copy</code></li><li><code>uninitialized_copy_n</code></li><li><code>uninitialized_fill</code></li><li><code>uninitialized_fill_n</code></li></ul><h1 id="第十三章-拷贝控制"><a class="anchor" href="#第十三章-拷贝控制">#</a> 第十三章 拷贝控制</h1><p>当定义一个类时，我们显式指定在此类型的对象拷贝、移动、赋值和销毁时做什么：</p><ul><li>拷贝构造函数：当用同类型的另一个对象初始化本对象时做什么</li><li>拷贝赋值运算符：将一个对象赋予同类型另一个对象时做什么</li><li>移动构造函数：当用同类型的另一个对象初始化本对象时做什么</li><li>移动赋值运算符：将一个对象赋予同类型另一个对象时做什么</li><li>析构函数：销毁时做什么</li><li>注：这些操作若我们未显式定义，则编译器会自动生成</li></ul><h2 id="拷贝构造函数"><a class="anchor" href="#拷贝构造函数">#</a> 拷贝构造函数</h2><p>一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值</p><ul><li>Foo (); // 默认构造函数</li><li>Foo (const Foo&amp;); // 拷贝构造函数</li></ul><p>拷贝初始化</p><ul><li>拷贝初始化通常使用拷贝构造函数完成，不过一个类有移动构造函数时，有时会使用移动构造函数完成</li><li>string s (&quot;1&quot;) // 直接初始化</li><li>string s2=s; // 拷贝初始化</li><li>其它发生情况：<ul><li>将一个对象作为实参传递给一个非引用类型的形参</li><li>从一个返回类型为非引用类型的函数返回一个对象</li><li>花括号列表初始化一个数组中的元素或一个聚合类中的成员</li></ul></li></ul><h2 id="拷贝赋值运算符"><a class="anchor" href="#拷贝赋值运算符">#</a> 拷贝赋值运算符</h2><p>重载赋值运算符</p><ul><li>重载运算符本质上是函数，其名字由 operator 关键字后接表示要定义的运算符的符号组成</li><li>因此赋值运算符是一个名为 operator= 的函数，类似于任何其它函数</li><li>运算符函数也有一个返回类型和一个参数列表</li></ul><p>拷贝赋值运算符表现：</p><ul><li><code>Foo&amp; operator=(const Foo&amp;);</code></li></ul><p>注：注意即使一个对象赋值给自身，也需要正确工作。因此处理拷贝控制时需要临时变量做缓存，即销毁左侧运算对象资源之前拷贝右侧运算对象。</p><h2 id="析构函数"><a class="anchor" href="#析构函数">#</a> 析构函数</h2><p>资源释放<br />注 1：析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的。析构函数体作为成员销毁步骤之外的另一部分而进行。<br />注 2：根据三 / 五法则，如果一个类需要定义析构函数，几乎可以肯定它也需要自定义拷贝构造函数和拷贝赋值运算符。</p><h2 id="阻止拷贝"><a class="anchor" href="#阻止拷贝">#</a> 阻止拷贝</h2><p>可以通过将拷贝构造函数和拷贝赋值运算符定义为 删除的函数 来阻止拷贝。</p><ul><li><code>NoCopy()=default; //使用合成的默认构造函数</code></li><li><code>NoCopy(const NoCopy&amp;)=delete; //阻止拷贝</code></li><li><code>NoCopy &amp;operator=(const NoCopy&amp;) =delete; //阻止赋值</code></li></ul><p>注 1：不同于 =default，我们可以对任何函数指定 =delete<br /> 注 2：本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。</p><h2 id="拷贝控制和资源管理"><a class="anchor" href="#拷贝控制和资源管理">#</a> 拷贝控制和资源管理</h2><p>众所周知，若一个类对象被拷贝，若成员是指针，而我们定义了释放该指针的析构函数，每个发生释放的拷贝对象都会释放指针资源，导致错误问题。<br />因此需要同时重载拷贝构造函数。</p><h3 id="行为像值的类"><a class="anchor" href="#行为像值的类">#</a> 行为像值的类</h3><p>重载的拷贝构造函数或拷贝赋值运算符中，将指针对象重新分配一次，每个拷贝对象中指针都指向内容相同但实际不同的对象。<br />这样每次析构函数释放时都是释放自己指向的指针。</p><h3 id="行为像指针的类"><a class="anchor" href="#行为像指针的类">#</a> 行为像指针的类</h3><p>需要定义拷贝构造函数和拷贝赋值运算符，以拷贝成员本身而不是它指向的对象。<br />而析构函数释放关联对象内存的方式，必须是最后一个指向关联对象的该对象销毁才可以释放。</p><ul><li>因此最好的方法是使用 shared_ptr 管理类中资源</li><li>或自定义引用计算进行管理<ul><li>构造函数还需要创建一个引用计算，记录有多少对象与正在创建对象共享状态</li><li>拷贝构造函数不分配新的计数器，而是拷贝数据成员并递增共享的计数器</li><li>析构函数递减计数器，若计数器达到 0，则释放状态</li><li>拷贝赋值运算符递增右侧运算对象计数器，递减左侧运算对象计数器，同时判断左侧计数器是否为 0 以决定是否释放其资源</li><li>注：引用计数不能直接作为对象数据成员，可以使用动态内存分配指针</li></ul></li></ul><h2 id="交换操作"><a class="anchor" href="#交换操作">#</a> 交换操作</h2><p>swap 标准库函数，有时需要定义自己的 swap 覆盖标准库的函数，避免额外分配。<br />可以在赋值运算符中使用使用 swap，使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。</p><h3 id="移动构造函数与-stdmove"><a class="anchor" href="#移动构造函数与-stdmove">#</a> 移动构造函数与 std:move</h3><h2 id="对象移动"><a class="anchor" href="#对象移动">#</a> 对象移动</h2><p>IO 类和 unique_ptr 可以移动但不能拷贝</p><h3 id="右值引用"><a class="anchor" href="#右值引用">#</a> 右值引用</h3><p>左值持久，右值短暂<br /> &amp;&amp;：只能绑定到临时对象，如对象将要销毁、对象没有其它用具</p><ul><li>使用右值引用可以自由地接管所引用对象的资源</li><li>变量是左值：因此不能将右值引用直接绑定到一个变量上，即使这个变量是右值引用也不行</li></ul><p>但是允许使用 move 函数显式将一个左值转换为对应右值引用类型</p><ul><li><code>int &amp;&amp;rr3=std::move(rr1);</code></li><li>调用 move 意味着承诺：除了对 rr1 赋值或销毁它外，我们将不再使用它</li><li>注：使用 move 应使用 std:move</li></ul><h2 id="移动构造函数和移动赋值运算符"><a class="anchor" href="#移动构造函数和移动赋值运算符">#</a> 移动构造函数和移动赋值运算符</h2><p>这两个成员类似对应拷贝操作，但它们从给定对象『窃取』资源而不是拷贝资源。</p><ul><li>移动构造函数不分配任何新的内存</li><li>类名 (类名 &amp;&amp;s) noexcept:{}</li></ul><p>noexcept</p><ul><li>承诺一个函数不抛出异常</li><li>移动构造函数通常不应抛出异常，因此可以以此标识，通知标准库减少一些额外操作</li></ul><p>移动赋值运算符执行与析构函数和移动构造函数相同工作。</p><ul><li>移动赋值运算符必须销毁左侧运算对象的旧状态</li></ul><p>注 1：在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值做任何假设。<br />注 2：编译器根本不会为某些类合成移动操作。特别是一个类已定义自己的 拷贝构造函数、拷贝赋值运算符或析构函数，就不会合成移动构造函数和移动赋值运算符。—— 只有当一个类没有定义任何自己版本的拷贝控制成员，且所有数据成员都能移动构造或移动赋值时，编译器才会为其合成移动操作。<br />注 3：如果一个类没有移动构造函数或移动赋值运算符，则类会使用对应的拷贝操作来代替移动操作。</p><h2 id="右值引用的成员函数"><a class="anchor" href="#右值引用的成员函数">#</a> 右值引用的成员函数</h2><p>成员函数也可以同时提供拷贝和移动版本。</p><h2 id="引用限定符"><a class="anchor" href="#引用限定符">#</a> 引用限定符</h2><p>通过 &amp; 或 &amp;&amp; 分别指出 this 可以指向一个左值或一个右值</p><ul><li><code>Foo &amp;operator=(const Foo&amp;) &amp;; //只能向可修改的左值赋值</code></li><li><code>Foo sorted() &amp;&amp;; //可用于可改变的右值</code></li></ul><h1 id="第十四章-重载运算与类型转换"><a class="anchor" href="#第十四章-重载运算与类型转换">#</a> 第十四章 重载运算与类型转换</h1><p><img data-src="/blogimages/2023/2023-10-22/-1327189457.jpeg" alt="" /></p><p>赋值运算符</p><ul><li>例如使类型可以像 vector 一样接受花括号初始化</li><li><code>xxx &amp;operator=(std::initializer_list&lt;std::string&gt;);</code></li></ul><p>下标运算符</p><ul><li><code>operator[]</code></li></ul><p>递增和递减运算符</p><ul><li>区分前置和后置</li><li>前置返回对象引用，后置返回对象的原值</li></ul><p>成员访问运算符</p><ul><li><code>*</code></li><li><code>-&gt;</code></li><li>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</li></ul><p>函数调用运算符</p><ul><li><code>operator()</code></li><li>可以像使用函数一样使用该类对象</li><li>如果类定义了调用运算符，则该类对象称作 函数对象</li></ul><p>lambda</p><ul><li>lambda 生成的匿名类型中含有一个重载函数调用运算符</li><li><code>stable_sort(words.begin(),words.end(),类名());</code></li><li>捕获变量的 lambda 则生成构造函数带有对应参数</li></ul><h2 id="可调用对象与-function"><a class="anchor" href="#可调用对象与-function">#</a> 可调用对象与 function</h2><p>C++ 语言中有几种可调用对象：</p><ul><li>函数</li><li>函数指针</li><li>lambda 表达式</li><li>bind 创建的对象</li><li>重载了函数调用运算符的类</li></ul><p>可调用对象也有类型，但两个不同类型的可调用对象可能共享同一种 调用形式。</p><ul><li>调用形式：指明了调用返回的类型及传递给调用的实参类型</li></ul><h3 id="标准库-function-类型"><a class="anchor" href="#标准库-function-类型">#</a> 标准库 function 类型</h3><ul><li>function 是一个模板，定义时可用于指定该 function 类型能够表示的对象的调用形式。</li><li>只要可调用对象满足指定的调用形式，就可以存储于同一个 function 类型中。</li><li>例如：<ul><li><code>function&lt;int(int,int)&gt;</code></li><li>表示接受两个 int，返回一个 int 的可调用对象</li><li>如此声明后，可用于表示任意一种类似可调用类型：函数指针、函数对象类的对象 (函数对象)、lambda</li></ul></li></ul><h3 id="重载函数与-function"><a class="anchor" href="#重载函数与-function">#</a> 重载函数与 function</h3><ul><li>如果函数存在重载，那么直接通过函数名称存储会导致二义性</li><li>可通过 存储函数指针而非函数名字，或 lambda 表达式来消除二义性<ul><li>定义函数指针： <code>int (*fp)(int,int)=add</code></li><li>定义 lambda： <code>[](int a,int b)&#123;return add(a,b);&#125;</code></li></ul></li></ul><h2 id="重载-类型转换与运算符"><a class="anchor" href="#重载-类型转换与运算符">#</a> 重载、类型转换与运算符</h2><h3 id="类型转换运算符"><a class="anchor" href="#类型转换运算符">#</a> 类型转换运算符</h3><p>类型转换运算符是类的一种特殊的成员函数，负责将一个类类型转换成其它类型。</p><ul><li><code>operator type() const</code></li><li>一个类型转换函数必须是类的成员函数，它不能声明返回类型，形参列表也必须为空 (类型转换运算符是隐式执行的)。类型转换函数通常应该是 const (不应修改待转换对象的内容)</li></ul><h3 id="显式的类型转换运算符"><a class="anchor" href="#显式的类型转换运算符">#</a> 显式的类型转换运算符</h3><ul><li>为防止隐式转换可能产生的异常情况</li><li><code>explicit operator type() const</code></li><li>显式的类型转换也可能会被隐式执行：<ul><li>if、while 及 do 语句条件部分</li><li>for 语句头的条件表达式</li><li>逻辑非运算符 (!)、逻辑或运算符 (||)、逻辑与运算符 (&amp;&amp;) 的运算对象</li><li>条件运算符  <code>(? :)</code>  的条件表达式</li></ul></li><li>注：向 bool 的类型转换通常用在条件部分，因此 operator bool 一般定义成 explicit 的</li></ul><h3 id="避免二义性转换"><a class="anchor" href="#避免二义性转换">#</a> 避免二义性转换</h3><ul><li>例如定义了多个类型转换规则，可以通过其它类型转换联系到一起。</li><li>重载构造函数 (默认隐式转换) 也可能导致</li><li>对同一个类既提供转换目标是算数类型的类型转换，也提供了重载的运算符，重载运算符与内置运算符将会有二义性问题</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;本篇笔记从原书第二部分开始，到第三部分第十四章重载运算与类型转换结束，不过对于 第八章 (IO 库)、第九章 (顺序容器)、第十一章 (关联容器) 基本略过。&lt;br</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CPP" scheme="https://wangjiaying.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>虚幻5动画适配方式-笔记</title>
    <link href="https://wangjiaying.top/2023/10/06/%E8%99%9A%E5%B9%BB5%E5%8A%A8%E7%94%BB%E9%80%82%E9%85%8D-%E7%AC%94%E8%AE%B0/"/>
    <id>https://wangjiaying.top/2023/10/06/%E8%99%9A%E5%B9%BB5%E5%8A%A8%E7%94%BB%E9%80%82%E9%85%8D-%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-06T13:08:22.000Z</published>
    <updated>2023-10-07T01:42:41.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>国庆将虚幻 5 C++ 基础又研究了一通，今天是最后一天了。<br />本来是想找找 Lyra C++ 相关东西看看有没有比较好的教程的，结果搜到一个虚幻官方很早以前就发的一个 Lyra 动画系统的直播介绍视频，看了下介绍似乎还不错。<br />特别是提到适用于不同情况下的动画 Retarging 操作，感觉正缺点这方面的知识。<br />于是今天就花了一天跟着看了一遍，操作了一遍，在此记录一下。</p><h1 id="情况一"><a class="anchor" href="#情况一">#</a> 情况一</h1><ul><li>同样的骨架资源</li><li>同样的参考姿势 (基础骨骼和层级)</li><li>同样的比例参数：例如角色高矮相同</li></ul><p>不需要重定向，可直接应用动画播放</p><h1 id="情况二"><a class="anchor" href="#情况二">#</a> 情况二</h1><ul><li>同样的骨架资源</li><li>同样的参考姿势 (基础骨骼和层级)</li><li><font color=red>不同的比例参数：例如角色高矮不同、肩宽、腿长 等有差异</font></li></ul><p>需要一些简单的重定向，确保动画播放不至于拉伸、挤压：</p><p><img data-src="/blogimages/2023/2023-10-06/1.png" alt="" /></p><h1 id="情况三"><a class="anchor" href="#情况三">#</a> 情况三</h1><ul><li><font color=red>不同的骨架资源</font></li><li>同样的参考姿势 (基础骨骼和层级)</li><li><font color=red>(可能) 额外的骨骼</font></li></ul><p>这应该是最常见的情况，操作方式主要有两种：</p><ul><li>从网格体复制姿势 (Copy Pose From Mesh)</li><li>使用兼容骨骼 (UE5 新功能)</li></ul><h2 id="copy-pose-from-mesh"><a class="anchor" href="#copy-pose-from-mesh">#</a> Copy Pose From Mesh</h2><ul><li>模块化角色的基础，适合具有额外骨骼角色，导入资源时，它们被导入自身独有的骨骼资源中</li><li>该选项位于动画蓝图 (ABP) 中，属于一个节点</li></ul><h3 id="原理"><a class="anchor" href="#原理">#</a> 原理</h3><ul><li>其中源骨骼运行正常基础动画：走路、奔跑、跳跃 等</li><li>额外骨骼 (马尾辫、背包、装饰品 等) 则由分离后作为子级驱动</li></ul><h2 id="兼容骨架"><a class="anchor" href="#兼容骨架">#</a> 兼容骨架</h2><ul><li>原理与 Copy Pose From Mesh 类似，都是首先得有相同的骨架，但可能具有额外的骨骼</li><li>即：虽然骨架资源不同，但它们拥有同样的基础骨骼和层级</li></ul><p>从 Window-&gt;AssetDetail 打开：<br /><img data-src="/blogimages/2023/2023-10-06/2.png" alt="" /><br />在没设置兼容骨架之前，下方 AssetBrwser 是空的，设置之后重新打开，就会发现会显示出兼容骨骼的动画。<br />注：兼容骨架是个数组，因此可以放置多个骨架，以适配多个骨架的动画资源</p><h1 id="情况四"><a class="anchor" href="#情况四">#</a> 情况四</h1><p>最复杂的情况是：</p><ul><li><font color=red>不同的骨架资源</font></li><li><font color=red>不同的骨骼层级</font></li><li><font color=red>不同的参考姿势</font></li><li><font color=red>有额外的骨骼 / 缺失的骨骼</font></li></ul><p>为了尽可能复用动画资源<br />操作方式：</p><ul><li>IK 重定向 (IK Retarging)，也是属于 UE5 新功能</li></ul><h2 id="retarget-pose-from-mesh"><a class="anchor" href="#retarget-pose-from-mesh">#</a> Retarget Pose From Mesh</h2><ul><li>该选项位于动画蓝图 (ABP) 中，属于一个节点</li><li>设计的与 Copy Pose From Mesh 使用方式类似，而原理也类似，都是从源骨骼复制数据</li><li>不同之处在于，这个选项不会对源骨骼作任何假设，因此需要我们告诉引擎如何将源骨骼与目标骨骼进行相互关联，该节点通过关联信息使用 IK Retarging 进行重定向</li></ul><p>始终涉及三个资源：</p><ul><li>源</li><li>目标</li><li>关联两者的 IK Retarging 资源</li></ul><p>注：绑定完成后，除运行时动态进行计算，还可以离线生成新的动画以进行进一步优化</p><h3 id="创建-ik-rig"><a class="anchor" href="#创建-ik-rig">#</a> 创建 IK Rig</h3><ol><li>创建 Animation-&gt;Retarging-&gt;IK Rig 资源</li><li>将需要修改的目标对象骨骼设置上去</li><li>选择需要重映射的『骨骼链』后创建重定向链</li></ol><p><img data-src="/blogimages/2023/2023-10-06/3.png" alt="" /><br />点击后会弹出几个弹窗，分别按照骨骼命名即可 (前臂、后腿之类的)<br /> 随后还需要依次设置：Spine、Neck、Head 等需要重定向的骨骼链<br />注意：创建的时候需要把对应的子骨骼也选中上！<br />效果如下：<br /><img data-src="/blogimages/2023/2023-10-06/4.png" alt="" /><br />选择对应骨骼会高亮显示。</p><ol start="4"><li>选择 手、脚 创建 IK Goal 以便后续进行微调 (通常一个 FullBodyIK 就够了)</li><li>保持选中 IK Solver 状态，选中对应根骨骼，将其设置为 SetRootBoneFromSolver</li></ol><p><img data-src="/blogimages/2023/2023-10-06/5.png" alt="" /><br />此时就已经可以使用 IK Goal 进行调整了：<br /><img data-src="/blogimages/2023/2023-10-06/6.png" alt="" /></p><ol start="6"><li>设置重定向动画的根 (Set Retarget Root)，右键对应的根骨骼选择设置即可，随后可在 IK Retargeting 界面看到：</li></ol><p><img data-src="/blogimages/2023/2023-10-06/7.png" alt="" /></p><h3 id="创建-ik-retargeter"><a class="anchor" href="#创建-ik-retargeter">#</a> 创建 IK Retargeter</h3><p>创建 IK Retargeter</p><ul><li>然后 Source 指定为 UE5 的 Mannequin</li><li>Target 指定为刚才我们创建的 IK_Dog</li></ul><p>此时在 ChainMapping 窗口可以看见，引擎已经自动应用了重映射 (字符串模糊匹配算法，所以结果不一定准确)：<br /><img data-src="/blogimages/2023/2023-10-06/8.png" alt="" /><br />随后，编译默认的 T-Pose，确保两者尽量一致<br />选择一个动画后，即可预览效果：<br /><img data-src="/blogimages/2023/2023-10-06/9.png" alt="" /><br />注：虚线连接的圆圈是 IK 位置，设置 BlendToSource 可使其混合，设置到源动画同样的位置 (高度)，还有静态偏移设置，用于调整步幅、匹配握抢姿势什么的。</p><h3 id="应用"><a class="anchor" href="#应用">#</a> 应用</h3><p>确认无误，就可以创建一个新的动画蓝图，添加 Retarget Pose From Mesh 节点，IK RetargeterAsset 选择刚才创建的 IK Retargeter 即可：<br /><img data-src="/blogimages/2023/2023-10-06/10.png" alt="" /></p><p>实际效果：</p><p><img data-src="/blogimages/2023/2023-10-06/GIF2023-10-6-17-05-01.gif" alt="" /></p><h1 id="blueprintthreadsafeupdateanimation"><a class="anchor" href="#blueprintthreadsafeupdateanimation">#</a> BlueprintThreadSafeUpdateAnimation</h1><ul><li>多线程执行</li></ul><h1 id="动态适配"><a class="anchor" href="#动态适配">#</a> 动态适配</h1><p>动画节点：</p><ul><li>OrientationWraping：方向适配<ul><li>调整脊椎、双脚，使角色动画匹配移动方向 (不旋转)，避免滑步等，主要用于移动过程，Idle 时没什么用</li><li>可以只在需要的状态中启用，且可以通过 Alpha 控制权重</li><li>控制台命令：a.AnimNode.OrientationWraping.Enable</li></ul></li><li>StrideWraping：步幅匹配<ul><li>使角色移动动画与其移动速度匹配 (有多种方式，例如调整播放速率，步幅撇配也是一种)</li><li>控制台命令：a.AnimNode.StrideWraping.Enable</li></ul></li><li>DistanceMatchToTarget：距离匹配<ul><li>如果角色移动了 100 个单位，希望动画也移动 100 个单位</li><li>例如角色坠落：距离地面 100 个单位，可以在动画中找到距离地面 100 个单位的关键帧并从此播放</li><li>以角色实际移动距离为准，不管动画的时间跨度多少，通过调整动画播放速率使其一定匹配对应移动距离 (可能使改变动画播放速度比较大，可对最高播放速率做限制)</li></ul></li><li>AdvanceTimeByDistanceMatching：距离匹配推动时间</li><li>SetPlayrateSpeed：设置播放速率匹配速度</li><li>MotionWraping：运动扭曲</li></ul><p>情境动画系统</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>各种尝试了下，总的来说，还是情况四提供的 IK Retarging 最靠谱，前三种情况都更适合有专门的动画师，以及能做到按照标准的素体骨骼制作动画才行。<br />而且要是新的动画要求或骨骼层级发生了改变，那么也没法兼容：<s>个人尝试使用兼容骨架功能将商城一个 UE4 的人形资源适配到 UE5 的官方骨架上，直接就变形了</s>。<br />补正：简单动画重定向选项可以与兼容骨架配合使用，一定程度避免变形。<br />(可能这也是为什么虚幻会增加 IK Retarging 功能的原因之一，试用一下就知道，跟其它方式相比灵活性太强了！)</p><h1 id="参考文档"><a class="anchor" href="#参考文档">#</a> 参考文档</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXlHNHkxODd5Ng==">[英文直播] 分析 Lyra 中的动画 (官方字幕)_哔哩哔哩_bilibili</span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;国庆将虚幻 5 C++ 基础又研究了一通，今天是最后一天了。&lt;br /&gt;
本来是想找找 Lyra C++ 相关东西看看有没有比较好的教程的，结果搜到一个虚幻官方很早</summary>
      
    
    
    
    <category term="虚幻引擎" scheme="https://wangjiaying.top/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="虚幻引擎" scheme="https://wangjiaying.top/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer(第五版)》-笔记(1)</title>
    <link href="https://wangjiaying.top/2023/10/02/CPP_Primer_%E7%AC%AC%E4%BA%94%E7%89%88_%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://wangjiaying.top/2023/10/02/CPP_Primer_%E7%AC%AC%E4%BA%94%E7%89%88_%E7%AC%94%E8%AE%B0-1/</id>
    <published>2023-10-02T09:14:12.000Z</published>
    <updated>2023-10-06T04:28:37.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本篇笔记主要包含原书第一部分，第一章～第七章，从变量定义到类结束。</p><p>这次仔细从头开始看，包括最基础的语法都给重新过了一遍，虽然可能看得稍微有点快，而且做不到看完就熟稔了，不过至少重点记录了笔记，后续翻看一下，总能回忆不少印象。</p><p>说实话的话，补完这几章，再去看 UE 的 C++ 代码的时候，看起来就感觉更轻松些了 —— 毕竟理论知识确实是基础，自然比全然不知道的情况下去总结经验来得强。</p><p>这本书还是有点厚，不知道这次国庆节抽出的时间看不看得完。</p><hr /><ul><li>像编译器一样来思考和理解 C++</li><li>本书主要为 C++11 标准</li></ul><h1 id="第一章-开始"><a class="anchor" href="#第一章-开始">#</a> 第一章 开始</h1><p>错误的注释比完全没有注释更糟糕。<br />点运算符只能用于类类型对象。</p><h1 id="第二章-变量和基本类型"><a class="anchor" href="#第二章-变量和基本类型">#</a> 第二章 变量和基本类型</h1><p>为赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据类型，类型决定数据所占比特数及如何解释这些比特内容。<br />整型和浮点型具有字面值</p><ul><li>整型字面值的具体数据类型由它的值和符号决定 (int、long、long long 尺寸最小的一个)</li><li>严格来说，十进制字面值不会是负数，『-42』这种字面值的负号不在字面值之内，作用是对字面值取负值</li><li>浮点型的字面值是一个 double</li><li>类型 short 没有对应的字面值</li></ul><p>字符串字面值</p><ul><li>是由常量字符构成的数组，字符串结尾会被编译器添加一个空字符 (\0)，因此字符串字面值实际长度比内容多一个。</li></ul><p>指针字面值</p><ul><li>nullptr</li></ul><p>指定字面值类型</p><ul><li>通过添加值的前缀或后缀，可指定字面值的默认类型</li><li>如 3.14F 表示 float</li></ul><h2 id="变量"><a class="anchor" href="#变量">#</a> 变量</h2><p>通常情况下，对象指一块能够存储数据并具有某种类型的内存空间。</p><h3 id="初始值值初始化"><a class="anchor" href="#初始值值初始化">#</a> 初始值 (值初始化)</h3><p>当对象在创建时获得了一个特定的值<br />注：(虽然都是等号) 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义则是把对象当前值擦除，而以一个新值替代</p><h3 id="列表初始化"><a class="anchor" href="#列表初始化">#</a> 列表初始化</h3><ul><li>可使用花括号初始值，称为列表初始化</li><li>注：对结构的数据成员进行初始化时，必须使用列表初始化进行</li></ul><h3 id="默认初始化"><a class="anchor" href="#默认初始化">#</a> 默认初始化</h3><ul><li>若定义变量时没有指定初值，则变量被默认初始化</li><li>此时变量被赋予 &quot;默认值&quot;</li><li>内置类型定义于函数体内时，将不被初始化，未初始化内置类型变量值属于未定义，访问将引发错误。(定义于函数体外则被默认初始化为 0)</li></ul><p>注：每个类各自决定其初始化对象的方式，是否允许不经初始化就定义对象也由类自己决定。多数类都支持无需显式初始化而定义对象。</p><h3 id="变量声明和定义"><a class="anchor" href="#变量声明和定义">#</a> 变量声明和定义</h3><p>为支持分离式编译，C++ 将声明 (declaration) 和定义 (definition) 区分开类。</p><ul><li>声明规定了变量类型和名字</li><li>定义除声明功能外，还申请存储空间，或为变量赋一个初始值</li></ul><p>例如</p><ul><li>仅声明：extern int i;</li><li>声明并定义：int j;</li><li>注：包含显式初始化的声明即成为定义，如 extern int x=12 表示的是定义 (extern 声明相当于无效)</li></ul><p>注 1：变量可以被多次声明，但只能被定义一次<br />注 2：C++ 是一种静态类型语言，编译器会在编译阶段检查类型，因此要求我们在使用某个变量之前必须声明其类型</p><h3 id="作用域"><a class="anchor" href="#作用域">#</a> 作用域</h3><p>当第一次使用变量时再定义它<br />全局作用域</p><ul><li>:: 变量名</li><li>如果函数有可能用到某全局变量，则不宜再定义一个同名局部变量 (此处记录表示可以有这种操作)</li></ul><h2 id="复合类型"><a class="anchor" href="#复合类型">#</a> 复合类型</h2><h3 id="引用"><a class="anchor" href="#引用">#</a> 引用</h3><p>引用为对象起了另外一个名字，引用类型引用另外一种类型。</p><ul><li>通过声明符 &amp; 定义引用类型</li><li>定义引用时，程序把引用和它的初始值绑定在一起</li><li>对引用的所有操作都是在与之绑定的对象上进行</li><li>引用必须被初始化，并且无法再重新绑定给另外对象</li><li>(引用本身不是一个对象，因此不能定义引用的引用)</li></ul><h3 id="指针"><a class="anchor" href="#指针">#</a> 指针</h3><p>指针是指向另外一种类型的复合类型，与引用类似，指针也实现了对其它对象的间接访问。</p><ul><li>指针本身是一个对象，允许对指针赋值和拷贝</li><li>指针允许无需在定义时赋初值</li><li>(与其它内置类型一样，块作用域定义的指针若未初始化则具有不确定值)</li></ul><p>解引用符 (*) 可用于访问指针指向的对象 (仅适用于确实指向了某个对象的有效指针)<br /> 空指针</p><ul><li>赋值 nullptr (推荐)</li><li>赋值 0</li><li>赋值 NULL (cstdlib 预处理变量，值实际为 0)</li></ul><p>void* 指针</p><ul><li>特殊的指针类型，可用于存放任意对象的地址</li><li>不能直接操作 void* 指针所指的对象 (因为不确定类型)</li><li>即 void* 仅代表内存空间，无法访问内存空间中所存储的对象</li></ul><p>注：面对一条比较复杂的指针或引用声明时，从右往左阅读有助于弄清楚它的真实含义。</p><h3 id="const-限定符"><a class="anchor" href="#const-限定符">#</a> const 限定符</h3><p>const 对象一旦创建后其值就不能改变因此 const 对象必须初始化。<br />默认状态下，const 对象仅在文件内有效</p><ul><li>编译器将在编译过程中把用到该变量的地方都替换成对应的值</li><li>添加 extern 关键字可以改变默认行为，使其全局 (多个文件之间共享) 生效</li></ul><h4 id="const-的引用"><a class="anchor" href="#const-的引用">#</a> const 的引用</h4><ul><li>可以把引用绑定到 const 对象上，称为对常量的引用，对常量的引用不能修改它所绑定的对象</li><li>const int &amp;r1=xxx</li><li>注：常量引用仅对引用可参与的操作做出限定，对于引用本身是否是一个常量未做限定</li></ul><h4 id="指针和-const"><a class="anchor" href="#指针和-const">#</a> 指针和 const</h4><ul><li>指针添加 const 称为 指向常量的指针</li><li>const double *ptr=&amp;xxx</li><li>指向常量的指针不能指向非常量地址，也不能修改指向对象的值 (也可以指向非常量对象，相当于多了不能修改的限制)</li></ul><h4 id="const-指针"><a class="anchor" href="#const-指针">#</a> const 指针</h4><ul><li>常量指针必须初始化，而且一旦初始化完成，其值 (指向的地址) 就不能再改变</li><li>把 * 放在 const 之前说明指针是一个常量，不变的是指针本身的值而非指向地址的值</li><li>int *const ptr=&amp;xxx</li></ul><h3 id="constexpr-和常量表达式"><a class="anchor" href="#constexpr-和常量表达式">#</a> constexpr 和常量表达式</h3><p>常量表达式</p><ul><li>指值不会改变并且在编译过程就能得到计算结果的表达式</li></ul><h4 id="constexpr-变量"><a class="anchor" href="#constexpr-变量">#</a> constexpr 变量</h4><ul><li>在一个复杂系统中很难分辨一个初始值到底是不是常量表达式</li><li>因此 C++11 规定，允许将变量声明为 constexpr 类型以便又编译器来验证变量的值是否是一个常量表达式</li></ul><h4 id="constexpr-函数"><a class="anchor" href="#constexpr-函数">#</a> constexpr 函数</h4><ul><li>这种函数应该足够简单以使得编译时就可以计算其结果</li><li>这样就能用 constexpr 函数去初始化 constexpr 变量了</li></ul><hr /><p>注：常量表达式的值需要在编译时就得到计算，因此对声明 constexpr 的类型必须有所限制 —— 称为字面值类型<br />指针和 constexpr</p><ul><li>constexpr 仅对指针有效，与指针所指对象无关</li><li>即：constexpr 定义的一定是 常量指针 (指针本身不可变)</li></ul><h2 id="处理类型"><a class="anchor" href="#处理类型">#</a> 处理类型</h2><h3 id="类型别名"><a class="anchor" href="#类型别名">#</a> 类型别名</h3><ul><li>typedef a b</li><li>using b=a</li></ul><h3 id="auto-类型说明符"><a class="anchor" href="#auto-类型说明符">#</a> auto 类型说明符</h3><ul><li>auto 让编译器通过初始值推算变量的类型 (因此定义必须有初始值)</li></ul><h3 id="decltype-类型指示符"><a class="anchor" href="#decltype-类型指示符">#</a> decltype 类型指示符</h3><ul><li>选择并返回操作数的数据类型</li><li>编译器分析表达式并得到它的类型，却不实际计算表达式的值</li><li>如果 decltype 使用的表达式不是一个变量，则 decltype 返回表达式结果对应的类型</li><li>decltype (func ()) sum=x; //sum 的类型即 func 函数返回类型</li></ul><p>注 1：decltype 与 auto 的区别是 decltype 的结果类型与表达式形式密切相关。<br />注 2：decltype ((variable))(注意是双括号) 的结果永远是引用，而 decltype (variable) 结果只有当 variable 本身就是一个引用时才是引用。</p><h2 id="自定义数据结构"><a class="anchor" href="#自定义数据结构">#</a> 自定义数据结构</h2><p>可使用 struct 定义自己的数据类型<br />确保头文件多次包含仍能安全工作的常用技术是雨处理器。<br />头文件保护符</p><ul><li>#define</li><li>#ifdef</li><li>#ifndef</li><li>#endif</li></ul><h1 id="第三章-字符串-向量和数组"><a class="anchor" href="#第三章-字符串-向量和数组">#</a> 第三章 字符串、向量和数组</h1><h2 id="命名空间的-using-声明"><a class="anchor" href="#命名空间的-using-声明">#</a> 命名空间的 using 声明</h2><p>使用 using namespace::name 后，可直接访问 name</p><ul><li>using std::cin;</li><li>cin&gt;&gt;x; // 正确</li></ul><p>注 1：每个 using 声明引入命名空间中的 一个 成员<br />注 2：头文件不应包含 using 声明 (可以做，但可能导致名字冲突)</p><h3 id="直接初始化和拷贝初始化"><a class="anchor" href="#直接初始化和拷贝初始化">#</a> 直接初始化和拷贝初始化</h3><ul><li>拷贝初始化：使用等号初始化 (只能初始化一个变量)</li><li>直接初始化：不使用等号 (可初始化具有多个初始值的对象)</li></ul><h2 id="string"><a class="anchor" href="#string">#</a> string</h2><p>初始化方式</p><ul><li>string s1</li><li>string s2(s1)</li><li>string s3=s1</li><li>string s3=&quot;value&quot;</li><li>string s4(n,'c')</li></ul><p>注 1：字符串字面值与 string 是不同类型 (因为历史及与 C 兼容等原因)<br /> 注 2：cctype 头文件中提供了一系列判断字符操作，例如判断是否是字母、数字、大写字母 等。<br />处理每个字符</p><ul><li>使用基于范围的 for 语句</li><li>如果想改变，则定义循环变量为引用类型</li><li>也可以通过索引访问，不过需要特别注意不要越界</li></ul><h2 id="vector"><a class="anchor" href="#vector">#</a> vector</h2><ul><li>允许使用列表初始化</li><li>允许提供一个元素数量，默认初始化 指定数量的元素</li><li>允许索引访问元素，但不能用下标形式添加元素</li></ul><p>操作</p><ul><li>push_back：添加到末尾</li></ul><h2 id="迭代器"><a class="anchor" href="#迭代器">#</a> 迭代器</h2><p>begin ()：指向第一个元素<br /> end ()：指向尾元素的下一个位置 (尾后迭代器)<br /> 注 1：容器为空时，均为尾后迭代器<br />注 2：C++11 引入了常量迭代器 - cbegin ()、cend ()<br /> 其它</p><ul><li>*iter：返回迭代器 iter 所指元素的引用</li><li>iter-&gt;mem：解引用 iter 并获取名为 mem 的成员 (等价 (*iter).mem)</li><li>++iter：令 iter 指示容器中的下一个元素</li><li>--iter：令迭代器指示容器中的上一个元素</li><li>注：迭代器运算也支持增减具体数字，使其移动若干个位置</li><li>iter1==iter2：判断两个迭代器是否相等 (指示同一元素或是同一个容器的尾后迭代器)</li><li>iter1&lt;iter2：判断前者是否比后者指示位置小</li><li>iter1-iter2：获得两个迭代器的距离 (右侧迭代器向前移动多少位置可以追上左侧迭代器，可能为负)</li></ul><p>箭头运算符 (-&gt;)：把解引用和成员访问两个操作结合在一起。</p><ul><li>成员访问即。操作</li></ul><h2 id="数组"><a class="anchor" href="#数组">#</a> 数组</h2><ul><li>数组的维度必须是一个常量表达式<ul><li>注：据说是因为数组作为 C++ 的内置数据类型，其空间分配在栈内存中，这部分空间的大小在编译时就要确定 (有的编译器支持了，但都不建议，因为容易爆栈)</li><li>动态大小可以使用 new 运算符分配到堆上</li></ul></li><li>默认情况下数组元素被默认初始化</li><li>注：与内置类型一样，函数内部定义了某种内置类型数组，默认初始化会令数组含有未定义的值</li></ul><p>注：与 vector 一样，数组元素应为对象，因此不存在引用的数组。</p><h3 id="显式初始化数组元素"><a class="anchor" href="#显式初始化数组元素">#</a> 显式初始化数组元素</h3><ul><li>可对数组元素进行列表初始化 (此时允许忽略数组维度，若未指定维度则编译器自动推测)</li></ul><p>字符数组特殊性</p><ul><li>字符数组可以用字符串字面值初始化，此时会额外多一个空字符 (\0)</li></ul><p>注：不允许对数组进行拷贝给其它数组和赋值给其它数组</p><ul><li>但是运行使用数组初始化 vector 对象，指明拷贝的首元素地址和尾后地址即可</li><li>vector<int> ivec(begin(array),end(array))</li></ul><p>注：(重要！) 在大多数表达式中，使用数组类型对象其实是使用一个指向该数组首元素的指针</p><ul><li>例如当使用数组作为一个 auto 变量初始值时，推断得到的类型是指针而非数组</li><li>指向数组元素的指针拥有更多功能，迭代器支持的运算数组的指针均支持</li><li>尾后指针：指向数组尾元素之后那个不存在的元素的地址，利用尾后指针可以像尾后迭代器一样判断</li></ul><p>标准库函数 begin、end：</p><ul><li>使用指针运算容易出错</li><li>C++11 提供了两个函数，分别返回数组首元素指针和尾后指针</li><li>begin(array)、end(array)</li></ul><p>关系运算符</p><ul><li>若两个指针指向同一个数组的元素，则还可以使用关系运算符进行比较</li></ul><h3 id="多维数组"><a class="anchor" href="#多维数组">#</a> 多维数组</h3><p>严格来说，C++ 语言中没有多维数组，通常所说的多维数组是数组的数组。<br />循环遍历多维数组时，需将外层类型定义为引用才能正确遍历下层数组</p><ul><li>如 for (auto &amp;row:array){</li><li>for(auto col:row)</li><li>} 才是合法的</li></ul><p>指针</p><ul><li>由多维数组名转换得来的指针是指向第一个内层数组的指针</li></ul><h1 id="第四章-表达式"><a class="anchor" href="#第四章-表达式">#</a> 第四章 表达式</h1><p>左值和右值</p><ul><li>左值：指求值结果为对象或函数的表达式，一个表示对象的非常量左值可以作为赋值运算符左侧运算对象。</li><li>右值：指一种表达式，其结果是值而非值所在的位置</li></ul><p>表达式语句</p><ul><li>C++ 中最低级别的计算，每个表达式都有对应的求值结果</li></ul><p>不为 0 的数值转 bool 都是 true<br />C++11 新标准规定商一律向 0 取整 (直接舍弃小数部分)<br /> 进行比较时，除非比较对象是布尔类型，否则不要使用布尔字面值 true 或 false 作为运算对象。</p><h2 id="赋值运算符"><a class="anchor" href="#赋值运算符">#</a> 赋值运算符</h2><h3 id="复合赋值运算符"><a class="anchor" href="#复合赋值运算符">#</a> 复合赋值运算符</h3><ul><li>使用复合赋值运算符只求值一次，使用普通运算符则求值两次 (一次运算，一次赋值)</li></ul><h3 id="递增和递减运算符"><a class="anchor" href="#递增和递减运算符">#</a> 递增和递减运算符</h3><ul><li>前置版本将对象本身作为左值返回 (值加 1 后直接返回改变了的运算对象)</li><li>后置版本则将对象原始值的副本作为右值返回</li><li>注：允许在一条语句中混用解引用和递增运算符</li></ul><h3 id="成员访问运算符"><a class="anchor" href="#成员访问运算符">#</a> 成员访问运算符</h3><ul><li>点运算符和箭头运算符均可用于访问成员</li><li>ptr-&gt;mem 等价于 (*ptr).mem</li></ul><h3 id="sizeof-运算符"><a class="anchor" href="#sizeof-运算符">#</a> sizeof 运算符</h3><ul><li>返回一条表达式或一个类型名字所占用的字节数</li><li>注：表达式类型返回的是其结果类型大小，并不实际计算其运算对象的值</li></ul><p>运算结果</p><ul><li>引用类型：得到被引用对象所占空间的大小</li><li>指针：得到指针本身所占空间大小</li><li>解引用指针：得到指针指向的对象所占空间的大小 (指针可以不需要有效)</li><li>数组：得到整个数组所占空间的大小，等同于对数组中所有元素各执行一次 sizeof 运算并求和 (注：sizeof 不会将数组转为指针来处理)<ul><li>因此可以以此除以单个元素大小得到数组中元素个数</li></ul></li><li>对 string 或 vector：返回该类型固定部分大小，不会计算对象中的元素占用了多少空间</li></ul><p>注：sizeof 返回的是一个常量表达式</p><h2 id="类型转换"><a class="anchor" href="#类型转换">#</a> 类型转换</h2><h3 id="隐式转换"><a class="anchor" href="#隐式转换">#</a> 隐式转换</h3><ul><li>低于整型类型可能会提升为整型</li><li>计算中，两个不同类型数值计算，宽度较小类型会提升为更大精度类型</li><li>在条件中，非布尔值转换成布尔类型</li><li>数组转换成指针：数组自动转换成指向数组首元素的指针<ul><li>当数组被用作 decltype、取地址符、sizeof、typeid 等运算符的运算对象时转换不会发生</li></ul></li></ul><p>指针的转换</p><ul><li>常量整数值 0 或字面值 nullptr 能转换成任意指针类型</li><li>指向任意非常量的指针能转换成 void*</li><li>指向任意对象的指针能转换成 const void*</li></ul><h3 id="显式转换"><a class="anchor" href="#显式转换">#</a> 显式转换</h3><p>注：避免强制类型转换</p><h4 id="旧式强制类型转换"><a class="anchor" href="#旧式强制类型转换">#</a> 旧式强制类型转换</h4><ul><li>type (expr)</li><li>(type)expr</li><li>注：旧式强制类型转换分别具有与 const_cast、static_cast 或 reinterpret_cast 相似的行为。</li></ul><h4 id="static_cast"><a class="anchor" href="#static_cast">#</a> static_cast</h4><ul><li>任何具有明确定义的类型转换，只要不包含底层 const 就可以使用<ul><li>T t=static_cast<T>(val)</li><li>还可以使用这个将存放于 void* 的指针转换回来</li></ul></li></ul><h4 id="const_cast"><a class="anchor" href="#const_cast">#</a> const_cast</h4><ul><li>可以将常量对象转换为非常量对象：即去掉 const 性质</li><li>转换后编译器就不会阻止我们对该对象进行写操作</li><li>注：如果对象本身不是常量，获得写操作是合法的。但若本身是一个常量，写操作可能产生未定义行为</li></ul><h4 id="reinterpret_cast"><a class="anchor" href="#reinterpret_cast">#</a> reinterpret_cast</h4><ul><li>通常为运算对象的位模式提供较低层次上的重新解释</li></ul><h1 id="第五章-语句"><a class="anchor" href="#第五章-语句">#</a> 第五章 语句</h1><p>空语句：『;』<br />空块：『{}』<br />异常处理</p><ul><li>throw 表达式</li><li>try 语句块</li><li>一套异常类 (异常类型具有 what 成员函数，返回 C 风格字符串，无初始值异常类型返回内容由编译器决定)</li></ul><h1 id="第六章-函数"><a class="anchor" href="#第六章-函数">#</a> 第六章 函数</h1><ul><li>形参和实参</li><li>函数返回类型不能是数组或函数类型，不过可以是指向数组或函数的指针</li></ul><p>局部静态对象</p><ul><li>标记为 static 的局部变量</li><li>在程序的执行路径第一次经过对象定义语句时初始化，直到程序终止才销毁</li><li>生命周期不受函数本身控制</li><li>注：若未有显式初始值，则执行值初始化</li></ul><p>参数传递</p><ul><li>引用传递 (传引用调用)：形参是引用类型时<ul><li>也可以利用这个返回额外信息</li></ul></li><li>值传递：实参的值被拷贝给形参时 (两个对象独立)<ul><li>注：指针形参与其它非引用类型一样，也属于拷贝的指针的值</li></ul></li></ul><p>注：若函数无需改变引用形参的值，最好将其声明为常量引用。</p><ul><li>常量引用可接受范围更大 (包括常量和非常量对象)，而且可以起到标记函数不会修改传入对象的功能</li></ul><p>数组作为参数</p><ul><li>一般需要传递长度相关信息</li><li>或使用数组引用形参<ul><li>func(int (&amp;array)[10])</li></ul></li></ul><p>main 的命令行选项</p><ul><li>main 函数可选具有形参的实现，使用户可从命令行传递参数</li></ul><h2 id="可变形参的函数"><a class="anchor" href="#可变形参的函数">#</a> 可变形参的函数</h2><p>当无法预知应该向函数传递几个实参时</p><ul><li>如果所有实参类型相同：initializer_list (标准库类型)，用于表示某种特定类型的值的数组</li><li>实参类型不同：可变参数模板</li><li>注：还有一种特殊形参类型 (省略符)</li></ul><p>initializer_list</p><ul><li>initializer_list<T> lst</li><li>lst.size()</li><li>lst.begin ()：首元素指针</li><li>lst.end ()：尾后指针</li><li>注：其中的元素永远是常量值</li></ul><p>省略符形参 (...)</p><ul><li>为了便于 C++ 程序访问某些特殊 C 代码设计</li><li>只能出现在形参列表的最后一个位置</li><li>通常，省略符形参不应用于其它目的</li></ul><h2 id="不要返回局部对象的引用或指针"><a class="anchor" href="#不要返回局部对象的引用或指针">#</a> 不要返回局部对象的引用或指针</h2><p>函数完成后，它所占用的存储空间也会随之释放。</p><ul><li>函数终止意味着局部变量的引用将指向无效内存区域</li></ul><h2 id="返回值"><a class="anchor" href="#返回值">#</a> 返回值</h2><ul><li>调用一个返回引用的函数得到左值</li><li>其它返回类型得到右值</li></ul><p>列表初始化返回值</p><ul><li>C++11 标准规定：函数可以返回花括号包围的值的列表</li></ul><p>返回数组指针</p><ul><li>尾置返回类型：尾置返回类型跟在形参列表后并以一个 -&gt; 符号开头</li><li>auto func (int i)-&gt;int (*)[10] //func 接受一个 int 类型实参，返回一个指向含有 10 个整数的指针</li><li>注：若知道返回指针指向的数组，可使用 decltype 表示返回类型</li></ul><h2 id="函数重载"><a class="anchor" href="#函数重载">#</a> 函数重载</h2><ul><li>如果形参是某种类型的指针或引用，可通过区分指向的是常量对象或非常量对象实现函数重载</li><li>其它 const 形参与普通形参的差别则不能构成重载</li></ul><p>const_cast 与重载</p><ul><li>将非常量对象转换为常量实参，以做到调用常量形参的重载函数 (如果同时存在非常量版本，而想调用常量版本时)</li></ul><h2 id="默认参数"><a class="anchor" href="#默认参数">#</a> 默认参数</h2><ul><li>局部变量不能作为默认实参</li><li>此外只要表达式的类型能转换成形参所需类型，该表达式就能作为默认实参：同名局部变量虽然会隐藏外层对象，但不会影响默认实参</li></ul><h2 id="内联函数与-constexpr-函数"><a class="anchor" href="#内联函数与-constexpr-函数">#</a> 内联函数与 constexpr 函数</h2><ul><li>函数前加上 inline (内联说明只是向编译器发出请求，编译器可以选择忽略)</li><li>constexpr 函数返回类型及所有形参类型都得是字面值类型</li></ul><p>注 1：constexpr 函数被隐式指定为内联函数，编译器会在编译过程中展开<br />注 2：constexpr 函数调用时，传递常量表达式则返回常量表达式。传递非常量表达式则返回的也会是非常量表达式。即 constexpr 不一定返回常量表达式。</p><h2 id="调试帮助"><a class="anchor" href="#调试帮助">#</a> 调试帮助</h2><p>assert 预处理宏</p><ul><li>assert(expr)</li><li>对 expr 求值，若表达式为 false，assert 输出信息并终止程序执行。否则什么也不做。</li></ul><p>NDEBUG 预处理变量</p><ul><li>assert 的行为依赖 NDEBUG 的预处理变量的状态</li><li>若定义了 NDEBUG 则 assert 什么也不做 (默认状态下未定义，assert 将执行运行时检查)</li></ul><p><code>__func__</code></p><ul><li>编译器定义的一个局部静态变量，用于存放函数的名字</li></ul><p><code>__FILE__</code></p><ul><li>存放文件名的字符串字面值</li></ul><p><code>__LINE__</code></p><ul><li>存放当前行号的整型字面值</li></ul><p><code>__TIME__</code></p><ul><li>存放文件编译时间的字符串字面值</li></ul><p><code>__DATA__</code></p><ul><li>存放文件编译日期的字符串字面值</li></ul><h3 id="函数指针"><a class="anchor" href="#函数指针">#</a> 函数指针</h3><p>要想声明一个可以指向函数的指针，只需用指针替换函数名即可</p><ul><li>bool (*pf)(xxxxx) // 注：*pf 的括号必不可少，否则就是一个返回值为 bool 指针的函数了</li><li>当我们把函数名作为一个值使用时，该函数自动地转换成指针</li><li>此外可以直接使用指向函数的指针调用该函数，无需提前解引用指针</li></ul><p>函数指针形参</p><ul><li>与数组类似，不能直接定义函数类型的形参</li><li>但是形参可以是指向函数的指针</li><li>void func(bool (*pf)(xxxxx))<ul><li>如果明确知道返回函数是哪一个，可使用类型别名或 decltype 简化</li><li>typedef decltype(myfunc) *callbackName</li></ul></li><li>可以直接把函数作为实参使用</li></ul><h1 id="第七章-类"><a class="anchor" href="#第七章-类">#</a> 第七章 类</h1><p>定义在类内部的函数是隐式的 inline 函数。<br />当我调用成员函数时，实际上是替某个对象调用。成员函数通过一个名为 this 的额外隐式参数来访问调用它的那个堆对象。</p><ul><li>默认情况下，this 是指向类类型非常量版本的常量指针</li><li>常量对象以及常量对象的引用或指针都只能调用常量成员函数</li><li>注：一个 const 成员函数如果以引用方式返回 *this，则返回类型将是常量引用 (不可再做修改)。</li></ul><h2 id="构造函数"><a class="anchor" href="#构造函数">#</a> 构造函数</h2><ul><li>构造函数不能声明为 const</li><li>当我们创建类的一个 const 对象时，直到构造函数完成初始化过程，对象才能真正取得其 常量 属性：因此构造函数在 const 对象构造过程中可以向其写值</li></ul><p>注：当对象被默认初始化或值初始化时自动执行默认构造函数。<br />例如：</p><ul><li>Sales_data obj1 (); // 错误：声明了一个函数而非对象</li><li>Sales_data obj3; // 正确：默认初始化 obj2 对象</li></ul><h3 id="合成的默认构造函数"><a class="anchor" href="#合成的默认构造函数">#</a> 合成的默认构造函数</h3><p>只有当类没有声明任何构造函数时编译器才会自动生成</p><ul><li>如果存在类内初始值，用其初始化成员</li><li>否则，默认初始化该成员</li><li>即：通过相应类内初始值初始化或执行默认初始化</li><li>=default：要求编译器生成构造函数</li></ul><h3 id="构造函数初始值列表"><a class="anchor" href="#构造函数初始值列表">#</a> 构造函数初始值列表</h3><ul><li>(构造函数中参数后冒号与花括号之间) 可用于成员初始化</li><li>fun(const std::string &amp;name):Name(name){}</li><li>例如 const 只能使用这种方式初始值 (而不能在花括号里面赋值)</li><li>注：该列表只说明用于初始化成员的值，而不限定具体执行顺序，具体顺序与其在类中定义的出现顺序一致。(因此最好保持顺序一致，或避免使用某些成员初始化其它成员)</li></ul><p>注 1：当我们提供一个类内初始值时，必须以符号 = 或 花括号表示。<br />注 2：初始化和赋值的区别事关底层效率问题，前者直接初始化数据成员，后者则先初始化再赋值。(因此建议使用构造函数初始值)</p><h3 id="委托构造函数"><a class="anchor" href="#委托构造函数">#</a> 委托构造函数</h3><p>一个委托构造函数使用它所属类的其它构造函数执行它自己的初始化过程。</p><ul><li>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。</li></ul><h3 id="隐式的类类型转换"><a class="anchor" href="#隐式的类类型转换">#</a> 隐式的类类型转换</h3><p>使用 explicit 可抑制构造函数定义的隐式转换</p><ul><li>当以 explicit 声明构造函数时，它将只能以直接初始化的形式使用</li><li>且编译器不会在自动转换过程中使用该构造函数</li></ul><h2 id="class-与-struct"><a class="anchor" href="#class-与-struct">#</a> class 与 struct</h2><p>唯一区别是：两者默认访问权限不一样</p><ul><li>struct：定义在第一个访问修饰符之前的成员是 public</li><li>class：第一个访问修饰符之前的成员是 private</li><li>一般当定义类所有成员都是 public 时采用 struct</li></ul><h2 id="可变数据成员"><a class="anchor" href="#可变数据成员">#</a> 可变数据成员</h2><p>变量声明中加入 mutable 关键字</p><ul><li>永远不会是 const</li><li>即使作为 const 对象成员</li></ul><h2 id="友元"><a class="anchor" href="#友元">#</a> 友元</h2><p>每个类复制控制自己的友元类或友元函数</p><ul><li>还可以某类成员函数成为自己的友元</li></ul><h2 id="类的声明"><a class="anchor" href="#类的声明">#</a> 类的声明</h2><p>前向声明</p><ul><li>class className;</li><li>引入类名并指明这是一个类类型</li><li>在它声明之后定义之前是一个『不完全类型』</li></ul><p>不完全类型</p><ul><li>只能在非常有限的情况下使用：可以定义指向这种类型的指针或引用，也可以声明 (但不能定义) 以不完全类型作为参数或返回类型的函数。</li></ul><h2 id="类作用域"><a class="anchor" href="#类作用域">#</a> 类作用域</h2><p>编译器处理完类中全部声明后才会处理成员函数的定义。</p><h2 id="聚合类"><a class="anchor" href="#聚合类">#</a> 聚合类</h2><p>聚合类使得用户可直接访问其成员，且具有特殊的初始化语法形式。</p><ul><li>所有成员都是 public 的</li><li>没有定义任何构造函数</li><li>没有类内初始值</li><li>没有基类，有没有虚函数</li></ul><p>可以使用花括号初始化聚合类的数据成员，初始值的顺序必须与声明一致。</p><h3 id="字面值常量类"><a class="anchor" href="#字面值常量类">#</a> 字面值常量类</h3><p>数据成员都是字面值类型的聚合类是字面值常量类。</p><ul><li>注：还有一些满足额外条件的非聚合类也可以是字面值常量类</li></ul><h2 id="类的静态成员"><a class="anchor" href="#类的静态成员">#</a> 类的静态成员</h2><p>成员与类本身直接相关，而不是与类的各个对象保持关联。<br />静态成员函数</p><ul><li>静态成员函数不包含 this 指针，静态成员函数不能声明为 const</li></ul><p>静态数据成员</p><ul><li>类似于全局变量，静态数据成员定义在任何函数之外，一旦被定义，将存在于程序整个生命周期</li><li>通常类的静态成员不应在类内部初始化，不过可以为其提供 const 类内初始值</li><li>注：<ul><li>静态数据成员可以是不完全类型</li><li>静态数据成员类型可以就是它所属类型 (普通成员只能声明所属类型的指针或引用)</li><li>可以使用静态成员作为默认实参</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;本篇笔记主要包含原书第一部分，第一章～第七章，从变量定义到类结束。&lt;/p&gt;
&lt;p&gt;这次仔细从头开始看，包括最基础的语法都给重新过了一遍，虽然可能看得稍微有点快，而且</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CPP" scheme="https://wangjiaying.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>《游戏编程模式》-笔记</title>
    <link href="https://wangjiaying.top/2023/09/25/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-%E7%AC%94%E8%AE%B0/"/>
    <id>https://wangjiaying.top/2023/09/25/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-%E7%AC%94%E8%AE%B0/</id>
    <published>2023-09-25T08:31:19.000Z</published>
    <updated>2023-10-06T04:02:54.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>说实话，关于正经游戏模式的书还是有点少，这本算是少数中的其中之一。</p><p>整本书看下来，发现书里并没有按照类似常规 “23 种设计模式” 这种概念来讲述，有不少其实都不存在于常规设计模式当中：<br />比如双缓冲、空间分区、脏标记等... 确实跟书名更符一点，讲的是 “游戏编程模式”，而不是单纯的设计模式。</p><p>不过，要说是是游戏程序设计方面的书籍，本书肯定是算的。总之值得一看。</p><h1 id="介绍"><a class="anchor" href="#介绍">#</a> 介绍</h1><p>设计模式相关的书籍，主要是为了做到如何更好组织程序</p><ul><li>编写超出大脑思考范围的程序，需要更好的设计与组织。</li><li>宝藏埋在代码深处，而许多人正在它们之上路过。</li></ul><p>作者将其描述的模式分为：序列型、行为型、解藕型、优化型</p><h1 id="架构-性能和游戏"><a class="anchor" href="#架构-性能和游戏">#</a> 架构、性能和游戏</h1><p>解藕</p><ul><li>解藕符合最少知识原则：如果两块代码耦合，意味着必须同时搞清楚两者，而如果解藕，只需要了解其一</li></ul><p>维护设计</p><ul><li>一个良好的设计必须在实现新需求时优雅地融入，否则就会死于一个又一个『小补丁』</li><li>在项目生命周期维护一个良好的架构需要很大努力</li></ul><p>许多模式会让代码更加灵活，但是依赖于一些运行时成本的机制 (如接口、消息、虚函数等)。</p><h2 id="寻求平衡"><a class="anchor" href="#寻求平衡">#</a> 寻求平衡</h2><ul><li>良好架构：在项目生命周期内更容易理解代码</li><li>快速的运行时性能</li><li>快速完成所需功能</li></ul><p>它们一部分是冲突的，需要权衡</p><h2 id="要点"><a class="anchor" href="#要点">#</a> 要点</h2><ul><li>抽象和解藕能够使程序开发变得更快和简单，但不必浪费时间来做，除非确信存在问题的代码需要这种灵活性</li><li>在开发周期中要对性能进行思考和设计，但要推迟会降低灵活性、底层的、详尽的优化</li><li>尽快探索游戏设计空间，但不要走得太快留下烂摊子</li><li>如果将要删除代码，那么不需要浪费时间将其整理得很整洁</li><li>乐在其中</li></ul><h1 id="再探设计模式"><a class="anchor" href="#再探设计模式">#</a> 再探设计模式</h1><h2 id="命令模式"><a class="anchor" href="#命令模式">#</a> 命令模式</h2><p>『命令就是一个对象化 (实例化) 的方法调用』</p><ul><li>将某个概念转化为一块数据、一个对象 (或者可以认为是传入函数的变量等)</li><li>支持 undo、redo 的命令模式与备忘录模式有点类似，但区别在于备忘录模式是记录所有数据，而命令模式仅需记录该条命令改变的数据</li></ul><p>示例：关卡编辑、角色 (包括 AI) 控制</p><h2 id="享元模式"><a class="anchor" href="#享元模式">#</a> 享元模式</h2><p>一般用于太多对象并考虑对其进行轻量化时<br />享元模式通过将对象数据切分成两种类型解决共同数据问题</p><ol><li>不属于单一实例对象并且能够被所有对象共享的数据 (内部状态)</li><li>单一对象实例特有数据 (外部状态)</li></ol><p>示例：地图绘制，地块类型等数据</p><h3 id="森林之树"><a class="anchor" href="#森林之树">#</a> 森林之树</h3><p>『迷雾升起，一片雄伟、古老而茂密的森林在眼前展现。数不尽的远古铁杉铺面而来，宛如一座绿色的大教堂。漫天树叶像是褪色的巨大玻璃穹顶，将阳光滤碎成细密的水雾，透过高大树干的间隙，你能感到这庞大的森林往远方渐逝。』</p><h2 id="观察者模式"><a class="anchor" href="#观察者模式">#</a> 观察者模式</h2><p>MVC 一般必然都会用到。<br />C# event 亦是。<br />分为『容器』方式和链表方式<br />链式观察者</p><ul><li>避免动态容器扩容导致的内存分配</li><li>链表节点池 (指向观察者及下一个链表)，可以使得多个链表节点指向同一个观察者，使得一个观察者可以同时观察多个被观察对象。</li></ul><p>注：观察者模式非常适合于一些不相干的模块之间的通信问题，但并不适合于单个紧凑的模块内部的通信。<br />目的：解藕<br />示例：成就系统、数据绑定</p><h2 id="原型模式"><a class="anchor" href="#原型模式">#</a> 原型模式</h2><p>如 prefab<br /> 原型数据建模</p><ul><li>如 BOSS 或某些特殊物品，通常是游戏中某一对象的重定义版本</li><li>即可定义：原型 + 额外数据</li></ul><h2 id="单例模式"><a class="anchor" href="#单例模式">#</a> 单例模式</h2><p>谨慎使用，避免使用、避免滥用。<br />单例会尽可能将初始化延后 (懒汉)，所以到那时它们所需信息一般都可获得。</p><ul><li>只要不是循环依赖，一个单例甚至可以在其初始化时引用另一个单例。</li><li>可以继承单例，例如使用简单的编译跳转，实现不同平台绑定到具体类型</li></ul><p>不推荐单例的原因：单例模式就是一个全局状态，只是被封装到类中了而已</p><ol><li>全局变量有害，令代码晦涩难懂</li><li>全局变量促进耦合，控制对实例的访问才能控制耦合</li><li>并发不友好</li></ol><p>注：不访问或不修改全局状态的函数称为『纯函数』，纯函数易于理解、利于编译器优化，并能使用诸如记忆缓存、重用调用结果等技巧。<br />为实例提供便捷访问方式</p><ul><li>传递参数</li><li>在基类获取</li><li>通过其它全局对象访问</li><li>通过 服务定位器访问 (定义一个类专门用来给对象做全局访问)</li></ul><h2 id="状态模式"><a class="anchor" href="#状态模式">#</a> 状态模式</h2><h3 id="有限状态机"><a class="anchor" href="#有限状态机">#</a> 有限状态机</h3><ul><li>借鉴了计算机科学里的自动机理论中的一种数据结构 (图灵机) 思想。</li><li>FSMs 可以看作最简单的图灵机</li></ul><p>表达的是：</p><ul><li>拥有一组状态，且可以在这组状态之间进行切换</li><li>状态机同一时刻只能处于一种状态</li><li>状态机会接收一组输入或事件</li><li>每一个状态有一组转换，每一个转换都关联着一个输入并指向另一个状态</li></ul><p>整个状态机可以分为：状态、输入和转换<br />注：部分状态机实例 (没有内部状态) 可通过享元模式复用</p><h3 id="并发状态机"><a class="anchor" href="#并发状态机">#</a> 并发状态机</h3><p>角色在持枪过程中可以跑、跳和躲避，并能在过程中开火，若执着于传统的有限状态机，那么之前的状态可能都需要加倍：对于已存在状态，需要定另一个 (附加额外操作的) 状态。</p><ul><li>并发状态机即另外定义一个状态机，与基础状态机同时运行</li><li>适用于两个状态没什么关系的时候 (也许还需要加点额外判断)，但至少比单层有限状态机更能完成任务</li></ul><h3 id="层次状态机"><a class="anchor" href="#层次状态机">#</a> 层次状态机</h3><p>比如有一个『on ground』状态用于处理跳跃状态和躲避状态，站立、走路、跑步状态则可以从这个『on ground』状态继承而来。</p><ul><li>一个状态有一个父状态，当一个事件进来时，如果子状态不处理则沿继承链传给父状态处理。</li><li>或使用状态栈实现状态链</li></ul><h3 id="下推自动机"><a class="anchor" href="#下推自动机">#</a> 下推自动机</h3><p>解决有限状态机没有历史记录问题。</p><ul><li>下推自动机有一个状态栈</li><li>在一个有限状态机里，当有一个状态切进来时，则替换之前状态</li><li>下推状态机除此之外还提供额外选择：<ul><li>可以把新状态放入栈中 (当前状态即存在栈顶)</li><li>可以弹出栈顶状态 (上一个状态变成新的栈顶状态)</li></ul></li></ul><h1 id="序列型模式"><a class="anchor" href="#序列型模式">#</a> 序列型模式</h1><h2 id="双缓冲"><a class="anchor" href="#双缓冲">#</a> 双缓冲</h2><p>当今多数游戏中，每个像素占 32 位：红、绿、蓝 各占 8 位，剩余 8 位保留做其它各种用途。<br />显示器从左至右，从上至下绘制显示器像素，会从帧缓冲区获知这些像素该是何种颜色。</p><ul><li>各种高级图形算法，本质上都是为了向这个帧缓冲数组写东西</li></ul><p>撕裂</p><ul><li>显示器访问速度 (屏幕刷新率) 比显卡写入速度 (帧率) 更快</li><li>GPU 的帧率超过显示器后、或在帧率较低的时候都可能会出现撕裂的情况：其本质是帧率和屏幕刷新率的不一致导致</li></ul><p>适用双缓冲情景：</p><ul><li>需要维护一些被逐步改变着的状态量</li><li>同个状态可能会在其被修改的同时被访问到</li><li>希望避免访问状态的代码能看到具体的工作过程</li><li>希望能够读取状态但不希望等待写入操作完成</li></ul><p>注意</p><ul><li>双缓冲需要在写入完成后进行一次交换操作，操作必须是原子性的</li><li>双缓冲意味着增加了内存使用</li></ul><p>双缓冲模式所解决的核心问题是对状态同时进行修改和访问的冲突 (并非只针对图形)</p><ul><li>状态被另一个线程或中断代码直接访问</li><li>进行状态修改的代码访问到了其正在修改的那个状态</li></ul><p>例如：战斗中事件状态？<br />做法</p><ul><li>交换缓冲区指针或引用 (需要注意外部不能缓冲这个引用，因为引用指向地址可能错误)</li><li>在两个缓冲区之间进行数据拷贝</li></ul><h2 id="游戏循环"><a class="anchor" href="#游戏循环">#</a> 游戏循环</h2><p>实现用户输入和处理器速度在游戏行进时间上的解藕。<br />一个游戏循环在游戏过程中持续运转，每循环一次，非阻塞地处理用户的输入、更新游戏状态并渲染游戏。它跟踪流逝的时间并控制游戏的速率。<br />关键部分：</p><ul><li>非阻塞用户输入</li><li>帧时间适配<ul><li>非同步的固定时间步长 (尽可能快执行更新循环)</li><li>同步的固定时长 (让循环以固定时间步长运行：增加延时或追赶帧时间)</li><li>变时步长 (使游戏变得不确定)</li><li>定时更新迭代，变时渲染 (最复杂且最具适配性)</li></ul></li></ul><h2 id="更新方法"><a class="anchor" href="#更新方法">#</a> 更新方法</h2><p>通过对所有对象实例同时进行帧更新来模拟一系列相互独立的游戏对象。<br />注 1：所有对象都在每帧进行模拟，但并非真正同步。且对象更新顺序亦有很大影响，因为 A 更新时，看到的 B 的状态是前一帧的。(除非借助双缓冲模式)<br /> 注 2：在更新期间修改对象列表必须谨慎</p><ul><li>更新期间删除列表对象可能导致某项被跳过</li><li>添加新对象则会导致新对象提前一帧更新</li></ul><p>update 依存：</p><ul><li>实体类中</li><li>组件类中</li><li>代理类中</li></ul><p>处理非激活对象</p><ul><li>过多无需被更新的对象会导致 CPU 浪费额外时间来遍历，并破坏缓存。若非激活对象较多，可考虑单独一个列表维护</li></ul><h1 id="行为型模式"><a class="anchor" href="#行为型模式">#</a> 行为型模式</h1><h2 id="字节码"><a class="anchor" href="#字节码">#</a> 字节码</h2><h3 id="解释器模式"><a class="anchor" href="#解释器模式">#</a> 解释器模式</h3><p>缺点</p><ul><li>从磁盘加载它需要进行实例化并串联成堆的小对象</li><li>这些对象与它们之间的指针占用大量内存</li><li>遍历子表达式、虚函数调用均对缓存不友好</li></ul><h3 id="虚拟机器码"><a class="anchor" href="#虚拟机器码">#</a> 虚拟机器码</h3><p>由虚拟机 (VM) 执行</p><ul><li>高密度</li><li>线性</li><li>底层</li><li>迅速</li></ul><p>字节码模式</p><ul><li>指令集定义了一套可以执行的底层操作，一系列指令被编码为字节序列，虚拟机逐条执行指令栈上的这些指令</li><li>通过组合指令，即可完成很多高级行为</li></ul><h3 id="堆栈机"><a class="anchor" href="#堆栈机">#</a> 堆栈机</h3><p>指令<br />字面值指令 + 数据<br />指令分类</p><ul><li>外部基本操作：虚拟机之外，引擎内部，做一些玩家能看到的事情，决定字节码能够表达的真正行为</li><li>内部基本操作：操作虚拟机内部的值 —— 字面值、算数运算符、操作栈的指令等</li><li>控制流：让指令有选择执行或循环重复执行，即跳转</li><li>抽象化：复用，方法调用</li></ul><h3 id="语法转换工具"><a class="anchor" href="#语法转换工具">#</a> 语法转换工具</h3><p>一个图形界面以让用户定义行为，随后转换为字节码<br />注 1：用户其实可以绕过编译器，手动编写一些恶意字节码<br />注 2：ANTLR 或 Bison 解析器生成器</p><h3 id="设计决策"><a class="anchor" href="#设计决策">#</a> 设计决策</h3><p>基于栈虚拟机</p><ul><li>指令较小</li><li>代码生成简单</li><li>指令数更多</li></ul><p>基于寄存器虚拟机</p><ul><li>指令更大：需要记录参数在栈中偏移量</li><li>指令更少：每个指令能做更多的事</li></ul><h2 id="子类沙盒"><a class="anchor" href="#子类沙盒">#</a> 子类沙盒</h2><p>使用基类提供的操作集合来定义子类中的行为。</p><ul><li>基类定义保护的方法供给子类调用</li><li>基类可能会与许多不同游戏系统耦合，而子类不会</li></ul><p>注：它去掉了继承类的耦合，但这是通过把耦合聚集到基类自身来实现的。（基类可能会变得更大且越难以维护）<br />适用情景：</p><ul><li>有一个带有大量子类的基类</li><li>基类能够提供所有子类可能需要执行的操作集合</li><li>在子类之间有重叠代码，使它们之间更简便共享代码</li><li>希望使这些继承类与其它代码之间耦合最小化</li></ul><h2 id="类型对象"><a class="anchor" href="#类型对象">#</a> 类型对象</h2><p>通过创建一个类来支持新类型的灵活创建，其每个实例都代表一个不同的对象类型。<br />继承树实现 (is-a 关系)</p><ul><li>游戏中每只怪物实例都将属于某一种派生的怪物种族，种族越多继承树就越庞大</li></ul><p>包含 (has-a 种类) 实现</p><ul><li>每个怪物包含种族数据 (初始生命值、攻击等)</li></ul><p>『定义一个类型对象类和一个持有类型对象类，每个类型对象表示一个不同的逻辑类型。每个持有类型对象类的实例引用一个描述其类型的类型对象。』<br />使用情景：</p><ul><li>需要定义一系列不同『种类』的东西，又不想硬编码进类型系统</li><li>不知道将来会有什么类型</li><li>需要在不重新编译或修改代码的情况下，修改或添加新的类型</li></ul><p>注：在 C++ 内部，虚方法通过 虚函数表 (vtable) 实现，一个虚函数表是包含了函数指针集合的简单结构体，每个函数指针指向类里一个虚方法。每个类在内存驻存一张虚函数表。每个实例都有一个指向其类虚函数表的指针。当调用虚函数时，代码首先从对象虚函数表中查找，通过存储在表里的函数指针进行函数调用。<br />缺点</p><ul><li>通过类型对象去定义类型相关的数据非常容易，但是定义类型相关的行为却很难</li><li>解决方式：<ul><li>简单方式：是创建一个固定的预定义行为集合，让类型对象中数据从中任选其一</li><li>复杂方式：支持在数据中定义行为 (解释器模式或字节码模式)</li></ul></li></ul><p>通过继承共享数据</p><ul><li>没错，数据之间也可以通过继承共享</li><li>分为动态继承 (基类可能会动态变更) 或静态 (基类属性不变) 直接复制给子类</li></ul><p>类型对象应该封装还是暴露</p><ul><li>如果封装<ul><li>类型对象模式的复杂性对代码库其它部分不可见，成为持有类型对象才关心的实现细节</li><li>持有类型对象可以选择性重写类型对象的行为</li><li>需要给类型对象暴露的所有内容提供转发函数</li></ul></li><li>如果公开类型对象<ul><li>外部代码在没有持有类型对象类实例的情况下就能访问类型对象</li><li>类型对象现在是对象公共 API 的一部分</li></ul></li></ul><h1 id="解藕型模式"><a class="anchor" href="#解藕型模式">#</a> 解藕型模式</h1><p>我们几乎没有可能不去更改程序的功能或特性，而解藕能够让变化变得简单点。<br />某块代码中的变化通常不会影响到另一块代码</p><ul><li>组件将游戏中不同域相互解藕成单一实体</li><li>事件队列能够静态而且及时地将两个通信中的对象解藕开来</li><li>服务器定位器允许代码访问功能却不需要被绑定到提供服务的代码上</li></ul><h2 id="组件模式"><a class="anchor" href="#组件模式">#</a> 组件模式</h2><p>『允许一个单一的实体跨越多个不同域而不会导致耦合』</p><ul><li>软件设计的趋势是尽可能使用组合而不是继承</li><li>为实现两个类之间的代码共享，应该让它们拥有同一个类的实例而不是继承同一个类</li></ul><p>单一实体横跨了多个域，为保持域之间的相互隔离，每个域的代码都独立地放在自己的组件类中。实体本身则简化为这些组件的容器。<br />使用情景：</p><ul><li>有一个涉及多个域的类，但也能够用在别的地方</li><li>一个类越来越庞大、难以开发</li><li>希望定义许多共享不同能力的对象，但采用继承方式却无法精确重用代码</li></ul><p>注 1：组件模式相较直接在类中实现，引入了更多复杂性：每个概念上的对象成为一系列必须被同时实例化、初始化，并正确关联的集群。不同组件间通信也变得更具挑战性。<br />注 2：组件指针属于二级引用，在循环代码中可能导致更低性能</p><h3 id="组件之间传递信息"><a class="anchor" href="#组件之间传递信息">#</a> 组件之间传递信息</h3><ol><li>通过修改容器对象的状态 (状态共享)<ul><li>使组件间可以保持解藕</li><li>要求组件间任何需要共享的数据都由容器对象进行共享</li><li>使得信息传递变得隐秘，同时对组件执行的顺序产生依赖</li></ul></li><li>直接相互引用 (组件之间会有耦合)</li><li>通过传递信息的方式 (最复杂)</li></ol><h2 id="事件队列"><a class="anchor" href="#事件队列">#</a> 事件队列</h2><p>『对消息或事件的发送与受理进行时间上的解藕』<br />事件队列是一个按照先进先出顺序存储一系列通知或请求的队列。请求可由处理直接处理或转交给对其感兴趣模块，使消息的处理变得动态且非实时。</p><ul><li>在很多方面，可以看作是观察者模式的异步版本</li></ul><p>使用情景：</p><ul><li>相比观察者模式的直接 『派发 - 处理』模式，队列提供给拉取请求的代码块一些控制权：接收者可以延迟处理，聚合请求或完全废弃它们</li><li>使得队列在发送端需要实时反馈时显得不适用</li><li>如播放音效：解藕播放与受理，并避免两个同类音效同时叠加播放</li></ul><p>注 1：队列事件视图比同步系统中的事件具有更重量级的数据结构：后者只需通知然后接收者可以通过检查系统环境获知，而队列则需要在事件发生时记录以便稍后处理消息时使用。<br />注 2：当消息系统是同步时，注意可能导致消息循环的情景，如避免在处理事件端代码中发送事件。</p><h3 id="环形缓冲区"><a class="anchor" href="#环形缓冲区">#</a> 环形缓冲区</h3><h3 id="设计决策-2"><a class="anchor" href="#设计决策-2">#</a> 设计决策</h3><p>入队的是什么</p><ul><li>事件：就有点类似异步观察者模式</li><li>消息：一个『消息』或『请求』描述一种期望发生在『将来』的行为，或者可以认为是一种异步 API 服务</li></ul><p>读取者</p><ul><li>单播队列：当一个队列是一个类 API 本身的一部分时</li><li>广播队列：类似事件系统</li><li>工作队列：可以有多个处理者，不过队列中一项只能投递给一个处理者</li></ul><p>写入者</p><ul><li>一个写入者：类似同步观察者模式<ul><li>隐式知道事件来源</li><li>通常允许多个读取者</li></ul></li><li>多个写入者：类似『全局』或『中央』事件总线工作原理</li></ul><p>同步消息提醒模式下，调用执行只有在所有接收者都处理完消息后才会返回到发送者。</p><h2 id="服务定位器"><a class="anchor" href="#服务定位器">#</a> 服务定位器</h2><p>『为某服务提供一个全局访问入口来避免使用者与该服务具体实现类之间产生耦合』</p><ul><li>一个服务类为一系列操作定义了一个抽象接口</li><li>一个具体的服务提供器实现这个接口</li><li>一个单独的服务定位器通过查找一个合适的提供器来提供这个服务的访问，同时屏蔽了提供器的具体类型和定位这个服务的过程</li><li>注：由于使用接口抽象，因此可以方便地使用装饰器模式额外为服务提供器附加额外功能</li></ul><p>注：注意处理服务不能被定位器使用时的处理</p><h1 id="优化型模式"><a class="anchor" href="#优化型模式">#</a> 优化型模式</h1><h2 id="数据局部性"><a class="anchor" href="#数据局部性">#</a> 数据局部性</h2><p>『通过合理组织数据利用 CPU 的缓存机制来加快内存访问速度』<br />我们能更快地处理数据，但不能更快地获取数据</p><ul><li>CPU 进行运算时需要从主存取出数据并置入寄存器</li><li>RAM 的存取速度远远跟不上 CPU 的速度，甚至从未接近</li></ul><p>数据获取 (缓存)</p><ul><li>利用数据的时空局部性，获取数据时同时缓存数据及相关数据。</li></ul><p>数据即性能</p><ul><li>缓存失效与面向数据局部性的代码，性能相差可能几十倍，由于缓存机制，组织数据的方式会直接影响性能 (包括代码也是在内存中，需要载入 CPU 执行)</li><li>缓存行：优化的目标在于尽量将数据结构组织，使其在内存中两两相邻</li></ul><p>使用情景</p><ul><li>找到出现性能热点的地方</li><li>不需要在不常执行之处：结果会更加复杂笨拙</li></ul><p>使用须知</p><ul><li>抽象化意味着要通过指针或引用访问对象，导致在内存中来回跳转，引发缓存未命中的现象</li><li>越是在数据局部性上下功夫，就越要牺牲继承、接口及这些手段带来的好处</li></ul><p>CPU 流水线</p><ul><li>免分支预测，导致 CPU 预测失准和流水线停顿<ul><li>现代 CPU 单条指令需要多个时钟周期来完成，为了让 CPU 保持忙碌，因此引入流水线以便多条指令并行执行</li></ul></li><li>流水线模式：CPU 猜测哪些指令接下来会被执行，顺序结构很简单，控制流结构很麻烦，需要分支猜测：分析前面代码走向，预测下一次代码执行流（因此出现控制流代码会降低面向数据设计的性能，因此关键代码最好避开控制流）</li></ul><p>冷 / 热代码分解</p><ul><li>每帧需要检查和修改的变量 (如位置)</li><li>非每帧需要用到的处理意外情况的变量 (如怪物掉落数据)</li></ul><h3 id="设计决策-3"><a class="anchor" href="#设计决策-3">#</a> 设计决策</h3><ul><li>避开继承<ul><li>或者至少在进行缓存优化之处避开</li></ul></li><li>为不同的对象类型使用相互独立的数组</li></ul><p>游戏实体的定义 (主要指配合组件模式)</p><ul><li>假如游戏实体通过类中的指针索引其组件<ul><li>可以将组件存于相邻数组中，游戏实体并不关心组件存储，这样组织可以对迭代过程进行优化</li><li>对于给定实体，很容易通过其指针获取对应组件</li><li>在内存中移动组件较困难：启用禁用组件，对其移动 (排序) 时，可能一不小心就破坏了指针关联，必须确保对实体相应指针进行更新</li></ul></li><li>假如游戏实体通过一系列 ID 进行索引更新<ul><li>更加复杂 (相比指针)</li><li>速度更慢：不大可能比遍历原始指针更快，通过 ID 获取组件可能也涉及到哈希查找问题</li><li>需要访问组件管理器：存储组件数组的管理类来提供 ID 获取组件的对应接口</li></ul></li><li>假如游戏实体本身就只是个 ID<ul><li>若将游戏实体所有行为和状态都从主类移动到组件中，游戏实体唯一要做的就是将自己与其组件绑定</li><li>实体类变得很小，只是个数值包装</li><li>实体类本身为空</li><li>无需管理其生命周期 (现在实体只是某些内置类型的值)</li><li>检索一个实体的所有组件会很慢：与前一个方案问题类似，为某个实体寻找对应组件需要进行 ID 映射带来开销 (或者将实体 ID 对应为其组件所在数组索引，但这样所有组件必须保持平行，导致不能排序)</li></ul></li></ul><h2 id="脏标记模式"><a class="anchor" href="#脏标记模式">#</a> 脏标记模式</h2><p>『将工作推迟到必要时进行以避免不必要的工作』<br />一组原始数据随时间变化，一组衍生数据经过一些代价昂贵的操作由这些数据确定。一个脏标记跟踪这个衍生数据是否和原始数据同步，它在原始数据改变时被设置。如果它被设置，那么当需要衍生数据时，它们就会被重新计算并清除标记，否则仅使用缓存数据。<br />使用情景</p><ul><li>这个模式解决一个相当特定的问题</li><li>仅当性能问题严重到值得增加代码复杂度时才使用</li></ul><p>其它要求</p><ul><li>原始数据修改次数比衍生数据的使用次数多</li><li>递增更新数据十分困难<ul><li>例如在容器里放东西，更新容器总量，每当增加或减少时重新统计 —— 这样还不如使用动态总重量：增加或减少物品时直接在总量上进行操作（例如属性系统）</li></ul></li></ul><p>注意</p><ul><li>延时太长会有代价<ul><li>这个模式将某些耗时工作推迟到真正需要时才执行</li><li>而真正需要时，往往刻不容缓</li></ul></li><li>必须保证每次状态改动时都设置脏标记</li><li>必须在内存中保存上次的衍生数据</li></ul><h2 id="对象池"><a class="anchor" href="#对象池">#</a> 对象池</h2><p>内存碎片化</p><ul><li>如同乱停的车和规矩停放的车，可停数量差异一样。</li><li>即使碎片化情况很少，它也依然在削减着堆内存并使其成为一个千疮百孔而不可用的泡沫块。</li></ul><p>使用情景</p><ul><li>需要频繁创建和销毁对象</li><li>对象的大小一致</li><li>在堆上进行对象内存分配较慢或会产生内存碎片时</li><li>每个对象封装着获取代价昂贵且可重用的资源</li></ul><p>注意</p><ul><li>每个对象的内存大小是固定的 (应当是一个类型)</li><li>重用对象不会被自动清理 (若没有适当重设，可能保留上一次的数据)</li><li>未使用的对象将占用内存 (并会阻碍垃圾回收释放它指向的对象)</li></ul><p>空闲表</p><ul><li>O (1) 的时间复杂度</li><li>一个头指针，依次指向形成链表</li><li>使用时取出当前头指针，并重置当前头指针为其指向的下一个空闲对象</li><li>回收时将回收对象指向当前头指针，然后重置当前头指针为回收对象</li></ul><h2 id="空间分区"><a class="anchor" href="#空间分区">#</a> 空间分区</h2><p>『将对象存储在根据位置组织的数据结构中来高效地定位它们。』<br />基本要求是有一组对象，每个对象都具备某种位置信息。</p><ul><li>普通 (方格) 空间分区</li><li>四叉树 (二维)</li><li>八叉树 (三维)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;说实话，关于正经游戏模式的书还是有点少，这本算是少数中的其中之一。&lt;/p&gt;
&lt;p&gt;整本书看下来，发现书里并没有按照类似常规 “23 种设计模式” 这种概念来讲述，有</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>虚幻5基础学习笔记-详细(C++)</title>
    <link href="https://wangjiaying.top/2023/09/18/%E8%99%9A%E5%B9%BB5%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-C/"/>
    <id>https://wangjiaying.top/2023/09/18/%E8%99%9A%E5%B9%BB5%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-C/</id>
    <published>2023-09-18T04:20:22.000Z</published>
    <updated>2023-10-06T04:24:14.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>前几天 Unity 公布了新的 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnVuaXR5LmNvbS9jbi9uZXdzL3BsYW4tcHJpY2luZy1hbmQtcGFja2FnaW5nLXVwZGF0ZXM=">收费政策</span>，然后整个开发者社区都沸腾了，处处都是 <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzYyMTc1MTM4MQ==">讨论的声音</span>，不管最后实际生效政策如何 (2023.9.18 官方似乎更新了公告，说会对『运行费』政策进行修改)，这种杀鸡取卵的行为必然都会造成以后开发选择的考虑点。</p><p>之前本来还打算专一 Unity 的，比如前些日子都还一直在研究 HDRP，算是基本把 HDRP 物理光照、各种调参熟悉得七七八八了，结果就听到这么个消息... 简直是...<br /> 如果真的实施，人家独立开发只怕都会把这个作为一个很大比例权重考虑进去了，毕竟哪个游戏开发者没有想做个好玩 (爆款) 的大作的梦想呢？</p><p>之前一直都关注 UE，比如 UE 商城每月一次的各种免费资源都嫖了好久：</p><p><img data-src="/blogimages/2023/2023-09-18/Snipaste_2023-09-18_14-48-05.jpg" alt="" /></p><p>要是没有使用之地也太可惜了。</p><p>加上想到到学 UE 顺便还能深入下 C++ 和真正的游戏引擎代码 (Unity 作为一个黑盒引擎，有时候用起来确实感觉不是自己的)</p><blockquote><p>之前本来还打算 C# 一条道走到黑的，现在考虑了良久，觉得至少 C/C++ 也要深入一下才行，UE 也可以算是个入口了<br />而且 UE 内置工具链比 Unity 完善很多，Unity 扩展几乎全靠插件... 怎么感觉 UE 才适合个人玩？毕竟很多东西给提供了，不用个人造轮子。<br />几年前使用 UE4 的时候，感觉很难搞下去还有一个重要原因是：UE 的 C++ 操作起来实在太慢了！最近重新试了下，现在代码跳转提示的速度算是可以接受了。</p></blockquote><p>这两天对 UE 的基础知识进行了一轮学习，先记录一部分笔记，后续再做补充。</p><h1 id="术语"><a class="anchor" href="#术语">#</a> 术语</h1><h2 id="gameplay"><a class="anchor" href="#gameplay">#</a> Gameplay</h2><ul><li>玩法：游戏的规则和状态</li><li>提供能力的是引擎，提供内容的是 Gameplay</li><li>Unreal Gameplay 框架：游戏规则、角色、控制、相机、用户界面和 HUD<ul><li>GameMode：不同的游戏规则</li><li>GameState：存储当前的游戏状态</li><li>PlayerState：存储玩家状态信息</li><li>Character：角色</li><li>Camera：相机</li><li>Controller：控制器</li><li>3C：Character、Control 和 Camera</li></ul></li></ul><p>GameFeatures：UE5 推出的一个支持动态改变游戏玩法的框架</p><ul><li>类似动态插件</li><li>一种模块化的逻辑组织方式，GameFeatures 允许在 “游戏功能” 这个颗粒度上进行解耦</li></ul><p>UGameInstance：游戏单例，全局唯一</p><ul><li>引擎的初始化加载</li><li>还可以包含 UGameInstanceSubsystem</li></ul><p>GEngine：全局变量</p><ul><li>也可以包含 UEngineSubsystem</li></ul><p>坐标轴</p><ul><li>X、Y、Z</li><li>Row、Pitch、Yaw</li></ul><p>服务器</p><ul><li>异构服务器：客户端和服务器的执行逻辑完全不一样，服务器和客户端分别各自实现</li><li>同构服务器：服务器和客户端用同一套框架和代码，通过在启动时指定自己作为服务器还是客户端即可</li></ul><h2 id="关系"><a class="anchor" href="#关系">#</a> 关系</h2><ul><li>Actor 组成世界</li><li>Actor 由 Component 组成</li></ul><h3 id="component"><a class="anchor" href="#component">#</a> Component</h3><ul><li>功能的载体，表达的是『功能』的概念，一定程度的嵌套组装能力 (SceneComponent)</li><li>正确理解『功能』和『游戏业务逻辑』的区分是理解 Component 的关键要点</li></ul><blockquote><p>是实现一个个『与特定游戏无关』的功能。理想情况下，已经实现完成的 Components 是可以直接在游戏之间迁移使用<br /> ——<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yMzMyMTY2Ng==">《InsideUE4》GamePlay 架构（四）Pawn</span></p></blockquote><h3 id="actor"><a class="anchor" href="#actor">#</a> Actor</h3><ul><li>世界中的基础对象</li><li>Actor 可以组装其它 Actor 或 Component</li><li>概念上也可以类比 Unity 中的 Prefab</li></ul><h3 id="pawn"><a class="anchor" href="#pawn">#</a> Pawn</h3><ul><li>可以响应响应外部输入、移动能力的 Actor (如可以被玩家或 AI 控制)</li><li>封装了一些列对 UPawnMovementComponent 组件操作 (因此也有封装碰撞)</li></ul><p>分类</p><ul><li>DefaultPawn：默认带 UFloatingPawnMovement (移动)、USphereComponent (碰撞)、UStaticMeshComponent (显示) 三件套</li><li>SpectatorPawn (观众)：相当于不带重力的 DefaultPawn</li><li>Character：人形角色使用 (Pawn 的加强特化版本)</li></ul><h1 id="结构"><a class="anchor" href="#结构">#</a> 结构</h1><p>保管库：下载资源地址，每个引擎对应一个，可自定义路径</p><ul><li>不需要的引擎可删除</li></ul><p>编译 (材质) 公共缓存：AppData/Local/UnrealEngine</p><ul><li>派生数据缓存 (DDC)</li><li>不用引擎版本可删除</li><li>还可以放服务器</li></ul><h2 id="视口"><a class="anchor" href="#视口">#</a> 视口</h2><ul><li>快速隐藏各个 Editor 提示图标：选 GameView (快捷键 G)</li><li>ShowFPS：显示帧率</li><li>全屏：F11</li><li>移动捕捉：视口右上，网格图标设置</li><li>相机自动跟随移动目标：按住 Shift + 移动</li><li>End 键：将对象投射到地面</li><li>物体对齐当前视口：右键对象，选择 SnapObjectToView</li><li>复制：Alt + 拖动</li><li>以视口控制移动：Ctrl+Shift+P (或右键 actor 选择控制)</li><li>运行模式退出鼠标：Shitf+F1</li></ul><h2 id="工具"><a class="anchor" href="#工具">#</a> 工具</h2><p>BSP：做原型的，可以避免普通 cube 材质拉伸等，还支持打洞、组合等。</p><h1 id="代码"><a class="anchor" href="#代码">#</a> 代码</h1><p>UHT：反射与垃圾回收系统</p><ul><li><code>#include &quot;xxx.generated.h&quot;</code>  需要包含在最后，其它头文件在此之前</li></ul><p>类型</p><ul><li>整型使用 int32 (UE 提供的跨平台类型)</li></ul><h2 id="类型关系"><a class="anchor" href="#类型关系">#</a> 类型关系</h2><p>继承关系</p><ul><li>UObject-&gt;<ul><li>UActorComponent</li><li>AActor<ul><li>APawn-&gt;ACharacter</li><li>AController-&gt;APlayerController</li><li>AInfo-&gt;APlayerState</li></ul></li></ul></li></ul><p>命名关系</p><ul><li>派生自 Actor 带有 A 前缀，如 AController</li><li>派生自 Object 带有 U 前缀，如 UComponent</li><li>Enums 的前缀是 E，如 EFortificationType</li><li>Interface 的前缀是 I，如 IAbilitySystemInterface</li><li>Template 的前缀是 T，如 TArray</li><li>派生自 SWidget 的类 (Slate UI) 带有前缀 S，如 SButton</li><li>其它类 (结构) 的前缀为字母 F，如 FVector</li></ul><h3 id="详情"><a class="anchor" href="#详情">#</a> 详情</h3><h4 id="uobject"><a class="anchor" href="#uobject">#</a> UObject</h4><ul><li>存放数据、不能放置到场景</li></ul><h4 id="uactorcomponent"><a class="anchor" href="#uactorcomponent">#</a> UActorComponent</h4><ul><li>可以挂载至场景 Actor 上，必须依附于 Actor 存在</li></ul><h4 id="aactor"><a class="anchor" href="#aactor">#</a> AActor</h4><ul><li>能放置在场景，可以有视觉表现</li><li>除了继承自 UObject 的序列化、反射、内存管理等能力之外，额外实现的是组件的组合能力，Tick 能力，网络复制能力和对生命周期的管控</li></ul><h4 id="apawn"><a class="anchor" href="#apawn">#</a> APawn</h4><ul><li>可以被控制器持有</li></ul><h4 id="acharacter"><a class="anchor" href="#acharacter">#</a> ACharacter</h4><ul><li>有角色移动组件 (CharacterMovementComponent)</li><li>具有角色封装好的一系列功能</li></ul><h4 id="acontroller"><a class="anchor" href="#acontroller">#</a> AController</h4><ul><li>可以控制 APawn 的控制器</li></ul><h4 id="aplayercontroller"><a class="anchor" href="#aplayercontroller">#</a> APlayerController</h4><ul><li>角色控制器存在于整个游戏关卡中，而 Pawn 可以被破坏、重生</li><li>可以控制不同的 Pawn，也可以在它们之间切换，或完全不控制任何 Pawn</li><li>具有输入，不过一般用于处理与 Pawn 无关的事件 (如 UI)</li></ul><h3 id="注意"><a class="anchor" href="#注意">#</a> 注意</h3><ul><li>如果想要一个 C++ 类可以被蓝图继承，需要填写<ul><li>UCLASS(Blueprintable)</li><li>注：继承应用了该宏的派生类可以不用加</li></ul></li><li>不建议 vs 生成代码，而是引擎中编译按钮进行重新生成，或按 Alt+Ctrl+F11 调用引擎 LiveCoding 编译 (编译信息可以在 Window-&gt;MessageLog 查看)</li><li>若关闭了 LiveCoding 可使用 Ctrl+Alt+Shift+P 热编译代码修改</li></ul><h2 id="接口"><a class="anchor" href="#接口">#</a> 接口</h2><h3 id="常规"><a class="anchor" href="#常规">#</a> 常规</h3><ul><li><p>GetWorld()：&quot;Engine/World.h&quot;</p><ul><li>UActorComponent、AActor 均有该接口</li></ul></li><li><p>GetActorTransform：transform</p></li><li><p>SetActorLocation：设置对象坐标，同 Unity position</p></li><li><p>AddActorLocalOffset：本地坐标增量移动 (注：sweep 只对根组件生效)</p></li><li><p>AddForce：启用物理模拟后施加力，可传入第三个参数指定忽略质量</p></li><li><p>SetupAttachment：设置父级组件</p></li><li><p>ContructorHelper：静态帮助类，可用于加载资源</p></li><li><p>&quot;Kismet/GameplayStatics.h&quot;</p><ul><li>各种帮助函数，如 GetAllActorsOfClass (GetWorld (),XXX::StaticClasd)</li></ul></li><li><p>碰撞</p><ul><li>设置为触发器：UBoxComponent-&gt;SetCollisionEnabled (ECollisionEnabled::QueryOnly)</li><li>设置响应通道：-&gt;SetCollisionResponseToChannel ()</li><li>绑定响应事件：-&gt;OnComponentBeginOverlap.AddDynamic ()</li><li>注：或直接使用 TriggerBox 等</li></ul></li></ul><h3 id="对象创建"><a class="anchor" href="#对象创建">#</a> 对象创建</h3><h4 id="uworldspawnactor"><a class="anchor" href="#uworldspawnactor">#</a> UWorld::SpawnActor</h4><ul><li>在世界中创建 Actor</li></ul><h4 id="uworldspawnactordeferred"><a class="anchor" href="#uworldspawnactordeferred">#</a> UWorld::SpawnActorDeferred</h4><ul><li>在世界中创建 Actor</li><li>配套 xxx-&gt;FinishSpawn () 调用后才会调用 BeginPlay 等进行初始化的函数，即延迟调用 (在此之前可设置一些其它初始化参数)</li></ul><h4 id="createdefaultsubobject"><a class="anchor" href="#createdefaultsubobject">#</a> CreateDefaultSubobject</h4><ul><li>为 Actor 创建组件 ( <code>只能在构造函数使用</code> )</li><li>T：类型</li><li>TEXT：一个标识，当前类中不能重复</li></ul><h4 id="newobject"><a class="anchor" href="#newobject">#</a> NewObject</h4><ul><li>仅在运行时构建 UObject 使用 ( <code>构造函数不要用</code> )</li><li>主要指 UObject 的派生类 (非 Actor、非 ActorComponent)</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNS4wL3poLUNOL29iamVjdHMtaW4tdW5yZWFsLWVuZ2luZS8=">objects-in-unreal-engine</span></li></ul><h4 id="aactoraddcomponentbyclass"><a class="anchor" href="#aactoraddcomponentbyclass">#</a> AActor::AddComponentByClass</h4><ul><li>动态为 Actor 创建一个组件</li><li>AActor 所实现，内部其实也是调用 NewObject 创建 (所以构造函数应当也不要用)</li></ul><h4 id="纯-c-类的创建"><a class="anchor" href="#纯-c-类的创建">#</a> 纯 C++ 类的创建</h4><ul><li>纯 C++ 类 (指非继承自 UObject 的类，如 UE 中一般以 F 开头的)</li><li>可以通过 new 来创建对象，并使用 TSharedPtr 和 TSharedRef 来管理对象</li><li><code>TSharedPtr&lt;MyClass&gt; MyClassPtr = MakeShareable(new MyClass())</code></li></ul><h3 id="资源加载"><a class="anchor" href="#资源加载">#</a> 资源加载</h3><h4 id="uobjectstaticloadobject"><a class="anchor" href="#uobjectstaticloadobject">#</a> UObject::StaticLoadObject</h4><ul><li>加载资源文件 (静态对象、非蓝图资源)</li><li>应该算是资源加载 API 中最底层的了？</li></ul><h4 id="uobjectstaticloadclass"><a class="anchor" href="#uobjectstaticloadclass">#</a> UObject::StaticLoadClass</h4><ul><li>可用于加载蓝图类资源</li><li>内部调用 LoadObject</li></ul><h4 id="loadobjectt"><a class="anchor" href="#loadobjectt">#</a> LoadObject&lt; <code>T</code> &gt;</h4><ul><li>封装  <code>StaticLoadObject</code> ，可以当做其泛型版本</li><li>可用来加载非蓝图资源，比如动画、贴图、音效等</li><li>内部会先执行 FindObject (查找已加载对象)</li></ul><h4 id="loadclasst"><a class="anchor" href="#loadclasst">#</a> LoadClass&lt; <code>T</code> &gt;</h4><ul><li>封装  <code>StaticLoadClass</code> ，用来加载 UClass，可以当做其泛型版本</li><li>可以用来加载蓝图并获取蓝图类</li></ul><h4 id="constructorhelpers"><a class="anchor" href="#constructorhelpers">#</a> ConstructorHelpers</h4><ul><li>FClassFinder：可以用来加载蓝图类资源</li><li>FObjectFinder：对 LoadObject () 的封装，加载非蓝图普通资源</li><li><code>只能在构造函数使用</code></li><li>查找某个对象的对象和类</li></ul><h4 id="fsoftobjectpath"><a class="anchor" href="#fsoftobjectpath">#</a> FSoftObjectPath</h4><ul><li>包含资源路径字符串的结构体</li><li>根据给定的资源路径找到对应的资源</li><li>ResolveObject 内部封装  <code>FindObject&lt;UObject&gt;(nullptr, PathString)</code>  调用</li><li>TryLoad 内部封装  <code>StaticLoadObject</code>  或  <code>LoadObject</code>  调用</li><li>可配合 StreamableManager 进行资源异步加载</li><li>TSoftObjectPtr ：看起来可以管理 FSoftObjectPath</li></ul><h4 id="fsoftclasspath"><a class="anchor" href="#fsoftclasspath">#</a> FSoftClassPath</h4><ul><li>继承自 FSoftObjectPath，可用于加载蓝图资源</li><li>提供 TryLoadClass 实际调用 LoadClass</li></ul><h4 id="fsoftobjectptr"><a class="anchor" href="#fsoftobjectptr">#</a> FSoftObjectPtr</h4><ul><li>封装对 FSoftObjectPath 操作</li><li>(也提供了 LoadSynchronous 同步加载方法，实际是调用 FSoftObjectPath.TryLoad)</li></ul><h4 id="tsoftclassptr"><a class="anchor" href="#tsoftclassptr">#</a> TSoftClassPtr</h4><ul><li>与 TSoftObjectPtr 类似</li></ul><h4 id="fstreamablemanager"><a class="anchor" href="#fstreamablemanager">#</a> FStreamableManager</h4><ul><li>可用于资源异步加载</li><li>异步加载：<ul><li>RequestAsyncLoad，返回 FStreamableHandle</li></ul></li><li>同步加载：<ul><li>RequestSyncLoad (多个或单个加载，返回 FStreamableHandle)</li><li>LoadSynchronous (单个加载，实际调用 RequestSyncLoad，直接返回 UObject)</li></ul></li><li>看起来主要是与 FSoftObjectPath 配合使用</li><li>官方建议定义在类似单例之类对象中使用</li><li>注：FStreamableHandle 是同步或者异步加载的句柄，只要句柄处于激活状态，资源就会一直存在于内存</li></ul><h4 id="objectlibrary"><a class="anchor" href="#objectlibrary">#</a> ObjectLibrary</h4><ul><li>资源加载库：设定一个路径，然后让它自动扫描</li><li>可用于在指定路径中加载所有资源数据，之后选择性加载实际资源</li><li>其中存储的 FAssetData 提供 GetSoftObjectPath () 接口返回 FSoftClassPath</li></ul><h4 id="调用关系"><a class="anchor" href="#调用关系">#</a> 调用关系</h4><ul><li><code>LoadObject</code> -&gt;UObject::StaticLoadObject</li><li><code>UObject::StaticLoadClass</code> -&gt;LoadObject-&gt;UObject::StaticLoadObject</li><li><code>LoadClass</code> -&gt;UObject::StaticLoadClass-&gt;LoadObject-&gt;UObject::StaticLoadObject</li><li><code>ConstructorHelpers::FObjectFinder</code> -&gt;LoadObject-&gt;UObject::StaticLoadObject</li><li><code>ConstructorHelpers::FClassFinder</code> -&gt;UObject::StaticLoadClass-&gt;LoadObject-&gt;UObject::StaticLoadObject</li><li><code>FSoftObjectPath</code> -&gt;ResolveObject-&gt;UObject::FindObject</li><li><code>FSoftObjectPath</code> -&gt;TryLoad-&gt;UObject::StaticLoadObject</li><li><code>FSoftClassPath</code> -&gt;TryLoadClass-&gt;LoadClass-&gt;UObject::StaticLoadClass-&gt;LoadObject-&gt;UObject::StaticLoadObject</li></ul><h4 id="注意-2"><a class="anchor" href="#注意-2">#</a> 注意</h4><p>资源加载中，同类 API 一般有  <code>LoadObject</code>  和  <code>LoadClass</code>  两种版本的，其中  <code>LoadObject</code>  最基础， <code>LoadClass</code>  属于在  <code>LoadObject</code>  之上的封装 (继承) 扩展。<br />相当于 LoadObject 可用于加载所有资源，而 LoadClass 可用于更方便地加载蓝图类资源 (不知道理解得对不对)。</p><p>FObjectFinder、FClassFinder、LoadClass、StaticLoadClass 等最终都会调用到 LoadObject</p><h3 id="模板"><a class="anchor" href="#模板">#</a> 模板</h3><p>TSubclassOf&lt; <code>T</code> &gt;：定义类类型属性时，使引擎面板过滤类型，只能选择 T 类本身或继承自它的类。</p><ul><li>注：直接定义类类型指针，将能选择场景中类型对象</li></ul><p>TArray：动态容器<br /> Cast&lt; <code>T</code> &gt;：类型转换</p><h3 id="字符串"><a class="anchor" href="#字符串">#</a> 字符串</h3><ul><li>FString::FromInt</li><li>FString::SanitizeFloat</li><li>FString::Printf</li></ul><h3 id="调试"><a class="anchor" href="#调试">#</a> 调试</h3><p>GEngine-&gt;AddOnScreenDebugMessage：屏幕调试显示 (-1 的 key 可以始终显示，否则会去重)</p><ul><li>蓝图中为 PrintString</li></ul><h3 id="材质"><a class="anchor" href="#材质">#</a> 材质</h3><p>Actor：BaseMesh</p><ul><li>BaseMesh-&gt;CreateAndSetMaterialInstanceDynamic</li><li>UMaterialInstanceDynamic-&gt;SetVectorParameterValue()</li></ul><h3 id="颜色"><a class="anchor" href="#颜色">#</a> 颜色</h3><p>FLineColor</p><ul><li>有预定义静态颜色</li><li>随机颜色：FLineColor::MakeRandomColor ()</li></ul><h3 id="定时器"><a class="anchor" href="#定时器">#</a> 定时器</h3><p>TimeManager.h</p><ul><li>GetWorldTimerManager().SetTimer(FTimeHandler,this,callback,timeRate,isLoop)</li><li>GetWorldTimerManager().ClearTimer(FTimeHandler)</li></ul><h3 id="组件"><a class="anchor" href="#组件">#</a> 组件</h3><ul><li>USceneComponent：空组件</li><li>UStaticMeshComponent：mesh 组件</li><li>USpringArmComponent：悬臂组件 (相机平滑跟随)</li><li>UCameraComponent：相机</li><li>UParticleSystem：粒子</li><li>UDecalComponent：贴花</li></ul><h2 id="宏定义"><a class="anchor" href="#宏定义">#</a> 宏定义</h2><ul><li>UPROPERTY<ul><li>BlueprintReadWrite</li><li>BlueprintReadOnly</li><li>VisibleAnywhere：可在任何地方可见</li><li>EditAnywhere：可在任何地方编辑 (常用，但指针类型避免使用)</li><li>Category=&quot;分类&quot;</li><li>EditInstanceOnly：只允许在实例上编辑</li><li>VisibleInstanceOnly：只允许在实例上查看</li><li>EditDefaultsOnly：只允许在原型中编辑</li><li>VisibleDefaultsOnly：只允许在原型中编辑</li><li>meta=(ClampMin=-5.0f,ClampMax=5.0f,UIMin=-5.0f,UIMax=5.0f)：数值限制等</li><li>meta=(AllowedClassses=&quot;Textures&quot;)：限制变量类型</li><li>注：标记该属性的对象会被引擎自动计数回收</li></ul></li><li>UFUNCTION<ul><li>BlueprintCallable</li><li>BlueprintImplementableEvent：标记方法为蓝图实现的事件，代码仅定义</li></ul></li><li>UE_LOG<ul><li>LogTemp,Log/Warning/Error,TEXT(&quot;Hello World!&quot;)</li></ul></li><li>FORCEINLINE：强制内联</li><li>DEFINE_LOG_CATEGORY_STATIC：自定义日志级别</li><li>UENUM：定义枚举<ul><li>BlueprintType (蓝图可用)</li></ul></li><li>USTRUCT：定义结构<ul><li>BlueprintType (蓝图可用)</li><li>主体需添加：GENERATED_USTRUCT_BODY</li></ul></li><li>DECLARE_DELEGATE：定义委托<ul><li>代码中通过 AddUObject 绑定</li></ul></li><li>DECLARE_MULTICAST_DELEGATE：定义多播委托</li><li>DECLARE_DYNAMIC_DELEGATE：定义委托 (蓝图可用)<ul><li>绑定的委托方法需要定义 UFUNCTION 宏</li><li>代码中通过 AddDynamic 绑定</li></ul></li><li>DECLARE_DYNAMIC_MULTICAST_DELEGATE：定义多播委托 (蓝图可用)</li></ul><h2 id="问题"><a class="anchor" href="#问题">#</a> 问题</h2><ul><li>不允许指针指向不完整类型<ul><li>官方文档搜索类型，可查看需要引入的头文件</li></ul></li><li>类前添加 class 可规避一些编辑器不识别的麻烦</li><li>默认创建类时，若添加了自己的目录，引用头文件也会添加，需要删除 (否则会找不到)</li></ul><h1 id="蓝图"><a class="anchor" href="#蓝图">#</a> 蓝图</h1><p>蓝图对象根组件：(如果没有任何组件时会自动创建) 相当于一个空物体对象，承载 Transform 等属性，可被替换</p><ul><li>根层级有多个组件且未指定根组件时，会随机选取一个作为根组件</li><li>指定方式很简单：(代码) 构造函数初始化时为 RootComponent 赋值即可</li></ul><p>操作</p><ul><li>Alt + 点击连接线：断开节点</li><li>右键蓝图 -&gt; 资产操作 -&gt; 重新加载</li></ul><p>其它</p><ul><li>关卡蓝图：每个关卡一张</li></ul><p>节点</p><ul><li>Construct Object from class：实例化一个继承自 UObject 的类</li><li>Break XXX：访问一个类型对象中的字段 (或直接右键节点 split)</li></ul><h1 id="物体"><a class="anchor" href="#物体">#</a> 物体</h1><p>碰撞</p><ul><li>默认导入对象生成的是复杂碰撞，简单碰撞需要手动生成 (Detail 面板也需要设置，引擎似乎也可以全局设置)</li><li>凸包碰撞：生成的凸包碰撞也是属于简单碰撞，外形与模型类似，可调整参数</li></ul><h1 id="控制台"><a class="anchor" href="#控制台">#</a> 控制台</h1><p>～键打开</p><ul><li>最大帧率：t.MaxFPS</li></ul><h1 id="参考文档"><a class="anchor" href="#参考文档">#</a> 参考文档</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MDgyOTY5NTU=">写给 Unity 开发者的 Unreal Engine 开发指南 （扫盲）</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTA1MjM0ODU=">Unreal Engine 的启动流程</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTI4MzcwNDU=">Unreal Engine 的 Gameplay 框架和重点</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NjcyMzY2NzU=">https://zhuanlan.zhihu.com/p/467236675</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUNlNHkxZTdQRQ==">【UE4/5】虚幻 4/5 入门 c++ 基础训练</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWFZNHkxeTdRNw==">成功上岸，将自己进大厂前花 3w 买的 C++ 游戏开发 &amp; 虚幻引擎 UE 全套教程，完整版 300 集，拿出来分享给大家！学会即可上岗就业</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yMzMyMTY2Nj9yZWZlcj1pbnNpZGV1ZTQ=">《InsideUE4》GamePlay 架构（四）Pawn</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yMzQ4MDA3MQ==">《InsideUE4》GamePlay 架构（五）Controller</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNC4yNy96aC1DTi9Qcm9ncmFtbWluZ0FuZFNjcmlwdGluZy9TdWJzeXN0ZW1zLw==">Subsystems</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b2ZlaXhpb25nc2l4L2FydGljbGUvZGV0YWlscy84MTA2MTc2NA==">Unreal Engine 4 C++ 创建对象的几种方法</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNS4wL3poLUNOL29iamVjdHMtaW4tdW5yZWFsLWVuZ2luZS8=">objects-in-unreal-engine</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85OTMyNzM3Mw==">【UE4 基础】对象创建与资源获取</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2luOTk4L3AvMTU1MDU5MTIuaHRtbA==">使用 ConstructorHelpers 来加载</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EzNTk4Nzc0NTQvYXJ0aWNsZS9kZXRhaWxzLzgwNTIzMzU0">[UE4] C++ 实现动态加载的问题</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMTc0NzkwMjI=">UE4_C++_资源加载与优化</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNC4yNi96aC1DTi9Qcm9ncmFtbWluZ0FuZFNjcmlwdGluZy9Qcm9ncmFtbWluZ1dpdGhDUFAvQXNzZXRzL0FzeW5jTG9hZGluZy8=">AsyncLoading</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC84MDg0NjI3Nw==">AssetManager 系列之 TAssetPtr 与 FStreamableManager</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2luOTk4L3AvMTU1NTQwNDguaHRtbA==">关于资产引用的各种 Path 和 Ptr 介绍</span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;前几天 Unity 公布了新的 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9ibG9nLnVuaXR5LmNvbS9jbi9</summary>
      
    
    
    
    <category term="虚幻引擎" scheme="https://wangjiaying.top/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    <category term="C++" scheme="https://wangjiaying.top/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/C/"/>
    
    
    <category term="虚幻引擎" scheme="https://wangjiaying.top/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>《.NET内存管理宝典》-笔记(6)[完]</title>
    <link href="https://wangjiaying.top/2023/08/21/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-6-%E5%AE%8C/"/>
    <id>https://wangjiaying.top/2023/08/21/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-6-%E5%AE%8C/</id>
    <published>2023-08-21T01:33:55.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本文包含原书第七章至第十五章，也就是本书最后一部分。<br />主要为对象资源释放、线程局部存储、托管指针、ref 类型、非托管类型、非托管约束、 <code>Span&lt;T&gt;</code> 、 <code>Memory&lt;T&gt;</code> 、Unsafe 类、面向数据设计 等高级主题。</p><p>这是本书的最后一份笔记，没想到整体看完这本书花了 2 月有余... 说来惭愧，这两个月花了太多时间在其它东西上去了：玩游戏，比如最近的蔚蓝档案、或者在家看 HDRP 相关的教程。<br />虽然除了玩游戏也不能说全无相关，但确实是这次没有专心看书了，导致时间线被严重拉长 —— 特别是本来每天就只有下班时间两个小时的情况下。</p><p>后面得再紧张一点了。</p><h1 id="第十二章-对象生存期"><a class="anchor" href="#第十二章-对象生存期">#</a> 第十二章 对象生存期</h1><h2 id="终结"><a class="anchor" href="#终结">#</a> 终结</h2><p>.NET 有两种终结方式：非确定性终结与确定性终结，也可以称为 隐式清除 和 显式清除</p><ul><li>析构函数</li><li>IDisposable</li></ul><p>终结机制和垃圾回收机制在概念上并没有直接关系。<br />终结器对象特点：</p><ul><li>执行时间非确定</li><li>执行顺序、及其持有的对象图只有在运行完终结器之后才能被回收</li><li>执行线程不确定</li><li>不保证终结器代码一定会执行一次 (如出错会阻塞执行线程)</li><li>在终结器引发异常会很危险 (无法执行终结器被视为最严重故障)</li><li>可终结对象对 GC 有额外开销</li></ul><p>因此，推荐显式 IDisposable 释放而非使用终结器<br />注：值类型可以有终结器，但只会在装箱实例上运行。其在 .NET Core 则直接无效。<br />调用时间点</p><ul><li>当 GC 结束时</li><li>当运行时卸载 AppDomain 和运行时终止时</li></ul><h3 id="关键终结器"><a class="anchor" href="#关键终结器">#</a> 关键终结器</h3><p>CriticalFinalizerObject<br /> 关键终结器是一种常规终结器，但其带有额外的保证，保证其代码一定会执行。</p><ul><li>是一个不包含实现的抽象类，只是类型系统和运行时之间的一个协议</li><li>运行时将采取一些预防措施确保在任何情况下都执行关键终结器 (如运行时会提前 jit 代码，避免后续因 out-of-memory 而无法 jit 编译和执行)</li></ul><p>(SafeHandle 继承 CriticalFinalizerObject)</p><h3 id="终结器内部实现"><a class="anchor" href="#终结器内部实现">#</a> 终结器内部实现</h3><p>GC 使用一个 finalization queue (终结器队列) 记录所有可终结对象</p><ul><li>在执行 GC 期间，GC 会在标记阶段结束后检查终结器队列，查看是否有可终结对象已死亡</li><li>若有，则将其移动到 fReachable queue (可达对象队列)，然后通知专门的终结器线程执行</li><li>终结器线程执行发生在 GC 将托管线程从挂起恢复到正常状态之后</li><li>由于引用这些对象的根已经从终结器队列移除，下一次 GC 时会最终对其执行回收：即可终结对象至少能存活到下一次 GC</li></ul><p>注 1：由于终结器线程不一定能在下一次 GC 前执行完毕，fReachable queue 在标记阶段也会被视为一个根，并导致终结器对象被提升到老一代，面临『中年危机』<br />注 2：.NET 提供一个方法 GC.WaitForPendingFunalizers ，可阻塞线程直到可达对象队列执行完毕<br />另外还有两个与终结器相关的重要 API：</p><ul><li>GC.ReRegisterForFinalize(object)</li><li>GC.SuppressFinalize (object)：设置对象标头中的一个 bit，终结器线程工作期间，不会调用此 bit 被设置过的对象的 Finalize 方法</li></ul><p>为什么需要专门的 queue 和终结器线程？</p><ul><li>终结器代码是用户的，以异步方式执行终结器代码更安全</li></ul><h3 id="终结器开销"><a class="anchor" href="#终结器开销">#</a> 终结器开销</h3><ul><li>默认情况下，分配对象时强制使用慢速分支</li><li>默认情况下，至少会让对象被提升一次，增加对象生存期</li><li>如果可终结对象分配速度快于被终结速度，导致危险后果</li></ul><h3 id="复活"><a class="anchor" href="#复活">#</a> 复活</h3><p>终结器代码可以将自身赋值给某个根，导致此对象重新变为可达，这种情况称为复活。</p><ul><li>注：复活后除非重新注册终结器队列，否则死亡时不会再执行终结器代码</li></ul><p>使用复活机制的场景之一是对象池的隐式回收，但隐式池化管理并没有特别的好处。</p><h3 id="终结器注意点"><a class="anchor" href="#终结器注意点">#</a> 终结器注意点</h3><ul><li>总是检查是否存在期待资源：如从构造函数抛出异常，会导致终结器在对象状态未完全初始化的情况下执行</li><li>避免在终结器分配资源：如果出现 OutOfMemory 会是严重错误</li><li>避免任何线程上下文依赖</li><li>不要在终结器抛出异常</li><li>避免从终结器调用 virtual 成员</li></ul><p>首选显式清理。</p><h2 id="idisposable"><a class="anchor" href="#idisposable">#</a> IDisposable</h2><p>通常可以将隐式释放的终结器与要求显式释放的 IDisposable 接口结合，若显示调用了 Dispose 方法则使用 GC.SuppressFinalize 抑制终结器的调用，否则以终结器兜底。<br />注：抑制终结器如上所示，操作很简单，没有性能影响</p><h2 id="安全句柄"><a class="anchor" href="#安全句柄">#</a> 安全句柄</h2><p>用于安全处理非托管资源的类型，构建于关键终结器 (CriticalFinalizerObject) 之上。</p><ul><li>即结合了显式和隐式释放</li></ul><p>CLR 在 P/Invoke 期间会以特殊方式处理：不会 (像 HandleRef 那样) 被垃圾回收，而是基于安全原因使用引用计数逻辑</p><ul><li>每个 P/Invoke 都包含 JIT 编译的用于递增引用计数逻辑，并在调用结束后递减计数器</li></ul><p>相比其它替代者，SafeHandle 好处有：</p><ul><li>拥有关键终结器，比常规终结器更可靠</li><li>仅对非托管资源 (句柄) 进行了最小化的简单封装</li><li>使用 SafeHandle 的对象无需使用终结器</li><li>更好的生存期管理：GC 在 P/Invoke 调用期间自动保持其存活状态，无需手动 GC.KeepAlive</li><li>有多个对应不同资源的 SafeHandle 子类型，比直接使用 IntPtr 拥有更好的强类型支持</li><li>对句柄重用攻击防范使得安全性提高</li></ul><p>注：P/Invoke marshaling 机制可以在底层将 SafeHandle 派生类视为 IntPtr (直接将 IntPtr 句柄赋值给 SafeHandle 派生类)</p><h3 id="预定义安全句柄"><a class="anchor" href="#预定义安全句柄">#</a> 预定义安全句柄</h3><ul><li>SafeFileHandle</li><li>SafeMemoryMappedFileHandle、SafeMemoryMappedViewHandle：内存映射文件句柄相关的安全句柄</li><li>SafeNCryptKeyHandle、SafeNCrypProviderHandle、SafeNCrypSecretHandle</li><li>SafePipeHandle：命名管道句柄的安全句柄</li><li>SafeProcessHandle：用于进程的安全句柄</li><li>SafeRegistryHandle：用于注册表键的安全句柄</li><li>SafeWaitHandle：安全等待句柄 (用于同步场景)</li></ul><p>注：若底层非托管代码某些部分确实需要直接使用 IntPtr，可以通过 DangerousGetHandle 获取原始句柄。</p><h2 id="弱引用"><a class="anchor" href="#弱引用">#</a> 弱引用</h2><p>存储一个对象的引用，但其自身不被视为一个根 (它对目标对象的引用不会使得后者保持可达状态)</p><ul><li>短弱句柄 (short weak handle)：当 GC 决定回收对象，在终结器运行之前被清零。即使终结器复活了对象，引用它的弱句柄依然保持清零状态。</li><li>长弱句柄 (long weak handle)：当对象由于终结被提升时，它们的目标仍然保持有效。如果终结器复活了对象，长弱句柄将保持有效状态。</li></ul><p>主要应用场景：</p><ul><li>各种类型的观察和侦听器</li><li>缓存</li></ul><p>.NET 提供：GCHandle 及封装其的 WeakReference 和 WeakReference<T>（请使用 TryGetTarget）<br />注：WPF 中存在 WeakEventManager 实现了弱事件的模式</p><h1 id="第十三章-其它主题"><a class="anchor" href="#第十三章-其它主题">#</a> 第十三章 其它主题</h1><h2 id="依赖句柄"><a class="anchor" href="#依赖句柄">#</a> 依赖句柄</h2><p>依赖句柄允许我们将两个对象的生存期耦合起来</p><ul><li>像其它 GC 句柄一样指向一个目标</li><li>行为像一个弱句柄：即不能使目标一直保持存活</li></ul><p>行为如下：</p><ul><li>句柄本身不会影响两个对象的生存期</li><li>只要主对象存活，次要对象也存活</li></ul><p>使用它的唯一方法是使用包装类 ConditionalWeakTable，其被组织为 Dictionary，其 key 存储主要对象，value 存储次要对象。</p><ul><li>注：此类的 key 是弱引用</li></ul><p>依赖句柄的底层弱引用行为像长弱引用：即使主要对象终结仍然会保持维护主要对象和次要对象之间的关系，使其可以正确处理复活场景。</p><h2 id="线程局部存储"><a class="anchor" href="#线程局部存储">#</a> 线程局部存储</h2><p>线程局部存储 (TLS)</p><ul><li>其行为像一个全局变量，但数据是为每个线程单独存储的。</li></ul><p>当前再 .NET 中有三种使用线程局部存储方法：</p><ul><li>线程静态字段：添加  <code>ThreadStatic</code>  属性标记后，就可以作为静态字段使用</li><li>包装线程静态字段的帮助类： <code>ThreadLocal&lt;T&gt;</code>  类型</li><li>线程数据插槽：在  <code>Thread.SetData</code>  和  <code>Thread.GetData</code>  方法的帮助下使用</li></ul><p>注：线程静态字段性能比线程数据插槽性能更好，且线程静态字段是强类型，而线程数据插槽始终对 object 进行操作。</p><h3 id="线程静态字段"><a class="anchor" href="#线程静态字段">#</a> 线程静态字段</h3><p>使用 ThreadStatic 标记常规静态字段即可，值和引用类型都可以用作线程静态字段。<br />注：若线程静态字段具有初始化程序，将只会在执行静态构造函数的线程上调用一次，会导致后续其它线程字段将保持其默认值。</p><ul><li>为克服类似问题，后续 .NET 提供了  <code>ThreadLocal&lt;T&gt;</code>  类以提供更好、更确定性的初始化行为。</li><li>当然，也因此  <code>ThreadLocal&lt;T&gt;</code>  会比直接使用 ThreadStatic 方式性能差一些</li></ul><h3 id="线程数据插槽"><a class="anchor" href="#线程数据插槽">#</a> 线程数据插槽</h3><p>使用非常简单，不过不建议使用，性能和 object 这种非强类型操作都很不妥当。</p><h3 id="线程局部存储内部"><a class="anchor" href="#线程局部存储内部">#</a> 线程局部存储内部</h3><p>有一个特殊的内存区域专用于每个线程自己的目的，在 Windows 中称为线程局部存储 (Thread Local Storage,TLS)，在 Linux 中称为线程专用数据 (thread-specific data)</p><ul><li>但是这样的区域相当小，例如 Windows 保证每个进程仅有 64 个此类插槽可用，且最大数量不超过 1088 个，其无法保存数据本身</li></ul><p>CLR 使用了 C++ 中使用线程局部存储方法，定义了一个 ThreadLocalInfo struct 类型的全局线程静态变量，其保留三个 CLR 内部数据地址：</p><ul><li>表示当前正在运行的托管线程的非托管 Thread 类的实例</li><li>正在执行当前线程的 AppDomain 实例</li><li>ClrTlsInfo 结构的实例</li></ul><p>当我们在 .NET 使用线程局部存储技术时，只存储了 ThreadLocalInfo 结构指针在 TLS 中，其它所有内容都驻留在 CLR 私有堆和 GC 堆中，即与常规静态变量实现方式类似：实例通常由堆分配，只是它们的引用存储在专用的常规对象数组中。</p><p><img data-src="/blogimages/2023/2023-08-21/2140760369.jpeg" alt="2140760369.jpeg" /></p><p>由于在编译时已经知道了类型的数量，因此专用的 Object [] 数组和静态 blob 都具有恒定的、预先计算的大小。<br />总的来说 TLS 仅用作对应数据结构的线程相关性的功能实现细节，它本身并没有加快任何速度 (甚至会有额外开销)</p><h3 id="使用场景"><a class="anchor" href="#使用场景">#</a> 使用场景</h3><ul><li>需要存储和管理线程敏感数据</li><li>可以利用单线程相关性：<ul><li>日志记录或诊断</li><li>缓存 (如 StreamBuilderCache)</li></ul></li></ul><p>注：使用线程静态变量显然不适合异步编程，因为异步方法的延续不能保证会在同一个线程执行。</p><ul><li>因此作为 ThreadLocal 的补充，AsyncLocal<T> 可用于在所有异步方法执行期间保留数据。</li></ul><h2 id="托管指针"><a class="anchor" href="#托管指针">#</a> 托管指针</h2><p>简称 byref。<br />对象的引用实际上是一个类型安全指针 (地址)，该指针始终指向对象 MethidTable 引用字段 (通常说指向对象的开头)，有了对象引用，就有了整个对象地址。</p><ul><li>例如 GC 可通过常量偏移量快速访问标头</li><li>通过 MethodTable 中存储的信息，字段地址也很容易计算</li></ul><p>相比引用而言，托管指针可以定义为一种更通用的指针类型，它可以指向其它位置，而不是对象的开头。</p><ul><li>局部变量</li><li>参数</li><li>复合类型的字段</li><li>数组元素</li></ul><p>托管指针任然还是类型，有一个指向 System.Int32 对象的托管指针类型，强类型使它们比纯粹的非托管指针更安全。</p><ul><li>但托管指针只允许用于局部变量和参数签名</li><li>由于这些限制，托管指针并没有直接暴露于 C#，以 ref 参数形式存在 (因此通常也称为 byref)</li></ul><h3 id="ref-局部变量"><a class="anchor" href="#ref-局部变量">#</a> ref 局部变量</h3><p>可视为存储托管指针的局部变量</p><h3 id="ref-返回值"><a class="anchor" href="#ref-返回值">#</a> ref 返回值</h3><p>允许我们从方法中返回托管指针</p><ul><li>返回值的生存期必须超过方法执行范围</li><li>例如不能返回方法中局部变量，可以是类的实例或静态字段、或传递给方法的参数</li></ul><h3 id="只读-ref-和-in-参数"><a class="anchor" href="#只读-ref-和-in-参数">#</a> 只读 ref 和 in 参数</h3><p>用于控制 ref 变量存储变化能力</p><ul><li>对于值类型：保证该值不会更改</li><li>对于引用类型：保证该引用不会被更改</li></ul><p>注：如果在只读 ref 结构调用可修改值的方法也可以确保不被修改：因为这是通过防御性复制方法来实现。因为编译器分析调用方法是否确实会修改状态。<br />创建防御性副本是一个明显开销，可以通过将此类结构设为只读 (如果适用) 来避免防御性复制。</p><ul><li>编译器可以安全略过直接在传递值类型参数上创建防御性复制和调用方法的操作。</li></ul><h3 id="ref-类型的内部"><a class="anchor" href="#ref-类型的内部">#</a> ref 类型的内部</h3><ul><li>指向堆栈分配对象的托管指针</li><li>指向堆分配对象的托管指针<ul><li>指向内部字段 (内部指针) 如何保证其主对象没有其它引用时存活：有一个 brick 表和 plug 树，判断并使内部指针成为根 (但是有开销)</li></ul></li></ul><p>他们均需要对 GC 进行报告，以使 GC 能够检测到目标可达性</p><p><img data-src="/blogimages/2023/2023-08-21/52284544.jpeg" alt="52284544.jpeg" /></p><h3 id="c-中的托管指针-ref-变量"><a class="anchor" href="#c-中的托管指针-ref-变量">#</a> C# 中的托管指针 - ref 变量</h3><p>ref (参数、局部变量、返回值) 都是围绕托指针的小型包装器，显然不应该被视为指针，而是属于变量。</p><blockquote><p>避免复制数据 - 特别是大型结构 - 以类型安全方式</p></blockquote><h2 id="关于更多结构知识"><a class="anchor" href="#关于更多结构知识">#</a> 关于更多结构知识</h2><p>只读结构</p><ul><li>public readonly struct xxx</li><li>避免防御性副本</li></ul><p>ref 结构</p><ul><li>public ref struct xxx</li><li>编译器对其施加了很多限制，以使其只会被堆栈分配 (不能装箱)<ul><li>不能声明为常规结构或类的字段</li><li>不能声明为静态字段</li><li>不能装箱：不能分配 / 强转为对象、动态或任何接口类型，也不能用作数组元素</li><li>不能用作迭代器、泛型参数</li><li>不能在异步方法用作局部变量：因为会被闭包类装箱</li><li>不能被 lambda 或局部函数捕获 (因为会被闭包装箱)</li></ul></li><li>特性：永远不会被堆分配、永远不会被多个线程访问到 (线程间传递堆栈地址非法)</li></ul><h3 id="固定大小缓冲区"><a class="anchor" href="#固定大小缓冲区">#</a> 固定大小缓冲区</h3><p>将结构的一个字段定义为数组时，该字段只是对堆分配数组的引用 (而不是数组本身)</p><ul><li>固定大小缓冲区即是将整个数组嵌入结构中</li><li>唯一限制：数组必须具有预定义的大小，类型只能是基元类型之一 (bool、byte、char、short、int、long、sbyte、ushort、uint、ulong、float、double)</li><li>使用固定大小缓冲区的结构需要标记为 unsafe</li></ul><p>固定大小缓冲区最长用于 P/Invoke 上下文中。</p><ul><li>也可以考虑将其用于通用代码，作为一种定义更密集数据结构的便捷方法，即使将此类结构作为泛型集合的一部分进行堆分配，生成代码也能提供更好的数据局部性。</li></ul><p><img data-src="/blogimages/2023/2023-08-21/1037927430.jpeg" alt="1037927430.jpeg" /></p><p>注：还可以将它们与 stackalloc 组合使用，以创建包含『其它』数组的元素的堆栈分配数组。</p><h2 id="对象结构布局"><a class="anchor" href="#对象结构布局">#</a> 对象 / 结构布局</h2><p>数据对齐</p><ul><li>每种基元数据类型都有其自己首选的对齐方式 —— 存储其地址的值的倍数。</li><li>通常，这种基元类型对齐方式与其大小相等</li><li>（CPU 访问未对齐数据需要更多指令）</li></ul><p>在包含基元类型的复杂类型在布局这些字段时也需要考虑它们的对齐要求，因此会在字段之间引入填充</p><ul><li>复杂类型实例本身也应对齐，以确保其成为更复杂类型 (如数组) 一部分时其字段仍然对齐</li></ul><p>MSDN 为有关对象的布局定义了三个规则：</p><ul><li>类型的对齐方式是其最大元素的大小或指定的打包大小 (以较小者为准)</li><li>每个字段必须与其自身大小或类型的对齐方式 (以较小者为准) 对齐</li><li>在字段之间添加填充以满足对齐要求</li></ul><p>两种类型类别中字段布局设计决策：</p><ul><li>结构：默认情况具有顺序布局 (因为默认假定其会传递给非托管代码)，这会引入填充并增加生成结构的大小</li><li>类：默认情况下具有自动布局，字段会以最高效的方式重新排序</li></ul><p>.NET 提供的控制字段布局方法：</p><ul><li>LayoutKind.Sequential：顺序布局</li><li>LayoutKind.Auto：自动布局</li><li>LayoutKind.Explicit：显式手动布局</li></ul><p>注 1：当为结构体添加托管的引用类型字段时，排列会自动更改为自动布局 (引用类型通常为第一个字段)。当该结构包含其它自动布局结构时，默认布局行为也会变为自动。<br />注 2：类和非托管结构的自动布局是无法更改的<br />注 3：上述特性提供了具有 Pack 参数的重载，即指定的打包大小，类型对齐也会以此为准</p><h3 id="联合"><a class="anchor" href="#联合">#</a> 联合</h3><p>手动指定布局时，故意让字段相互重叠，则称为可区分联合 (discriminated union)</p><h3 id="字段对齐工具"><a class="anchor" href="#字段对齐工具">#</a> 字段对齐工具</h3><ul><li>ObjectLayoutInspector：用于检查对象内存布局，可打印类型布局信息。</li><li><span class="exturl" data-url="aHR0cDovL1NoYXJwbGFiLmlv">Sharplab.io</span></li><li>WinDbg</li></ul><h2 id="非托管类型unmanaged-type"><a class="anchor" href="#非托管类型unmanaged-type">#</a> 非托管类型 (Unmanaged Type)</h2><ul><li>14 种基元类型 + Decimal (decimal)</li><li>枚举类型</li><li>指针类型（比如 int*， long*）</li><li>只包含 Unmanaged 类型字段的结构体</li></ul><h3 id="非托管约束"><a class="anchor" href="#非托管约束">#</a> 非托管约束</h3><p>非托管类型是一直不是引用类型的类型，并且在任何嵌套级别都不包含引用类型字段。</p><ul><li>即上文提到过的不包含 (嵌套) 引用类型的结构体</li></ul><p>借助非托管泛型约束，可以让编译器为我们检查非托管类型条件，可用于泛型方法和泛型结构类型。<br />使用：where T:unmanaged</p><h3 id="非托管约束的作用"><a class="anchor" href="#非托管约束的作用">#</a> 非托管约束的作用</h3><ul><li>可以使用 T 的指针 (也可以转换为 void*)</li><li>可以使用 sizeof (T)</li><li>可以对 T 使用 stackalloc</li></ul><p>注：由于非托管约束意味着 T 是一个值类型，因此不需要固定即可获取参数的指针 (通过引用传递、或在结构实例方法中使用时，还是必须固定，因为可能是装箱的堆分配)<br /> 另外还可以借此更方便使用非托管内存类型。</p><h2 id="blittable-类型"><a class="anchor" href="#blittable-类型">#</a> blittable 类型</h2><p>blittable 类型被定义为托管和非托管代码在内存中都具有相同的表示形式。<br />非托管类型与 bilittable 类型几乎相同，不过后者比前者更为严格。因为有些值类型只是『有时是 bilttable』：</p><ul><li>deceimal：二进制表示形式不够完善，因此不能采用非托管方面格式</li><li>bool：通常在托管和非托管方面都占用 1 字节，但有时在非托管方面占用会更大</li><li>char：通常占用 2 字节，但有时在非托管方面会更小或更大 (取决于编码)</li><li>DateTime：具有自动布局结构因此不能 blittable</li><li>Guid：内部表示取决于机器端</li></ul><p>因此包含这种特殊值类型字段的结构是有效的非托管类型 (满足非托管泛型约束)，但在 Interop marshal 意义上是不能 bilittable 的<br />总结：</p><ul><li>非托管类型 (以及非托管泛型约束) 主要用于通用编程，通常于 unsafe 上下文使用，对序列化等功能进行底层内存优化</li><li>Blittable 类型在 Interop marshal 处理场景中使用</li></ul><p>更多知识：<br /><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MveEcxVGo0cjh0VS1oMlNNdlRUdFFNUQ==">.NET 的基元类型包括哪些？Unmanaged 和 Blittable 类型又是什么？</span></p><h1 id="第十四章-高级技巧"><a class="anchor" href="#第十四章-高级技巧">#</a> 第十四章 高级技巧</h1><h2 id="spant"><a class="anchor" href="#spant">#</a>  <code>Span&lt;T&gt;</code></h2><p>为值类型 (ref struct)，可以表示各种形式的值的连续集合，可以像使用数组一样使用，并内置切片功能。</p><ul><li>由于其分配在堆栈上，因此完全没有堆分配开销</li><li>编译器也能智能地处理封装到  <code>Span&lt;T&gt;</code>  中的数据的生存期 (如返回局部 stack 数据会报错，返回封装托管数组 (或非托管内存) 的 span 则被允许)</li></ul><p>注：C# 不允许将 stackalloc 的执行结果赋值给一个已经定义的变量 (它只能赋值给正在初始化的变量)<br /> 注：其它比如还可以使用  <code>string.AsSpan().Slice()</code>  代替开销更大的 SubString</p><h3 id="内部实现"><a class="anchor" href="#内部实现">#</a> 内部实现</h3><p>在 .NET Core 2.1 之后运行时提供了一种模拟内部指针 (byref) 的功能，称为快速 span，在这之前则称为慢速 span (兼容版本)。</p><ul><li>注 1：目前 byref (内部指针) 不支持定义为字段 (即使是 byref 类型中也不行)</li><li>注 2：快速和慢速之分，实际相差 25%，通常使用情况下只相差 12%~15%</li></ul><h2 id="memoryt"><a class="anchor" href="#memoryt">#</a>  <code>Memory&lt;T&gt;</code></h2><p><code>Span&lt;T&gt;</code>  存在种种限制，如无法存在于堆中。<br /> <code>Memory&lt;T&gt;</code>  同样表示任意内存中一段连续区间，不过它既不是 byref 式类型，也不包含 byref 式实例字段。可用于封装如下数据：</p><ul><li>arrayT[]</li><li>字符串</li><li>实现  <code>IMemoryOwner&lt;T&gt;</code>  的类型 (对生存期有控制)</li></ul><p>可以将  <code>Memory&lt;T&gt;</code>  想象成一个能自由分配并传入传出的盒子，通常不会直接访问其存储内容，而是：</p><ul><li>从它生成  <code>Span&lt;T&gt;</code>  以供局部高效使用 (因此也称为  <code>Span&lt;T&gt;</code>  工厂)</li><li>对于  <code>Memory&lt;char&gt;</code>  可以 ToString 生成字符串，其它类型 ToArray 生成数组</li><li>与  <code>Span&lt;T&gt;</code>  一样支持数据切片</li><li>注：切片和生成 Span 都是非常高效的操作</li></ul><p>注：不允许  <code>Memory&lt;T&gt;</code>  封装 stack 数据 (如 stackalloc 返回值)</p><h2 id="unsafe类"><a class="anchor" href="#unsafe类">#</a> Unsafe 类</h2><p>相比使用普通的不安全代码 (基于指针和 fixed 语句)</p><ul><li>System.Runtime.CompilerServices.Unsafe 提供了一组泛型 / 底层功能以一种更安全的方式操作指针</li><li>并暴露了一些 CIL 支持但 C# 不直接支持的功能</li></ul><p>注：当然实际上它所做的操作仍然是不安全且危险的<br />其提供了大量方法，按功能分组如下：</p><ul><li>类型转换和重解释：在非托管指针和 ref 类型之间来回转换，或在任意两种 ref 类型之间转换</li><li>指针运算：可以像操作普通指针一样对 ref 类型实例做加法和减法</li><li>信息：获取各种信息，如两个 ref 类型实例的大小或字节差异</li><li>内存访问：从任何位置写入或读取任何内容</li></ul><p>注：使用 Unsafe 的方法并不需要标记为 unsafe<br />MemoryMarshal 辅助类</p><ul><li>AsBytes：将任何基元类型 (结构) 的  <code>Span&lt;T&gt;</code>  转换为  <code>Span&lt;byte&gt;</code></li><li>Cast：在两种不同基元类型 (结构)  <code>Span&lt;T&gt;</code>  之间相互转换</li><li>TryGetArray、TryGetMrmoryManager、TryGetString：尝试将指定  <code>Memory&lt;T&gt;</code>  或  <code>ReadOnlyMemory&lt;T&gt;</code>  转换成一种特定类型</li><li>GetReference：以 ref 返回值 (ref return) 方式返回底层  <code>Span&lt;T&gt;</code>  或  <code>ReadOnlySpan&lt;T&gt;</code>  对象</li></ul><p>对非托管内存的封装 (原生内存分配)：</p><ul><li><span class="exturl" data-url="aHR0cDovL2plbWFsbG9jLk5FVA==">jemalloc.NET</span></li><li>Snowflake</li></ul><p>Unsafe 原理：</p><ul><li>对受 IL 支持但 C# 不支持的底层操作的封装</li></ul><h2 id="面向数据设计"><a class="anchor" href="#面向数据设计">#</a> 面向数据设计</h2><p>即基于最高效的内存访问目的来设计数据，与面向对象设计针锋相对：</p><ul><li>设计数据和功能时尽量实现循序内存访问，同时考虑 cacheline 的限制 (将最常用数据打包在一起) 和分层缓存得影响 (将尽可能多的数据保持在高层缓存中)</li><li>设计类型和数据以及使用它们的算法时，使其易于并行化且无需高开销的同步锁</li></ul><p>面向数据设计还可以进一步细分为两类：</p><ul><li>战术型面向数据设计：专注于『局部』数据结构，如最高效的字段布局或以正确的顺序访问数据 (可以很容易在面向对象应用程序应用)</li><li>战略型面向数据设计：从架构层面专注于应用程序的高层设计</li></ul><h3 id="战术型设计"><a class="anchor" href="#战术型设计">#</a> 战术型设计</h3><ol><li>将类型设计成把尽可能多的关联数据容纳进首个 cacheline（例如托管类型自动内存布局将引用字段放置于对象起始位置）</li><li>将数据设计成可以填充进更高层级的缓存</li><li>将数据设计成易于并行化</li><li>避免非循序，特别是随机式内存访问</li></ol><h3 id="战略型设计"><a class="anchor" href="#战略型设计">#</a> 战略型设计</h3><p>战略型设计需要程序员大幅度转变自己的思维</p><ol><li>从 Array-of-structures 走向 Structures-of-arrays（值类型数组才能提供更好的数据局部性）</li><li>Entity Component System<ul><li>实体 (Entity)：一个具有标识符的简单对象，不包含任何数据货逻辑。定义实体的功能是通过向它添加或移除特定组件。</li><li>组件 (Component)：只包含数据而不包含逻辑的简单对象。组件包含的数据表示了它所代表的功能的当前状态。</li><li>系统 (System)：特定功能与特性的逻辑所在，系统对过滤后的实体列表逐个进行操作。</li><li>注：过滤实体的效率对系统很重要，但只要管理得当，数据组件将被循序访问，获得良好的数据局部性和预取命中率。</li></ul></li></ol><h2 id="未来特性"><a class="anchor" href="#未来特性">#</a> 未来特性</h2><ul><li>可空引用类型</li><li>Piplines：替代 streams，具有更好性能和避免分配，大量使用了 Span 和 Memory。目前 Kestrel 是 Piplines 主要使用者之一。</li></ul><h1 id="第十五章-编程-api"><a class="anchor" href="#第十五章-编程-api">#</a> 第十五章 编程 API</h1><h2 id="gc-api"><a class="anchor" href="#gc-api">#</a> GC API</h2><h3 id="收集数据和统计"><a class="anchor" href="#收集数据和统计">#</a> 收集数据和统计</h3><ol><li>GC.MaxGeneration：告知 GC 当前实现的最大代数</li><li>GC.CollectionCount (Int32)：告知自程序启动以来特定代的 GC 出现次数 (包含性)</li><li>GC.GetGeneration：告知给定对象所属的代</li><li>GC.GetTotalMemory：返回所有代中正在使用的字节数 (不包括碎片)，即托管堆上所有托管对象的总大小 (非常耗性能)</li><li>GC.GetAllocatedBytesForCurrentThread：返回当前线程到目前为止分配过的字节总数 (注：只考虑分配过多少数量，并不考虑垃圾回收后的)</li><li>GC.KeepAlive：延长堆栈根存活性，使传递的参数在调用此方法时至少可以到达行 (从而影响生成的 GC 信息)</li><li>GCSetting.LargeObjectHeapCompactionMode：例如设置为 CompactOnce，可以显式请求发生第一个完全阻塞 GC 时压缩 LOH</li><li>GCSetting.LatencyMode</li><li>GCSetting.IsServerGC</li></ol><h3 id="gc-通知"><a class="anchor" href="#gc-通知">#</a> GC 通知</h3><p>只有阻塞垃圾回收才会引发此类通知：</p><ul><li>GC.RegisterForFullGCNotification：如果满足完全阻塞 GC 条件将引发此通知 (该通知并不能保证将会发生完全 GC，只有条件达到足以进行完全 GC 的阈值才会发生)</li><li>GC.CancelFullGCNotification</li><li>GC.WaitForFullGCApproach：无限期等待 GC 通知</li><li>GC.WaitForFullGCComplete：无限期等待完全 GC 的完成</li></ul><h3 id="控制非托管内存压力"><a class="anchor" href="#控制非托管内存压力">#</a> 控制非托管内存压力</h3><p>通知 GC 某些托管对象正在持有 (或释放) 一些非托管内存：</p><ul><li>GC.AddMemoryPressure(Int64)</li><li>GC.RemoveMemoryPressure(Int64)</li></ul><h3 id="无-gc-区域"><a class="anchor" href="#无-gc-区域">#</a> 无 GC 区域</h3><p>创建运行时尝试禁止 GC 的代码区域：</p><ul><li>GC.TryStartNoGCRegion</li><li>GC.EndNoGCRegion</li></ul><h3 id="终结finalization管理"><a class="anchor" href="#终结finalization管理">#</a> 终结 (Finalization) 管理</h3><ul><li>GC.ReRegiterForFinalize</li><li>GC.SuppressFinalize</li><li>GC.WaitForPendingFinalizers</li></ul><h2 id="clr-hosting"><a class="anchor" href="#clr-hosting">#</a> CLR Hosting</h2><p>略</p><h2 id="clrmd"><a class="anchor" href="#clrmd">#</a> ClrMD</h2><p>一组用于自检托管进程和内存转储的托管 API，提供与 WinDBG 的 SOS 相似功能不过可以用 C# 更方便使用。<br />注：如 Netext 和 SOSEX 这些 WinDbg 扩展就是围绕 ClrMD 的包装器。</p><h2 id="traceevent"><a class="anchor" href="#traceevent">#</a> TraceEvent</h2><p>略</p><h2 id="自定义-gc"><a class="anchor" href="#自定义-gc">#</a> 自定义 GC</h2><p>从 .NET Core 2.1 开始，垃圾回收与执行引擎之间的耦合已经松动很多，并引入本地 GC 的概念，意味着现在 GC 是可插拔的：我们可以通过设置单个环境变量来插入自定义 GC。<br />它允许完全替换 GC 的实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;本文包含原书第七章至第十五章，也就是本书最后一部分。&lt;br /&gt;
主要为对象资源释放、线程局部存储、托管指针、ref 类型、非托管类型、非托管约束、 &lt;code&gt;S</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《.NET内存管理宝典》-笔记(5)</title>
    <link href="https://wangjiaying.top/2023/08/04/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-5/"/>
    <id>https://wangjiaying.top/2023/08/04/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-5/</id>
    <published>2023-08-04T06:31:59.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本文包含原书第七章至第十一章，主要为 .NET 垃圾回收过程的详细描述</p><h1 id="第七章-垃圾回收-简介"><a class="anchor" href="#第七章-垃圾回收-简介">#</a> 第七章 垃圾回收 - 简介</h1><h2 id="高层视图"><a class="anchor" href="#高层视图">#</a> 高层视图</h2><p>.NET GC 的两种模式：</p><ul><li>工作站模式：最大限度减少 GC 引入的延迟，GC 频率更高<ul><li>非并发：GC 时应用程序所有托管线程都挂起</li></ul></li><li>服务器模式：最大限度提高应用程序的吞吐量，GC 频率更低<ul><li>并发：GC 的某些部分在托管现在还在工作时执行</li></ul></li></ul><h2 id="gc-过程示例"><a class="anchor" href="#gc-过程示例">#</a> GC 过程示例</h2><p>垃圾回收是在特定代的上下文中发生，该代称为被判决的代。</p><ul><li>可决定同时回收比当前被判决代更小的代</li></ul><h3 id="第-0-代被判决的垃圾回收"><a class="anchor" href="#第-0-代被判决的垃圾回收">#</a> 第 0 代被判决的垃圾回收：</h3><ul><li>仅检查第 0 代中对象的可达性</li><li>第 0 代变为空 (只有意保留非常小的空间)，最小一代所有对象要么被回收，要么提升到更大的一代</li><li>第 0 代可达对象提升至第 1 代</li><li>第 1 代增长</li><li>第 2 代和 LOH 不变</li></ul><p><img data-src="/blogimages/2023/2023-08-04/139468769.jpeg" alt="139468769.jpeg" /></p><h3 id="第-1-代被判决的垃圾回收"><a class="anchor" href="#第-1-代被判决的垃圾回收">#</a> 第 1 代被判决的垃圾回收：</h3><ul><li>仅检查第 0 代和第 1 代中对象的可达性</li><li>第 0 代变为空</li><li>第 0 代的可达性对象被提升到第 1 代</li><li>第 1 代的可达性对象被提升到第 2 代</li><li>第 1 代可能会增长或缩小</li><li>第 2 代增长</li><li>LOH 不变</li></ul><p>从性能上讲，第 1 代被判决的垃圾回会有更多的对象被分析，不过在这两种情况下，GC 都在单个临时段内运行</p><h3 id="第-2-代被判决完全gc"><a class="anchor" href="#第-2-代被判决完全gc">#</a> 第 2 代被判决 (完全 GC)</h3><p>与前两种情况相比，这种完全 GC 需要分析更多对象，且标记阶段将分析整个托管堆：第 0、1、2 和 LOH ，并可能跨越多个段</p><ul><li>所有代和 LOH 的所有对象的可达性都经检查</li><li>第 0 代变为空</li><li>第 0、1 代的可达对象相应提升到第 1、2 代</li><li>第 2 代可达对象继续留在第 2 代中</li><li>LOH 在没有压缩的情况下被回收，空闲空间被 空闲列表记录以便重用</li></ul><p>最后，第 2 代在段中增长后，可能大到导致第 0、1 代没有足够空间：</p><ul><li>当前临时段被更改为只有第 2 代的段</li><li>创建一个新的临时段，将第 0 代的所有可达性对象都压缩过去 (作为第 1 代对象)<ul><li>如果有一个已存在的且具有较小第 2 代的『只有第 2 代的段』也可作为新的临时段重新使用</li></ul></li><li>LOH 照常使用清除回收处理</li></ul><p>完全垃圾回收与第 0、1 代被判决的临时垃圾回收之间的开销差异可能是几个数量级的，因此尽可能避免完全垃圾回收。</p><h2 id="gc-过程步骤"><a class="anchor" href="#gc-过程步骤">#</a> GC 过程步骤</h2><ol><li>触发垃圾回收</li><li>挂起托管线程</li><li>用户线程启动 GC 代码</li><li>选择要判决的代</li><li>标记</li><li>计划</li><li>清除或压缩</li><li>恢复托管线程</li></ol><h2 id="垃圾回收数据"><a class="anchor" href="#垃圾回收数据">#</a> 垃圾回收数据</h2><h3 id="静态数据"><a class="anchor" href="#静态数据">#</a> 静态数据</h3><p>表示 .NET 运行时初始设置的配置，以后将永远不会更改</p><ul><li>最小大小：最小分配预算</li><li>最大大小：最大分配预算</li><li>碎片限制和碎片比率限制：在决定是否应该压缩时使用</li><li>限制和最大限制：用于计算代分配预算的增长</li><li>时间限制：指定开始回收代要达到的时间</li><li>时间时钟：指定开始回收代要达到的时间，以性能计数</li><li>GC 时钟：指定开始回收代要达到的 GC 数量</li></ul><p><img data-src="/blogimages/2023/2023-08-04/-1582334348.jpeg" alt="-1582334348.jpeg" /></p><p>注：</p><ul><li>SSIZE_T_MAX：(最大地址限制) 字长的一半</li></ul><h3 id="动态数据"><a class="anchor" href="#动态数据">#</a> 动态数据</h3><p>表示托管堆当前状态，会在 GC 期间更新，计算各种决策所需的数据</p><ul><li>分配预算：GC 希望在下一次 GC 之前用于新分配的大小<ul><li>代表 GC 希望用于特定代分配的总大小</li><li>在回收该代的每个 GC 上，分配预算会动态更改，主要基于该代的存活率</li></ul></li><li>新分配：在当前分配预算下，在下一次 GC 之前剩余分配空间的大小<ul><li>对于分配器和 GC 的合作至关重要，跟踪一代中相对于分配预算进行了多少分配，如果为负数，则意味已经超出分配预算，将为该代触发垃圾回收</li></ul></li><li>碎片：该代中空闲对象消耗的总大小</li><li>存活的大小：存活对象占用的总大小</li><li>存活固定的大小：存活固定插头占用的总大小</li><li>存活率：存活字节数除以总字节数的比率</li><li>当前大小：GC 发生后所有对象的总大小 (不包括碎片部分)</li><li>GC 时钟：回收这一代 GC 的数量</li><li>时间时钟：回收这一代的上一次 GC 开始时间</li></ul><p>注：代只是被简单创建为空，跟它们默认大小无关，随着对象被分配和提升，它们大小会根据分配预算而增加。</p><h2 id="回收触发器"><a class="anchor" href="#回收触发器">#</a> 回收触发器</h2><h3 id="分配触发器"><a class="anchor" href="#分配触发器">#</a> 分配触发器</h3><p>如果无法为正在创建的对象找到合适的空间，小对象堆分配器和大对象堆分配器都可能触发垃圾回收。</p><ul><li>小对象分配 (AllocSmall)：在对象分配期间，第 0 代预算已用完 (最常见)，在第 0 代分配预算超出的情况下触发</li><li>大对象分配 (AllocLarge)：在大对象分配期间，LOH 的预算已经用完</li><li>慢速路径上的小对象分配 (OutOfSpaceSOH)</li><li>慢速路径上的大对象分配 (OutOfSpaceLOH)</li></ul><p>如果没有分配，则不会发生这种触发。</p><h3 id="显式触发器"><a class="anchor" href="#显式触发器">#</a> 显式触发器</h3><p>显示调用相关 API：</p><ul><li><code>GC.Collect()</code>  及其重载</li><li><code>GC.AddMemoryPresure</code>  (非托管内存)</li></ul><p>调用 GC.Collect 很少是合理的，显式调用会干扰内部启发式垃圾回收算法，破坏 GC 的自我调整。</p><h3 id="低内存级别系统触发器"><a class="anchor" href="#低内存级别系统触发器">#</a> 低内存级别系统触发器</h3><p>操作系统发现内存不足，.NET 接收到信号后触发</p><h3 id="各种内部触发器"><a class="anchor" href="#各种内部触发器">#</a> 各种内部触发器</h3><ul><li>AppDomain 卸载</li><li>清理表示为死线程的线程对象 (每个线程由一个托管对象表示)</li><li>在启动 NoGC 区域之前 (15 章)</li></ul><h2 id="ee-挂起"><a class="anchor" href="#ee-挂起">#</a> EE 挂起</h2><p>挂起用户代码的所有线程的过程称为『EE 挂起』</p><ul><li>即执行引擎挂起，意为挂起托管线程</li><li>从应用程序角度看，整个世界都是在垃圾回收时暂停的</li></ul><p>安全点是一个可以检查寄存器和堆栈位置的实时引用的代码位置，安全点的实现并非易事，挂起也必须是非常高效的。</p><ul><li>如果一个线程被挂起在安全点之外 (这很可能)，那么当前堆栈帧的返回地址将被操作到一个特殊的存根，这个根将把它『停』在一个安全点上。</li></ul><p>注：非托管线程不会挂起和重启，若创建一个后台本机线程执行，则它将独立于 EE 挂起运行 (当然 P/Invoke 机制肯定会从非托管代码返回托管代码时阻塞)</p><h1 id="第八章-垃圾回收-标记阶段"><a class="anchor" href="#第八章-垃圾回收-标记阶段">#</a> 第八章 垃圾回收 - 标记阶段</h1><p>在非并发 GC 的情况下，一开始所有线程均会挂起，托管堆以此确保自己不会发生任何变化，保持 GC 的独占性，以安全地浏览堆，从中搜寻出所有可达对象。</p><h2 id="对象的遍历与标记"><a class="anchor" href="#对象的遍历与标记">#</a> 对象的遍历与标记</h2><p>对于一个特定的根地址，遍历程序将执行以下步骤：</p><ol><li>将其转换为一个托管对象的确切地址：如果根地址是个内部指针 (表示它并不指向托管对象的开头，而是指向对象内部的某个位置)，则需要进行此转换</li><li>设置固定标记：如果一个对象被固定，则在对象头中设置一个合适的位</li><li>开始遍历对象的引用：由于有存储于 MethodTable 中的类型信息，GC 可以知道哪些偏移位置 (字段) 代表传出的引用<ul><li>GC 以深度优先方式访问所有这些引用并维护到一个集合，称为标记堆栈<ul><li>已访问对象将被跳过</li><li>尚未访问对象将被标记：通过在 MethodTable 指针中设置一个位来完成 (此操作不会破坏 MT 指针，其至少有两个未被使用的最低位)</li><li>添加传出引用到标记堆栈集合中</li></ul></li><li>当标记堆栈中不再有尚未访问的对象时，遍历操作即完成</li><li>注：使用自己实现的标记堆栈而不是递归，是为了避免堆栈溢出</li></ul></li></ol><p>GC 根是 .NET 内存管理中最有用的部分，根包含可达对象的整个图并可能导致：</p><ul><li>占用大量内存</li><li>内存泄露</li></ul><p>标记机制始于各种不同类型的根并随之逐渐构建出包含所有可达对象的完整对象图。<br />注：暂存字符串和静态引用数据采用了和其它对象完全一致的标记机制。</p><h2 id="局部变量根"><a class="anchor" href="#局部变量根">#</a> 局部变量根</h2><ul><li>局部变量存储：可以存储在堆栈或 CPU 寄存器中</li><li>堆栈根：既可能位于堆栈中，也可能位于 CPU 寄存器中</li><li>词法作用域：定义了变量可见代码区域</li><li>存活堆栈根与词法作用域：在 Debug 编译模式下，JIT 编译器将所有局部变量的可达性延长至方法结束 (Release 将进行更多优化)</li><li>带有渐进式根回收的存活堆栈根：Release 模式下 JIT 将使用激进式根回收，不需要通过将局部变量设置为 null 来『通知』GC 对象不再使用，通过激进式根回收，编译器和 JIT 可以完美确定变量的实际使用范围。(编译器会优化掉冗余的 null 赋值语句)<ul><li>由于编译器会尽量最短化局部变量的生存周期，可能会进行方法『其中一部分 (调用了实例本身的语句)』的代码内联化 (不至于影响代码逻辑的情况)，以使对象可以更早被回收</li><li>GC.KeepAlive：不包含任何代码，而是使用 MethodImplOptions.NoInLining 选项为方法添加一个特性，使对象不被内联，传入参数将被视为可达</li></ul></li></ul><h3 id="gc-信息"><a class="anchor" href="#gc-信息">#</a> GC 信息</h3><p>GC 信息实际上是非常紧密的二进制数据，当前唯一可以查看 GC 信息的工具是带有 SOS 扩展的 WinDbg</p><h3 id="固定局部变量"><a class="anchor" href="#固定局部变量">#</a> 固定局部变量</h3><p>固定局部变量是一种特殊类型的局部变量，在 C# 中使用 fixed 关键字可以显式创建</p><ul><li>JIT 编译器会针对固定局部变量生成适当的 GC 信息，有关根本身的信息也被保持为固定状态。</li><li>这种被固定的根只在很短时间内可见 (仅在包含它的方法执行期间)</li></ul><h3 id="堆栈根扫描"><a class="anchor" href="#堆栈根扫描">#</a> 堆栈根扫描</h3><p>当所有线程在安全点挂起时，可以从 GC 信息中解码出存在哪些存活插槽，每个这样的插槽 (无论位于堆栈或寄存器中) 都被视为根并从它们开始执行标记遍历操作。</p><h2 id="终结根"><a class="anchor" href="#终结根">#</a> 终结根</h2><p>终结器对象第一次被回收时，放入终结器队列，会成为终结器根？</p><h2 id="gc-内部根"><a class="anchor" href="#gc-内部根">#</a> GC 内部根</h2><p>例如卡根扫描</p><h2 id="gc-句柄根"><a class="anchor" href="#gc-句柄根">#</a> GC 句柄根</h2><p>句柄有各种不同类型，全都存储在一个全局句柄表映射中。扫描句柄表后，扫描到的一组句柄类型与它们指向的目标都将被视为根。</p><ul><li>强句柄 (GCHandle.Alloc)：类似普通引用</li><li>固定句柄：强句柄的子类别</li></ul><h2 id="处理内存泄露"><a class="anchor" href="#处理内存泄露">#</a> 处理内存泄露</h2><p>持续增长的内存使用率和内存泄露一定不会是因为垃圾回收器无法正常识别对象是否处于可达状态</p><ul><li>而很可能是因为有些对象持续持有对其它对象的引用</li><li>因此关键在于找出哪些根在持续持有应当回收但始终存活的对象</li></ul><h1 id="第九章-垃圾回收-计划阶段"><a class="anchor" href="#第九章-垃圾回收-计划阶段">#</a> 第九章 垃圾回收 - 计划阶段</h1><p>标记阶段之后，所有对象都被标记为可达或不可达，那些可达对象将用一个专用位进行标记，某些被标记对象可能还要用额外一个位标记为固定的。此时，垃圾回收器已经有了启动其工作所需的所有信息。<br />计划阶段计算与压缩过程结果直接对应的所有信息，这些信息『在侧面』准备，并没有实际去移动对象。并让随后的清理和压缩阶段使用。</p><ul><li>如进行『虚假的压缩』得到结果并评估是否值得压缩</li></ul><p>注：源码中方法为 plan_phase (int)，该阶段准备了所有必要数据，后续阶段只是以适当方式使用这些数据。</p><h2 id="小对象堆"><a class="anchor" href="#小对象堆">#</a> 小对象堆</h2><h3 id="插头和间隙"><a class="anchor" href="#插头和间隙">#</a> 插头和间隙</h3><p>通过将对象组织成 slot 和 gap，可以非常高效获得如下一整套信息：</p><ul><li>压缩效率</li><li>如果是清除回收，应在哪里创建空闲列表</li><li>如果是压缩回收，将把可达对象移到哪里</li></ul><p>不过，这些数据存储在哪里？</p><ul><li>.NET 重用了托管对象标头位置</li></ul><p>如果我们适当地建立 slot 和 gap，那么每个 slot 在其之前都会具有其对应的 gap，而 gap 的内容可以安全覆盖：它只包含将不再使用的不可达对象。</p><ul><li>这样的 slot 信息精确占用 24 字节 (32 位 12 字节)</li><li>它包含相应的间隙大小、slot 重定位偏移量及一些附加数据</li></ul><p><img data-src="/blogimages/2023/2023-08-04/-697247850.jpeg" alt="-697247850.jpeg" /></p><p>最后可以构建一个包含所有插头地址的二叉插头树 (组织成二叉搜索树 - BST)</p><h3 id="砖表"><a class="anchor" href="#砖表">#</a> 砖表</h3><p>插头树的根需要存储在某个地方，但为整个托管堆创建一个巨大的插头树不切实际。</p><ul><li>一种更实际的方法是为连续地址范围构建插头树</li><li>这样的范围在 CLR 中称为砖，砖大小为 2048B (32 位) 和 4096B (64 位)</li><li>砖存储在覆盖整个托管堆的砖表中</li></ul><p>通过将砖表条目与与每个插头头的左 / 右偏移量组合，可以高效地表示插头树。</p><h3 id="固定"><a class="anchor" href="#固定">#</a> 固定</h3><p>如果一个对象被固定，则很可能是因为我们想把它的地址传递给非托管代码。<br />有两种固定源：</p><ul><li>固定局部变量：fixed 关键字隐式创建的局部变量对象</li><li>固定句柄：通过固定句柄引用显式固定的对象 (GCHandle.Allocate)</li></ul><p>因为要固定，所以实际上可能有三种对象组：</p><ul><li>插头：表示一组已标记 (可达) 的对象</li><li>固定插头：表示一组被固定 (并因此标记) 的对象</li><li>间隙：表示一组未标记 (不可达) 对象</li></ul><h3 id="代边界"><a class="anchor" href="#代边界">#</a> 代边界</h3><p>在清除或压缩后，代边界将相应地更改。<br />在计划阶段，内部分配器计算插头的新地址，也计算新的代边界。</p><ul><li>所有这些操作都是在实际上没有移动任何对象的情况下完成的。</li></ul><h3 id="降级"><a class="anchor" href="#降级">#</a> 降级</h3><p>固定对象可能会提升和降级。</p><h2 id="大对象堆"><a class="anchor" href="#大对象堆">#</a> 大对象堆</h2><p>事实上，LOH 中的计划阶段几乎不需要，因为它基本只是清除 (除非我们明确要求进行压缩)</p><ul><li>仅在启用压缩时才需要大对象堆的压缩阶段</li><li>LOH 是特殊的，因为它确保只有大对象活在其中，因此有一些简化<ul><li>在每个插头前存储的信息仅包含插头的重定位偏移量</li><li>由于大对象堆内部也没有代，因此也无需重新计算代边界，也没有降级的可能性</li></ul></li></ul><p>与 SOH 相比，LOH 中的固定并没有区别，因此一样会引入可能碎片化的问题。</p><h2 id="压缩决策"><a class="anchor" href="#压缩决策">#</a> 压缩决策</h2><p>在计划阶段执行了复杂的计算后，GC 会决定是否值得压缩。大多数情况下，该决策基于碎片化级别。<br />决定压缩的原因：</p><ul><li>这是抛出 OutOfMemoryException 之前最后一个完全 GC，GC 尽可能尝试回收内存</li><li>显式指定压缩 (GC.Collect 参数)</li><li>用完了临时段中的空间</li><li>代的碎片化程度较高</li><li>系统中物理内存负载较高</li></ul><p>如上所述，决策中，代的碎片化阈值起到作用最重：</p><p><img data-src="/blogimages/2023/2023-08-04/-1519001997.jpeg" alt="-1519001997.jpeg" /></p><h1 id="第十章-清除和压缩"><a class="anchor" href="#第十章-清除和压缩">#</a> 第十章 清除和压缩</h1><p>尽管大部分计算已在之前完成，但从性能开销角度看，清除和压缩仍然是性能消耗最大的一个阶段，因为修改和移动内存中数据是最耗时的操作。<br />最典型的 GC 组合是：</p><ul><li>执行 SOH 的压缩和 LOH 的清除，并在 SOH 压缩之前完成 LOH 的清除</li></ul><h2 id="清除阶段"><a class="anchor" href="#清除阶段">#</a> 清除阶段</h2><p>清除回收很简单：所有不可达对象都被转换成空闲内存空间，即 GC 把所有或某些内存间隙转换成空闲列表项。</p><h3 id="小对象堆-2"><a class="anchor" href="#小对象堆-2">#</a> 小对象堆</h3><ul><li>基于内存中的间隙创建空闲列表项<ul><li>将每个尺寸大于两个最小对象的间隙创建一个空闲列表项并组织进一个空闲列表</li><li>尺寸更小的间隙将被视为未使用空闲空间</li></ul></li><li>恢复已保存的前置和后置插头</li><li>完成其它统计工作以更新终结器队列并提升 (或降级) 适当类型的存活句柄</li><li>相应地重排段，如移除掉一些不再需要的段</li></ul><h3 id="大对象堆-2"><a class="anchor" href="#大对象堆-2">#</a> 大对象堆</h3><p>清除操作将逐个扫描对象，并简单地在被标记对象之间创建空闲列表项，所有不再需要的 LOH 段将被删除 (或启用段重用后进行缓存)</p><h2 id="压缩阶段"><a class="anchor" href="#压缩阶段">#</a> 压缩阶段</h2><p>包含两个主要子步骤：移动 (或复制) 对象并将所有指向被移动对象的引用更新到对象所在的新位置。<br />注：压缩阶段比清除阶段复杂得多，可能导致大量内存操作</p><h3 id="小对象堆-3"><a class="anchor" href="#小对象堆-3">#</a> 小对象堆</h3><ol><li>如果需要，则获取一个新的临时段</li><li>重定位引用<ul><li>堆栈上的引用</li><li>存储在跨代记忆集中的对象内的引用</li><li>SOH 和 LOH 中对象内的引用<ul><li>SOH：重定位操作大量使用砖和插头树，以快速将当前地址转换为新地址</li><li>LOH：逐个扫描存活下来的 LOH 对象</li></ul></li><li>前置和后置插头内的引用<ul><li>某些对象的结尾可能被插头信息覆盖而损坏，其原始内存内容存储在固定插头队列的条目中</li></ul></li><li>终结器队列中对象内的引用</li><li>句柄表中的引用：句柄需要更新其指针</li></ul></li><li>压缩对象<ul><li>复制对象：使用计算出的重定位偏移量逐个 slot 完成复制<ul><li>采用滑动压缩，总是首先复制低位内存空间，只要复制的单位足够小，就不会产生覆盖问题</li></ul></li><li>恢复前置和后置插头信息：从存储于固定插头队列条目内的副本中恢复对象的损坏部分</li></ul></li><li>修复代边界</li><li>若需要，删除或反提交段</li><li>创建空闲列表项</li><li>提升根</li></ol><h3 id="大对象堆-3"><a class="anchor" href="#大对象堆-3">#</a> 大对象堆</h3><p>压缩大对象堆与小对象堆类似，不过实现更简单</p><h1 id="第十一章-gc-风格"><a class="anchor" href="#第十一章-gc-风格">#</a> 第十一章 GC 风格</h1><h2 id="模式概述"><a class="anchor" href="#模式概述">#</a> 模式概述</h2><h3 id="工作站与服务器模式"><a class="anchor" href="#工作站与服务器模式">#</a> 工作站与服务器模式</h3><p>工作站模式</p><ul><li>GC 将会更频繁发生</li><li>作为上一点副作用：内存使用率将更低</li><li>只有一个托管堆</li><li>段更小</li></ul><p>服务器模式</p><ul><li>GC 的发生频率将更低</li><li>作为上一点副作用：内存使用率见更高</li><li>有多个托管堆</li><li>默认段大小更大</li><li>因此，服务器模式将消耗更多内存，但带来更小的 Time in GC 值</li></ul><h3 id="并发模式与非并非模式"><a class="anchor" href="#并发模式与非并非模式">#</a> 并发模式与非并非模式</h3><p>这两种模式在工作站与服务器模式下都支持。<br />非并发模式</p><ul><li>在 GC 期间，所有托管用户线程都将被挂起。执行完毕后恢复。</li></ul><p>并发模式</p><ul><li>并发 GC 在普通用户线程工作时运行，用户线程和回收器在工作期间必须进行额外同步。</li></ul><h2 id="模式配置"><a class="anchor" href="#模式配置">#</a> 模式配置</h2><h3 id="net-framework"><a class="anchor" href="#net-framework">#</a> .NET Framework</h3><ul><li><span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> WEB 应用程序：web.config</li><li>控制台应用程序或 Windows 服务：[应用程序名].exe.config</li></ul><h3 id="net-core"><a class="anchor" href="#net-core">#</a> .NET Core</h3><p>文件配置方式与 .NET Framework 相似<br />并引入了 配置旋钮 概念，可通过多种方式提供值。</p><h2 id="gc-停顿和开销"><a class="anchor" href="#gc-停顿和开销">#</a> GC 停顿和开销</h2><h2 id="模式模式"><a class="anchor" href="#模式模式">#</a> 模式模式</h2><h3 id="非并发工作站模式"><a class="anchor" href="#非并发工作站模式">#</a> 非并发工作站模式</h3><p>即典型的 GC</p><ul><li>整个 GC 期间，所有托管线程都将挂起</li><li>GC 代码在触发回收的用户线程上执行 (从分配器内部)</li><li>GC 总是在『停止世界』阶段执行</li></ul><h3 id="并发工作站模式40版本之前"><a class="anchor" href="#并发工作站模式40版本之前">#</a> 并发工作站模式 (4.0 版本之前)</h3><ul><li>有一个专用于 GC 目的的额外线程 (多数时间挂起等待)</li><li>临时回收总是非并发</li><li>完全 GC 可以两种模式执行<ul><li>并发 GC</li><li>非并发 GC</li></ul></li><li>并发完全 GC 附加特性：<ul><li>用户托管线程可能在其工作期间分配对象，此类分配仅限于临时段大小 (如果用完了将挂起，直到 GC 结束)</li><li>包含两个短的『停止世界』阶段 (开始和中间)</li><li>从 GC 开始到第二个『停止世界』阶段之前分配的对象将被提升</li><li>在第二个『停止世界』阶段之后分配的所有事物都将被提升</li></ul></li></ul><h3 id="后台工作站模式"><a class="anchor" href="#后台工作站模式">#</a> 后台工作站模式</h3><p>.NET Framework4.0 后取代并发工作站模式<br />主要改进在于：即使在并发 GC 期间，如果需要也可以触发临时 GC</p><h4 id="并发标记"><a class="anchor" href="#并发标记">#</a> 并发标记</h4><p>标记一个对象意味着在 MethodTable 中设置一个位，完成后恢复。<br />但并发工作时意味着线程可能正在使用它，因此不能这样干。</p><ul><li>并发标记会将有关标记的信息存储在一个专用的单独的标记数组中，组织结构类似于卡表</li></ul><h3 id="非并发服务器模式"><a class="anchor" href="#非并发服务器模式">#</a> 非并发服务器模式</h3><p>默认情况下，托管堆的数量与 CPU 逻辑内核一样多</p><ul><li>有专用于 GC 的线程，默认与托管堆数量相同</li><li>所有回收都是非并发 GC</li><li>标记是从多个 GC 线程并行完成</li></ul><h3 id="后台服务器模式"><a class="anchor" href="#后台服务器模式">#</a> 后台服务器模式</h3><p>最复杂的 GC，也是最消耗资源的 GC</p><ul><li>每个托管堆都有两个专用于 GC 目的的线程<ul><li>服务器 GC 线程</li><li>后台 GC 线程</li></ul></li><li>临时回收是非并发 GC</li><li>完全 GC 可能以一以下两种模式执行：<ul><li>非并发 GC</li><li>后台 GC</li></ul></li><li>后台完全 GC 还有以下额外特征：<ul><li>用户托管线程能够在其工作期间分配对象，这些分配可以触发临时回收 (前台 GC)</li><li>在后台 GC 期间，前台 GC 可能会多次发生</li><li>包含两个短暂的『停止世界』阶段 (GC 开始和中间)</li></ul></li></ul><h2 id="延迟模式"><a class="anchor" href="#延迟模式">#</a> 延迟模式</h2><ul><li>批处理模式</li><li>交互式模式</li><li>持续低延迟模式</li><li>无 GC 区域模式</li><li>延迟优化目标</li></ul><h2 id="选择-gc-风格"><a class="anchor" href="#选择-gc-风格">#</a> 选择 GC 风格</h2><p><img data-src="/blogimages/2023/2023-08-04/-1641765449.jpeg" alt="-1641765449.jpeg" /></p><p>注：并发 (后台) 版本 GC 的托管堆会更大，频繁的非压缩后台 GC 会导致更严重的碎片化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;本文包含原书第七章至第十一章，主要为 .NET 垃圾回收过程的详细描述&lt;/p&gt;
&lt;h1 id=&quot;第七章-垃圾回收-简介&quot;&gt;&lt;a class=&quot;anchor&quot; hre</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《.NET内存管理宝典》-笔记(4)</title>
    <link href="https://wangjiaying.top/2023/07/19/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-4/"/>
    <id>https://wangjiaying.top/2023/07/19/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-4/</id>
    <published>2023-07-19T03:16:33.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本篇包含原书第五章和第六章，主要讲了 .NET 内存分区和内存分配方式</p><ul><li>小对象通过指针快速分配 (多数情况下)</li><li>大对象通过空闲列表分配 (因此最好避免)</li></ul><p>并提出了一些优化方式：避免分配，包括显式和隐式分配等</p><h1 id="第五章-内存分区"><a class="anchor" href="#第五章-内存分区">#</a> 第五章 内存分区</h1><h2 id="分区策略"><a class="anchor" href="#分区策略">#</a> 分区策略</h2><p>总体上有：</p><ul><li>大小</li><li>生存期</li><li>可变性</li><li>类型</li><li>种类</li></ul><p>简单来说，.NET 根据『大小』和『生存期』作为分区策略。</p><h2 id="按大小分区"><a class="anchor" href="#按大小分区">#</a> 按大小分区</h2><p>.NET 根据大小处理不同对象，分为两类：</p><ul><li>小对象堆 (SOH)：所有小于 85000 字节的对象在此分区创建</li><li>大对象堆 (LOH)：所有大于或等于 85000 字节的对象在此创建</li></ul><p>区别在于，默认情况下小对象堆在 GC 回收后会进行压缩，而大对象堆默认不会。<br />对齐方式</p><ul><li>32 位：SOH 4 字节对齐，LOH 8 字节对齐</li><li>64 位：SOH 和 LOH 均 8 字节对齐</li></ul><p>注 1：Mono 5.4 单个对象大小阈值为 8000 字节<br />注 2：具传言所说，85000 字节是微软内部测试实验而选出，但并未经证实。<br />注 3：计算的是对象引用的浅表大小 (即实际大小)，而非引用对象的大小。对大数组作为字段时，只是对其一个小引用。</p><h3 id="小对象堆"><a class="anchor" href="#小对象堆">#</a> 小对象堆</h3><p>使用频率最高的内存区域，通常其中分配对象会在数量级上超过位于 LOH 的对象数量。<br />因此将其划分为更小的分离部分，即常规意义上说的分代：0、1、2 代</p><h3 id="大对象堆"><a class="anchor" href="#大对象堆">#</a> 大对象堆</h3><p>有时候被称为第三代，或者是被第三个索引引用 (位于 0、1、2 这三代之后)</p><ul><li>不过从回收器角度看，LOH 中的大对象在逻辑上属于第二代，因为它们仅在第二代被回收时才被回收。</li></ul><p>处于其中的常见对象：</p><ul><li>double 数组：等于或大于 1000 个元素时就会在 LOH 中进行分配 (例外)——[注意是 32 位运行环境]<ul><li>原因与内存对齐方式有关，double 占 8 个字节，而 32 位环境下，大对象堆 8 字节对齐，访问消耗更低</li><li>1000 个阈值是为了避免内存碎片</li></ul></li><li>内部 CLR 数据：LargeHeapHandleTable，该结构管理在大对象堆中分配用于内部用途的对象数组。<ul><li>每个域的静态成员，至少包含一个 bucket</li><li>全局字符串文字映射 (StringIntern)-GlobalStringLiteralMap</li></ul></li></ul><p><img data-src="/blogimages/2023/2023-07-19/-523718562.jpeg" alt="-523718562.jpeg" /></p><p>注：大对象堆默认不压缩，注意会产生内存碎片</p><h2 id="按生存期分区"><a class="anchor" href="#按生存期分区">#</a> 按生存期分区</h2><p>如前所述，小对象堆可能存在大量对象，因此在决定再根据生存期分成若干部分，即『分代垃圾回收 (Generational Garbage Collection』<br />做法有两种：</p><ul><li>提升复制，为名为 0、1、2 的代提供三个单独的内存区域，回收年轻代对象时，存活对象被复制到老一代内存区域（会有复制开销）</li><li>按地址边界在逻辑上定义代，即在单个连续内存区域内通过逻辑边界来形成代，避免复制开销（.NET 采用的方式）</li></ul><p><img data-src="/blogimages/2023/2023-07-19/-1903600403.jpeg" alt="-1903600403.jpeg" /></p><h3 id="记忆集remembered-sets"><a class="anchor" href="#记忆集remembered-sets">#</a> 记忆集 (remembered sets)</h3><p>标记阶段使用可达性分析进行。<br />如何做到只回收『年轻』一代的？</p><ul><li>从根开始遍历，忽略此代之外的引用</li></ul><p>同时存在跨代引用问题需要处理：</p><ul><li>从年轻到老：最近创建对象可能引用已存在老对象</li><li>从老到年轻：老对象可能直接设置包含新创建对象的引用</li></ul><p><img data-src="/blogimages/2023/2023-07-19/-1012548466.jpeg" alt="-1012548466.jpeg" /></p><p>记忆集是一组记忆从老一代到年轻一代的引用、用于跨代回收的集。然后在标记阶段对它们进行简单的审查。</p><ul><li>在创建此类引用时记住它，主要发生于字段分配期间</li><li>在 Mutator.write 操作插入这个指令会带来很大开销，不过 JIT 编译器可以从 IL 代码了解信息 (是否将托管对象的引用存储到另一个托管对象的字段中)，并在生成汇编代码时可选是否生成对应代码 (.NET 运行时采用的方式)</li></ul><p>如果年轻代引用老年代，也需要如此实现记忆集，这并不容易。因此 .NET 采用了更简单的决定：回收某一代同时也意味着回收比它更年轻代的对象。</p><ul><li>仅回收第 0 代</li><li>回收第 0 代和第 1 代</li><li>回收所有第 0 代、第 1 代和第 2 代以及大对象堆 (完全垃圾回收)</li></ul><h3 id="卡表card-tables"><a class="anchor" href="#卡表card-tables">#</a> 卡表 (Card Tables)</h3><p>.NET 有三代，因此可能的跨代引用数量可能很大。将一个记忆集作为每个跨代引用的幼稚回收管理会带来过大开销。<br />卡表即是对记忆集的优化：</p><ul><li>将老一代拆分成恒定大小区域 (具有给定字节数的连续内存区域)</li><li>当某个地方将对象 C 分配给对象 E 字段时，计算 E 的卡，并将卡标记为 dirty，此后该卡中所有对象都被视为附加的根</li></ul><p><img data-src="/blogimages/2023/2023-07-19/672960811.jpeg" alt="672960811.jpeg" /></p><p>这显然也会有开销：即使只有一个从老一代对象到年轻一代的引用，也必须访问卡中所有对象并遵循它们的引用。不过，这也是性能和准确性之间的权衡。<br />注意：</p><ul><li>如果一张卡片很小，小到做多只能包含一个对象，那么我们最终会得到一个典型记忆集方法。</li><li>如果一张卡片很大以至于覆盖了整整一代，那么最终会变成遍历整个对象图的方法。</li></ul><p>在 .NET 运行时 (64 位) 中，一张卡对应于 256 个字节，每个这样的卡都由一个位标志表示。</p><ul><li>1 字节能表示 8 倍 256 字节，即 2048 字节的存储区域。</li><li>卡片被分为 32 个元素，称为卡片字，意味着卡片字是 4 字节宽的 DWORD 类型 (ulong)。单个卡片字表示 8192 字节。</li></ul><h3 id="卡包card-bundles"><a class="anchor" href="#卡包card-bundles">#</a> 卡包 (Card Bundles)</h3><p>卡表优化了记忆集的使用，但是扫描依然会带来较大开销，此外卡表可能比较稀疏。<br />因此增加了另一个级别的观察：</p><ul><li>一个卡字将多个卡组合在一起，而一个卡包字将多个卡字组合在一起</li><li>卡包字设计密度更高，可覆盖更大内存区域</li><li>首先扫描卡包以查找 dirty 的大区域，再对其中卡表进行更精确扫描。</li></ul><h2 id="按物理分区"><a class="anchor" href="#按物理分区">#</a> 按物理分区</h2><p>从物理上讲，托管堆由一组堆段组成：一个段要么属于 SOH 要么 属于 LOH</p><ul><li>注：对于 SOH，如果存在多个段，那么只有一个称为『临时段』的包含第 0 代和第 1 代，其它段都是第 2 代的段。</li></ul><p>堆段从低地址到高地址使用</p><ul><li>.NET 运行时尝试为初始段分配 (保留) 单个连续内存块</li><li>为 SOH 和 LOH 创建两个单独的段</li><li>第 0、1、2 代通过提交一些指定数量内存在 SOH 段内创建，LOH 也提交一定数量内存</li></ul><p><img data-src="/blogimages/2023/2023-07-19/270983224.jpeg" alt="270983224.jpeg" /></p><h3 id="段和堆解析"><a class="anchor" href="#段和堆解析">#</a> 段和堆解析</h3><p>段是托管堆的物理表示，每个 SOH 和 LOH 都具有以下结构：</p><ul><li>在开始处存储段信息 (heap_segment  类的一个实例)</li><li>对象从名为 mem 的地址分配</li><li>当前已分配对象结束的地址被命名为 allocated</li></ul><p><img data-src="/blogimages/2023/2023-07-19/335804534.jpeg" alt="335804534.jpeg" /></p><h3 id="段重用"><a class="anchor" href="#段重用">#</a> 段重用</h3><p>连续创建和删除段可能导致碎片问题，特别是 32 位虚拟地址空间有限的情况。<br />因此引入更智能的段处理：虚拟机囤积 (VM Hoarding)</p><ul><li>与其完全释放空段，不如将其存储 (囤积) 以供以后使用</li></ul><p>即：</p><ul><li>整个段内存将保持保留</li><li>该段大部分内存被取消提交 (不消耗物理内存)，只有少量信息 (如段信息) 保持提交状态</li><li>在一个可重用列表记录，当需要新段时，首先检查</li></ul><p>注 1：在 64 位执行引擎中，由于虚拟地址空间大很多，囤积相对就没那么重要了。不过，由于在非常动态场景中，有许多段被创建和销毁时，重用速度更快，因此在 64 位下段重用也是值得的。<br />注 2：默认情况下 .NET 会禁用段囤积功能 (System.GC.RetainVM)</p><h1 id="第六章-内存分配"><a class="anchor" href="#第六章-内存分配">#</a> 第六章 内存分配</h1><p>分配器 (allocator) 概念：负责提供指定大小内存，在此抽象层次上，分配器并不关心内存中需要存储的是哪种类型对象，只需提供正确数量字节空间即可。<br />.NET 托管环境会预先分配连续内存块，比每次创建对象都向操作系统请求更快，且可以简化内存分配机制。<br />对象分配发生于：</p><ul><li>对于 SOH：分配发生于 0 代，位于一个暂留段。</li><li>对于 LOH：分配发生在多个 LOH 段中的一个。</li></ul><blockquote><p>每次分配一个大对象时会考虑整个 LOH，而分配小对象仅考虑暂留段。</p></blockquote><p>有两种实现分配器方法：</p><ul><li>循序分配和自由列表</li><li>.NET 同时使用了两者</li></ul><h2 id="bump-pointer-分配"><a class="anchor" href="#bump-pointer-分配">#</a> Bump Pointer 分配</h2><p>即采用循序分配的一种模式，分配指针指向已分配对象末尾，提前清零区域 (allocation context) 前端，分配内存时，仅需要往提前清零区域移动指定字节即可。</p><ul><li>注：allocation context 是每个线程独占的</li></ul><p><img data-src="/blogimages/2023/2023-07-19/662564621.jpeg" alt="662564621.jpeg" /></p><h2 id="空闲列表分配"><a class="anchor" href="#空闲列表分配">#</a> 空闲列表分配</h2><p>当运行时要求 GC 分配给定大小内存时，其在一个空闲列表中搜索，以找到一块足够大的空闲空隙。</p><ul><li>最佳匹配：找到最匹配所需空间内存</li><li>最先匹配：找到第一块能满足需求的空闲内存</li></ul><h2 id="创建新对象"><a class="anchor" href="#创建新对象">#</a> 创建新对象</h2><p>CIL 代码：newobj</p><ul><li>如果对象超出大尺寸阈值 (在 LOH 中创建)，或者其有终结器则使用通用且稍慢的 JIT_New 函数</li><li>否则使用较快的辅助函数</li></ul><p>例外的是创建数组：newarr，用于创建数组对象的优化版本</p><h3 id="小对象堆分配"><a class="anchor" href="#小对象堆分配">#</a> 小对象堆分配</h3><p>基本通过 bump pointer 分配到到 allocation context 中。</p><ul><li>注：若 allocation context 无法满足所需大小，或对象带终结器，则将回退到调用更通用的 JIT_NEW 函数，此函数包含完成分配的慢速分支代码。</li></ul><p>慢速分支逻辑：</p><ul><li>首先尝试使用暂留段中已有的未使用空间<ul><li>尝试使用空闲列表找到一块合适的内存空隙，用其创建一个新的 allocation context</li><li>尝试调整 commited 内存中的分配限制位</li><li>尝试从 reserved 内存中提交更多内存，并调整位于其内部的分配限制位</li></ul></li><li>若上述操作皆失败，则触发垃圾回 (收回收根据具体情况执行多次)</li><li>若上述依然失败，则触发 OutOfMemoryException</li></ul><h3 id="大对象堆分配"><a class="anchor" href="#大对象堆分配">#</a> 大对象堆分配</h3><p>主要使用空闲列表分配机制，并在段空间末尾使用一种简化的 bump pointer 技术 (不使用 allocation context)<br /> LOH 分配器总是采取与 SOH 慢速分支类似的方法。</p><ul><li>首先尝试使用未使用的现有空间<ul><li>尝试使用空闲列表为对象寻找一个合适的内存空隙</li></ul></li><li>在每个包含 LOH 段中：<ul><li>尝试调整 commited 内存中的分配限制位</li><li>尝试从 reserved 内存中提交更多内存，并调整位于其内部的分配限制位</li></ul></li><li>若上述操作皆失败，则触发垃圾回收 (回收根据具体情况执行多次)</li><li>若上述依然失败，则触发 OutOfMemoryException</li></ul><p>同时，由于 LOH 没有 allocation context 机制，因此分配完成后还需对对象内存清零，而大对象内存清零本来也是一段耗时过程。<br />因此 LOH 分配开销远大于 SOH 分配。</p><h2 id="堆再平衡"><a class="anchor" href="#堆再平衡">#</a> 堆再平衡</h2><p>略</p><h2 id="outofmemoryexception-异常"><a class="anchor" href="#outofmemoryexception-异常">#</a> OutOfMemoryException 异常</h2><p>已经触发垃圾回收器</p><ul><li>此时再触发垃圾回收没什么用，倒是可以考虑显示触发 LOH 压缩后再触发一次 GC</li></ul><p>分配器无法准备所需大小的内存区域</p><ul><li>虚拟内存已耗尽 (32 位)，主要由于内存碎片导致</li><li>物理后备存储 (包括物理内存和交换内存) 已耗尽</li></ul><p>改进：</p><ul><li>少分配一些对象</li><li>使用对象池</li><li>使用 VM Hoarding</li><li>编译为 64 位程序</li></ul><h2 id="堆栈分配"><a class="anchor" href="#堆栈分配">#</a> 堆栈分配</h2><p>堆栈分配只需要移动 stack 指针，不会造成任何 GC 开销。<br />在满足条件的情况下，值类型将在堆栈上分配。<br />除此之外，也可以通过 stackalloc 显示在堆栈分配内存。其返回一个指针，可使用指针或 span&lt;&gt; 操作，其有两个好处：</p><ul><li>销毁以这种方式创建的对象与销毁堆栈上其它对象的速度一样快，无需使用堆分配器，不会进入分配决策树的慢速分支，也完全不需要 GC</li><li>由于 stack frames 不会在内存中移动，因此此类对象的地址也被隐式固定，可以安全将指针传递给非托管代码。</li></ul><p>stackalloc 被转换为 CIL 指令 localloc<br /> 注：stackalloc 仅能用于分配一个 unmanaged_type 元素类型的数组。</p><ul><li>基元类型</li><li>枚举类型</li><li>指针类型</li><li>所有非构造类型且仅包含 unmanaged_type 字段的用户自定义结构</li></ul><p>无法显示释放 stackalloc 分配的内存，方法结束时将隐式释放。</p><h2 id="避免分配"><a class="anchor" href="#避免分配">#</a> 避免分配</h2><h3 id="显式的引用类型分配"><a class="anchor" href="#显式的引用类型分配">#</a> 显式的引用类型分配</h3><p>可以认真评估，在特定情况下，是否真的有必要在堆上创建引用类型对象？</p><ol><li>通用场景 - 考虑使用结构<ul><li>例如数据不存储任何基于堆的数据内部</li></ul></li><li>元组 - 使用 ValueTuple 代替<ul><li>注 1：Tulpe 和匿名类型都是引用类型</li><li>注 2：值元组有种称为解构 (deconstruction) 的特性，允许直接将方法返回元组赋值给元组，还可以使用弃元 (discarding) 显示忽略不感兴趣的元素</li></ul></li><li>小型临时局部数据 - 考虑使用 stackalloc<ul><li>结构数组依然会分配在堆上，可以使用 stackalloc 使其分配于堆栈</li><li>stackalloc 缺点在于可能引发堆栈溢出异常</li><li>如果想使用并希望百分百不会引发堆栈溢出异常，可尝试使用 RuntimeHelpers.TryEnsureSufficientExecutionStack () 或 RuntimeHelpers.EnsureSufficientExecutionStack () 方法</li></ul></li><li>创建数组 - 使用 ArrayPool<ul><li>ArrayPool 提供可重用托管数组池的专用方案 (包含在 SystemBuffers 中)</li><li>其管理指定类型的不同大小的数组集，并将数组分组到不同的 bucket 中</li><li>通过静态属性 ArrayPool<T>.Share 可获得此类型的默认数组池：当需要时调用 Rent，不需要时调用 Return 方法归还（获取的数组长度可能大于指定长度，不低于指定值，从 16 开始按倍数提前确定好）</li><li>注 1：内部使用了相当复杂的缓存技术，并针对多线程有处理，如使用了 TLS (thread local storage)</li><li>注 2：位于 ArrayPool 的数组将永久存活，因此若是短时间临时使用需要谨慎考虑</li></ul></li><li>Streams - 使用 RecyclableMemoryStream<ul><li>注：若程序需要密集使用 MemoryStream，还可以考虑使用 System.IO.Pipelines，比 Stream 更高效，内存分配更少</li></ul></li><li>创建大量对象 - 使用对象池</li><li>返回 Task 对象的异步方法 - 使用 ValueTask</li></ol><h3 id="隐式的分配"><a class="anchor" href="#隐式的分配">#</a> 隐式的分配</h3><ol><li>委托导致的分配<ul><li>创建一个新的委托会导致一次隐式分配</li><li>C# 编译器对 lambda 有一个重要优化：如果表达式未捕获任何数据，编译器会生成额外代码，将委托实例作为静态字段缓存，使其仅在第一次分配一次</li></ul></li><li>装箱<ul><li>在需要使用对象 (引用类型) 的地方使用值类型</li><li>以接口类型使用值类型实例<ul><li>避免方式是最好使用泛型、泛型约束</li></ul></li><li>调用 valueType.GetHashCode () 和 valueType.ToString () 但值类型未重写</li><li>调用 valueType.GetType () 一定会将值类型装箱</li><li>从一个值类型的方法创建委托时一定会将其装箱 (值类型实例需要被引用)</li></ul></li><li>闭包 (closures)</li><li>Yield Return (迭代器)</li><li>参数数组 (params)</li><li>串联多个字符串</li></ol><h3 id="类库中各种隐式分配"><a class="anchor" href="#类库中各种隐式分配">#</a> 类库中各种隐式分配</h3><ol><li>System.Generics 集合</li><li>LINQ - 委托</li><li>LINQ - 创建匿名类型</li><li>LINQ - 枚举</li></ol><p>注：可以使用自动将 LINQ 查询重写成常规过程式代码的类库，可以既享受 LINQ 查询的好处，又避免分配的缺点。</p><ul><li>如 roslyn-linq-rewrite</li><li>LinqOptimizer</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;本篇包含原书第五章和第六章，主要讲了 .NET 内存分区和内存分配方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小对象通过指针快速分配 (多数情况下)&lt;/li&gt;
&lt;li&gt;大对象通</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《.NET内存管理宝典》-笔记(3)</title>
    <link href="https://wangjiaying.top/2023/07/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-3/"/>
    <id>https://wangjiaying.top/2023/07/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-3/</id>
    <published>2023-07-12T07:38:51.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本篇包含原书的第三章和第四章，第三章主要讲了一些测试工具使用，我自己也看得也比较囫囵吞枣 (毕竟个人是搞 Unity3D，这块多数工具基本都是没用的，当然部分理论依然还是可以参考的)。</p><p>其次是第四章的  <code>.NET基础知识</code> ，这一章名字说是基础知识，实际上还是比较深入的，比如各个字段的内存区域、详细描述了为什么值类型 <code>更快</code> 等等。评价是  <code>比较重要</code> 。</p><h1 id="第三章-内存测量"><a class="anchor" href="#第三章-内存测量">#</a> 第三章 内存测量</h1><h2 id="尽早测量"><a class="anchor" href="#尽早测量">#</a> 尽早测量</h2><p>与其过早地专注于优化，不如先测量评估一下我们是否有这方面的需求。</p><h3 id="开销和侵入性"><a class="anchor" href="#开销和侵入性">#</a> 开销和侵入性</h3><p>开销：额外消耗<br />侵入性：游戏应用程序本身功能</p><h3 id="采样与跟踪"><a class="anchor" href="#采样与跟踪">#</a> 采样与跟踪</h3><p>跟踪：诊断数据在特定的、被关注的时间触发时收集 (基于事件)，优势是具有数据精确性。<br />采样：可以接受数据精度丢失，仅间隔一定时间搜集 (基于时间) 采样频率越低，从测量中得到的数据就越不精确。</p><h3 id="调用树"><a class="anchor" href="#调用树">#</a> 调用树</h3><ul><li>独占：仅包含该特定函数的值。</li><li>包含：测量该特定函数的值及其所有子函数的测量值的总和。(在该函数时间、它所调用的所有其它函数的时间，及调用的所有函数等时间总和)</li></ul><p>浏览这个树，我们可以很快找出最慢的函数，或不一定很慢但被多次调用的方法。<br />同样的想法亦可用于可视化内存使用情况，其每个节点代表一种特定类型对象，子级是该对象包含或引用的该对象实例的其它类型。<br /><img data-src="/blogimages/2023/2023-07-12/1390063999.jpeg" alt="1390063999.jpeg" /></p><h3 id="对象图"><a class="anchor" href="#对象图">#</a> 对象图</h3><p>表示内存中对象之间关系的图，称为对象图或引用图。</p><ul><li>最短根路径：取决于所选对象，从特定对象到某个根的引用的最短路径。</li><li>依赖关系子图：取决于所选对象，是包含对象本身以及被其直接或间接引用的所有对象的子图。</li><li>保留子图：取决于所选定对象，指如果删除了给定对象本身则也会被删除的对象的子图。<ul><li>(因为依赖关系图很复杂，因此删除对象并不意味着所有依赖于它的对象都被删除了，对它们的引用可能仍然由其它对象保留着)</li></ul></li></ul><p>指示对象大小</p><ul><li>浅大小：对象本身大小 (其所有字段、包括对其它对象的引用的大小)</li><li>总大小：对象的浅大小与其直接或间接引用的所有对象的浅大小之和</li><li>保留大小：保留子图中所有对象的总和，即保留大小是删除给定对象后可以释放的内存量。对象图中不同引用共享的对象越多，保留大小就越小于总大小。（需要对整个对象图进行复杂分析）</li></ul><h3 id="统计"><a class="anchor" href="#统计">#</a> 统计</h3><ul><li>平均值：直观，计算方便，但是其结果没有指向任何特定样本，且容易掩盖数据分发的真实本质。</li><li>中位数：将样本分为高低两半的值</li><li>百分位数：低于给定百分比的样本的值</li><li>直方图：样本分布的图形表示（最好的测量方法）</li></ul><h3 id="延迟与吞吐量"><a class="anchor" href="#延迟与吞吐量">#</a> 延迟与吞吐量</h3><p>阿姆达尔定律</p><ul><li>潜在的延迟加速受程序的串行 (无法并行化) 部分的限制。</li><li>例如，如果程序的 90% 部分可以并行化，但仍有 10% 的部分必须正常执行，那么最大潜在加速度被限制为最多 10 倍。</li></ul><h3 id="内存转储-跟踪-实时调试"><a class="anchor" href="#内存转储-跟踪-实时调试">#</a> 内存转储、跟踪、实时调试</h3><p>监视：通过跟踪或采样方式生成诊断信息。<br />内存转储：在给定时刻保存进程的内存状态。</p><ul><li>如果没有时间变化背景，有时很难得出具体结论，因此一般进行两个或多个内存转储并相互比较。</li><li>崩溃转储可作为内存转储一种特殊情况</li></ul><p>实时调试：最具侵入性的方法，将调试器直接连接到进程上，然后逐步分析应用程序。</p><h2 id="windows-环境"><a class="anchor" href="#windows-环境">#</a> Windows 环境</h2><h3 id="vmmap"><a class="anchor" href="#vmmap">#</a> VMMap</h3><p>查看进程内存使用情况分析，vmmap 检测 .net 托管堆使用的页以及专用于堆栈或加载的二进制文件专用的页。</p><h3 id="性能计数器"><a class="anchor" href="#性能计数器">#</a> 性能计数器</h3><ul><li>性能计数器值的读取完全由我们使用的工具采样的频率来控制。</li><li>仅当发生特定事件时，才会更新性能计数器数据，之后其值将一直保持不变。</li></ul><h3 id="windows-事件跟踪"><a class="anchor" href="#windows-事件跟踪">#</a> Windows 事件跟踪</h3><p>EWT<br />（诊断功能强大）</p><h3 id="windows-性能工具包"><a class="anchor" href="#windows-性能工具包">#</a> Windows 性能工具包</h3><p>Windows performance toolkit,WPT 是 Windows 环境中的一组诊断工具，具有搜集和分析 EWT 数据能力。</p><ul><li>Windows performance recorder (WPR，Windows 性能记录器)：充当 EWT 的控制器</li><li>Windows performance analyzer (WPA，Windows 性能分析器)：充当 EWT 的使用者</li></ul><h3 id="perfview"><a class="anchor" href="#perfview">#</a> PerfView</h3><h3 id="procdump-debugdiag"><a class="anchor" href="#procdump-debugdiag">#</a> ProcDump、DebugDiag</h3><p>进行内存转储的工具<br />前着为命令行，后者为 GUI 工具</p><h3 id="windbg"><a class="anchor" href="#windbg">#</a> WinDbg</h3><p>最底层的工具，不管是 net 托管程序还是原生 Windows 应用程序或调试内核本身。<br />也可以直接附加到托管程序并调试。<br />默认情况下，windbg 作为原生调试器工作，因此必须使用 windbg 扩展以为其提供 net 相关概念：</p><ul><li>SOS</li><li>SOSEX</li><li>NetExt 和 MEX</li></ul><p>由于一次又一次地输入所有命令非常麻烦，可使用命令树窗口简化。</p><h3 id="benchmarkdotnet"><a class="anchor" href="#benchmarkdotnet">#</a> BenchmarkDotNet</h3><p>代码性能测量</p><h3 id="商业工具"><a class="anchor" href="#商业工具">#</a> 商业工具</h3><p>visual studio<br />Scitech .Net Memory Profiler<br />JetBrain dotMemory<br />RedGate ANTS Memory Profiler<br />Intel VTune Amplifier 和 AMD CodeAnalyst Performance Analyzer</p><ul><li>专门用于基于硬件的底层代码分析，这些工具通常由处理器制造商提供</li><li>可以从硬件中内置的硬件计数器中获取其有关内部行为的信息：缓存和内存利用率、管道停顿等</li><li>只有这样的底层工具才能清楚地指出诸如第二章中显示的伪共享之类的问题。</li></ul><p>Dynatrace 和 AppDynamics</p><ul><li>用于监视应用程序性能的上层工具，可持续收集数据</li></ul><h2 id="linux-环境"><a class="anchor" href="#linux-环境">#</a> Linux 环境</h2><p>略</p><h1 id="第四章-net基础知识"><a class="anchor" href="#第四章-net基础知识">#</a> 第四章 .NET 基础知识</h1><p>.NET 整个概念都基于 common language infrastructure (CLI) 的规范，CLI 描述了代码和运行时 环境的概念，并确保无需重新编译的情况在不同计算机运行。<br />有很多不同 .NET 实现，此处略。</p><h2 id="net-内部原理"><a class="anchor" href="#net-内部原理">#</a> .NET 内部原理</h2><p>代码被编译为 CIL (common intermediate language) 然后由 common language runtime (CLR) 执行。CLR 是托管环境的执行核心。<br />CLR 主要职责：</p><ul><li>JIT 编译器：将 cil 代码转换为机器码。这种执行托管代码方式其实是对原生系统机制的巧妙封装，就像内存管理包含了线程堆栈和堆一样。</li><li>类型系统：负责管理类型控制和兼容性机制。包括 common type system (CTS) 和 (用于反射机制的) 元数据。</li><li>异常处理：负责在用户程序和运行时两个层次上进行异常处理。</li><li>内存管理 (通常指垃圾回收器)：运行时中管理内存的组件。</li><li>执行引擎：负责大部分运行时的职责，包括 jit 编译和异常处理，ecma-335 中被称为虚拟执行系统 (VES)，负责加载和运行为 cli 编写的程序。</li><li>垃圾回收器：负责内存管理、对象分配，回收不再使用的内存区域。</li></ul><p>托管代码：包含足够额外信息的代码，这些信息用于使 CLI 为代码执行提供一组核心服务。</p><ul><li>如给出代码中一个方法地址，CLI 必须能够定位到描述该方法的元数据，还必须能够遍历 stack、处理异常、存储和获取安全信息。</li></ul><p>一些误解：</p><ul><li>.NET 并非一般意义上的虚拟机，.NET 运行时不会创建一个隔离环境，也不会模拟任何特定的架构或计算机。其重用了诸如操作系统内存管理之类的内置系统资源，包括 heap、stack、进程和线程等，然后再在这些内置资源之上构建一些附加功能 (自动内存管理等)</li><li>计算机不会始终运行着一个 .NET 运行时，每个 .NET 程序运行时才被加载和执行</li></ul><p>.maxstack：</p><ul><li>不是 CIL 指令，而是一个元数据描述，其它工具可以使用它验证代码安全性 (防止缓冲区溢出攻击)。其描述了方法执行期间 evaluation stack 中最多可以分配多少字节。</li></ul><p>.NET stack machine 的位置概念：</p><ul><li>方法中局部变量</li><li>方法参数</li><li>另一个值的实例字段</li><li>(类、接口或模块的) 静态字段</li><li>本地内存池</li><li>暂时放在 evaluation stack 上</li></ul><p>JIT 编译器会负责将每个 逻辑位置 映射到特定的计算机架构 (即寄存器操作的机器码)。</p><h2 id="程序集和应用程序域"><a class="anchor" href="#程序集和应用程序域">#</a> 程序集和应用程序域</h2><p>为满足安全性、可靠性或版本化需求，应用程序域提供将应用程序代码不同部分隔离到应用程序域中的功能。</p><ul><li>注：由于为使得 .NET Core 保持精简，应用程序域已移除，不过 CoreCLR 内部依然使用了应用程序域</li><li>（微软建议开放人员使用进程或新式容器实现 .NET Core 程序隔离）</li></ul><p>应用程序域分类：</p><ul><li>共享域：不同应用程序域之间共享代码加载此域。包括 basic class library、system 命名空间中的类型</li><li>系统域：核心运行时组件加载到此域，负责创建和初始化其它应用程序域。还保存了进程范围内暂存的字符串文本。</li><li>默认域：用户代码会加载至该域。</li><li>动态域：通过 AppDomain.CreateDomain 根据需要创建，.NET Core 不提供该功能。</li></ul><p>所有共享代码由共享域负责处理，所有用户代码由单个默认域处理。系统域仅存在结构和逻辑，在进程内存中不可见。</p><h2 id="进程内存区域"><a class="anchor" href="#进程内存区域">#</a> 进程内存区域</h2><p>每个应用程序域，包括共享域、系统域、默认域及其它所有动态加载的域，都各自有自己的一组堆：</p><ul><li>High Frequency Heap (高频堆)：应用程序域基于其内部目的，将频繁访问的数据存储于此。<ul><li>CoreCLR 描述：这些堆用于分配应用程序域生命周期内始终存在的数据。为更好管理 page，应将频繁分配的对象分配到高频堆。</li><li>如详细的方法和字段描述等基元静态数据也存放在这。</li></ul></li><li>Low Frequency Heap (低频堆)：包含了较少使用的类型相关数据，如 EEClass、JIT 编译、反射、类型加载机制所需要的其它数据。</li><li>Stub Heap：文档描述 -- 保存了实现代码访问安全 (CAS)、COM 包装调用和 P/Invoke 的 sub</li><li>Virtual Call Stub：包含用于虚拟 stub 调度 (VSD) 技术所使用的数据结构和代码。<ul><li>VSD 技术：使用 stub 用于虚拟方法调用，而非使用传统的虚拟方法表。</li></ul></li><li>High Frequency Heap、Low Frequency Heap、Stub Heap 和各种 Virtual Call Stub 都统称为 Loader Heap 类型，因为它们存储的都是类型系统所需的各种数据 (因此加载任何一个类型时都需要它们)<ul><li>即虽然有 Loader Heap 这个术语，但内存其实不存在一个 Loader Heap，而是代表上述内存区域统称</li><li>注：加载至 Loader Heap 区域的类型的生命周期跟随应用程序域。</li></ul></li></ul><h2 id="类型系统"><a class="anchor" href="#类型系统">#</a> 类型系统</h2><p>Common Type System (通用类型系统)<br />.NET 中每种类型都由一个称为 MethodTable 的数据结构描述，其中包含类型的大量信息，最重要的有：</p><ul><li>GCInfo：用于垃圾回收器用途的数据结构</li><li>标志：描述各种类型的属性</li><li>基本实例大小：每个对象的大小</li><li>EEClass 引用：存储通常仅用于类型加载、JIT 编译或反射的『冷』数据，包括所有方法、字段和接口的描述信息。</li><li>调用所有方法 (包括继承自基类的方法) 所需要的描述信息。</li><li>静态字段有关的数据：包括与基元静态字段有关的数据。</li></ul><p>只要有需要，运行时将通过访问 MethodTable 的地址 (表示为 TypeHandle) 获取被加载的类型信息。</p><h3 id="类型的分类"><a class="anchor" href="#类型的分类">#</a> 类型的分类</h3><ul><li>值类型：这种类型的实例直接包含其所有数据 (值类型的值是自包含的)</li><li>引用类型：这种类型的实例包含对其数据的引用 (引用类型所描述的值指示其它值的位置)</li></ul><h4 id="生存期"><a class="anchor" href="#生存期">#</a> 生存期</h4><ul><li>值类型实例包含的数据，其生存期与实例本身一样长</li><li>引用类型的值描述了其它值的位置，那些值的生存期并不取决于引用类型值本身</li></ul><h4 id="可共享性"><a class="anchor" href="#可共享性">#</a> 可共享性</h4><ul><li>值类型的值不可共享，如果想在其它地方使用，默认只会按照字节复制一份出来。复制值不影响原始值。</li><li>引用类型的值可被共享，在传递之后会多出一个指向同一个位置的引用类型实例。</li></ul><h4 id="相等性"><a class="anchor" href="#相等性">#</a> 相等性</h4><ul><li>值类型不存在相等性，当且仅当它们值的二进制序列一样时才认为完全相同</li><li>引用类型当且仅当它们指示的位置一样就是完全相同的</li></ul><h3 id="类型的存储"><a class="anchor" href="#类型的存储">#</a> 类型的存储</h3><p>存储在堆栈，还是存储在堆？这是实现细节上的决策。通常值类型和引用类型存储位置的说法，并不准确，因为他们存在包含关系。<br />注：CLI 标准中并未指定关于存储位置的任何实现细节决策。</p><h3 id="值类型"><a class="anchor" href="#值类型">#</a> 值类型</h3><p>ECMA335：类似整数或浮点数，值类型使用了一种简单的将数据直接按位存储模式。每个值都有一个类型，该类型描述了它使用的存储空间以及它的表现方法中各个位 (bit) 的含义，也描述了对该表现方式进行的操作。在编程语言中，值通常用于表现简单类型和非对象。<br />通用语言规范 (CLS) 定义了两种值类型：</p><ul><li>结构：包括许多内置整型类型 (char/byte/integer)、浮点类型和布尔类型</li><li>枚举：基本是整型类型的扩展，由一组命名常量构成。从内存管理的角度看就是整型类型（内部本质上是结构）</li></ul><h4 id="值类型的存储"><a class="anchor" href="#值类型的存储">#</a> 值类型的存储</h4><p>『堆栈是一种轻量级机制，只需要创建一个大小合适的 activation frame 并在不再需要时将其关闭，就可以在堆栈上 分配 和 回收 对象』<br />但堆栈的生存期和值本身需要的生存期不匹配，生存期和值共享这两个因素，决定我们可以使用何种机制存储值类型数据。<br />值类型可能出现位置：</p><ul><li>方法中局部变量：具有非常严格和定义良好的生存期，其长度和方法的调用时长相同。<ul><li>CLI 指出：引用局部变量或参数变量的托管指针，有可能出现引用失效的问题，因为它的行为无法验证。</li></ul></li><li>方法的参数：可以完全被视作局部变量。</li><li>引用类型的实例字段：其生存期取决于父值的生存期。将于引用类型一并被分配于堆。</li><li>另一个值类型的实例字段：跟随父值。</li><li>(类 / 接口 / 模块中的) 静态字段：静态字段的生存期和定义此字段的类型等长，因此肯定不能使用堆栈保存。</li><li>局部内存池：生存周期与方法生存期严格等长，堆栈</li><li>evaluation stack 上临时值：处于性能考虑，JIT 显然会尽量使用 CPU 寄存器和堆栈。</li></ul><h4 id="结构"><a class="anchor" href="#结构">#</a> 结构</h4><ul><li>分配于堆上而非栈上：可以从实现细节上受益，例如避免 GC 管理它们所带来的开销。</li><li>较小：结构只存储其数据而无需存储任何额外的元数据，因此所需内存更小。</li><li>提供了更佳的数据局部性：由于结构更小，因此可以更密集地在集合中打包数据。</li><li>访问速度更快：直接包含数据，因此访问时无需进行额外的解引用 (dereferencing) 操作。</li><li>天然具有传值语义</li></ul><h4 id="结构概述"><a class="anchor" href="#结构概述">#</a> 结构概述</h4><p><img data-src="/blogimages/2023/2023-07-12/1515094104.jpeg" alt="1515094104.jpeg" /></p><p>上图内存区域可能位于堆栈、堆，甚至 CPU 寄存器。<br />不过当前 CLR 实现不允许直接在托管堆上使用上述布局，托管堆中的对象必须是自描述的引用类型。因此当需要在堆中存储结构时，将执行装箱 (boxing)。</p><ul><li>当结构被装箱，就将很难再获得结构的种种优点。结构的真正能力只在未被装箱的情况才能得以体现。</li></ul><p>优化内存和性能的核心规则之一是：避免分配，结构即是帮助我们应用这条规则的利器。<br />此外，由于结构的限制，比如不带继承功能，可以让编译器可以对其使用方式进行大量预判。</p><h4 id="结构的存储"><a class="anchor" href="#结构的存储">#</a> 结构的存储</h4><ul><li>ldloca.s 0：将第一个局部变量的地址推入 evaluation stack</li><li>initobj：从 evaluation stack 取出并移除地址，将其指向内存初始化为指定类型初始值</li><li>ldarg.0：将方法的第一个参数 (实例方法为 this) 推入 evaluation stack（后续参数依此类推）</li><li>ldloc.0：将第一个局部变量的值推入 evaluation stack</li><li>call：调用方法，结果放入 evaluation stack</li><li>ret：从方法返回至调用者</li><li>newobj：堆分配</li></ul><p>对于小型结构数据，JIT 可以仅使用 CPU 寄存器从而完全避免使用堆栈以极大优化性能 (生成的机器码中彻底没有了结构的概念)。<br />还可以对 (大型) 结构体使用传引用优化复制效率。<br />结构是高效的数据容器，其简洁性提供了极大的代码优化潜力，『局部结构类型变量被分配在堆栈上』确实不假，但实际情况可能比这更好，局部变量可以被优化成完全由 CPU 寄存器处理而无需用到堆栈，从而使按值传递也不过需要对 CPU 寄存器进行一些操作而已。<br />注 1：release 和 debug 模式编译后代码有很大差异。<br />注 2：影响 JIT 优化与否的大小大概是 24 字节，可以安全假设 JIT 将对不超过 16 字节的结构进行优化。(注意测试代码是 64 位 RyuJIT 编译器)<br /> 注 3：在一个结构体方法中可以将新值赋给 this 字段，是由于结构体直接存储数据，可看作再次初始化。</p><h3 id="引用类型"><a class="anchor" href="#引用类型">#</a> 引用类型</h3><p>通用规范中定义了两种主要的引用类型：</p><ul><li>对象类型： ECMA335 所述，对象是 自描述值的引用类型，类型显示存储于其表现形式中。包括类和委托。</li><li>指针类型：一个指向某个内存位置的特定于当前计算机的纯地址。指针分为托管指针和非托管指针两种。</li></ul><p>概念区分：</p><ul><li>一个引用类型的值是对其数据的引用，引用本身可被视为一个值类型，内部是个 32 位或 64 位地址，引用具有传值语义。</li><li>引用类型的数据：被引用的一段内存区域，标准中并未定义数据的存储位置，反正它肯定存储在引用本身以外的其它位置。</li></ul><p>引用可以被视为指针的一种，但与普通指针不同的是运行时为引用提供了额外的安全性。</p><p><img data-src="/blogimages/2023/2023-07-12/-1385607071.jpeg" alt="-1385607071.jpeg" /></p><p>注：存在一种逃逸分析的技术，也许可以让类分配于堆栈，不过 .NET 目前不支持。</p><h4 id="类"><a class="anchor" href="#类">#</a> 类</h4><p>由于 .NET 内存管理的设计方式，堆上每个对象都有严格的内存布局：</p><ul><li>object header：存储了需要附加到对象上的所有附加信息，大多数时候都是 0。<ul><li>常见的用途有：此对象上的 lock 信息或 GetHashCode 结果缓存值（遵循先到先得规则）</li></ul></li><li>method table reference：即 MethodTable 引用，指向类型描述数据结构中的一个相应条目 (位于 high frequency heap)。这里也是对象相互引用时的引用点。</li><li>数据占位符 (若类型没有字段)：当前垃圾回收器要求每个对象都至少有一个指针大小的字段。<ul><li>该字段不必专门用于垃圾回收，而是可以其它各种用途重用 (如用作存储对象第一个字段 - 如果有的话)</li></ul></li></ul><p><img data-src="/blogimages/2023/2023-07-12/-1159290546.jpeg" alt="-1159290546.jpeg" /></p><p>堆上每个对象都至少包含上述三个字段。<br />32 位 最小堆对象为 12 字节：</p><ul><li>4 字节用于对象标头</li><li>4 字节 (一个指针大小) 用于 method table reference</li><li>4 字节 (一个指针大小) 用于内部数据占位符</li></ul><p>64 位 最小堆对象位 24 字节：</p><ul><li>8 字节用于对象标头：实际只用到 4 个字节，另外以 0 填充的 4 字节仅用于对齐目的（64 位架构基于 8 字节对齐）</li><li>8 字节 (一个指针大小) 用于 method table reference</li><li>8 字节 (一个指针大小) 用于内部数据占位符</li></ul><p>一个包含 1 字节数据的分配于堆栈上的结构仅占用 1 字节空间 (内存对齐可能有额外开销)，而一个包含 1 字节数据的分配于堆上的类将在 64 位运行时占用 24 字节空间，两者内存开销相差明显。<br />另外，类生成的最终汇编代码也比结构更复杂，在测试代码中，类的性能与结构之间相差超过 4 倍。</p><h2 id="字符串"><a class="anchor" href="#字符串">#</a> 字符串</h2><p>字符串不可变性仅体现在 Basic Class Library 未提供任何修改字符串的 API，但在运行时并没有这个限制。</p><ul><li>它只是一段连续的、以某种方式表示字符的字节区块，完全可以使用 unsafe 模式使用指针修改 —— 当然这种做法是不受支持的。</li></ul><p>string.format、string.join 等常见辅助函数内部已经使用了 stringbuilder，为进一步优化甚至甚至进一步封装了 StringBuilderCache</p><ul><li>StringBuilderCache 内部存储了一个 thread static stringbuilder，每个线程上都会创建一个专门的实例，因此是线程安全的。</li></ul><p>字符串不可变优缺点：</p><ul><li>优点<ul><li>安全性</li><li>并发性</li></ul></li><li>缺点<ul><li>修改操作将导致额外字符串实例</li></ul></li></ul><h3 id="字符串暂存"><a class="anchor" href="#字符串暂存">#</a> 字符串暂存</h3><p>.NET 运行时内部有一个名为字符串暂存 (string interning) 的机制，此机制默认仅适用于字符串字面量 (string literal)。</p><ul><li>.NET 内部也提供了手动暂存的 API</li></ul><p>暂存的字符串由 StringLiteralMap 和 LargeHeapHandleTable 注册和管理，这几个数据结构生成周期与应用程序一样长。</p><p><img data-src="/blogimages/2023/2023-07-12/592931748.jpeg" alt="592931748.jpeg" /></p><p>字符串暂存优缺点</p><ul><li>优点<ul><li>消除重复字符串</li><li>提供相等比较性能</li></ul></li><li>缺点<ul><li>永续性：暂存字符串将永远保持可达状态</li><li>创建临时字符串：只能暂存已创建的字符串，因此即使仅用于检查是否存在某个已暂存字符串，也会有一个留存极短时间的未暂存字符串。</li></ul></li></ul><p>结论：字符串暂存仅在大量重复字符串需要长时间保留于内存下才有意义。(该场景似乎并不常见)</p><h2 id="装箱与拆箱"><a class="anchor" href="#装箱与拆箱">#</a> 装箱与拆箱</h2><p>是一个效率较低的操作，应尽量避免。例如避免在需要对象 (引用类型) 的地方使用值类型。</p><ul><li>作为一个通用规则：尽量避免在调用以 object 类型为参数的方法。</li></ul><p>注：以接口类型使用值类型实例 (若值类型实现了该接口)，由于接口是引用类型，因此同样会导致装箱。（可以考虑利用泛型优化，泛型方法将被编译为特定具体类型的方法）<br />foreach 遍历值类型列表，会导致隐式装箱。</p><ul><li>为何 list&lt;&gt; 这类常见集合类型采用结构实现枚举器？<ul><li>绝大部分场景中，枚举器都被当做一个局部变量，值类型可以快速低廉地在堆栈上分配 (好处超过装箱可能带来的问题)</li></ul></li></ul><p>与装箱对应是拆箱，不过拆箱不会导致太大内存开销。</p><h2 id="按引用传递"><a class="anchor" href="#按引用传递">#</a> 按引用传递</h2><p>我们可以按引用传递任何值，无论它是值类型实例还是引用类型实例。</p><h2 id="类型数据局部性"><a class="anchor" href="#类型数据局部性">#</a> 类型数据局部性</h2><p>结构的数据构造内存使用效率更好。<br />且结构体数组才是内存连续，而引用类型数组只包含连续的引用，实际值分散于整个托管堆。</p><ul><li>类实例数组有额外一次解引用，并且无法在内存中连续排列，因此类实例数组具有更差的数据局部性，加载类数组必须使用更多的 cache line，导致其性能会相差更大。</li></ul><h2 id="静态数据"><a class="anchor" href="#静态数据">#</a> 静态数据</h2><p>静态数据可以被视作程序中的一种全局变量。</p><ul><li>C# 仅支持一种静态数据类型：静态字段</li></ul><h3 id="静态字段"><a class="anchor" href="#静态字段">#</a> 静态字段</h3><p>静态字段的值被该类型的所有实例所共享，通过使用类型名称，在任何可以访问该类型的地方都可以访问该类型上定义的静态字段。</p><ul><li>静态数据具有应用程序域作用域 (每个应用程序域单独一份实例)</li><li>定义在一个程序集的类型上的静态数据将一直存活到应用程序域被卸载 (使其引用的静态数据和对象也将保持可达)。</li></ul><p>实现细节</p><ul><li>静态基元数据 (如数字) 存储于相应应用程序域的一个 HighFrequencyHeap 中</li><li>静态引用类型实例存储于常规 GC Heap 中，与普通对象区别在于额外被一个内部 static table 引用</li><li>静态用户自定义值类型实例 (结构) 将以装箱形式存储于常规 GC Heap 中</li></ul><p><img data-src="/blogimages/2023/2023-07-12/1274258931.jpeg" alt="1274258931.jpeg" /></p><p>访问</p><ul><li>对于基元类型静态字段，已知维护此字段的 DomainLocalModule 地址和要访问的字段在 statics blob 中的偏移量，计算后可得静态数据的绝对地址</li><li>对于引用类型静态字段 (包括结构类型，其以装箱形式分配在堆上)，已知对应 object [] 数组的地址和访问字段偏移量，计算出静态字段的绝对地址，获得指向托管堆真正实例数据的引用。</li></ul><p>访问基元静态字段的速度非常快，它唯一做的操作就是从适当的 statics blob 区域读取一个指定值。<br />访问类型 / 结构静态字段数据需要执行解引用操作，并随之带来额外开销。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;本篇包含原书的第三章和第四章，第三章主要讲了一些测试工具使用，我自己也看得也比较囫囵吞枣 (毕竟个人是搞 Unity3D，这块多数工具基本都是没用的，当然部分理论依</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Unity Addressables 笔记</title>
    <link href="https://wangjiaying.top/2023/07/10/Addressables-%E7%AC%94%E8%AE%B0/"/>
    <id>https://wangjiaying.top/2023/07/10/Addressables-%E7%AC%94%E8%AE%B0/</id>
    <published>2023-07-10T08:26:05.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>前两天公司其他同事在推荐让试一试 <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vd2VjaGF0LW1pbmlnYW1lL21pbmlnYW1lLXVuaXR5LXdlYmdsLXRyYW5zZm9ybS9ibG9iL21haW4vRGVzaWduL1VzaW5nQXNzZXRCdW5kbGUubWQ=">WXAssetBundle</span>，看看性能是不是真的有所提升，然后顺便就看到微信官方推荐使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vd2VjaGF0LW1pbmlnYW1lL21pbmlnYW1lLXVuaXR5LXdlYmdsLXRyYW5zZm9ybS9ibG9iL21haW4vRGVzaWduL1VzaW5nQWRkcmVzc2FibGUubWQ=">Addressables</span> 系统进行资源加载 (其实之前就有瞄到这文档，只是当时项目重点不在这，所以没怎么注意)<br /> 当然微信虽然推荐 Addressables ，也提到如果自己进行维护管理的 AB 包 性能肯定会比 AA (Addressables) 包更好 ——</p><blockquote><p>AA 包较大项目时生成的未压缩的 catalog 较大，加载效率低</p></blockquote><p>所以微信推荐的原因是：</p><ul><li>学习使用曲线平滑，便于使用和维护，并且能快速切换想要的资源管理技术。</li></ul><p>因此，就算我们还是在使用自己的包管理方式，先了解一下总无坏处：比如上面提到的 catalog，catalog 在 Addressables 中用来干什么的？</p><h1 id="总览"><a class="anchor" href="#总览">#</a> 总览</h1><p>Addressables 底层使用引用计数维护资源关系 (这是当然，我们自己的也是)，被引用自动加载时，Unity 自动维护其引用计数。不过当我们显式加载可寻址资源时，就必须在使用完该资源后释放该资源了。</p><ul><li>另外，资源使用的内存只有在其所属的 AssetBundle 也被卸载后才会被释放 (与我们自己维护的一样)</li></ul><p>所以，避免资源内存泄露的情况与使用自己的资源管理器是一样的：显式加载了记得释放。<br />另外需要注意：</p><ul><li>如果将 Resources 文件夹中的资源设置为可寻址，则 Unity 会将资源移出目录。可以选择自己将资源移动到项目中的其他文件夹，但不能将可寻址资源存储在 Resources 目录中。</li></ul><p>注：Windows 的文件路径限制为 260 个字符</p><h2 id="加载与卸载"><a class="anchor" href="#加载与卸载">#</a> 加载与卸载</h2><p>自动加载依赖及引用计数<br />主要有以下几种方式：</p><ul><li>AssetReferences<ul><li>一种资源引用，可以看做 可用于替换在 MonoBehaviour、ScriptableObject 定义的常规拖上去而使用的引用资源，例如对应 GameObject：AssetReferenceGameObject 或 AssetReferenceTexture 等，而 AssetReference 可认为是对应此前 Object 类型 (可以拖任何对象上去)</li><li>此外，也可以使用 AssetReferenceUILabelRestriction 限制能拖上去指定标签的 Addressables 对象</li><li>注：AssetReference.cs 中有详细列表</li></ul></li><li>通过地址 (路径) 加载<ul><li><code>Addressables.InstantiateAsync(path)</code></li><li><code>Addressables.LoadAssetAsync&lt;GameObject&gt;(path)</code></li></ul></li><li>通过标签加载</li><li>IResourceLocation</li></ul><p>与常规资源一样，加载之后需要对应卸载资源。</p><p>注：加载时也可以采用 async、await 异步方法，其 Load 方法中有  <code>Task</code>  属性</p><h2 id="分组和标签"><a class="anchor" href="#分组和标签">#</a> 分组和标签</h2><ul><li>分组用于组织具体内容，每个组可以有自己的打包设置 (如整个组单打为一个包，或分离打包、名字是否带 Hash 等)<ul><li>一个组打包成一个 Bundle</li><li>组内每个资源都单独打成一个 Bundle</li><li>组内同一标签的打成一个 Bundle</li></ul></li><li>同时也可以支持通过标签加载 (如果设置了标签的话)</li></ul><h1 id="资源清单catalogs"><a class="anchor" href="#资源清单catalogs">#</a> 资源清单 (catalogs)</h1><p>即 catalogs 文件，Addressables 用来管理资源加载、依赖啥的<br /> catalog_{日期}.hash</p><ul><li>检查 catalog.json 文件是否发生变化</li><li>先下载这个，再决定是否下载  catalog_{日期}.json 文件</li></ul><p>catalog_{日期}.json</p><ul><li>具体记录依赖关系啥的数据，Bundle 越多，该文件越大</li><li>可以在 AddressableAssetSettings 中设置命名方式</li></ul><p>可以自动加载，也可以手动加载，建议当然是手动加载比较好。Addressables 同样会缓存改文件，在 hash 发生变化时才会重新下载。</p><ul><li>哈希文件需要与目录位于同一位置并且具有相同的名称，路径的唯一区别是扩展名。</li></ul><h2 id="手动加载方式"><a class="anchor" href="#手动加载方式">#</a> 手动加载方式</h2><ul><li>Addressables.LoadContentCatalogAsync</li><li>可选参数是否自动释放句柄，官方建议直接传 true 自动释放</li><li>还可以手动调用 Addressables.CheckForCatalogUpdates 更新 (官方文档表示可以同时加载多个)</li></ul><h2 id="catalogs-大小优化方式"><a class="anchor" href="#catalogs-大小优化方式">#</a> catalogs 大小优化方式</h2><ul><li>压缩：打包进 AssetBundle，当然这样做会导致加载时间增加 (有提供选项)<ul><li>注：只影响本地的 catalog，即与整包打包到 SteamingAssets 目录的那个</li></ul></li><li>禁止包含额外资源：每个分组设置上的 IncludeXXXXX<ul><li>这个选项得看情况设置，最新 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5hZGRyZXNzYWJsZXNAMS4yMS9tYW51YWwvYnVpbGQtY29udGVudC1jYXRhbG9ncy5odG1s">Content catalogs 1.21.14</span> 提供了 Disable built-in scenes and Resources 选项（我自己测试版本是 1.19 ，没这个选项，只有一些 IncludeXXXXX）</li></ul></li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5hZGRyZXNzYWJsZXNAMS4yMS9tYW51YWwvTG9hZENvbnRlbnRDYXRhbG9nQXN5bmMuaHRtbA==">Manage catalogs at runtime | Addressables | 1.21.14</span></p><h1 id="资源组类型"><a class="anchor" href="#资源组类型">#</a> 资源组类型</h1><p>这里主要是指 『动态资源』、『静态资源』之分，其区别如下：</p><p>静态资源</p><blockquote><p>Content Update Restriction 设置为 Cannot Change Post Release<br /> 动态资源<br /> Content Update Restriction 设置为 Can Change Post Release</p></blockquote><p>同时，基于是否设置为 Remote 而确定属于： <code>本地静态资源</code> 、 <code>远程静态资源</code> 还是 <code>远程动态资源</code>  三类中的一类。</p><p>注：在进行完整构建之后，如果只是更新打包不要修改该项，否则对更新会有影响</p><h2 id="静态资源组"><a class="anchor" href="#静态资源组">#</a> 静态资源组</h2><p>分为  <code>本地静态资源</code> 、 <code>远程静态资源</code></p><p>在资源发生变更后，可以通过菜单的  <code>Tools-&gt;Check for Content Updates</code>  将其自动设置到一个名为  <code>ContentUpdate</code>  的新分组中：</p><p><img data-src="/blogimages/2023/2023-07-10/Snipaste_2023-07-10_16-33-16.jpg" alt="" /><br /><img data-src="/blogimages/2023/2023-07-10/Snipaste_2023-07-10_17-47-51.jpg" alt="" /></p><p>然后再使用 Build-&gt;Update Preview Build 就可以打出新组的包。</p><p>也就是说，更新打包时， <code>Check for Content Updates</code>  用于单独把修改过的资源挪到  <code>UpdateContent</code>  分组进行打包，这个分组默认设置就是  <code>远程动态资源组</code></p><blockquote><p>注：经测试，每次执行  <code>Check for Content Updates</code>  都会生成一个新的  <code>UpdateContent</code>  远程动态资源分组，分组重名则在后面加序号。</p></blockquote><h3 id="本地静态资源"><a class="anchor" href="#本地静态资源">#</a> 本地静态资源</h3><p>即  <code>Build&amp;LoadPaths</code>  设置为  <code>Local</code>  模式</p><p>在项目构建的时候 Addressables 会自动把资源拷贝到 SteamingAssets。</p><ul><li>试了下是真的 (PC 包)—— 另外 Remote (远程资源) 就不会跟随 Unity 打包进 SteamingAssets 目录。</li><li>简单来说，似乎就是  <code>Library\com.unity.addressables\aa</code>  下的会跟随打包拷入 SteamingAssets 目录。<ul><li>注： 因为  <code>Remote资源</code>  是在  <code>ServerData</code>  目录，这个目录是没有的</li></ul></li></ul><h3 id="远程静态资源"><a class="anchor" href="#远程静态资源">#</a> 远程静态资源</h3><p>即  <code>Build&amp;LoadPaths</code>  设置为  <code>Remote</code>  模式</p><p>远程静态资源一样会被复制到  <code>ServerData</code>  目录，这种就被称为  <code>远程静态资源</code> 。</p><ul><li>不过远程资源肯定都是没有就去下载，所以，暂时没弄明白  <code>远程静态资源</code> 和  <code>远程动态资源</code>  相比，除了更新时会单独把修改过的资源挪到  <code>UpdateContent</code>  分组外，还有其它啥明显的区别和作用？</li><li>感觉远程静态资源只会增加复杂性，所以还有其它在下没想到的设计考虑吗？</li></ul><p><img data-src="/blogimages/2023/2023-07-10/Snipaste_2023-07-10_17-53-38.jpg" alt="" /><br />如上图所示，远程静态资源 (动态资源也一样) 包括其下载路径都会直接存储到本地的  <code>catalog</code>  数据中。</p><h2 id="动态资源组"><a class="anchor" href="#动态资源组">#</a> 动态资源组</h2><p>动态资源组只存在  <code>远程动态资源</code>  (都动态了肯定是远程下载了对吧？)<br /> 发生变更的资源会重新打包，同时直接覆盖掉原资源 (如果是附加了 Hash，则与原资源同级新增)。<br />如果想要进行资源更新，必须使用  <code>Remote catalog</code> ，即  <code>远程动态资源组</code> ，上述静态资源组更新而自动创建的  <code>UpdateContent</code>  分组即为  <code>Remote</code>  动态资源组。</p><p>注：远程动态资源组确实很适合微信这种按需延迟下载使用的方式，使用流程跟正常的操作几乎一样方便。</p><h1 id="测试"><a class="anchor" href="#测试">#</a> 测试</h1><p>编辑器中提供了三种加载方式：</p><p><img data-src="/blogimages/2023/2023-07-10/Snipaste_2023-07-11_17-01-53.jpg" alt="" /></p><ul><li>Use Asset Database：使用 AssetDatabase 进行加载，不用打 AssetBundle 即可测试</li><li>Simulate Groups：模拟 AssetBundle 信息进行加载，不用打 AssetBundle 即可测试，相比第一种方式会有更多一些信息</li><li>Use Exising Build：需要打包后加载，加载真实 AssetBundle 包</li></ul><p>同时也直接提供了一个  <code>Hosting</code>  编辑器界面可用于本地打包后，开启一个模拟服务器测试远程加载资源情况，局域网内的设备也可以通过本地网络连测试资源的加载。</p><h2 id="eventviwer"><a class="anchor" href="#eventviwer">#</a> EventViwer</h2><p>需要勾选设置项的  <code>Send Profiler Events</code></p><p><img data-src="/blogimages/2023/2023-07-10/Snipaste_2023-07-11_17-12-46.jpg" alt="" /></p><p>这个界面初步看来，可以查看加载的 AssetBundle 对象及其依赖啥的。其它功能还待了解。</p><h2 id="analyze"><a class="anchor" href="#analyze">#</a> Analyze</h2><p>资源分析界面，可用来查找重复资源引用之类的，可以方便地将重复资源直接设置到一个新分组。</p><h1 id="注意"><a class="anchor" href="#注意">#</a> 注意</h1><ul><li>addressables_content_state.bin<ul><li>更新打包时需要用来对比 (Update Preview Build)</li></ul></li><li>Update Restrictions<ul><li>区分静态资源和动态资源</li><li>打包之后不要变更</li></ul></li></ul><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>过了一番流程之后，感觉官方的 Addressables 的使用确实已经比较方便，特别是连模拟加载及自带服务器模拟都提供了。<br />至于最开始前言提到的 &quot;catalog&quot; 作用，也知道了这该是属于 Addressables 的清单文件，记录了资源依赖之类的关系，必须首先加载才能进入后续流程。<br />当年 (记得好像是 2017 年？) 就听说官方要出新的资源管理方式，就不想去研究 AssetBundle，结果最后还是搞起了 AssetBundle，直到现在才过了一遍官方这个新的 Addressables... 如果以后我自己搞新项目，一定得实际尝试一番。</p><p>注：Addressables 是开源的。</p><h1 id="参考文档"><a class="anchor" href="#参考文档">#</a> 参考文档</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vd2VjaGF0LW1pbmlnYW1lL21pbmlnYW1lLXVuaXR5LXdlYmdsLXRyYW5zZm9ybS9ibG9iL21haW4vRGVzaWduL1VzaW5nQWRkcmVzc2FibGUubWQ=">Design/UsingAddressable.md · Ocean/minigame-unity-webgl-transform - Gitee.com</span><br /><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vd2VjaGF0LW1pbmlnYW1lL21pbmlnYW1lLXVuaXR5LXdlYmdsLXRyYW5zZm9ybS9ibG9iL21haW4vRGVzaWduL1Jlc291cmNlc0xvYWRpbmcubWQ=">Design/ResourcesLoading.md · Ocean/minigame-unity-webgl-transform - Gitee.com</span><br /><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5hZGRyZXNzYWJsZXNAMS4yMS9tYW51YWwvQWRkcmVzc2FibGVBc3NldHNNaWdyYXRpb25HdWlkZS5odG1s">Configure your project to use Addressables | Addressables | 1.21.14</span><br /><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MDExMDk3OTA=">Addressables 之远程内容分发</span><br /><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80OTkxNzI5MzM="> Addressables 之配置</span><br /><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vd2VjaGF0LW1pbmlnYW1lL21pbmlnYW1lLXVuaXR5LXdlYmdsLXRyYW5zZm9ybS9ibG9iL21haW4vRGVzaWduL1VzaW5nQWRkcmVzc2FibGUubWQ=">使用 Addressable Assets System 进行资源按需加载</span><br /><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81ODgxMjAwNTg="> Unity - Addressables 项目总结（一）：基础工作流</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;前两天公司其他同事在推荐让试一试 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRlZS5jb20vd2VjaGF0LW</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/categories/Unity3D/"/>
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/tags/Unity3D/"/>
    
    <category term="AssetBundle" scheme="https://wangjiaying.top/tags/AssetBundle/"/>
    
  </entry>
  
  <entry>
    <title>《.NET内存管理宝典》-笔记(2)</title>
    <link href="https://wangjiaying.top/2023/06/26/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-2/"/>
    <id>https://wangjiaying.top/2023/06/26/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-2/</id>
    <published>2023-06-26T02:23:19.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-底层内存管理"><a class="anchor" href="#第二章-底层内存管理">#</a> 第二章 底层内存管理</h1><h2 id="硬件"><a class="anchor" href="#硬件">#</a> 硬件</h2><ul><li>处理器 (CPU)：计算机的主单元，负责执行指令。包含算数逻辑单元 (ALU)、浮点单元 (FPU)、寄存器和指令来执行流水线 (负责高效执行被切分成一组更精简指令集的操作指令，并在可能的时候并行执行它们)</li><li>前端总线 (front side bus,fsb)：连接 CPU 和北桥的数据总线</li><li>北桥 (northbridge)：主要包含内存控制单元，负责控制内存和 CPU 之间的数据通信</li><li>RAM (随机存取存储器)：也叫易失性存储器</li><li>内存总线 (memory bus)：连接 RAM 和北桥的数据总线</li><li>南桥 (southbridge)：处理计算机所有 I/O 功能的芯片</li><li>存储 I/O：存储数据的永久性存储器</li></ul><p><img data-src="/blogimages/2023/2023-06-26/-430140174.jpeg" alt="-430140174.jpeg" /></p><p>注：现代计算机架构北桥芯片被内至于 cpu 中，由于内存控制器与 cpu 执行单元距离更近，降低了整体通信延迟</p><p><img data-src="/blogimages/2023/2023-06-26/313265336.jpeg" alt="313265336.jpeg" /></p><p>内存管理背后的主要问题是当今 cpu 的强大处理能力与内存和大容量存储子系统之间的不匹配</p><ul><li>当处理器需要访问内存时，都会导致额外的延迟</li><li>当 cpu 需要停下来等待对内存数据的访问 (无论写入或读取) 完成时，称之为停顿。停顿越多，cpu 利用率就越低</li></ul><p>目前主流内存的内部时钟频率非常低，依靠多种技巧提升频率。内存模块由内部存储单元和附加缓冲器组成，后者用于协助突破内部低时钟频率的限制。</p><ul><li>单个时钟周期内，从内部存储器单元发送两次数据：准确是是在时钟信号的下降和上升周期分别发送一次数据。例如：双倍数据传输率 (double data rate，ddr)</li><li>在单个时钟周期内，使用内部缓冲一次进行多次读取</li></ul><p>即使 DDR 内存已经应用了各种优化手段，但 CPU 的速度仍然比内存快。为克服这个问题，在不同层面都引入了一个相似方法：将一部分数据放到性能更好 (同时更昂贵) 的存储器中，即称为缓存。</p><h3 id="内存"><a class="anchor" href="#内存">#</a> 内存</h3><p>目前存在两种主要内存类型：</p><ul><li>静态随机存取存储器 (static random access memory，SRAM)：具备极高的访问速度但工艺复杂，占用面积大，每个存储单元由 6 个晶体管组成 (用于存储单个比特)。只要保持通电数据就可以一直保存，无需刷新。主要用于 cpu 缓存。</li><li>动态随机存取存储器 (dynamic random access memory，DRAM)：存储单元的结构简单很多 (比 SRAM 小很多)，由单个晶体管和电容器组成。<ul><li>由于电容会漏电，一个存储单元需要不断地刷新其自身保存的数据 (这将耗时宝贵的几豪秒并拖慢读取内存速度)。</li><li>从电容器读取的信号还需要被放大，导致整个过程更为复杂</li><li>由于电容器本身存在延迟，数据的读取和写入也需要额外耗时，且耗时时长并非线性 (需要等待一段时间以确保数据的正确读取和成功写入)</li></ul></li></ul><p>芯片面积和工艺决定芯片价格，同容量的 SRAM 价格更贵<br />我们计算机安装的内存，即 DRAM 为了减少成本，是进行行列地址复用的 (芯片引脚数不够)，通常寻址结构如下：</p><p><img data-src="/blogimages/2023/2023-06-26/484749549.jpeg" alt="484749549.jpeg" /></p><p>从一个指定单元读取 1 比特数据过程：</p><ul><li>将行号放在地址线上</li><li>行地址选通 (row address strobe，RAS) 信号在行地址线上触发对行地址的解码</li><li>将列号放在地址线上</li><li>列地址选通 (column address strobe，CAS) 信号在列地址线上触发对列地址的解码</li><li>读取 1 比特数据 (定位到特定的 DRAM 单元)</li></ul><p>上述每个步骤切换时长<br />对内存性能有巨大影响，比如内存延时标识如 DDR3-9-9-9-24：</p><ul><li>tCL (CAS)：列地址选通和起始应答 (获得数据) 之间的时长</li><li>tRCD (RAS 到 CAS 的延迟)：之间可能导致的最短延迟时长</li><li>tRP (行预冲)：访问一行之前，对它进行预冲 (precharge) 所花费的时长。使用一行之前必须先对它进行预冲。</li><li>tRAS (行激活延迟)：激活一行以访问其信息的最短时长。这个时长通常至少是上面 3 个时长之和。</li></ul><p>若已经设置了需要访问的行和列，其所在位置数据几乎可以被即时读取。</p><ul><li>如果需要更改读取列，将花费 tCL 个时钟周期。</li><li>如果想要更改读取行，情况会更糟：必须先预冲 (tRP 个周期)，然后再经历 RAS 和 CAS 所导致的延迟 (tCL 和 tRCD 个周期)</li></ul><p>DRAM 存储器架构和它的延迟时长对于内存管理的影响：</p><ul><li>更改访问的行是耗时最长的操作，它包含了 RAS 信号、预冲等带来的延迟</li><li>因此内存循序访问模式远快于非循序访问模式</li></ul><p>注：尽量避免对内存的非循序访问。</p><h3 id="cpu"><a class="anchor" href="#cpu">#</a> CPU</h3><p>cpu 运行机制中的一个核心角色是寄存器，因为当前所有计算机都是以寄存器机器的形式实现的。</p><ul><li>cpu 操作数据时，访问寄存器是即时可得的，整个操作可以在一个处理器周期内完成，不存在任何形式延迟</li><li>寄存器是最靠近 cpu 的数据存储位置（当然，寄存器存储的是当前指令所需要的数据）</li></ul><h4 id="cpu-缓存"><a class="anchor" href="#cpu-缓存">#</a> CPU 缓存</h4><p>采用 SRAM 芯片，容量较小，但由于采用了高成本的方案，其速度可以与 CPU 匹敌或仅慢上一两个数量级<br />注：从 ISA (instruction set architecture)<br /> 的角度看，不管是程序员或操作系统，都不需要对它的运作进行任何管理。理想情况下应当仅是 cpu 的责任。</p><h4 id="缓存命中与未命中"><a class="anchor" href="#缓存命中与未命中">#</a> 缓存命中与未命中</h4><p>当处理器执行的指令需要访问内存 (不管是写操作还是读操作)，它首先查看缓存，检查需要的数据是否已经位于缓存中。</p><ul><li>如果存在，则可以以极快速度获取数据，即为缓存命中</li><li>若不存在，即为缓存未命中，处理器就需要从内存中读取数据，再将数据放到缓存</li></ul><h4 id="数据的局部性data-locality"><a class="anchor" href="#数据的局部性data-locality">#</a> 数据的局部性 (data locality)</h4><p>缓存的理念基于一个重要概念：数据局部性</p><ul><li>时间局部性：如果访问了一些内存区域，那么很可能很快还需要重复访问</li><li>空间局部性：如果访问了一些内存区域，那么临近区域很可能也会访问到</li></ul><p>缓存是一把双刃剑，如果我们写出的程序破坏了数据局部性，缓存反而会带来不必要的负担。</p><h4 id="缓存的实现"><a class="anchor" href="#缓存的实现">#</a> 缓存的实现</h4><p>缓存行 (cache line)：在内存与缓存之间传输数据时，以此数据块进行。其具有固定大小，在当今计算机中，大小都是 64 字节。<br />注意：不能从内存中读出或写入小于 cache line 大小 (64 字节) 的数据。即使从内存读取 1 比特也会一次性读取出整个 64 字节大小的一块数据。</p><ul><li>设计目的是为了更好地遵循 DRAM 访问 (预冲、RAS 延迟)</li></ul><p>由于对 DRAM 访问是以 64 位 (8 字节) 为单位，因此填充一个 cache line 需要与内存进行 8 次数据传输。</p><ul><li>由于 8 次传输需要花费相当多 cpu 周期时间，因此发展出一些优化，如：关键词优先和提前重启动 (critical word first &amp; early restart)，首先读取最需要的字并执行，cache line 剩余部分异步填充</li></ul><p>注：缓存修改分为直写和回写策略<br />另外注意：<br /><img data-src="/blogimages/2023/2023-06-26/-493473709.jpeg" alt="-493473709.jpeg" /></p><p>如对二维数组进行逐行索引和逐列索引的差异</p><h4 id="数据对齐"><a class="anchor" href="#数据对齐">#</a> 数据对齐</h4><p>对齐的意思是指数据的起始地址是给定对齐方式 (指定为 N 字节) 的整数倍。一个数据结构的对齐方式取决于它的字段的对齐方式。<br />未对齐数据访问速度相比已对齐数据慢很多，对于 CLR 数据结构，数据布局由运行时自身进行管理。</p><h4 id="非时态访问non-temporal-access"><a class="anchor" href="#非时态访问non-temporal-access">#</a> 非时态访问 (non-temporal access)</h4><p>在大多数常见 cpu 中，不能绕过缓存去直接访问内存，cpu 对 DRAM 的所有内存读取和写入操作，都存储于缓存中。<br />假设想要初始化一个大数组，但并非立即使用，正常情况下：</p><ul><li>数组将分块以 cache line 为单位依次被写入</li><li>每次写入操作都包含 3 个步骤：将 cache line 读入缓存；修改缓存内容；将 cache line 写回主内存</li><li>仅仅为了把数据写回主内存就需要填充 cache line，且会抢占本来可以用于其它程序的缓存</li></ul><p>可以通过一种称为非时态访问的汇编指令避免上述所说的缓存占用，指令包括：MOVNTI/MOVNTQ/MOVNTDQ 等，可以让程序员向内存写入数据时避免把数据加载到缓存中。<br />注：C# 可以通过 P/Invokes 调用 _mm_stream_si128</p><h4 id="预取"><a class="anchor" href="#预取">#</a> 预取</h4><p>数据局部性是让缓存自动起作用的特性 (只要程序员不破坏数据局部性就行)<br /> 不过还有另一种提高缓存利用率的机制：将短期之内可能用到的数据提前填充到缓存，因此称之为预取。</p><ul><li>硬件驱动：当 cpu 注意到一些缓存未命中的情况存在某些特定模式时触发。</li><li>软件驱动：在代码中通过 C/C++ 的 _mm_prefetch () 函数调用 PREFETCH0 指令显式触发</li></ul><p>与其它所有缓存机制类似，预取也是一把双刃剑。<br />如果在内存中不以正确的方法排列数据，预取和基于 cache line 访问内存等特性对性能显然起不到多大正面作用。<br />内存不仅是一块平坦的空间，如果我们总是从这里读取 1 字节，从那里读取 1 字节，就必然会承受相应的代价。</p><h4 id="分层缓存"><a class="anchor" href="#分层缓存">#</a> 分层缓存</h4><p>对于 cpu 架构，一方面我们需要高性能，另一方面又希望成本可控。因此都引入了一种更复杂的分层缓存设计。</p><p><img data-src="/blogimages/2023/2023-06-26/82046390.jpeg" alt="82046390.jpeg" /></p><p>一级缓存：被分为两个独立部分，一个用于数据，一个用于指令<br />二级、三级缓存：指令和数据被同等对待</p><p><img data-src="/blogimages/2023/2023-06-26/193791621.jpeg" alt="193791621.jpeg" /></p><h4 id="多核分层缓存"><a class="anchor" href="#多核分层缓存">#</a> 多核分层缓存</h4><p>cpu 每个核心都有独占的一级、二级缓存，并共享同一个三级缓存。<br />每个核都有自己的一级和二级缓存，只有三级缓存共享，这种架构导致引入了一个复杂概念：缓存一致性</p><ul><li>该机制用于维护数据一致性，通过缓存一致性协议 (一种将数据变化告知各个核的方法) 实现</li><li>存在许多高级的缓存一致性协议以及扩展，如流行的 MESI（modified、exclusive、shared、invalid）</li></ul><p>缓存一致性协议可以导致产生很大的内存通信流量，从而严重影响程序总体性能。</p><ul><li>因此编写代码应尽量避免从不同的核去访问相同的 cache line 下内存地址，最好完全避免跨线程通信</li></ul><p>伪共享：位于一个 cache line 中且理论上未被修改的数据，由于受到其它线程的影响而导致其不断变为无效状态。</p><p><img data-src="/blogimages/2023/2023-06-26/1855023160.jpeg" alt="1855023160.jpeg" /></p><h2 id="操作系统"><a class="anchor" href="#操作系统">#</a> 操作系统</h2><h3 id="虚拟内存"><a class="anchor" href="#虚拟内存">#</a> 虚拟内存</h3><p>每个程序直接管理真实物理地址非常麻烦和危险 (如避免干扰其它程序)，为此引入了该概念：</p><ul><li>将内存管理逻辑从程序转移到操作系统，并向程序提供虚拟地址空间。</li><li>这意味着每个进程都认为它上系统中运行着的唯一一个进程，所有内存都为自己所用。</li><li>而且由于地址空间是虚拟的，因此甚至可以大过实际物理内存大小 (扩展内存)。</li></ul><p>内存管理程序两个主要职责：</p><ul><li>将虚拟地址空间映射到物理内存：32 位、64 位计算机分别使用对应位长的虚拟地址。（目前 64 位通常使用低 48 位，可以支持最大 128TB 内存寻址）</li><li>将一些此时不需要的内存区域从 DRAM 转移到硬盘 (page file、swap file)</li></ul><p>虚拟内存在 cpu 中通过内存管理单元 (memory management unit，MMU) 执行并与操作系统协同工作。<br />每个进程都有一个由操作系统维护的 page 目录，作用是将一个虚拟地址映射到物理地址：page 目录中的一个条目指向一个 page 的物理起始地址等信息，典型的 page 大小是 4KB。<br />虚拟地址向物理地址转换需要遍历一个 tree 结构完成，会有开销，因此引入了将转换结果缓存的组件：translation look-aside buffers (TLB)</p><ul><li>类似键值对 map 结构，未命中才会执行一次代价高昂的 full-page 目录遍历</li></ul><h3 id="large-page"><a class="anchor" href="#large-page">#</a> Large Page</h3><p>虚拟地址转换成本可能较高，可以使用较大的 page，由于同一个 page 可以容纳许多地址，TLB 缓存转换结果后，地址转换需求就变少了（但大 page 同样会浪费资源）</p><h3 id="通用内存布局"><a class="anchor" href="#通用内存布局">#</a> 通用内存布局</h3><p><img data-src="/blogimages/2023/2023-06-26/-1670233885.jpeg" alt="-1670233885.jpeg" /></p><p>虚拟地址空间被划分为两个部分：</p><ul><li>内核空间：高位地址空间被操作系统占用</li><li>用户空间：低位地址空间被分配给进程</li></ul><p>注：看起来 stack 和 heap 最终似乎有可能碰到一起，但因为两者大小都是受限的，因此永远不会发生。<br />内存段：</p><ul><li>数据段：包含已初始化和未初始化的全局变量和静态变量</li><li>text 段：包含应用程序二进制和字符串文本 (根据定义，只包含只读数据)</li></ul><h3 id="windows-内存管理"><a class="anchor" href="#windows-内存管理">#</a> Windows 内存管理</h3><p>当 Windows 为一个进程保留内存区域时，将遵循如下限制：</p><ul><li>内存区域的起始地址和大小，都必须是系统 page 大小（通常 4KB）和分配粒度（通常 64KB）的整数倍，否则若试图分配小于粒度的内存空间，剩余部分将被标记为不可用。</li><li>因此为避免浪费，应使用合适的对齐方式和大小使用内存块</li></ul><p>既然 page 大小是 4KB，为何分配粒度是 64KB？</p><ul><li>历史原因导致</li></ul><h3 id="windows-内存布局"><a class="anchor" href="#windows-内存布局">#</a> Windows 内存布局</h3><p><img data-src="/blogimages/2023/2023-06-26/197102419.jpeg" alt="197102419.jpeg" /></p><p>.Net 中默认栈大小：</p><ul><li>典型 32 位：1MB</li><li>典型 64 位：4MB</li></ul><p>注 1：Windows 上初始线程栈大小取自可执行文件标头，因此也可通过修改 .Net 可执行二进制文件标头修改<br />注 2：出于安全考虑，系统引入了一种地址空间布局随机化 (address space layout randomization,ASLR) 的机制，因此上图并不能代表内存中真正的布局</p><h3 id="linux-内存管理"><a class="anchor" href="#linux-内存管理">#</a> Linux 内存管理</h3><p>由于 Linux 使用了相同硬件技术，包括 page、MMU 和 TLB，因此前面已涵盖大部分知识。</p><ul><li>例如 64 位系统依然是 48 位寻址</li><li>（注：查了下为什么不是 64 位，据说是因为会增加系统复杂度和地址转换成本，而且现目前几乎不可能用得到，因此先仅保留使用 48 位）</li></ul><p>当在 Linux 上分配内存时，并不会立即分配物理资源，直到访问该特定的内存区域时才会分配 —— 称为惰性分配机制，类似 Windows 保留机制类似。<br />注：Windows 的内存分配粒度是 64KB，而 Linux 分配内存只需按照 page 大小，即 4KB</p><h3 id="linux-内存布局"><a class="anchor" href="#linux-内存布局">#</a> Linux 内存布局</h3><p><img data-src="/blogimages/2023/2023-06-26/1884609898.jpeg" alt="1884609898.jpeg" /></p><p>Linux 处理线程栈与 Windows 有显著差别，Linux 没有两步 (two-stage) 内存保留机制，Linux 进程的栈按照需要进行扩展，不会提前保留相应内存 page</p><ul><li>由于下一个 page 按需创建，因此线程栈不会位于连续内存区域</li></ul><h2 id="numa-和-cpu-组"><a class="anchor" href="#numa-和-cpu-组">#</a> NUMA 和 CPU 组</h2><p>对称多处理器 (symmetric multiprocessing,SMP)：装备了多个独立 cpu 的计算机<br /> NUMA（non-uniform memory architecture, 非统一内存访问）：因为在 cpu 之间共享数据会存在明显延迟，因此从性能角度看，并非所有共享内存都是一样的，软件应感知到 numa 存在并选择位于本地而非更远的内存。</p><h2 id="本章总结"><a class="anchor" href="#本章总结">#</a> 本章总结</h2><p>避免随机访问，拥抱循序访问</p><ul><li>注：随机访问不仅指完全随机，也指没有使用一种可预测的模式进行有序访问</li></ul><p>提高时间和空间数据局部性</p><ul><li>有时，只需要确保数据结构足够小、预先分配并重复使用就可以保证</li></ul><p>不要放弃使用更高技巧的可能性</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>说来惭愧，端午节还额外请了两天假，结果待在家里竟然... 又玩起《三国志幻想大陆》了...<br /> 这游戏几年前就玩过，这次都到三周年庆了，记得跟原神好像是同一年出的？</p><p>因此这个假期，最终也只把这本书的第二章... 结尾看完了 (之前就看了大半的)。</p><hr /><p>所以， <code>人类不能高估自己的自制力，最好的克制方式就是：不听、不思、不闻</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-底层内存管理&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#第二章-底层内存管理&quot;&gt;#&lt;/a&gt; 第二章 底层内存管理&lt;/h1&gt;
&lt;h2 id=&quot;硬件&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#硬件&quot;&gt;#&lt;/a&gt; 硬件&lt;/h2&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Assets、Resources 和 AssetBundles-翻译-笔记</title>
    <link href="https://wangjiaying.top/2023/06/16/Unity3DAssets-ResourcesAndAssetBundles-%E7%AC%94%E8%AE%B0/"/>
    <id>https://wangjiaying.top/2023/06/16/Unity3DAssets-ResourcesAndAssetBundles-%E7%AC%94%E8%AE%B0/</id>
    <published>2023-06-16T08:23:25.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>最开始是因为项目的一个问题：微信的 Unity 转小游戏，转出来的  <code>XXXX.webgl.data.unityweb.bin.txt(首包资源文件)</code>  文件极大，其中占据数量最多的是一系列的  <code>MonoScript</code> ，且经过对比检查，其它占用够大的 Shader、图片或冗余资源都被我一一处理过了，但是呢这个文件依然很大。</p><p>达到什么程度呢？公司其它项目转出来只有 7M，而我们的达到了 16M？！这正常吗？不正常吧！</p><p>最麻烦的一点是：经过  <code>AssetStudio</code>  打开看之后，排头的只有寥寥几个资源，而且都不算大：</p><p><img data-src="/blogimages/2023/2023-06-16/Snipaste_2023-06-16_16-29-42.jpg" alt="" /></p><p>与只有  <code>7M</code>  资源的对比， <code>AssetStudio</code>  列出的文件基本上也是一样的。</p><p>于是去查找信息，结果找到 <span class="exturl" data-url="aHR0cHM6Ly9nd2IudGVuY2VudC5jb20vY29tbXVuaXR5L2RldGFpbC8xMjUwMjc=">Unity 资源管理 - 资源（Assets）、对象（Objects）和序列化 - 腾讯游戏学堂</span> ，然后又顺着其贴的原始文档找到了：  <span class="exturl" data-url="aHR0cHM6Ly9sZWFybi51bml0eS5jb20vdHV0b3JpYWwvYXNzZXRzLXJlc291cmNlcy1hbmQtYXNzZXRidW5kbGVz">Assets, Resources and AssetBundles - Unity Learn</span> 文章，这篇文章看着算是官方对 Unity 的资源系统的一个比较详细的描述了，有点熟悉..... 以前是不是见过？曾经好像零零散散在某些文章看到过，但是并不齐全，于是这次就整体过了一遍。</p><p>注：本文也并不是全文翻译，而是取自己觉得重要、或都知道什么情况的知识点就暂且忽略了 (如 AssetBundle 依赖管理)。</p><p>(当然截止本文完成的时候，依然没有找出资源大小的具体原因，打算后续把  <code>AssetStudio</code>  源码拉下来调试一下，看是不是有什么隐藏资源)</p><h1 id="资源与序列化"><a class="anchor" href="#资源与序列化">#</a> 资源与序列化</h1><h2 id="assets-and-objects"><a class="anchor" href="#assets-and-objects">#</a> Assets and Objects</h2><p>Asset：指的是一个存在于磁盘上的资源文件<br /> UnityEngine.Objects：一组序列化数据，共同描述资源的特定实例<br />大多数 Object  类型都是内置类型，除了两个例外：</p><ul><li>ScriptableObject：提供一个方便的自定义数据类型的系统，这些类型可以由 Unity 自动序列化和反序列化，并在 Unity 编辑器窗口中进行操作。</li><li>MonoBehaviour：提供对 MonoScript 引用的包装，MonoScript 是 Unity 用于保存对特定程序集和命名空间中特定脚本类的引用的内部数据类型</li></ul><p>Assets 和 Objects 之间是一对多的关系：任何给定的资产文件都包含一个或多个对象。</p><h2 id="标识与引用"><a class="anchor" href="#标识与引用">#</a> 标识与引用</h2><p>所有 UnityEngine.Objects 都可以引用其他 UnityEngine.Objects，被引用的 Object 可能在同一个 Asset 文件中，也可能在导入的其它 Asset 文件中</p><ul><li>在序列化后，这些引用由两部分独立的数据组成：FileGUID (标识资源位置) 和 LocalID (标识资源中的对象 [Object])<ul><li>FileGUID 存储在 .meta 文件中</li><li>FileGUID 提供了文件特定位置的抽象，只要特定文件 GUID 可以与特定文件相关联，该文件在磁盘上的位置就变得无关紧要。该文件可以自由移动，而无需更新引用该文件的所有对象。<ul><li>由于任何给定的资产文件可能包含（或通过导入生成）多个 UnityEngine.Object 资源，因此需要 LocalID 来明确区分每个不同的对象。</li></ul></li><li>Unity 编辑器将文件路径和 FileGUID 进行映射，每当加载或导入 Asset 时，都会记录一个映射条目。</li></ul></li><li>注：如果 .meta 文件在 Unity 编辑器关闭时丢失，或者 Asset 的路径发生变化而 .meta 文件没有随 Asset 一起移动，那么对该 Asset 中对象的所有引用都将被破坏。</li></ul><p>尽管 FileGUID 和 LocalID 足够稳健，但 GUID 比较速度较慢</p><ul><li>因此 Unity 在内部维护了一份缓存（PersistentManager），它将 FileGUID 和 LocalID 转换成简单的、会话唯一（Session-unique）的整数：这些整数被称为 InstanceID，当有新的对象注册到缓存时，InstanceID 以简单的、单调递增的顺序分配</li><li>在启动时，游戏会立即初始化包含所有被项目需要的对象 (例如在内置场景中引用)、以及 Resources 文件夹中包含的所有对象的 InstanceID 缓存<ul><li>当在运行时创建新资源 (如 new Texture2D) 以及从 AssetBundle 加载对象时，新的条目也将添加到缓存中</li><li>在提供具体 FileGUID 和 LocalID 的 AssetBundle 被卸载时，会从缓存中移除 InstanceID 条目。这时原来的 InstanceID、FileGUID 和 LocalID 会被删除，如果再次加载了这个 AssetBundle，则会重新生成新的 InstanceID</li><li>注：当应用程序暂停时，可能从 iOS 上的图形内存中卸载图形资源，如果这些对象来源于已卸载的 AssetBundle，Unity 将无法重新加载对象的源数据。对这些对象的任何现有引用也将无效</li></ul></li><li>注：当构建项目时，FileGUID 和 LocalID 会被确定性地映射到更简单的格式 (这也是不能在运行时查询  Asset 的 FileGUID 的原因)，但概念仍然是相同的</li></ul><h1 id="monoscript"><a class="anchor" href="#monoscript">#</a> MonoScript</h1><p>其重点是 MonoBehaviour 引用 MonoScript (MonoBehaviour 就是 MonoScript 的包装器)，而 MonoScripts 只包含定位特定脚本类所需的信息，两种类型的对象都不包含脚本类的可执行代码。</p><ul><li>MonoScript 包含三个字符串：程序集名称、类名称和命名空间。</li></ul><p>当构建项目时，Unity 将 Assets 文件夹中所有松散的脚本文件编译成 Mono 程序集 (它们也是 MonoScript 引用的程序集)</p><ul><li>Plugins 子文件夹外的 C# 脚本被放入 Assembly-CSharp.dll</li><li>Plugins 子文件夹中的脚本被放入 Assembly-CSharp-firstpass.dll</li><li>注：还可以自定义程序集</li></ul><p>与其他资源不同，Unity 应用程序中包含的所有程序集都在应用程序启动时加载<br />这允许不同的 MonoBehaviours 引用特定的共享类，即使 MonoBehaviours 在不同的 AssetBundle 中。</p><h1 id="资源加载"><a class="anchor" href="#资源加载">#</a> 资源加载</h1><h2 id="加载方式"><a class="anchor" href="#加载方式">#</a> 加载方式</h2><p>在以下情况下会自动加载对象：</p><ul><li>映射到该对象的 InstanceID 被间接引用</li><li>该对象当前未加载到内存中</li><li>可以定位 (找到) 对象的源数据</li></ul><p>对象也可以在代码中显式加载，比如直接代码创建或调用资源加载 API (例如 AssetBundle.LoadAsset)<br /> 加载一个对象时，Unity 会尝试通过由每个被引用对象的 FileGUID 和 LocalID 转换而成的 InstanceID 来解析任何引用。<br />对象被间接引用而导致按需加载的条件：</p><ul><li>InstanceID 引用当前未加载的对象</li><li>InstanceID 具有在缓存中注册的有效 FileGUID 和 LocalID</li></ul><p>注 1：可以通过调用 Resources.UnloadAsset API 显式卸载来自 Resources 文件夹的对象，不过这些对象的 InstanceID 仍然有效，并且仍将包含有效的 FileGUID 和 LocalID 条目，只要被任何活动对象间接引用时，就会重新加载该对象<br />注 2：注意任何标有 HideFlags.DontUnloadUnusedAsset 和 HideFlags.HideAndDontSave 的东西都不会被卸载</p><h2 id="大资源加载消耗"><a class="anchor" href="#大资源加载消耗">#</a> 大资源加载消耗</h2><p>创建任何 GameObject 层次结构时，CPU 时间主要花费在以下几种方式上：</p><ul><li>读取源数据（从存储、AssetBundle、另一个 GameObject 等）</li><li>设置新 Transform 之间的父子关系</li><li>实例化新的游戏对象和组件</li><li>在主线程上唤醒新的游戏对象和组件</li></ul><p>后三种时间成本通常是不变的，无论层次结构是从现有层次结构中克隆还是从存储中加载。然而，读取源数据的时间随着序列化到层次结构中的组件和游戏对象的数量线性增加，并且还乘以数据源的速度。</p><ul><li>在所有当前平台上，从内存中的其他位置读取数据比从存储设备加载数据要快得多，加载操作的成本与存储 I/O 时间有关。</li></ul><p>如前所述，在序列化单体预制件时，每个 GameObject 和组件的数据都是单独序列化的，这可能会重复数据。</p><ul><li>例如，具有 30 个相同元素的 UI 屏幕会将相同元素序列化 30 次，从而产生大量二进制数据。</li><li>在加载时，必须从磁盘读取这 30 个重复元素中每一个的所有游戏对象和组件的数据，然后再传输到新实例化的对象。此文件读取时间是实例化大型预制件的总成本的主要消耗。</li><li>因此，大型层次结构对象应该在模块化中实例化，然后在运行时结合在一起。</li></ul><p>注：在实例化一个立即会重新设置为另一个对象子节点的新游戏对象时，请使用接受父对象参数的 GameObject.Instantiate 重载变体。使用此重载可避免为新游戏对象分配根变换层次结构。在测试中，这将实例化操作所需的时间加快了大约 5-10%。</p><h1 id="resources-目录"><a class="anchor" href="#resources-目录">#</a> Resources 目录</h1><p><strong>不要使用</strong><br />缺点很明显：</p><ul><li>使用 Resources 文件夹使细粒度的内存管理更加困难</li><li>资源文件夹使用不当会增加应用程序启动时间和构建时间</li><li>Resources 系统降低了项目向特定平台交付自定义内容的能力，并消除了增量内容升级的可能性<ul><li>AssetBundle Variants 可以用于根据每个设备调整内容</li></ul></li></ul><p>总之，官方是非常不推荐使用的，也许快速原型阶段可以使用，但当项目进入全面生产阶段时，应取消使用 Resources 文件夹<br />构建项目时，所有名为 Resources 的文件夹中的资源和对象都合并到一个序列化文件中。该文件还包含元数据和索引信息，类似于 AssetBundle。如 AssetBundle 文档中所述，该索引包括一个序列化查找树，用于将给定对象的名称解析为其适当的 FileGUID 和 LocalID。它还用于在序列化文件主体中的特定字节偏移处定位对象。</p><ul><li>在应用程序启动时，也会进行 Resources 资源数据结构的构建</li><li>在大多数平台上，查找数据结构是一个平衡的搜索树，其构建时间以 O (n log (n)) 的速度增长。随着资源文件夹中对象数量的增加，这种增长也会导致索引的加载时间以超线性方式增长。</li></ul><h1 id="assetbundle"><a class="anchor" href="#assetbundle">#</a> AssetBundle</h1><p>AssetBundle 由两部分组成：标头和数据段<br />标头</p><ul><li>包含有关 AssetBundle 的信息，例如其标识符、压缩类型和清单。清单是一个以对象名称为关键字的查找表。每个条目都提供一个字节索引，指示在 AssetBundle 的数据段中可以找到给定对象的位置。在大多数平台上，此查找表被实现为平衡搜索树。具体来说，Windows 和 OSX 衍生平台（包括 iOS）采用红黑树。因此，随着 AssetBundle 中资产数量的增长，构建清单所需的时间将超过线性增长。</li></ul><p>数据段</p><ul><li>数据段包含序列化 AssetBundle 中的 Assets 生成的原始数据。如果将 LZMA 指定为压缩方案，则会压缩所有序列化资产的完整字节数组。如果改为指定 LZ4，则单独压缩单独资产的字节。如果不使用压缩，数据段将保持为原始字节流。</li></ul><p>通常，Unity 会缓存一份 AssetBundle 的解压副本，以提高后续对同一个 AssetBundle 的加载请求的加载性能。</p><h2 id="加载-assetbundle-方式"><a class="anchor" href="#加载-assetbundle-方式">#</a> 加载 AssetBundle 方式</h2><h3 id="assetbundleloadfrommemoryasync"><a class="anchor" href="#assetbundleloadfrommemoryasync">#</a> AssetBundle.LoadFromMemory(Async)</h3><p>建议是不要使用这个 API</p><ul><li>这个 API 会从托管代码字节数组（C# 中的 byte []）加载 AssetBundle。它总是将源数据从托管代码字节数组复制到新分配的、连续的本机内存块中。如果 AssetBundle 是 LZMA 压缩的，它会在复制时解压 AssetBundle。未压缩和 LZ4 压缩的 AssetBundle 将被逐字复制。</li></ul><p>此 API 消耗的内存峰值量将至少是 AssetBundle 大小的两倍：一份在 API 创建的本机内存中，一份在传递给 API 的托管字节数组中。</p><ul><li>因此，从通过此 API 创建的 AssetBundle 加载的资源将在内存中复制三次：一次在托管代码字节数组中，一次在 AssetBundle 的本机内存副本中，第三次在资源本身的 GPU 或系统内存中</li></ul><h3 id="assetbundleloadfromfileasync"><a class="anchor" href="#assetbundleloadfromfileasync">#</a> AssetBundle.LoadFromFile(Async)</h3><p>这是一个高效的 API，用于从本地存储（如硬盘或 SD 卡）加载 AssetBundle。</p><ul><li>在桌面、控制台和移动平台上，API 只会加载 AssetBundle 的标头，剩余数据依然保留在磁盘上。<ul><li>AssetBundle 的对象将在调用加载方法（例如 AssetBundle.Load）或取消引用它们的 InstanceID 时按需加载。在这种情况下不会消耗过多的内存。</li></ul></li><li>在 Unity Editor 中，API 会将整个 AssetBundle 加载到内存中，就像从磁盘读取字节并使用 AssetBundle.LoadFromMemoryAsync 一样。如果在 Unity 编辑器中分析项目，此 API 可能会导致在 AssetBundle 加载期间出现内存峰值。这不影响真机性能，在采取修复措施之前应在真机设备上重新测试这些内存峰值情况。</li></ul><h3 id="unitywebrequestgetassetbundle"><a class="anchor" href="#unitywebrequestgetassetbundle">#</a> UnityWebRequest.GetAssetBundle</h3><p>这个 API 会使用工作线程，将下载的数据流式传输到固定大小的缓冲区，然后将缓冲的数据保存到临时存储或 AssetBundle 缓存，具体取决于下载处理程序的配置方式。</p><ul><li>所有这些操作都发生在本机代码中，从而消除了扩展托管堆的风险。</li><li>此外，此下载处理程序不会保留所有下载字节的本机代码副本，从而进一步减少了下载 AssetBundle 的内存开销</li></ul><p>注：LZMA 压缩的 AssetBundle 将在下载期间解压缩并使用 LZ4 压缩进行缓存。可以通过设置 Caching.CompressionEnabled 来更改此行为。</p><ul><li>如果缓存已满，Unity 将从缓存中删除最近最少使用的 AssetBundle</li><li>注：缓存系统中的 AssetBundle 仅由文件名标识 (而不是下载的完整 URL)</li></ul><p>下载完成后，AssetBundle 属性提供的对下载的 AssetBundle 的访问，与已在下载的 AssetBundle 上调用 AssetBundle.LoadFromFile 一样。</p><ul><li>如果向 UnityWebRequest 对象提供缓存信息，并且请求的 AssetBundle 已存在于 Unity 的缓存中，则此 API 的操作与 AssetBundle.LoadFromFile 相同。</li></ul><p>注 1：请确保下载程序代码在加载 AssetBundle 后正确调用 Dispose (或使用 using 语句)<br /> 注 2：更多缓存机制详情参考原文缓存机制部分<br />注 3：官方推荐若想自己实现细粒度资源下载管理，使用 C# HttpWebRequest 或自定义本机代码，官方强烈建议使用 Application.persistentDataPath 作为持久存储位置</p><h3 id="wwwloadfromcacheordownload"><a class="anchor" href="#wwwloadfromcacheordownload">#</a> WWW.LoadFromCacheOrDownload</h3><p>从 Unity 2017.1 开始，这个 API 只是对 UnityWebRequest 的包装，以后可能会直接弃用。</p><h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3><p>总之，应尽可能使用 AssetBundle.LoadFromFile，这个 API 在速度、磁盘使用和运行时内存使用方面都是最有效的。<br />对于必须下载或修补 AssetBundles 的项目，建议使用 UnityWebRequest。<br />对于需要独特、特定缓存或下载要求的项目，可以考虑使用自定义下载器。任何自定义下载器都应该与 AssetBundle.LoadFromFile 兼容。</p><h2 id="加载-assetbundle-中的资源"><a class="anchor" href="#加载-assetbundle-中的资源">#</a> 加载 AssetBundle 中的资源</h2><p>可以使用三个不同的 API 从 AssetBundle 加载，这些 API 都属于 AssetBundle 对象的实例方法 (并且可选同步或异步)：</p><ul><li>LoadAsset (LoadAssetAsync)</li><li>LoadAllAssets (LoadAllAssetsAsync)</li><li>LoadAssetWithSubAssets (LoadAssetWithSubAssetsAsync)</li></ul><p>这些 API 的同步版本总是比异步版本快至少一帧。</p><ul><li>异步加载将每帧加载多个对象，直到它们达到时间片限制 (参考底层加载细节)。</li></ul><p>LoadAllAssets</p><ul><li>应该在加载多个独立的 UnityEngine.Objects 时使用。仅当需要加载 AssetBundle 中的大部分或所有对象时才应使用它。与其他两个 API 相比，LoadAllAssets 比多次单独调用 LoadAssets 稍微快一些。</li><li>因此，如果要加载的资源数量较多，但一次需要加载的 AssetBundle 不到 66%，可以考虑将 AssetBundle 拆分成多个更小的 bundle，使用 LoadAllAssets。</li></ul><p>LoadAssetWithSubAssets</p><ul><li>应该在加载包含多个嵌入式对象的复合资产时使用，例如带有嵌入式动画的 FBX 模型或其中嵌入了多个精灵的精灵图集。</li><li>如果需要加载的 Object 都来自同一个 Asset，但是和很多其他不相关的 Object 存储在一个 AssetBundle 中，那么就使用这个 API。</li></ul><p>对于任何其他情况，使用 LoadAsset 或 LoadAssetAsync</p><h2 id="底层加载细节"><a class="anchor" href="#底层加载细节">#</a> 底层加载细节</h2><p>UnityEngine.Object 加载是在主线程之外执行的：对象的数据使用工作线程从磁盘读取。</p><ul><li>任何不涉及 Unity 系统的线程敏感部分（脚本、图形）的内容都将在工作线程上进行转换。</li><li>例如，VBO 将从网格创建，纹理将被解压等。</li></ul><p>从 Unity 5.3 开始，对象加载已经并行化。多个对象在工作线程上被反序列化、处理和集成。当一个对象完成加载时，将调用其 Awake 回调，并且该对象将在下一帧期间可供 Unity 引擎的其余部分使用。<br />同步 AssetBundle.Load 方法将暂停主线程，直到对象加载完成。它们还将对对象加载进行时间切片，限制每帧的占用的总的加载时间不会超过超过一定毫秒数。毫秒数由属性 Application.backgroundLoadingPriority 设置：</p><ul><li>ThreadPriority.High：每帧最多 50 毫秒</li><li>ThreadPriority.Normal：每帧最多 10 毫秒</li><li>ThreadPriority.BelowNormal：每帧最多 4 毫秒</li><li>ThreadPriority.Low：每帧最多 2 毫秒</li></ul><p>假设所有其他因素都相同，资产加载 API 的异步版本将始终比对应同步版本花费更长的时间来完成，因为发出异步调用和对象对引擎可用之间的至少也有最小一帧的延迟。</p><h2 id="assetbundle-依赖"><a class="anchor" href="#assetbundle-依赖">#</a> AssetBundle 依赖</h2><p>根据运行时环境，可以使用两个 API 自动跟踪 AssetBundle 之间的依赖关系：</p><ul><li>在 UnityEditor 中，可以通过 AssetDatabase API 查询 AssetBundle 依赖项</li><li>在运行时，Unity 提供了一个可选的 API ：AssetBundleManifest，可以加载在 AssetBundle 构建期间生成的依赖信息。</li></ul><p>如之前的序列化和实例部分所述，AssetBundle 充当其中包含的每个对象的 FileGUID 和 LocalID 标识的源数据的来源。<br />因为一个对象是在它的 InstanceID 第一次被间接引用时加载的，并且在加载一个 AssetBundle 时其中对象会被分配一个有效的 InstanceID，因此加载 AssetBundle 的顺序并不重要。</p><ul><li>相反，重要的是在加载对象本身之前加载所有包含对象依赖项的 AssetBundle (但不必显式去加载依赖资源)。</li><li>注：Unity 不会尝试自动加载任何被依赖的 AssetBundle 包本身</li></ul><h2 id="assetbundle-manifests"><a class="anchor" href="#assetbundle-manifests">#</a> AssetBundle manifests</h2><p>当使用 BuildPipeline.BuildAssetBundles API 执行 AssetBundle 构建时，Unity 会序列化一个包含每个 AssetBundle 的依赖信息的对象。</p><ul><li>此数据存储在单独的，与构建 AssetBundle 的父目录同名的 AssetBundle 中，其中包含一个 AssetBundleManifest 类型的对象。</li><li>例如构建目的目录为：<ul><li><em>(projectroot)/build/Client/</em></li><li>则包含清单的 AssetBundle 将被保存为：<em>(projectroot)/build/Client/Client.manifest</em></li></ul></li></ul><p>包含清单的 AssetBundle 可以像任何其他 AssetBundle 一样加载、缓存和卸载：</p><ul><li>AssetBundle bundle =AssetBundle.LoadFromFile((projectroot)/build/Client/Client)</li><li>AssetBundleManifest manifest =bundle.LoadAsset<AssetBundleManifest>(&quot;AssetBundleManifest&quot;);</li></ul><p>AssetBundleManifest 对象本身提供了 GetAllAssetBundles API 来列出与清单同时构建的所有 AssetBundle，并提供两种方法来查询特定 AssetBundle 的依赖项：</p><ul><li>AssetBundleManifest.GetAllDependencies 返回 AssetBundle 的所有层次依赖关系，包括 AssetBundle 的直接子项、其子项的子项等的依赖项</li><li>AssetBundleManifest.GetDirectDependencies 仅返回 AssetBundle 的直接子级依赖</li></ul><p>注意：这两个 API 都分配字符串数组。因此它们应该被谨慎使用，而不是在应用程序生命周期的性能敏感部分使用。</p><h2 id="卸载-assetbundle-方式"><a class="anchor" href="#卸载-assetbundle-方式">#</a> 卸载 AssetBundle 方式</h2><p>切换场景 (即当 SceneManager.LoadScene 被非附加地调用时)</p><ul><li>将销毁当前场景中的所有对象并自动调用 Resources.UnloadUnusedAssets</li></ul><p>脚本调用 Resources.UnloadUnusedAssets 时</p><ul><li>此过程仅卸载未引用的对象：仅当没有 Mono 变量持有对对象的引用并且没有其他活动对象持有对对象的引用时，才会卸载对象</li></ul><p>调用 AssetBundle.Unload (true) API 时，源自 AssetBundle 的对象会自动并立即卸载</p><ul><li>这会使对象实例 ID 的文件 GUID 和本地 ID 无效，并且对已卸载对象的任何实时引用都将成为 Missing 引用</li><li>在 C# 脚本中，尝试访问已卸载对象的方法或属性将产生 NullReferenceException</li><li>如果调用 AssetBundle.Unload (false)--<em> 不推荐使用</em>，来自已卸载 AssetBundle 的活动对象将不会被销毁，但 Unity 将使其 FileGUID 和 LocalID 引用无效。如果稍后从内存中卸载这些对象并且对卸载对象的实时引用仍然存在，Unity 将不可能重新加载这些对象。</li></ul><p>注：当 Unity 失去对其图形上下文的控制时，对象在运行时会从显存中移除。这可能发生在移动应用程序暂停并且应用程序被迫进入后台时。在这种情况下，移动操作系统通常会从 GPU 内存中逐出所有图形资源。当应用程序返回前台时，Unity 必须在场景渲染恢复之前将所有需要的纹理、着色器和网格重新加载到 GPU (如果 AssetBundle 已经被卸载，就会导致问题)</p><h2 id="注意-安卓"><a class="anchor" href="#注意-安卓">#</a> 注意 - 安卓</h2><p>安卓平台：</p><ul><li>在 Android 上，StreamingAssets 文件夹中的资源存储在 APK 中，如果它们被压缩可能需要更多时间来加载，因为存储在 APK 中的文件可以使用不同的存储算法。</li><li>使用 7-zip 等归档程序打开 APK 可以确定文件是否被压缩，如果是则 AssetBundle.LoadFromFile 肯定执行得更慢，这种情况下可以使用 UnityWebRequest.GetAssetBundle 作为解决方法来检索缓存的版本。通过使用 UnityWebRequest，AssetBundle 将在第一次运行期间被解压缩和缓存，从而使后续执行速度更快。但是将占用更多存储空间，因为 AssetBundle 将被复制到缓存中。</li><li>或者可以编辑 build.gradle 文件并将该扩展名添加到 noCompress 部分，这样使用 AssetBundle.LoadFromFile () 也能无需消耗额外解压缩成本。</li></ul><h2 id="总结-2"><a class="anchor" href="#总结-2">#</a> 总结</h2><p>多数情况下，最好在玩家进入程序的性能关键区域（例如主游戏关卡或世界）之前加载尽可能多的所需对象。这在移动平台上尤为重要，因为在移动平台上访问本地存储很慢，并且在运行时加载和卸载对象的内存波动会触发 GC<br /> 使用 AssetBundle.LoadFromFile 加载资源并采用 AssetBundle.Unload (true) 释放资源。</p><h1 id="参考文档"><a class="anchor" href="#参考文档">#</a> 参考文档</h1><p><span class="exturl" data-url="aHR0cHM6Ly9nd2IudGVuY2VudC5jb20vY29tbXVuaXR5L2RldGFpbC8xMjUwMjc=">Unity 资源管理 - 资源（Assets）、对象（Objects）和序列化 - 腾讯游戏学堂</span><br /><span class="exturl" data-url="aHR0cHM6Ly9sZWFybi51bml0eS5jb20vdHV0b3JpYWwvYXNzZXRzLXJlc291cmNlcy1hbmQtYXNzZXRidW5kbGVz"> Assets, Resources and AssetBundles - Unity Learn</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;最开始是因为项目的一个问题：微信的 Unity 转小游戏，转出来的  &lt;code&gt;XXXX.webgl.data.unityweb.bin.txt(首包资源文件)&lt;</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/categories/Unity3D/"/>
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/tags/Unity3D/"/>
    
    <category term="性能优化" scheme="https://wangjiaying.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="翻译" scheme="https://wangjiaying.top/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
