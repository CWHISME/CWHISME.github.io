<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CWHISME</title>
  
  <subtitle>人不能没有梦想，也要有足够的敬畏</subtitle>
  <link href="https://wangjiaying.top/atom.xml" rel="self"/>
  
  <link href="https://wangjiaying.top/"/>
  <updated>2023-06-04T12:17:56.305Z</updated>
  <id>https://wangjiaying.top/</id>
  
  <author>
    <name>WangJiaYing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《数据结构与算法之美》-笔记</title>
    <link href="https://wangjiaying.top/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%AC%94%E8%AE%B0/"/>
    <id>https://wangjiaying.top/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%AC%94%E8%AE%B0/</id>
    <published>2023-06-04T11:57:25.000Z</published>
    <updated>2023-06-04T12:17:56.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>例行总结一下时间：</p><p><img data-src="/blogimages/2023/2023-06-04/Snipaste_2023-06-04_20-09-24.png" alt="" /></p><p>满打满算的话，怕是也花了一个月。主要是这本书涉及需要理性思考的更多，想不明白的话，就得多花点时间了。</p><p>加上这个月还插入了一些其它的东西，比如前几天的 <a href="/2023/05/28/%E6%B7%BB%E5%8A%A0%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%BB%9F%E8%AE%A1/" title="优化博客加载、添加文章统计等">优化博客加载、添加文章统计等</a> 之类的就花去了挺多时间。</p><p>本书我是非常推荐的，看完之后，对很多算法原理性的东西认识都更深了 <span class="spoiler" title="你知道得太多了！">(虽然现在又忘了不少了，所以才需要笔记呢，等我跟着笔记再复习下)</span></p><h1 id="第一章-复杂度分析"><a class="anchor" href="#第一章-复杂度分析">#</a> 第一章 复杂度分析</h1><h2 id="精确统计法事后统计法"><a class="anchor" href="#精确统计法事后统计法">#</a> 精确统计法（事后统计法）</h2><ul><li>运行一次代码，通过监控和统计手段得到算法执行的时间和占用内存大小</li><li>缺点<ul><li>测试结果受环境影响</li><li>测试结果受测试数据影响</li></ul></li></ul><h2 id="大-o-复杂度表示法"><a class="anchor" href="#大-o-复杂度表示法">#</a> 大 O 复杂度表示法</h2><ul><li>粗略估计算法执行效率</li></ul><h3 id="时间复杂度"><a class="anchor" href="#时间复杂度">#</a> 时间复杂度</h3><ul><li>表示算法执行时间与数据规模之间的增长关系（并不能度量在特定的数据规模下，代码执行的时间具体多少）</li><li>分析方法<ul><li>加法法则：代码总的复杂度等于量级最大的那段代码的复杂度</li><li>乘法法则：嵌套代码复杂度等于嵌套内外代码复杂度的乘积</li></ul></li><li>常见时间复杂度量级<ul><li>O (1)：常量级，代码执行时间不随数据规模 n 变化</li><li>O (n)：线性阶</li><li>O (n*n)：平方阶</li><li>O (logn)、O (nlogn)：对数阶时间复杂度</li><li>O (m+n)、O (mn)：复杂度由两个数据规模决定</li></ul></li><li>常见增长趋势排序：O (logn)-&gt;O (n)-&gt;O (nlogn)-&gt;O (n*n)</li></ul><h3 id="空间复杂度"><a class="anchor" href="#空间复杂度">#</a> 空间复杂度</h3><ul><li>表示算法存储空间与数据规模之间的增长关系</li><li>常见量级与时间复杂度一样</li><li>注：代码空间复杂度指的是除原本的数据存储空间外，算法运行过程中需要额外申请的存储空间</li></ul><h3 id="其它"><a class="anchor" href="#其它">#</a> 其它</h3><ul><li>最好时间复杂度</li><li>最坏时间复杂度</li><li>平均时间复杂度</li><li>均摊时间复杂度</li></ul><h1 id="第二章-数组-链表-栈和队列"><a class="anchor" href="#第二章-数组-链表-栈和队列">#</a> 第二章 数组、链表、栈和队列</h1><ul><li>线性表结构</li><li>线性表：线性表中数据只有前后两个方向</li></ul><h2 id="数组"><a class="anchor" href="#数组">#</a> 数组</h2><p>用一块连续内存空间存储相同类型的一组数据</p><h3 id="特点"><a class="anchor" href="#特点">#</a> 特点</h3><ul><li>线性表结构</li><li>连续内存空间</li><li>相同类型的数据</li></ul><h3 id="重要特性"><a class="anchor" href="#重要特性">#</a> 重要特性</h3><ul><li>随机访问：支持在 O (1) 时间复杂度内按照下标快速访问数组中的元素</li></ul><p>排好序的数组，通过二分查找，时间复杂度为 O (logn)<br /> 数组支持随机访问，因此根据下标访问元素的时间复杂度为 O (1)</p><h3 id="插入删除低效"><a class="anchor" href="#插入删除低效">#</a> 插入删除低效</h3><ul><li>时间复杂度为 O (n)</li><li>优化<ul><li>若不需要有序，将插入位置元素搬到最后，再插入元素 (或直接插入最后)</li><li>或标记删除，空间不足时才删除元素</li></ul></li></ul><h3 id="其它-2"><a class="anchor" href="#其它-2">#</a> 其它</h3><ul><li>下标：确切定义应该是偏移，相对于首地址偏移量，若从 1 开始，每次访问都需要做一次减法运算</li><li>一维数组偏移：baseAddress+i*typeSize</li><li>二维数组偏移：baseAddress+(m*i+j)*typeSize</li><li>注：二维数组，C# 中可不是这样的</li></ul><h2 id="链表"><a class="anchor" href="#链表">#</a> 链表</h2><p>链表不需要一块连续内存，通过指针将一组零散内存块串联起来使用。</p><ul><li>比较擅长 插入、删除操作，时间复杂度为 O (1)<ul><li>注：前提是已知前驱节点，否则操作时间复杂度为 O (n)</li></ul></li><li>随机访问需要遍历，时间复杂度为 O (n)</li></ul><h3 id="循环链表"><a class="anchor" href="#循环链表">#</a> 循环链表</h3><h3 id="双向链表"><a class="anchor" href="#双向链表">#</a> 双向链表</h3><p>比单链表更加常用，双向链表可以快速找到某个节点的前驱节点，支持双向遍历 (会占用多一些内存)</p><ul><li>随机访问时间复杂度与单链表一致，为 O (n)</li><li>插入、删除 操作比单链表更加高效（单链表不支持直接获取前驱节点），时间复杂度为 O (1)</li></ul><h3 id="数组与链表性能对比"><a class="anchor" href="#数组与链表性能对比">#</a> 数组与链表性能对比</h3><ul><li>数组使用连续内存空间存储数据，可以更有效利用 cpu 缓存机制，提高访问效率。链表则不然</li><li>数组大小固定，占用连续内存空间，扩容耗时。链表则本身没有大小限制，天然支持动态扩容</li><li>链表需要额外数据，总体内存消耗更高</li></ul><h3 id="问题"><a class="anchor" href="#问题">#</a> 问题</h3><ul><li>寻找链表中间节点<ul><li><s>遍历求长度，再遍历取值</s></li><li>快慢指针</li></ul></li><li>单链表反转<ul><li>遍历，存储下一个节点，将当前节点下一个节点设置为上一个节点，将当前节点设置为上一个节点，进入下一轮</li></ul></li><li>删除链表倒数第 n 个节点<ul><li><s>遍历求长度，再遍历删除</s></li><li>双指针法，快指针先前进 n 步，然后两个指针一块走，快指针走到尾的时候，慢的指针就处于节点 n 上</li></ul></li><li>链表中环检测<ul><li>快慢指针，相遇则有环 (快追慢)，无环则末尾</li></ul></li></ul><h2 id="栈"><a class="anchor" href="#栈">#</a> 栈</h2><p>先进后出，后进先出<br />操作受限的线性表数据结构</p><ul><li>用数组实现的栈称作顺序栈，用链表实现的栈称为链式栈</li><li>应用<ul><li>函数调用</li><li>表达式求值</li><li>括号匹配</li><li>浏览器前进后退 (两个栈)</li></ul></li></ul><h2 id="队列"><a class="anchor" href="#队列">#</a> 队列</h2><p>先进先出<br />操作受限的线性表数据结构</p><ul><li>用数组实现的队列称为顺序队列，基于链表实现的队列称为链式队列</li><li>基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的无锁并发队列，因此循环队列比链式队列应用更加广泛</li><li>应用<ul><li>有限资源池的请求排队功能 (如线程池)</li><li>注：C# 队列是循环队列，扩容时尾指针比头指针小时，会有两次复制操作</li></ul></li></ul><h1 id="第三章-递归-排序-二分查找"><a class="anchor" href="#第三章-递归-排序-二分查找">#</a> 第三章 递归、排序、二分查找</h1><h2 id="递归"><a class="anchor" href="#递归">#</a> 递归</h2><h3 id="条件"><a class="anchor" href="#条件">#</a> 条件</h3><ul><li>待求解问题可以分解为几个子问题的解</li><li>待求解问题与分解后子问题除数据规模差异，求解思路相同</li><li>存在递归终止条件</li></ul><h3 id="思考方式"><a class="anchor" href="#思考方式">#</a> 思考方式</h3><ul><li>对于一个问题 A，只需要思考问题 A 及其分解问题的两层之间关系，屏蔽递归细节</li><li>不需要一层层往下思考子问题与子问题的关系</li><li>不要试图以人脑分解递归每个步骤，而是通过总结递推公式找出终止条件方式</li></ul><h3 id="问题-2"><a class="anchor" href="#问题-2">#</a> 问题</h3><ul><li>堆栈溢出</li><li>重复计算</li><li>函数调用耗时多</li><li>空间复杂度高</li></ul><h3 id="尾递归"><a class="anchor" href="#尾递归">#</a> 尾递归</h3><ul><li>有限制</li><li>并不是所有的编程语言都支持尾递归优化</li><li>并不是所有递归都可以改成尾递归</li><li>能改成尾递归的都可以改成迭代</li><li>尾递归代码可读性差</li></ul><h2 id="排序"><a class="anchor" href="#排序">#</a> 排序</h2><h3 id="执行效率"><a class="anchor" href="#执行效率">#</a> 执行效率</h3><ul><li>最好时间复杂度、最坏时间复杂度和平均时间复杂度<ul><li>原始数据有序程度对排序执行时间有较大影响</li></ul></li><li>时间复杂度的系数、常数和低阶<ul><li>实际排序中，规模可能较小，因此需要考虑</li></ul></li><li>比较次数和交换 (/ 移动) 次数<ul><li>比较元素大小的耗时少于交换 (/ 移动) 元素位置</li><li>两者需要区分统计</li></ul></li></ul><h3 id="内存消耗"><a class="anchor" href="#内存消耗">#</a> 内存消耗</h3><ul><li>原地排序算法：在原存储空间上完成排序操作</li><li>非原地排序算法：需要额外的非常量级数据存储空间才能完成排序</li><li>注：空间复杂度为 O (1) 的一定是原地排序算法，反过来原地排序算法空间复杂度不一定是 O (1)</li></ul><h3 id="算法稳定性"><a class="anchor" href="#算法稳定性">#</a> 算法稳定性</h3><ul><li>待排序数据中存在值相等元素，经排序后是否可能发生改变</li></ul><h3 id="排序类型"><a class="anchor" href="#排序类型">#</a> 排序类型</h3><h4 id="冒泡排序稳定排序"><a class="anchor" href="#冒泡排序稳定排序">#</a> 冒泡排序（稳定排序）</h4><p>两层循环，第一层为  <code>i&lt;length，第二层 j&lt;length-i-1</code></p><ul><li>最好时间复杂度 (已经有序)：O (n)<ul><li>注：若某一次没有任何元素交换，可提前退出</li></ul></li><li>最坏时间复杂度 (倒序排列)：O (n*n)</li><li>平均时间复杂度：O (n*n)</li></ul><h4 id="插入排序稳定排序"><a class="anchor" href="#插入排序稳定排序">#</a> 插入排序（稳定排序）</h4><p>将数组分为两个区间：已排序区与未排序区<br />取未排序区元素插入已排序区合适位置，保持插入后依然有序</p><ul><li>注：虽然理论时间复杂度与冒泡一样，但实际插入排序比冒泡排序性能好，插入交换操作只有一条，冒泡有 3 条</li></ul><h4 id="选择排序不稳定排序"><a class="anchor" href="#选择排序不稳定排序">#</a> 选择排序（不稳定排序）</h4><p>与插入排序一样，将数组划分为已排序区和未排序区<br />每次从未排序区寻找最小元素，将其放 (交换) 到已排序区末尾</p><ul><li>不稳定：若从大到小 1、1、2、7，7 与第一个 1 交换，此时两个 1 顺序就已经被交换了</li><li>时间复杂度都是 O (n*n)</li></ul><h4 id="归并排序稳定排序"><a class="anchor" href="#归并排序稳定排序">#</a> 归并排序（稳定排序）</h4><p>分治算法思想：由下到上，先处理子问题，再合并<br />分治算法一般是用递归实现</p><ul><li>注：分治是一种解决问题的处理思想，递归是一种编程技巧</li></ul><p>归并排序的执行效率与原始数组的有序程度无关，任何情况下时间复杂度都非常稳定，执行时间复杂度都一样。但不是原地排序算法，空间复杂度较高，因此没有快速排序应用广泛。</p><ul><li>时间复杂度：O (nlogn)</li><li>空间复杂度：O (n)</li></ul><h4 id="快速排序不稳定排序"><a class="anchor" href="#快速排序不稳定排序">#</a> 快速排序（不稳定排序）</h4><p>分治算法思想：由上往下，先分区，再处理子问题</p><ul><li>时间复杂度：O (nlogn)<ul><li>最坏：O (n*n)</li><li>退化到 O (n*n) 的概率较小，而且可以通过合理选择 pivot 避免极端情况发生</li></ul></li><li>空间复杂度 (递归深度，函数调用栈空间)：O (logn)<ul><li>最坏：O (n)</li></ul></li></ul><p>注：最好是指被中心点分割的区间均衡，最坏是指分区极不均衡</p><h3 id="线性排序"><a class="anchor" href="#线性排序">#</a> 线性排序</h3><p>时间复杂度是线性的，不基于比较的排序算法，排序过程不涉及元素之间的比较操作，排序的速度快于任何比较排序算法。</p><h4 id="桶排序bucket-sort"><a class="anchor" href="#桶排序bucket-sort">#</a> 桶排序（bucket sort）</h4><p>定义几个有序的『桶』，将要排序的数据分到这几个桶里，对每个桶的数据单独进行排序，再把每个桶数据按照顺序依次取出，组成的序列即有序</p><ul><li>或者，若数据排序值较低，则直接划分为值数量的桶（例如，根据年龄排序，划分 150 个年龄桶），填充完毕后，依次遍历即已经排好序了</li></ul><p>平均时间复杂度：O (n+k)<br /> 空间复杂度：O (n+k)<br /> 桶排序比较适合用在外部排序中：外部排序即数据存储在外部磁盘中，数据量比较大，而内存有限，无法全部加载内存处理</p><h4 id="计数排序counting-sort"><a class="anchor" href="#计数排序counting-sort">#</a> 计数排序（counting sort）</h4><p>桶排序的一种特殊情况<br />当要排序的 n 个数据所处范围并不大的时候，如最大值为 k，那么就可以把数据划分成 k 个『桶』，每个桶内数据都是相等的，省掉了桶内排序时间</p><ul><li>计数 (遍历待排序数组，计算每个数据个数)</li><li>求每个计数累加和 (遍历计数数组累加)</li><li>整理<ul><li>从后往前遍历待排序数组，扫描到的元素的数据即为计数数组的下标</li><li>从计数数组取出下标对应值 (整数索引)，该值即代表扫描元素应该处于新的排序数组所在位置</li><li>将元素放入排序数组中，计数减一（从后往前处理数组，是为了保持排序算法稳定性，即相同数据元素保证依然排在前面）</li></ul></li></ul><p>平均时间复杂度：O (n+k)<br /> 空间复杂度：O (k)-- 听说是为了返回而创建的新数组不算？</p><ul><li>计数排序时间复杂度为 O (n+k)，k 表示要排序的数据范围，若 k 远小于 n，那么时间复杂度可以表示为 O (n)</li><li>计数排序只能用在数据范围不大的场景，若数据范围 k 比要排序的数据 n 大很多，就不适合了</li><li>除此之外，计数排序只能给非负整数排序，若待排序数据是其它类型，就得将其在不改变相对大小的前提下，转换为非负整数</li></ul><p>其它优化方式</p><ul><li>k 大小取待排序的数组中元素大小的极值差 + 1（max-min+1），确保不会造成额外不需要的空间浪费</li></ul><p>注：通常会用于基数排序的子过程</p><h4 id="基数排序radix-sort"><a class="anchor" href="#基数排序radix-sort">#</a> 基数排序（radix sort）</h4><p>将整数按位数切割成不同的数字，然后每个『位』的数进行依次排序<br />注：按照每位排序算法必须稳定，否则就会有问题：非稳定排序算法，后一次排序不会兼顾前一次排序之后的数据顺序，那么之前所做的基于低位的排序就相当于白做了<br />根据每一位排序的排序算法，可以使用桶排序或计数排序（有多少位就做多少次额外排序）<br />平均时间复杂度：O (n*k)<br /> 空间复杂度：O (n+k)<br /> 要求</p><ul><li>数据可以分割出独立的『位』，并且位之间有递进关系 (如手机号码)：如果 a 数据的高位比 b 数据大，那么剩下低位就不用比较了</li><li>另外，不等长数据也可以经过处理满足要求（例如根据单词排序，单词字母数量不一致，补齐到相同长度）</li><li>每一位数据范围不能太大，可以使用其它线性排序算法来排序，否则基数排序时间复杂度就无法达到 O (n) 了</li></ul><h4 id="总结"><a class="anchor" href="#总结">#</a> 总结</h4><p>上述三种线性排序算法对数据有一定特殊要求，因此应用不是非常广泛，但如果数据正好符合这些排序算法要求，应用会更加高效，时间复杂度可达到 O (n)<br /> 桶排序 (每个桶存储一定范围的数值) 与计数排序 (每个桶只存储单一值) 思想类似，都是针对范围不大的数据，将数据划分到不同『桶』里实现排序<br />基数排序则要求数据可以划分成高低位，位之间有递进关系，且每一位的数据范围不能太大，因为基数排序需借助桶排序或计数排序完成每一个位的排序工作<br />另外，理论上 计数排序 是最快的</p><h3 id="排序优化"><a class="anchor" href="#排序优化">#</a> 排序优化</h3><h4 id="优化快速排序"><a class="anchor" href="#优化快速排序">#</a> 优化快速排序</h4><p>如果数据原来就是有序或接近有序，每次分区点选最后一个数据，那么性能就会退化到 O (n*n)<br /> 理想的分区点是，被分区点分开的两个小区间大小接近相等</p><ul><li>选择合理分区点方式<ul><li>三数取中法：从区间首尾中分别取出一个数据，对比大小，取中间值作为分区点</li><li>随机法：每次从待排序区间随机选取一个元素作为中心点</li></ul></li><li>为避免堆栈溢出，限制递归深度，该用其它排序，或采用模拟实现函数调用栈</li></ul><h3 id="二分查找"><a class="anchor" href="#二分查找">#</a> 二分查找</h3><p>对有序数据的一种快速查找算法<br />时间复杂度：O (logn)<br /> 对数运算的逆运算就是指数运算，该算法及其高效</p><ul><li>mid=low+(high-low)/2</li><li>或 mid=low+((high-low)&gt;&gt;1)</li></ul><h4 id="二分查找变体问题"><a class="anchor" href="#二分查找变体问题">#</a> 二分查找变体问题</h4><p>通常的二分查找，只能查找不重复元素，若元素重复，那么查出来的结果就不能确定是重复元素中的哪个了<br />若对查找出的元素没有顺序要求，自然也无所谓，不过若有一定要求，那么就涉及变体问题<br />因此，其又分为以下四种变体方式：</p><ul><li>查找第一个值等于给定值元素<ul><li>简洁写法<ul><li>while(low&lt;=high){a[mid]&gt;value high=mid-1 else low=mid+1} if(low&lt;n&amp;&amp;a[low]==value return low</li><li>注意循环退出条件，并注意返回值，返回的是 low，此时 low 应该比 high 大，low 和 high 通过不断逼近 value 实现，最后 low 和 high 交错而过，low</li></ul></li><li>清晰写法<ul><li>a [mid] 与要查找的 value 大小关系有三种情况：大于、小于和等于，主要特殊处理等于的情况</li><li>a[mid]&gt;value;high=mid-1</li><li>a[mid]&lt;value;low=mid+1</li><li>if(mid==0)||(a[mid]-1!=value) return mid;else high=mid-1</li></ul></li></ul></li><li>查找最后一个值等于给定值的元素（同上）</li><li>查找第一个值大于或等于给定值的元素（同上）</li><li>查找最后一个值小于或等于给定值的元素（同上）</li></ul><h1 id="第四章-哈希表-位图和哈希算法"><a class="anchor" href="#第四章-哈希表-位图和哈希算法">#</a> 第四章 哈希表、位图和哈希算法</h1><p>哈希表 (hash table) 是数组的一种扩展，由数组演化而来，底层依赖数组支持按下标快速访问元素的特性</p><ul><li>如果没有数组，就没有哈希表</li><li>即：哈希表利用数组通过下标访问元素的时间复杂度为 O (1) 的特性，利用哈希函数把元素的键值映射为数组的下标存储；当按照键值查询元素时，使用同样的哈希函数将键值转化为数组下标，然后通过索引直接取值</li></ul><p>哈希函数涉设计时 3 个基本要求：</p><ul><li>哈希函数计算得到的值是一个非负整数（因为数组下标从 0 开始）</li><li>如果 key1=key2，hash (key1)=hash (key2)</li><li>如果 key1≠key2，hash (key1)≠hash (key2)<ul><li>这个要求满足比较困难，也叫哈希冲突，即使 md5 都会出现冲突；而且数组存储空间有限，因此更加大了冲突概率</li><li>哈希冲突需要进行解决</li></ul></li></ul><h2 id="哈希冲突解决"><a class="anchor" href="#哈希冲突解决">#</a> 哈希冲突解决</h2><h3 id="开发寻址法open-addressing"><a class="anchor" href="#开发寻址法open-addressing">#</a> 开发寻址法 (open addressing)</h3><p>一旦出现冲突，就通过重新探测新位置的方法来解决冲突</p><ul><li>线性探测法 (linear probing)<ul><li>当插入数据时，若对应位置已经被占据，那就从该位置向后依次查找，直到找到一个空闲位置为止</li><li>线性探测法删除时需要特殊处理，避免影响查找节点逻辑（查找若探测到空位置，就会导致直接返回空），方式是标记为 delete，查找探测时，遇到 delete 不会停止</li><li>对于线性探测法，随着插入数据越来越多，空闲位置越来越少，哈希冲突概率就会越来越大，探测时间也会越来越长（最差时间复杂度 O (n)）</li></ul></li><li>二次探测法<ul><li>与线性探测法很像，只是探测步长变为原来的二次方</li><li>hash (key)+0、hash (key)+pow (1,2)、hash (key)+pow (2,2) 等</li></ul></li><li>双重哈希法<ul><li>使用多个哈希函数，若第一个哈希函数计算得出位置已经被占用，就用第二个、第三个哈希函数重新计算...... 直到找到空闲位置</li></ul></li></ul><h3 id="链表法chaining"><a class="anchor" href="#链表法chaining">#</a> 链表法 (chaining)</h3><p>是一种更加常用的解决哈希冲突的方法<br />在哈希表中，每个『桶』或者『槽』会对应一个链表，将哈希值相同的元素放到相同的槽位对应的链表中</p><ul><li>当插入元素时，通过哈希函数计算出对应的槽位，然后将元素插入槽位对应的链表中；查找、删除元素同理</li><li>插入时间复杂度是 O (1)，且当链表中元素不多（哈希冲突不是那么高）时，其它操作 (查找、删除) 也可以粗略认为操作时间复杂度是 O (1)</li></ul><p>装载因子 (load factor)= 元素个数 / 哈希表长度 (槽个数)<br /> 装载因子越大，说明链表长度越长，哈希表性能就会更低</p><h2 id="工业级哈希表"><a class="anchor" href="#工业级哈希表">#</a> 工业级哈希表</h2><p>若所有数据都被装到一个链表，哈希表退化后时间复杂度为 O (n)，是原本的执行消耗的 n 倍</p><ul><li>精心设计的数据能使其退化造成性能急剧下降，形成拒绝服务攻击，这就是哈希表碰撞攻击的基本原理</li></ul><h3 id="设计哈希函数"><a class="anchor" href="#设计哈希函数">#</a> 设计哈希函数</h3><p>哈希函数设计好坏，决定了哈希表冲突概率大小，也直接决定了哈希表的性能</p><ul><li>哈希函数不能过于复杂，否则会消耗更多计算时间</li><li>哈希函数生成的值应尽可能随机分布</li></ul><h3 id="解决装载因子过大"><a class="anchor" href="#解决装载因子过大">#</a> 解决装载因子过大</h3><p>动态扩容</p><ul><li>动态扩容后，需要通过哈希函数重新计算每个数据在新的哈希表中位置</li><li>触发扩容的操作时间复杂度为 O (n)</li></ul><h4 id="避免低效扩容增量扩容"><a class="anchor" href="#避免低效扩容增量扩容">#</a> 避免低效扩容（增量扩容）</h4><p>集中扩容会导致某一次插入时，耗时过高，因此可以考虑增量扩容</p><ul><li>当装载因子达到阈值时，仅创建新的表，但并不立即将数据全部移到新表中</li><li>当插入新数据时，还会从原数据表中搬运一个数据到新表中，经过多次插入后，原表数据就被一点点移到新表中了，使扩容消耗分散，所有插入操作都变得很快</li><li>缺点：原表数据没有搬移完成时，内存无法释放，且为了兼容，查询操作需要同时在两张表中进行</li></ul><h3 id="选择合适的冲突解决方法"><a class="anchor" href="#选择合适的冲突解决方法">#</a> 选择合适的冲突解决方法</h3><h4 id="开放寻址法"><a class="anchor" href="#开放寻址法">#</a> 开放寻址法</h4><p>优点</p><ul><li>数据直接存储在数组中，可有效利用 cpu 缓存加快查询速度</li><li>不涉及链表和指针，方便序列化</li></ul><p>缺点</p><ul><li>所有数据都存在一个数组，发生冲突概率更高</li><li>因此装载因子不能过大，必须小于 1，所有需要消耗更多空间<ul><li>装载因子接近 1 时，会有大量的哈希冲突，导致大量探测、再哈希等，性能急剧下降</li></ul></li><li>删除数据比较麻烦，需要额外特殊标记删除数据</li></ul><p>因此，当数据量小，装载因子小时，适合采用开发寻址法</p><h4 id="链表法"><a class="anchor" href="#链表法">#</a> 链表法</h4><p>链表法相比开放寻址法，对大装载因子容忍度更高</p><ul><li>只要哈希函数计算得到的值比较随机且均匀，即便装载因子变成 10，也只是链表长度变长了点，性能下降并不多</li></ul><p>缺点</p><ul><li>链表中节点要额外存储 next 指针，对于小对象存储，有可能会让内存消耗翻倍（当然若存储大对象，远大于指针消耗，那么指针内存消耗就可以忽略了）</li><li>链表节点在内存种零散分布，对 cpu 缓存不友好</li></ul><p>也可以考虑将链表改造成其它高效数据结构，例如红黑树，这样即便出现哈希冲突，在极端情况下所有数据都哈希到了同一个『桶』，最终哈希表也只是退化成红黑树，查询效率也不会太差 (O (logn))</p><h3 id="总结-2"><a class="anchor" href="#总结-2">#</a> 总结</h3><p>需满足要求</p><ul><li>支持快速查询、插入、删除操作</li><li>内存占用合理，不浪费过多内存空间</li><li>性能稳定，在极端情况下，哈希表性能也不会退化到无法接受的程度</li></ul><p>设计思路</p><ul><li>设计一个合适的哈希函数</li><li>设置合理的装载因子阈值 (开放寻址法)，并设计动态扩容策略</li><li>选择合适的哈希冲突解决方法</li></ul><h2 id="利用哈希表优化-lru-缓存淘汰算法"><a class="anchor" href="#利用哈希表优化-lru-缓存淘汰算法">#</a> 利用哈希表优化 LRU 缓存淘汰算法</h2><p>哈希表对应链表中对应节点，节省遍历链表开销</p><ul><li>虽然哈希表支持高效插入、删除和查找操作，但哈希表中数据经哈希函数打乱后是无规律存储的，无法支持按照某种顺序遍历并输出数据</li><li>因此可以将其与有序链表结合使用</li></ul><p>有序链表支持按照某种顺序遍历并输出数据，哈希表与其结合，就可以实现：既可以快速插入、删除和查找操作，又支持 O (n) 时间复杂度按顺序遍历并输出数据</p><h2 id="位图网址链接去重"><a class="anchor" href="#位图网址链接去重">#</a> 位图：网址链接去重</h2><p>假设一条网址平均长度 64B，10 条网址为 60G 左右<br />对基于链表法解决冲突的哈希表，在查询网址链接时，找到对应链表后，还需要用待判重网址链接依次对比，对比也操作较耗时</p><h3 id="位图bitmap"><a class="anchor" href="#位图bitmap">#</a> 位图（bitmap）</h3><p>原理：申请对应长度的 bool 数组，使用 bool 进行标记，标记对应元素是否存在<br /> char 类型表示一个长度为 16 的位图</p><ul><li>存取位图数据时，用数据除以 16，得到数据存储元素，然后与 16 取余，得到具体哪个二进制位上</li></ul><h3 id="布隆过滤器bloom-filter"><a class="anchor" href="#布隆过滤器bloom-filter">#</a> 布隆过滤器（Bloom filter）</h3><p>基于位图实现，是对位图的一种改进，用于改进存储空间的利用<br />做法</p><ul><li>尽管数据范围增大了，但是依然使用更低范围的位图，但是使用哈希函数进行索引</li><li>哈希函数必然有冲突，其做法是定义多个哈希函数，并同时将对应下标处置为 true，即用 k 个二进制位而非一个表示一个元素是否存在</li><li>判断是否存在时，判断所有哈希函数计算的下标都为 true 才通过</li></ul><p>缺点</p><ul><li>存在『误判』，即不存在的被判断为存在</li><li>多个元素的哈希函数重叠设置导致</li></ul><p>对于误判情况，某些业务场景可以容忍的情况下，是可以使用的<br />另外，误判只会误判断『已经存在』，数据存在的情况下不会导致判断『不存在』</p><ul><li>利用该特定，也可以在例如查询数据库之前，利用布隆过滤器判断数据是否存在，不存在就可以省略查询开销</li></ul><p>布隆过滤器非常适合不需要完全准确，允许存在小概率误判的大规模判重场景<br />其误判概率主要与哈希函数个数、位图大小有关，更适合静态数据，当数据越来越多，false 越来越少，误判率就会增高（因此对于动态数据，布隆过滤器还需要支持动态扩容，阈值）</p><h3 id="总结-3"><a class="anchor" href="#总结-3">#</a> 总结</h3><p>位图和布隆过滤器，相比哈希表，在内存消耗上降低了许多，在特定场景下，优势更明显<br />而且位图属于 cpu 密集型，哈希表由于链表存在，若进行判重还需要读取对应数据 (内存密集型) 对其元素进行额外对比，因此理论上位图性能更好</p><h2 id="哈希算法"><a class="anchor" href="#哈希算法">#</a> 哈希算法</h2><p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射规则就叫做『哈希算法』，原始数据映射后得到的二进制值串就称为『哈希值』<br />一般要求</p><ul><li>哈希值不能反向推导出原始数据（因此也叫单向哈希算法）</li><li>对数据变化敏感，原始数据哪怕变动一个二进制，对应哈希值也大不同</li><li>哈希冲突概率要小</li><li>执行效率要高</li></ul><h3 id="应用-安全加密"><a class="anchor" href="#应用-安全加密">#</a> 应用 - 安全加密</h3><p>MD5（message-digest 5）、SHA（secure hash algorithm）<br />需求</p><ul><li>很难根据哈希值反向推导出原始数据</li><li>哈希冲突概率要很小</li></ul><p>哈希冲突无法完全避免</p><ul><li>巢鸽理论（抽屉理论）：将 11 只鸽子放进 10 个鸽巢，那么肯定有一个鸽巢中鸽子数量多于一个，即肯定有两只鸽子在一个鸽巢内</li><li>例如 MD5 最大 128 位，表示数据也有限，而需要计算的原始数据是无穷大的</li><li>另一个角度看，哈希值越长的算法，哈希冲突概率就越低（相应计算时间就越长）</li></ul><h3 id="应用-唯一标识"><a class="anchor" href="#应用-唯一标识">#</a> 应用 - 唯一标识</h3><p>例如海量图库中查询是否存在，例如从图片开头取 100B、中间取 100B、末尾取 100B，然后放在一块计算哈希值</p><h3 id="应用-数据校验"><a class="anchor" href="#应用-数据校验">#</a> 应用 - 数据校验</h3><p>例如 BT 分块文件的校验，通过将下载文件块与种子文件记录的哈希进行对比避免文件块出现问题</p><h3 id="应用-哈希函数"><a class="anchor" href="#应用-哈希函数">#</a> 应用 - 哈希函数</h3><p>哈希函数是设计哈希表的关键，不过相比其它，对冲突容忍度更高，一般比较简单，更追求效率</p><h3 id="应用-负载均衡"><a class="anchor" href="#应用-负载均衡">#</a> 应用 - 负载均衡</h3><p>会话沾滞：属于同一会话所有请求都会被路由到同一台服务器上</p><h3 id="应用-数据分片"><a class="anchor" href="#应用-数据分片">#</a> 应用 - 数据分片</h3><p>统计 1TB 大小日志 “搜索关键词” 出现的次数</p><ul><li>从日志文件依次读取每个搜索关键词，通过哈希算法计算哈希值，然后与机器个数求模取余</li><li>假设得出值为 k，那么数据就会发送至编号为 k 的机器</li><li>相同关键词会被分配给相同机器处理，每台机器分别计算统计结果，最后合并</li></ul><h3 id="应用-分布式存储"><a class="anchor" href="#应用-分布式存储">#</a> 应用 - 分布式存储</h3><p>哈希算法计算哈希值，求模取余，最终值即为对应缓存机器编号</p><ul><li>该方式在新增机器后，会有扩容问题：数据需要在机器之间重新分配，即缓存失效</li></ul><p>为解决缓存失效问题，于是有一致性哈希算法</p><ul><li>假设 k 台机器，数据的哈希值范围是 [0,Max]，将整个范围划分为 m 个区间（m 远大于 k），每台机器负责 m/k 个小区间</li><li>当有新机器加入，就将某几个小区间数据搬入新机器</li><li>这样既不需要全部重新计算哈希值并搬移数据，又保持了各个机器上数据量的均衡</li></ul><h2 id="总结-4"><a class="anchor" href="#总结-4">#</a> 总结</h2><p>哈希算法作为密码存储，可以加『盐』以提高用户密码复杂度，增加字典攻击的破解难度</p><h1 id="第五章-树"><a class="anchor" href="#第五章-树">#</a> 第五章 树</h1><h2 id="树和二叉树"><a class="anchor" href="#树和二叉树">#</a> 树和二叉树</h2><h3 id="树的定义"><a class="anchor" href="#树的定义">#</a> 树的定义</h3><ul><li>节点的高度 = 节点到叶子节点的最长路径长度</li><li>节点的深度 = 根节点到这个节点的路径长度</li><li>节点的层 = 节点的深度 + 1</li><li>节点的高度 = 根节点的高度</li></ul><h3 id="二叉树"><a class="anchor" href="#二叉树">#</a> 二叉树</h3><p>每个节点最多两个子节点，但是并不要求每个节点必须要有两个子节点<br />分类</p><ul><li>满二叉树：除叶子节点外，每个节点都有左右两个子节点</li><li>完全二叉树：叶子节点分布在最下层和倒数第二层，最下面一层 (若只有一个节点) 的叶子节点都靠左排列</li></ul><p>注：满二叉树是完全二叉树的一种特殊情况</p><h3 id="二叉树的存储"><a class="anchor" href="#二叉树的存储">#</a> 二叉树的存储</h3><p>一般两种方法</p><ul><li>基于指针的链式存储方式（通用）</li><li>基于数组的顺序存储方式（适用完全二叉树）<ul><li>若节点 x 存储于数组 i 处</li><li>左子节点 = 2i</li><li>右子节点 = 2i+1</li><li>父节点 = i/2</li></ul></li></ul><p>完全二叉树仅浪费一个下标 0 的存储空间，对于非完全二叉树，会浪费比较多的存储空间，因此非完全二叉树一般采用链式存储<br />采用数组方式更节省内存，且不需要记录左右子节点指针，因此完全二叉树单独提出，这也是完全二叉树要求最下层节点需要全部靠左排列的原因</p><h3 id="二叉树的遍历"><a class="anchor" href="#二叉树的遍历">#</a> 二叉树的遍历</h3><ul><li>前序：根左右</li><li>中序：左根右</li><li>后序：左右根</li></ul><p>遍历时间复杂度：O (n)</p><h2 id="二叉查找树binary-search-tree"><a class="anchor" href="#二叉查找树binary-search-tree">#</a> 二叉查找树（binary search tree）</h2><p>也称为二叉搜索树，也是二叉树中常用的一种类型<br />用来组织动态数据集合，可以支持数据的快速插入、删除和查找操作</p><ul><li>对于二叉查找树中任意节点，左子树值都小于这个节点的值，右子树值都大于这个节点的值</li></ul><h3 id="操作"><a class="anchor" href="#操作">#</a> 操作</h3><h4 id="查找操作"><a class="anchor" href="#查找操作">#</a> 查找操作</h4><ul><li>while(p!=null)<ul><li>if(data&lt;p.data) p=p.left</li><li>else if(data&gt;p.data) p=p.right</li><li>else return p</li></ul></li></ul><h4 id="插入操作"><a class="anchor" href="#插入操作">#</a> 插入操作</h4><p>与查找类似，判断节点大小插入叶子节点</p><h4 id="删除操作"><a class="anchor" href="#删除操作">#</a> 删除操作</h4><ul><li>待删除节点没有子节点，直接将父节点指向该节点指针置为 null</li><li>待删除节点有一个子节点，更新父节点指向删除节点指针，使其重新指向待删除节点的子节点</li><li>待删除节点有两个子节点，需要找到这个节点<strong>右子树</strong>中最小节点，将其替换到删除的节点位置</li></ul><p>另外，还有一个比较简单、取巧的处理方法：只将删除节点标记为已删除，而并不真正删除。这样删除操作就会变得很简单，缺点是占用了内存并会降低查询效率</p><h4 id="其它-3"><a class="anchor" href="#其它-3">#</a> 其它</h4><p>中序遍历可以从小到大有序输出数据，且时间复杂度为 O (n)</p><ul><li>因此二叉查找树也称二叉排序树</li></ul><h3 id="支持重复数据的二叉查找树"><a class="anchor" href="#支持重复数据的二叉查找树">#</a> 支持重复数据的二叉查找树</h3><p>针对包含值相同的节点的二叉树，有两种存储方式</p><ul><li>每一个节点存储不是一个数据，而是一组数据，把值相同的数据存储在同一个节点上</li><li>每个节点仍然只存储一个数据，当插入数据时，如果碰到一个节点的值与插入数据的值相同，就将插入的数据放到该节点的右子树。即某个节点的右子树存储的是大于等于该节点的值的节点</li></ul><h3 id="二叉查找树的性能"><a class="anchor" href="#二叉查找树的性能">#</a> 二叉查找树的性能</h3><p>在二叉查找树中，查找、插入和删除等操作与树的高度成正比</p><ul><li>最坏时间复杂度 (退化为链表)：O (n)</li><li>最好时间复杂度 (完全二叉树)：O (logn)</li></ul><h3 id="哈希表与二叉查找树"><a class="anchor" href="#哈希表与二叉查找树">#</a> 哈希表与二叉查找树</h3><p>哈希表不能替代二叉查找树</p><ul><li>哈希表数据无序存储，若需要输出有序数列，需要先排序，或配合有序链表使用（二叉查找树中序遍历即可）</li><li>哈希表扩容耗时，当哈希冲突时，性能不稳定（二叉查找树性能也不稳，但平衡二叉查找树是稳定 O (logn) 的）</li><li>O (logn) 有时不一定比 O (1) 慢，取决于具体数据规模、常量、系数等。因此哈希表由于哈希冲突、哈希计算等，不一定比之高效</li><li>哈希表构造比二叉查找树复杂，需要考虑更多：哈希函数设计、冲突解决、扩容、缩容 等。平衡二叉查找树只需要考虑如何维护平衡性</li></ul><h2 id="平衡二叉查找树"><a class="anchor" href="#平衡二叉查找树">#</a> 平衡二叉查找树</h2><p>普通二叉查找树在频繁动态更新过程中，可能会树的高度远大于 log2n 的情况，导致各个操作效率下降。特别是极端情况下退化为链表，时间复杂度变成 O (n)<br /> 因此有了平衡二叉查找树</p><h3 id="定义"><a class="anchor" href="#定义">#</a> 定义</h3><p>二叉树中任意一个节点的左右子树的高度相差不大于 1（完全二叉树、满二叉树均为平衡二叉树）<br />平衡二叉查找树不仅满足平衡二叉树定义，同时满足二叉查找树的特点</p><ul><li>种类：AVL、红黑树、Treap (树堆)、Splay Tree (伸展树)</li><li>AVL 树：最先被提出的平衡二叉查找树是 AVL 树，它严格符合平衡二叉查找树的定义，是一种高度平衡的二叉查找树</li><li>红黑树：并没有严格符合平衡二叉查找树的定义，从根节点到各个叶子节点的最长路径有可能会比最短路径长一倍</li></ul><h3 id="红黑树的定义"><a class="anchor" href="#红黑树的定义">#</a> 红黑树的定义</h3><p>Red-Black Tree,R-B Tree，是一种相对平衡的二叉查找树，并不符合严格意义上的平衡二叉查找树的定义</p><ul><li>根节点是黑色</li><li>每个叶子节点都是黑色的空节点 (叶子节点不存储数据)</li><li>任何上下相邻的节点不能同时为红色，红色节点被黑色节点隔开（不会有连续的红色节点）</li><li>对每个节点，从该节点到叶子节点的所有路径，都包含相同数目的黑色节点</li></ul><h3 id="红黑树性能"><a class="anchor" href="#红黑树性能">#</a> 红黑树性能</h3><p>平衡二叉查找树提出是为了解决二叉查找树因为动态更新导致性能退化问题<br />『平衡』可以等价为性能不退化，『近似平衡』可以等价为性能退化不太严重</p><ul><li>红黑树比高度平衡的 AVL 树高了一倍，性能损失不会太大。红黑树维护节点平衡成本更低，因此性能并不比 AVL 树差</li></ul><p>为何红黑树更受欢迎？</p><ul><li>AVL 是一种高度平衡的二叉树，查找数据效率非常高。但为了维护平衡，每次插入、删除数据都要对树中节点的分布做调整，操作复杂耗时</li><li>红黑树只做近似平衡，因此维护平衡成本比 AVL 树更低，性能又损失不大。</li></ul><h2 id="递归树"><a class="anchor" href="#递归树">#</a> 递归树</h2><p>借助 树 求递归算法的时间复杂度</p><h2 id="b树"><a class="anchor" href="#b树">#</a> B + 树</h2><p>通过二叉查找树演化而来</p><ul><li>B + 树由 m 叉查找树和有序链表组合而成</li><li>每个节点中子节点个数不能超过 m，也不能小于 m/2</li><li>根节点的子节点个数可以不超过 m/2，这是例外</li><li>一般情况下，根节点会被存储在内存，其它节点存储在磁盘</li></ul><p>其它，与 B- 树差异（注：B - 就是 B 树） BalanceTree、B-Tree</p><ul><li>B+ 树中节点不存储数据，只是索引，而 B 树中节点存储数据</li><li>B 树中的叶子节点并不需要链表串联<ul><li>即 B 树只是一个每个节点的子节点个数不能小于 m/2 的 m 叉树</li></ul></li></ul><h1 id="第六章-堆"><a class="anchor" href="#第六章-堆">#</a> 第六章 堆</h1><h2 id="堆如何维护动态集合的最值"><a class="anchor" href="#堆如何维护动态集合的最值">#</a> 堆：如何维护动态集合的最值</h2><h3 id="堆的定义"><a class="anchor" href="#堆的定义">#</a> 堆的定义</h3><ul><li>堆必须是一个完全二叉树</li><li>堆中每个节点的值必须大于或等于 (或小于等于) 其子树中每个节点的值<ul><li>即堆中每个节点的值都大于或等于 (或小于或等于) 其左右子节点的值</li><li>注：由于该特性，堆不一定是二叉查找树，左子节点不一定比右子节点小</li></ul></li></ul><p>若堆中每个节点的值都大于或等于子树中每个节点的值，称为大顶堆<br />若堆中每个节点的值都小于或等于子树中每个节点的值，称为小顶堆<br />注：下述理论部分特指大顶堆</p><h3 id="堆的存储"><a class="anchor" href="#堆的存储">#</a> 堆的存储</h3><p>完全二叉树比较适合用数组存储，因此堆也适合用数组存储</p><ul><li>用数组存储完全二叉树非常节省内存，因为不需要存储左右子节点指针，只需要通过数组下标运算就可以找到某个节点的左右子节点和父节点</li></ul><p>对于下标为 i 的节点，根存储于 1 处，有：</p><ul><li>左子节点：2i</li><li>右子节点：2i+1</li><li>父节点：i/2</li></ul><p>另外，也可以将根节点存储于 0 处：</p><ul><li>左子节点：2i+1</li><li>右子节点：2i+2</li><li>父节点：(i-1)/2</li></ul><p>对比来看，将根节点从 1 开始存储，计算父子节点下标更方便<br />比较常用操作：插入元素、获取堆顶元素、删除堆顶元素</p><ul><li>不常用操作：按照节点指针 (数组下标) 删除任意元素</li></ul><h3 id="在堆中插入元素"><a class="anchor" href="#在堆中插入元素">#</a> 在堆中插入元素</h3><p>若将新元素插入堆的末尾 (数组的末尾)，堆就不满足定义要求了，因此需要调整，调整过程称为『堆化』<br />堆化分为两种：自上而下和自下而上</p><ul><li>自下而上：假设堆化节点为 a，顺着节点 a 所在路径向上对比，若节点 a 大于父节点，就将其与父节点交换，重复该过程</li><li>自上而下：从堆顶元素开始，对父子节点进行对比，对于不满足大小关系的父子节点互换位置，重复该过程直到满足要求</li></ul><h3 id="删除堆顶元素"><a class="anchor" href="#删除堆顶元素">#</a> 删除堆顶元素</h3><p>对于大顶堆，当删除堆顶节点后，需要将第二大节点放到堆顶，并迭代处理后续节点<br />不过如此处理后，最后对就不是完全二叉树树了（叶子节点出现空洞），因此有另一种处理方式：</p><ul><li>将最后一个节点放到堆顶，然后利用自上而下的堆化方式让堆重新满足定义</li></ul><h3 id="删除任意元素"><a class="anchor" href="#删除任意元素">#</a> 删除任意元素</h3><p>将堆中最后一个元素替换到删除元素位置，分条件执行堆化</p><ul><li>替换的元素大于删除元素，进行自下而上的堆化</li><li>替换的元素小于删除元素，进行自上而下的堆化</li><li>替换元素等于删除元素，不需要堆化</li></ul><h3 id="性能"><a class="anchor" href="#性能">#</a> 性能</h3><p>获取堆顶元素（最大最小值)：O (1)<br /> 插入、删除、删除任意元素时间复杂度：O (logn)</p><h2 id="堆排序"><a class="anchor" href="#堆排序">#</a> 堆排序</h2><p>堆排序时间复杂度：O (nlogn)<br /> 空间复杂度：O (1)<br /> 堆排序的时间复杂度要比快速排序稳定，但性能比快速排序慢</p><ul><li>数据访问方式对 cpu 不友好 (数据跳着访问，堆排比较的几乎都不是相邻元素)，且实际交换可能会比快排更多</li><li>建堆会降低数据有序度，例如对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了</li></ul><p>排序整个过程分为两步：建堆、排序</p><h3 id="建堆"><a class="anchor" href="#建堆">#</a> 建堆</h3><p>先将数组中数据原地组织成一个堆<br />两种思路</p><ul><li>借助堆中插入数据处理思路<ul><li>将堆中数据划分为前后两个部分，前半部分表示已建好堆的数据，后半部分表示非堆中数据</li><li>开始堆中只存在下标为 1 的数组元素，将下标 2~n 依次插入堆中，执行自下而上的堆化，执行完毕后所有数据即组织成堆结构</li><li>建堆时间复杂度：O (nlogn)</li><li>每个节点堆化时间复杂度：O (logn)</li></ul></li><li>从后往前处理数组，对每个数据执行自上而下的堆化（效率更好）<ul><li>因为叶子节点不需要堆化，对于完全二叉树，下标 n/2-1~n 的节点都是叶子节点</li><li>因此只需要对 n/2~1 的数据依次执行自上而下堆化</li><li>建堆时间复杂度：O (n)</li><li>每个节点堆化时间复杂度：O (logn)</li></ul></li></ul><h3 id="排序-2"><a class="anchor" href="#排序-2">#</a> 排序</h3><p>建堆结束后，堆中数据已经是按照大顶堆的特性来组织的了（注：左右子节点中，左子节点不一定大于右子节点）</p><ul><li>将最大元素与最后一个元素 k 交换<ul><li>k=k-1</li><li>然后执行从 0~k 的自上而下堆化</li></ul></li><li>反复进行，直到最后只剩一个元素即排序完成</li></ul><h2 id="堆的应用"><a class="anchor" href="#堆的应用">#</a> 堆的应用</h2><p>经典应用是求 topK 一类的问题，另外还有例如优先级队列、求中位数和求百分位数</p><h3 id="优先级队列"><a class="anchor" href="#优先级队列">#</a> 优先级队列</h3><p>在优先级队列中，数据并不是先进先出，而是按照优先级的高低，优先级最高的最先出队<br />堆天然就是一个优先级队列</p><h4 id="合并多个有序文件"><a class="anchor" href="#合并多个有序文件">#</a> 合并多个有序文件</h4><p>使用优先级队列 (堆) 维护动态数据最小值的时间复杂度是 O (logn)，更高效</p><h4 id="高性能定时器"><a class="anchor" href="#高性能定时器">#</a> 高性能定时器</h4><p>常规做法是每指定间隔 (如 1s) 扫描一次定时任务，该做法比较低效：任务可能间隔还很久、每次扫描整个任务列表消耗大<br />使用堆做优先级队列存储任务，队首存储最先执行任务</p><ul><li>将队首任务执行时间与当前时间相减，得到时间间隔 t，t 代表从当前时间开始，需要等待多久才会有第一个任务被执行，如此定时器就可以设定 t 秒后再来执行任务</li><li>t 秒后取队首任务执行，然后计算新的队首任务的执行时间与当前时间之差</li></ul><h3 id="求-topk"><a class="anchor" href="#求-topk">#</a> 求 TopK</h3><ul><li>静态数据，事先确定，不会再变<ul><li>建堆、堆化</li><li>时间复杂度：O (nlogK)</li></ul></li><li>动态数据，有数据会动态加入集合<ul><li>插入时维护堆</li></ul></li></ul><h3 id="求中位数和百分位数"><a class="anchor" href="#求中位数和百分位数">#</a> 求中位数和百分位数</h3><p>如果数据个数是奇数，把数据从小到大排列，第 n/2+1 就是中位数<br />如果数据个数是偶数，中位数有两个：n/2 和 n/2+1</p><ul><li>静态数据集合<ul><li>建堆后排序即可</li></ul></li><li>动态数据集合<ul><li>维护一个大顶堆和一个小顶堆</li><li>大顶堆存储动态集合前半部分数据，小顶堆存储后半部分数据，且小顶堆数据都大于大顶堆数据</li><li>如此，大顶堆中堆顶元素即为中位数（偶数情况下，则大小堆顶元素）</li><li>插入元素时，判断元素大小，以决定插入哪个堆</li><li>插入后若元素个数不满足要求，则将其中一个堆顶元素移到另一个堆，以保持平衡</li></ul></li></ul><p>求百分位数</p><ul><li>与中位数原理一致，同样维护两个大小顶堆，只是元素个数比例调整为规定的百分比</li></ul><h1 id="第七章-跳表-并查集-线段树和树状数组"><a class="anchor" href="#第七章-跳表-并查集-线段树和树状数组">#</a> 第七章 跳表、并查集、线段树和树状数组</h1><h2 id="跳表"><a class="anchor" href="#跳表">#</a> 跳表</h2><p>我们只需要对链表稍加改造，就可以支持类似『二分』的查找算法，改造后的数据结构可称为跳表 (skip list)<br /> 如 Redis 中有序集合就是用跳表实现</p><ul><li>按区间查找：跳表可以以 O (logn) 时间复杂度定位区间起点，然后在原始链表中顺序向后遍历，直到遇到区间终点节点</li><li>相比红黑树，跳表更灵活、易实现</li></ul><p>跳表实现非常灵活，可以通过改变索引构建策略，平衡空间、时间复杂度<br />注：跳表是有序的</p><h3 id="跳表的由来"><a class="anchor" href="#跳表的由来">#</a> 跳表的由来</h3><p>在链表中的数据，即使有序存储，查找数据的时间复杂度也是为 O (n)<br /> 于是对链表建立一级『索引』，每指定间隔 (如两个) 节点提取到索引层，这样查找节点时，先遍历索引层，然后跳入原始链表层，节省遍历时间</p><ul><li>第三级索引：2 个节点</li><li>第二级索引：4 个节点</li><li>第一级索引：8 个节点</li><li>原始链表：16 个节点</li></ul><p>即，假设原始链表包含 n 个节点，第一级大约 n/2 个节点，每上升一级大约减少一半节点，依次类推直到剩下两个节点为止</p><h3 id="跳表效率"><a class="anchor" href="#跳表效率">#</a> 跳表效率</h3><p>时间复杂度：O (logn)，与二分查找相同</p><ul><li>不过由于查询效率提升的前提是构建多级索引，属于空间换时间的设计思路</li></ul><p>空间复杂度：O (n)</p><ul><li>不过可以通过增加抽取节点间隔控制索引节点占用的存储空间，以达到时间复杂度和空间复杂度的平衡</li></ul><p>插入、删除时间复杂度：O (logn)</p><ul><li>若删除节点在索引中也有出现，除删除原始链表节点外，还需要删除索引中对应节点</li></ul><h3 id="跳表索引动态更新"><a class="anchor" href="#跳表索引动态更新">#</a> 跳表索引动态更新</h3><p>跳表借助随机函数更新索引结构<br />如通过随机函数得到某个值 k，就将该节点添加到第一级到第 k 级索引中</p><h2 id="并查集union-find-set"><a class="anchor" href="#并查集union-find-set">#</a> 并查集（Union-find set）</h2><p>根据对象两两之间的直接关系来快速查询任意两个对象之间是否存在关系（直接或间接）</p><ul><li>即 若 a、b 存在关系，b、c 存在关系，那么 a 和 c 就是存在关系的</li></ul><p>基于操作的对象 (集合) 和行为 (并和查)，将这种数据结构称为并查</p><h3 id="基于链表的实现"><a class="anchor" href="#基于链表的实现">#</a> 基于链表的实现</h3><p>通过链表来表示集合，链表头节点作为集合代表标识集合<br />假设原始数据存储在一个数组中，通过</p><ul><li>将链表头节点作为集合的『代表』，每个链表节点除存储 next 指针外，还存储一个指向『代表』的头节点 R 指针</li><li>合并集合时，将两个链表合并，并更新其中一个链表所有节点的 R 指针指向新的表头</li><li>查询两个对象是否属于同一个集合时，判断指向头节点的 R 指针是否指向相同即可</li></ul><p>查找时间复杂度：O (1)<br /> 合并时间复杂度：O (n)</p><ul><li>主要是更新指向头节点指针耗时</li></ul><h3 id="基于树的实现"><a class="anchor" href="#基于树的实现">#</a> 基于树的实现</h3><p>为降低 union 操作时间复杂度，可以使用树的方式实现<br />基于树的并查集实现，使用树来表示集合，树的根节点作为集合代表来标识集合</p><ul><li>判断节点所属集合时，通过借助节点父节点指针，向上追溯，沿着节点路径到达根节点</li><li>合并时，只需要把一棵树拼接到另一棵树：让其中一棵树的根节点指针指向另一棵树的根节点即可</li></ul><p>因此，按树实现方式虽然会减少合并消耗，但是会增加查找时间复杂度<br />为避免查询时间复杂度增加过高，需要尽量让树 矮胖 而非 高瘦</p><ul><li>按秩合并<ul><li>记录树的高度，称为秩 (rank)</li><li>若两棵树的秩不同，合并后的秩为原高度大的树的秩</li><li>若两棵树的秩相同，合并后的秩等于原秩 + 1</li></ul></li><li>路径压缩（更有效）<ul><li>在借助父节点指针追溯根节点时，将经过路径上的所有节点父节点指针都更新为指向根节点（再次查找就快了）</li></ul></li></ul><p>合并时间复杂度：O (1)<br /> 查找时间复杂度：路径压缩后，O (1)<br /> 两个优化是可以同时支持的</p><h2 id="线段树"><a class="anchor" href="#线段树">#</a> 线段树</h2><p>如果我们需要罗列落在某个区间的所有数据，基于跳表的实现方案最优<br />但若是只需要统计落在某个区间的数据『个数』，即解决区间统计问题时，线段树更加高效</p><ul><li>假设数据集合最大值为 m，且数据都是正整数，可以构建一棵特殊的二叉树，每个节点代表一个区间，包含 3 个基本数据：区间起始点、区间结束点和统计值 (如数据个数，具体视需求而定)</li><li>根节点表示最大区间 [1,n]，左右子节点分别代表 [1,n/2]、[n/2+1,n]</li><li>可采用数组形式存储（虽然不是完全二叉树，可能会浪费一定空间，不过由于线段树叶子节点主要集中在最后两层，整体空洞不大，可以接受。另外还有链式方式）</li></ul><p>空间复杂度：O (n)</p><ul><li>与数据集合个数无关，与数据集合最大值有关</li></ul><p>时间复杂度：</p><ul><li>构建：O (n)</li><li>插入、删除：O (logn)</li></ul><p>线段树能解决的问题统一称为区间统计问题，除统计区间数据个数外，还可以统计某个区间数据之和、最大值和最小值，以及某个区间第 k 大值<br />注：关于线段树数据存储大小</p><ul><li>如果 n 恰好是 2 的 k 次幂，由于线段树最后一层的叶子节点存储的是数组元素本身，最后一层的节点数就是 n，前面所有层的节点数之和是 n−1，那么总节点数就是 2×n−1。为了方便起见，分配 2×n 的空间。</li><li>如果 n 不是 2 的 k 次幂，最坏的情况就是 n=2k+1，那么有一个元素需要开辟新的一层来存储，需要 4×n−5 的大小。为了方便起见，可以分配 4×n 的空间</li></ul><h2 id="树状数组"><a class="anchor" href="#树状数组">#</a> 树状数组</h2><p>可以解决大部分基于区间上的更新以及求和问题</p><ul><li>所有树状数组能做的，线段树也能做，不过树状数组的优点是简单（但是原理反而感觉更难理解一些）、效率更高点</li><li>利用线段树可以解决区间统计问题，利用树状数组可以解决前缀和问题，区间统计包括 前缀和</li></ul><p>时间复杂度：O (logn)，</p><ul><li>相比线段树系数更少</li><li>缺点是功能有限，不能解决复杂区间问题</li></ul><h3 id="前缀和"><a class="anchor" href="#前缀和">#</a> 前缀和</h3><p>标准做法：创建一个 n+1 大小的前缀和数组，遍历计算，前缀和数组下标从 1 开始</p><ul><li>preSum[i]=preSum[i-1]+array[i]</li><li>要么更新元素慢 (更新时计算)，要么查询前缀和操作慢 (查询时计算)</li></ul><p>任何一个数，都可以分解为一组 2 的 k 次方的和</p><ul><li>6=b110=2<sup>2+2</sup>1+2^0</li><li>7=b111=2<sup>2+2</sup>1+2^1</li></ul><p>lowbit：求某一个数的二进制表示中最低的一位 1，例如 6 返回 2</p><ul><li><s>先消掉最后一位 1，然后再用原数减去消掉最后一位 1 后的数</s></li><li>求负数的二进制补码表示：负数的补码为其绝对值取反后加 1，然后与原数进行与操作  i&amp;(-i)，正好得到最低一位 1</li></ul><p>前缀和可通过递推公式计算</p><ul><li>假设数组 c 存放所有通过 lowbit 计算出来的对应数值的和</li><li>那么前缀和 preSum=preSum [i-lowbit (i)]+c [i]</li></ul><p>借助树状数组，可以将前缀和更新操作的时间复杂度降低到 O (logn)</p><h1 id="第八章-字符串匹配算法"><a class="anchor" href="#第八章-字符串匹配算法">#</a> 第八章 字符串匹配算法</h1><p>概念：主串和模式串，所有字符串匹配算法都会用到</p><ul><li>如果在字符串 a 中查找字符串 b，那么字符串 a 就是 主串，字符串 b 就是模式串</li><li>将主串长度记作 n，模式串长度记作 m</li><li>一般情况下，n 大于或等于 m；若 n 小于 m，则主串中必然不存在模式串</li></ul><h2 id="bf算法"><a class="anchor" href="#bf算法">#</a> BF 算法</h2><h3 id="原理与实现"><a class="anchor" href="#原理与实现">#</a> 原理与实现</h3><p>BF（Brute Force，暴力匹配）算法，也称为朴素匹配算法，该算法比较暴力，简单直接，因此性能不高</p><ul><li>如果模式串长度为 m，主串长度为 n，那么在主串中就会有 n-m+1 个长度为 m 的子串</li><li>只需要暴力对比这 n-m+1 个子串与模式串，就可以找出主串与模式串匹配的子串</li></ul><h3 id="性能-2"><a class="anchor" href="#性能-2">#</a> 性能</h3><p>最坏时间复杂度：O (nm)<br /> 虽然时间复杂度较高，但实际却比较常用</p><ul><li>实际开发中，大部分情况模式串和主串长度不会太长，数据规模较小（小规模下性能与更加高效的 KMP、BM 算法可能相差无几）</li><li>每次模式串与主串中字符串匹配时，若中途遇到不能匹配字符，可提前终止</li><li>BF 算法思想简单，代码实现也简单（意味着不容易出错）</li></ul><h2 id="rk算法rabin-karp"><a class="anchor" href="#rk算法rabin-karp">#</a> RK 算法（Rabin-Karp）</h2><p>对 BF 算法的优化，借助哈希算法提高匹配效率</p><h3 id="原理"><a class="anchor" href="#原理">#</a> 原理</h3><p>通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较</p><ul><li>若某个哈希值相等，则说明匹配</li></ul><p>哈希计算优化</p><ul><li>假设主串和模式串对应字符集只包含 k 个字符，那么就可以用一个 k 进制数表示一个子串</li></ul><p>时间复杂度：O (n)</p><ul><li>RK 算法的执行效率取决于哈希算法</li><li>若事先缓存，则会有额外空间复杂度消耗</li></ul><h2 id="bm算法boyer-moore"><a class="anchor" href="#bm算法boyer-moore">#</a> BM 算法（Boyer-Moore）</h2><p>模式串和主串的匹配过程可以看做模式串在主串中不停地往后滑动，当遇到不匹配字符串时，BF 算法和 RK 算法的做法：将模式串往后滑动一位，从模式串第一个字符重新开始匹配</p><ul><li>BM 算法本质上就是在寻找某种规律，借助这种规律，在模式串与主串匹配过程中，能够跳过一些肯定不会匹配的情况，将模式串往后多滑几位，以此提高效率</li></ul><h3 id="原理-2"><a class="anchor" href="#原理-2">#</a> 原理</h3><ul><li>坏字符串规则（bad character rule）<ul><li>按照模式串下标从大到小顺序倒序进行</li><li>当发现某个字符无法匹配，就将该字符称为坏字符（指主串中字符）</li><li>用坏字符在模式串中查找，发现不存在则可以直接滑到坏字符之后</li><li>若坏字符在模式串中存在，则滑动对应位数，使其与模式串对齐，再重新匹配</li><li>滑动规则<ul><li>坏字符对应模式串下标记为 si，若在模式串存在，则记作 xi，不存在则 xi=-1</li><li>往后滑动位数 = si-xi，所以若不存在，滑动位数等于模式串字符个数 (length-1-(-1))</li><li>计算滑动位数有可能是负数，因此有好后缀规则补充</li></ul></li></ul></li><li>好后缀规则（good suffix rule）</li></ul><p>最坏时间复杂度：O (n)<br /> 最好时间复杂度：O (n/m)<br /> 注：空间复杂度较高</p><h2 id="kmp算法"><a class="anchor" href="#kmp算法">#</a> KMP 算法</h2><p>与 BM 算法本质一样，希望匹配过程中找到一些规律，多滑几位</p><ul><li>从前往后匹配</li><li>将不能匹配的字符称为坏字符</li><li>已经匹配的那段字符串称为好前缀</li></ul><p>空间复杂度：O (m) m 表示模式串长度<br />时间复杂度：O (m+n)</p><h2 id="trie树字典树"><a class="anchor" href="#trie树字典树">#</a> Trie 树（字典树）</h2><p>又叫前缀树 (prefix tree)，属于多模式串匹配算法<br />是一个树形结构，用来解决在一组字符串集合中快速查找某个字符串的问题<br />本质上是利用字符串之间的公共前缀，将重复的前缀合并在一起</p><ul><li>根节点不包含信息</li><li>其它每个节点表示字符串中一个字符</li><li>从根节点到到某节点一条路径表示字符串集合中的一个字符串（添加字符串时，需要将字符串结尾节点设置为 EndingChar，以使查找时能区分）</li></ul><h3 id="效率"><a class="anchor" href="#效率">#</a> 效率</h3><p>构建时间复杂度：O (m*len)</p><ul><li>len 表示模式串平均长度，m 表示模式串个数</li></ul><p>查询时间复杂度：O (k)</p><ul><li>k 表示待查询字符串长度</li></ul><p>字符串匹配非常高效，不过由于借助了空间换时间的设计思路，内存消耗较大</p><ul><li>例如每个节点存储字符串的数据结构，需借助有序数组、哈希表、红黑树</li></ul><h3 id="总结-5"><a class="anchor" href="#总结-5">#</a> 总结</h3><p>对于精确匹配，哈希表或红黑树更加适合<br />对于模糊查找，例如查找前缀匹配字符串，Trie 树更合适、无可替代</p><ul><li>如关键词提示</li><li>自动输入补全</li></ul><h2 id="ac自动机多模式串匹配实现敏感词过滤"><a class="anchor" href="#ac自动机多模式串匹配实现敏感词过滤">#</a> AC 自动机：多模式串匹配实现敏感词过滤</h2><ul><li>单模式串匹配算法是指在一个模式串和一个主串之间进行匹配</li><li>多模式匹配串算法是指在多个模式串和一个主串之间作匹配（在一个主串中同时查找多个模式串）<ul><li>只需要扫描一遍主串，就可以在主串中一次性查找多个模式串是否存在</li></ul></li></ul><h3 id="基于-trie-树的敏感词过滤"><a class="anchor" href="#基于-trie-树的敏感词过滤">#</a> 基于 Trie 树的敏感词过滤</h3><p>对敏感词库进行预处理，构建成 Trie 树</p><ul><li>将用户输入作为主串，从第一个字符开始，在 Trie 树中进行匹配</li><li>当匹配到 Trie 树叶子节点或中途遇到不匹配字符时，将主串起始匹配位置向后移一位，重新从根节点开始</li></ul><h3 id="基于-ac自动机的敏感词过滤"><a class="anchor" href="#基于-ac自动机的敏感词过滤">#</a> 基于 AC 自动机的敏感词过滤</h3><p>借鉴单模式串匹配算法优化思路，对 Trie 树进行优化，进一步提高效率，产生 AC 自动机</p><ul><li>类似于单模式串匹配算法中 BF 与 KMP 的关系</li></ul><p>主要操作</p><ul><li>将多个模式串构建成 Trie 树</li><li>在 Trie 树上构建失败指针<ul><li>失败指针指向『最长可匹配后缀子串』</li><li>例如 abc 后缀子串为 bc、c，将其与其它模式串匹配，若两个都能匹配上，则最长可匹配后缀子串为 bc</li></ul></li></ul><p>匹配的时间复杂度：O (n*len)</p><ul><li>与 Trie 树一样</li><li>但实际情况下，由于失败指针优化，可以接近 O (n)</li></ul><h1 id="第九章-图"><a class="anchor" href="#第九章-图">#</a> 第九章 图</h1><h2 id="图的表示如何存储社交网络中好友关系"><a class="anchor" href="#图的表示如何存储社交网络中好友关系">#</a> 图的表示：如何存储社交网络中好友关系</h2><h3 id="图的定义"><a class="anchor" href="#图的定义">#</a> 图的定义</h3><p>图 (graph) 与树一样，也是一种非线性表，不过相比树更复杂</p><ul><li>对应树中元素称为节点，图中的元素称为顶点 (vertex)</li><li>图中一个顶点可以与任意其它顶点建立连接关系，这种连接关系称为边 (edge)</li><li>与顶点相连接的边的条数，称为顶点的度 (degree)</li><li>边有方向的称为有向图，边没有方向的称为无向图</li><li>无向图中顶点的度表示此顶点有多少条边与之相连，有向图中则分为入度 (in-degree) 和出度 (out-degree)</li><li>带权图 (weighted graph)：每条边都有一个权重</li></ul><h3 id="邻接矩阵的存储方法"><a class="anchor" href="#邻接矩阵的存储方法">#</a> 邻接矩阵的存储方法</h3><p>邻接矩阵（adjacency matrix），底层依赖二维数组</p><ul><li>对于无向图，若顶点 i 与 j 之间有边，则将 A [i][j] 和 A [j][i] 标记为 1</li><li>对于有向图，则只标记有连接的为 1</li><li>对于带权图，数组中存储对应权重</li></ul><p>邻接矩阵存储方式，可能比较浪费空间，特别是对于稀疏图（sparse matrix）来说，顶点很多，每个顶点的边并不多</p><h3 id="邻接表的存储方法"><a class="anchor" href="#邻接表的存储方法">#</a> 邻接表的存储方法</h3><p>邻接表（adjacency list），每个顶点对应一条链表</p><ul><li>对于有向图，每个顶点对应的链表存储其指向的顶点</li><li>对于无向图，每个顶点对应的链表存储的是与这个顶点有边相连的顶点</li></ul><p>邻接矩阵存储起来比较浪费空间，但使用起来更高效<br />邻接表存储起来比较节省空间，但使用起来就没那么高效了（当然邻接表的链表数据结构也可以再优化，换成更合适的数据结构）</p><h2 id="深度优先搜索与广度优先搜索"><a class="anchor" href="#深度优先搜索与广度优先搜索">#</a> 深度优先搜索与广度优先搜索</h2><p>六度分割理论：只需要六层关系就能认识任何一个陌生人；即与任何一个陌生人之间能通过 5 个中间人建立关系</p><h3 id="搜索算法"><a class="anchor" href="#搜索算法">#</a> 搜索算法</h3><p>搜索：在图中寻找从一个顶点出发到另一个顶点的路径<br />深度、广度优先搜索是针对无权图的搜索算法</p><h3 id="广度优先搜索breadth-first-searchbfs"><a class="anchor" href="#广度优先搜索breadth-first-searchbfs">#</a> 广度优先搜索（Breadth First Search，BFS）</h3><p>是一直地毯式层层推进的搜索策略，首先查找距离起始顶点 s 最近的，然后是次近的，依次往外搜索，直到找到终止顶点<br />时间复杂度：O (V+E)</p><ul><li>V 表示顶点个数</li><li>E 表示边的个数</li></ul><p>空间复杂度：O (V)</p><h3 id="深度优先搜索depth-first-searchdfs"><a class="anchor" href="#深度优先搜索depth-first-searchdfs">#</a> 深度优先搜索（Depth First Search，DFS）</h3><p>不撞南墙不回头策略<br />即走完一条路径之后，才可能搜索下一个节点路径<br />时间复杂度：O (V+E)<br /> 空间复杂度：O (V)</p><h2 id="拓扑排序"><a class="anchor" href="#拓扑排序">#</a> 拓扑排序</h2><p>拓扑排序运行在有向无环图上<br />一般可用于通过局部顺序推导全局顺序问题，还能检测图中是否存在环</p><ul><li>通过局部的依赖关系、先后顺序，推导出一个满足所有局部依赖关系的执行序列</li><li>解决算法主要有两种：Kahn 算法和深度优先搜索</li></ul><h3 id="kahn算法实现拓扑排序"><a class="anchor" href="#kahn算法实现拓扑排序">#</a> Kahn 算法实现拓扑排序</h3><p>Kahn 算法利用贪心算法思想<br />在定义数据结构时，若 s 需要先于 t 执行，就添加一条 s 指向 t 的边</p><ul><li>因此每个顶点的入度表示这个顶点依赖多少个其它顶点</li><li>若某个顶点入度变成 0，则表示该顶点没有依赖的顶点了（或者说依赖都已执行）</li><li>从图中找出一个入度为 0 的顶点，将其输出到拓扑排序结果序列，所有依赖它的顶点入度都可以减 1（即将该顶点可达顶点入度减 1）<ul><li>循环执行该过程，最后输出序列即为满足所有局部依赖关系的一个拓扑排序</li></ul></li></ul><p>时间复杂度：O (V+E)</p><h3 id="深度优先搜索实现拓扑排序"><a class="anchor" href="#深度优先搜索实现拓扑排序">#</a> 深度优先搜索实现拓扑排序</h3><p>或者应该叫『深度优先遍历』，需要遍历图中所有顶点，而非只是搜索一个顶点到另一个顶点的路径</p><ul><li>通过邻接表构建逆邻接表</li><li>在邻接表中，s-&gt;t 表示 s 先于 t 执行，即 t 依赖于 s</li><li>在逆邻接表中，s-&gt;t 表示 s 后于 t 执行，即 s 依赖于 t</li><li>递归处理每个顶点，先输出其可达所有顶点，再输出自己</li></ul><p>时间复杂度：O (V+E)</p><h3 id="利用拓扑排序检测环"><a class="anchor" href="#利用拓扑排序检测环">#</a> 利用拓扑排序检测环</h3><p>对于 Kahn 算法，如果最终输出顶点个数少于图中顶点个数，也就是图中还存在入度不是 0 的顶点，就说明图中存在环</p><h2 id="单源最短路径"><a class="anchor" href="#单源最短路径">#</a> 单源最短路径</h2><p>例如地图做优出行路线<br />适用于场景抽象成有权图的搜索<br />单源最短路径算法不仅能求得单个源点到单个终点的最短路径，还能一次性求得单个源点到多个终点的最短路径</p><h3 id="dijkstra算法"><a class="anchor" href="#dijkstra算法">#</a> Dijkstra 算法</h3><p>类似于广度优先搜索，每次找到与起点最近的顶点，往外扩展</p><ul><li>用一个优先级队列记录已经遍历的顶点</li><li>取与起点路径长度最小顶点进行扩展</li></ul><p>构建于有向有权图之上，要求不能存在负权边</p><ul><li>将所有顶点除初始顶点外的距离初始化为 int.max</li><li>将起始顶点距离初始化为 0，放入优先级队列中</li><li>从优先级队列中取出距离最短的顶点，然后考察该顶点可达的所有顶点</li><li>若顶点距离加上前往考察顶点边权重，的值小于考察顶点距离，则将其距离更新为顶点距离 + 权重，并将考察顶点加入优先级队列（重复该过程）</li></ul><p>时间复杂度：O (ElogV)</p><h2 id="多源最短路径"><a class="anchor" href="#多源最短路径">#</a> 多源最短路径</h2><h3 id="floyd算法"><a class="anchor" href="#floyd算法">#</a> Floyd 算法</h3><p>Floyd 算法：可以一次性计算出图中任意两个顶点之间的最短路径<br />与 Dijkstra 算法一样，既可以处理有向图，也可以处理无向图，但 Floyd 算法允许图中存在负权边（但不允许存在负权环）<br />该算法利用了动态规划思想，状态转移方程式：</p><ul><li>dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j])</li></ul><p>多阶段决策模型：将整个算法划分为 v 个阶段，每个阶段引入一个中转节点，基于上一个节点状态，推导下一个阶段状态<br />时间复杂度：O (V^3)</p><h2 id="启发式搜索"><a class="anchor" href="#启发式搜索">#</a> 启发式搜索</h2><p>heuristically search algorithm</p><h3 id="a算法"><a class="anchor" href="#a算法">#</a> A * 算法</h3><p>能实现快速寻找次优路线，对 dijkstra 算法的优化改造<br /> dijkstra 算法可能跑偏，因为其主要按照顶点与起点的路径长度排出出队顺序，与起点越近的顶点，就会越早出队，但是并未考虑其与终点距离</p><ul><li>因此，将顶点到终点距离也考虑进去，综合判断哪个顶点应该先出队列，避免跑偏</li></ul><p>不过，尽管 A * 算法可以更加快速地找到起点到终点的路线，但并不能像 Dijkstra 算法那样找到最短路径</p><ul><li>A * 算法只要找到终点即结束，不会考察所有路线</li><li>Dijkstra 算法则是终点出队结束，实际上考察了从起点到终点所有路线</li></ul><p>启发式搜索算法利用估价函数避免跑偏，贪心地朝着最有可能到达终点的方向前进，因此找出并非最短路径，而是次优路径。但工程中路径规划问题往往不需要如此精确，因此启发式搜索算法能更好地平衡路线质量和执行效率，应用更加广泛</p><h2 id="最小生成树随机生成迷宫地图"><a class="anchor" href="#最小生成树随机生成迷宫地图">#</a> 最小生成树：随机生成迷宫地图</h2><h3 id="什么是最小生成树"><a class="anchor" href="#什么是最小生成树">#</a> 什么是最小生成树</h3><p>假设图包含 V 个顶点和 E 条无向有权边，要连通所有顶点，至少需要 V-1 条边（对于一个连通图，V-1 肯定小于或等于 E）</p><ul><li>这 V-1 条边和 V 个顶点构成一棵树，称为生成树</li><li>图的生成树并不是唯一的，如果某棵生成树包含的 V-1 条边的权重和最小，那么这棵树就称为最小生成树（Minimum Spanning Tree，MST）</li></ul><p>最小生成树在现实生活中应用就很多，例如 V 个城市建立通信网络最省铺设线路方式、道路建设等</p><h3 id="kruskal算法"><a class="anchor" href="#kruskal算法">#</a> Kruskal 算法</h3><p>贪心算法思想</p><ul><li>利用并查集，初始时每个顶点对应一个集合，按照权重从小到大依次考察每条边</li><li>如果某条边对应的两个顶点不在同一个集合中，就将这条边选入最小生成树中，并将两个顶点对应集合合并<ul><li>若某条边对应两个顶点在同一个集合，说明两个顶点已经连通，若再添加一条边会导致形成环</li></ul></li><li>依此类推，考察每条边，直到最小生成树中包含 V-1 条边为止</li></ul><p>时间复杂度：O (ElogE)</p><h3 id="prim算法"><a class="anchor" href="#prim算法">#</a> Prim 算法</h3><p>同样利用贪心算法思想<br />在 Prim 算法中，使用优先级队列存储待考察顶点、以及前驱顶点与这个顶点之间的边的权重</p><ul><li>先初始化一棵只包含图中最小边的最小生成树</li><li>基于当前的最小生成树，考察与最小生成树相连的所有边，找到权重最小且加入不会导致最小生成树中包含环的那个边，将这个边加入最小生成树</li><li>依此类推，重复第二步，直到最小生成树中包含 V-1 条边</li></ul><p>具体步骤</p><ul><li>初始选择一个顶点，将该顶点相连的边放入优先级队列</li><li>从优先级队列中取出队首元素</li><li>若边的两个顶点均已访问，则不进行任何处理，跳入下一轮</li><li>若边对应顶点中，有一个顶点未访问，则将这条边加入最小生成树中，并考察与其相连的所有边</li><li>直到有 V-1 条边出队，此时即为最小生成树</li></ul><p>时间复杂度：O (ElogE)</p><h3 id="随机-prim算法"><a class="anchor" href="#随机-prim算法">#</a> 随机 Prim 算法</h3><p>将迷宫中元素分为两类：道路、墙</p><ul><li>初始迷宫没有任何道路，可以将迷宫中每个单元格看作图中一个顶点，墙看作一条边</li><li>一堵墙要么连接左右两个道路单元格，要么连接上下两个道路单元格</li><li>在这样一个图上，寻找一棵生成树，生成树中包含的边代表墙将被打通（移除）</li><li>因为生成树包含所有的顶点，且连通所有的顶点，将生成树中边对应的墙从迷宫地图移除，所以所有这样的道路单元格就打通了</li><li>任选一个迷宫的起点和终点，都会有相应的通路</li></ul><p>随机 Prim 算法与 Prim 算法处理思路几乎相同，唯一区别在于将优先级队列改为了随机队列，从随机队列取出的元素是随机选择元素，而非权重最小元素</p><ul><li>对于随机生成迷宫问题，抽象出来的是无权图，只需要求得生成树即可满足要求</li></ul><h2 id="最大流"><a class="anchor" href="#最大流">#</a> 最大流</h2><p>针对一张有向权图，选定两个顶点分别作为源点 s 和汇点 t，计算从源点到汇点的最大流量</p><ul><li>即源点可以发出的最大流量，也等于汇点可以接受的最大流量</li></ul><p>最大流算法很多，大体可以分为两类：</p><ul><li>基于增广路径（augmenting path）的算法</li><li>基于推送 - 重贴标签（push relabel）的算法</li></ul><p>例如应用于网络流</p><h3 id="ford-fulkerson方法"><a class="anchor" href="#ford-fulkerson方法">#</a> Ford-Fulkerson 方法</h3><p>基于增广路径<br />之所以称为方法而非算法，是因为其只给出了求解最大流框架思路，而非具体实现<br />基本原理非常简单：即通过不停地在残余网络中寻找增广路径来求解最大流。不过也需要对基本原理进行修正，通过增加反向边对之前的增广路径实现『改道』</p><ul><li>用 g [i][j] 表示顶点 i 到顶点 j 的边的权值 (容量)，初始从源点到汇点的最大流值 maxflow=0</li><li>在图中找出一条从源点到汇点的可达路径 p<ul><li>假设路径中最小边的权值是 delta，也就表示这条路径可以输送 delta 大小的流量</li></ul></li><li>将 delta 值加到 maxflow 上，并将路径 p 中所有边的容量都减去 delta</li><li>这条流量为 delta 的路径称为增广路径，将增广路径从图中移除后，剩下的图即为残余网络，使用 c [i][j] 记录残余网络中顶点 i 到顶点 j 的残余容量</li><li>不停在残余网络中寻找增广路径，然后增加 maxflow 值 -&gt; 移除增广路径，直到残余网络中没有增广路径为止</li><li>最后得到的 maxflow 值就是图的最大流，此时 g [i][j]-c [i][j] 就是对应 maxflow 每条边流过的流量</li></ul><p>注 1：指的是所有路径加起来的流量，以及所有可以自己独立运行，不互相干涉的路径<br />单纯像上述计算，会有缺陷，可能找出的不一定是最大流</p><ul><li>调整方式：其它逻辑不变，当找到一条增广路径后，不仅将其从图中移除，还会将反向的增广路径添加至残余网络</li><li>即，例如找到 i~j，将其流量减掉后，反向添加 j~i 的流量（即，使存在反向边）</li></ul><h3 id="edmonds-karp算法"><a class="anchor" href="#edmonds-karp算法">#</a> Edmonds-Karp 算法</h3><p>利用广度优先搜索实现的 Ford-Fulkerson 方法称为 Edmonds-Karp 算法</p><h2 id="最大二分匹配"><a class="anchor" href="#最大二分匹配">#</a> 最大二分匹配</h2><p>对于一个二分图，图中顶点分为左右两个部分，所有的边都横跨左右两部分，起始顶点在左，结束顶点在右<br />如果某两个顶点有边相连，称其为可匹配，一个顶点最多与一个顶点匹配成功<br />找出二分图中最大可匹配树，即为最大二分匹配</p><ul><li>例如单身交友联谊匹配问题</li></ul><p>可在二分图上补充两个顶点，一个源点，一个汇点。源点连接左半部分，汇点连接右半部分，即可转换为最大流问题</p><h1 id="第十章-贪心-分治-回溯和动态规划"><a class="anchor" href="#第十章-贪心-分治-回溯和动态规划">#</a> 第十章 贪心、分治、回溯和动态规划</h1><h2 id="贪心算法greedy-algorithm"><a class="anchor" href="#贪心算法greedy-algorithm">#</a> 贪心算法（greedy algorithm）</h2><p>应用：霍夫曼编码 (Huffman coding)、Prim、最小生成树等<br />针对一组数据，事先定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大</p><ul><li>套用贪心算法模型</li><li>尝试用贪心算法解决；每次选择对限制值同等贡献量的情况下，对期望值贡献最大的数据</li><li>举例验证算法是否正确</li></ul><p>注：使用贪心算法解决问题，并不总能给出最优解</p><ul><li>主要原因在于贪心选择过程中前面的选择会影响后面的选择</li><li>例如即便第一步选择了最优解 (权值最小)，但也可能因为这一步的选择，导致后面可选择的路径不是最好的</li></ul><p>对于贪心算法，最难的是将要解决的问题抽象成贪心算法模型，只要完成这一步，贪心算法就会很简单</p><h3 id="霍夫曼编码"><a class="anchor" href="#霍夫曼编码">#</a> 霍夫曼编码</h3><p>霍夫曼编码是一种非常有效的编码方法，广泛应用于数据压缩中，压缩率通常为 20%～90%<br /> 霍夫曼编码使用一种特别的方法为信号源中的每个符号设定二进制码。出现频率更大的符号将获得更短的比特，出现频率更小的符号将被分配更长的比特，以此来提高数据压缩率，提高传输效率</p><ul><li>其不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率</li><li>根据频率不同，选择不同长度的编码，使用这种不等长的编码方法进一步提高压缩效率</li><li>由于编码不定长，因此解压缩时比较复杂，另外为了避免歧义，要求各个字符编码之间不能出现某个编码是另一个编码前缀的情况</li></ul><p>编码方式</p><ul><li>将每个字符看作一个节点，并把对应的出现频率一起放到优先级队列中</li><li>从优先级队列中取出出现频率最小的两个节点 A、B</li><li>新建一个节点 C，其频率设置为两个节点之和，然后将两个节点设置为 C 节点的子节点</li><li>将 C 节点放入优先级队列中（A、B 节点将标记为已处理）</li><li>重复操作直到队列没有未处理数据，最终将得到一棵霍夫曼树</li><li>霍夫曼树构造完成对树进行编码，左子节点标记为 0，右子节点标记为 1（左 0 右 1），从根节点到叶子节点的路径就是叶子节点对应的霍夫曼编码（二进制）</li></ul><h2 id="分治算法"><a class="anchor" href="#分治算法">#</a> 分治算法</h2><p>分治算法（divide and conquer）核心思想其实就 4 个字：分而治之</p><ul><li>将原问题划分成 n 个规模更小并且结构与原问题相似的子问题，递归地解决这些子问题，然后合并结果得出原问题解</li></ul><p>条件</p><ul><li>原问题与分解成的小问题具有相同的结构</li><li>由原问题分解成的子问题可以独立求解，相互没有相关性（与动态规划的明显区别）</li><li>具备分解终止条件</li><li>可以将子问题合并成原问题的结果</li></ul><h3 id="应用示例"><a class="anchor" href="#应用示例">#</a> 应用示例</h3><p>求一组数据的逆序对个数<br />我们使用一组数据中包含的有序对或逆序对个数来表示有序度或逆序度</p><ul><li>有序度：一组数据的有序程度</li><li>逆序度：一组数据的无序程度</li></ul><p>使用归并排序，排序合并两个元素组时顺便统计：合并时判断左边元素是否大于右边元素进行统计</p><h2 id="回溯算法"><a class="anchor" href="#回溯算法">#</a> 回溯算法</h2><p>如深度优先搜索即利用回溯算法思想<br />我们一生中，会遇到很多重要的『岔路口』，每个选择都会影响我们今后的人生。有的人在每个岔路口都能做出正确的选择，生活、事业达到一个新的高度。而有的人一旦选错，最后可能碌碌无为。<br />贪心算法，每次面对选择时，都能做出『当下』最优选择，期望这一局部最优使我们达到全局最优。但是，贪心算法不一定能得到最优解。</p><h3 id="理解"><a class="anchor" href="#理解">#</a> 理解</h3><p>回溯的处理思想有点类似枚举（或穷举），枚举所有的解，找出其中满足期望的解</p><ul><li>为了有规律枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段</li><li>每个阶段都会面对一个『岔路口』，先随意选择一条路走，当发现这条路走不通时 (不符合期望解)，就回退到上一个『岔路口』，另选一种走法继续走</li></ul><h3 id="应用"><a class="anchor" href="#应用">#</a> 应用</h3><ul><li>八皇后问题</li><li>0~1 背包问题（经典解法是动态规划，回溯算法也可以，但性能没那么好）</li><li>正则表达式匹配</li><li>图的着色</li><li>旅行商</li><li>数独</li><li>求全排列</li></ul><h2 id="动态规划"><a class="anchor" href="#动态规划">#</a> 动态规划</h2><p>动态规划比较适合用来求最值问题，如最大值最小值等，可以显著降低时间复杂度，提高代码执行效率<br />大部分动态规划能解决的问题，也可以通过回溯算法解决，不过时间复杂度较高<br />动态规划可以避免重复计算，并利用上一阶段的最优状态来推导下一个阶段的状态，但是动态规划的空间复杂度也提高了，相当于空间换时间的算法思想</p><h3 id="理论"><a class="anchor" href="#理论">#</a> 理论</h3><p>一个模型和三个特征</p><ul><li>一个模型指动态规划适合解决的问题的模型：多阶段决策模型<ul><li>一般用动态规划来解决最优问题，并把解决问题过程划分为多个决策阶段，每个决策阶段对应一组状态</li><li>寻找一组决策序列，经过这组决策序列能够产生最终期望求解的最优指</li></ul></li><li>三个特征<ul><li>最优子结构：问题的最优解包含子问题的最优解，可以通过子问题最优解推导出问题最优解（后面阶段状态可以通过前面阶段状态推导而来）</li><li>无后效性：在推导后面阶段状态时，只关心前面阶段状态的状态值，不关心这个状态是如何推导出来的。某阶段状态一旦确定，就不受之后阶段的决策影响</li><li>重复子问题</li></ul></li></ul><h3 id="两种解题方法"><a class="anchor" href="#两种解题方法">#</a> 两种解题方法</h3><p>状态转移表法</p><ul><li>先设计一个状态表（一般是二维的）</li><li>每个状态包含 3 个变量：行、列和数组值</li><li>根据决策先后过程，分阶段填充状态表中的每个状态</li><li>将递推填表过程翻译成代码</li></ul><p>状态转移方程法</p><ul><li>有点类似递归思路：需要分析某个问题如何通过子问题来求解，找最优子结构，根据最优子结构写递推公式，即状态转移方程</li></ul><h2 id="四种算法对比"><a class="anchor" href="#四种算法对比">#</a> 四种算法对比</h2><p>贪心、回溯、动态规划可以划分为一类，分治可以单独作为一类。前三个算法解决问题模型多数可以抽象成多阶段决策模型，分治虽然也是求最优解，但大部分不能抽象为多阶段决策最优解模型<br />回溯是个比较万金油算法，对于能用动态规划、贪心解决的问题基本也能用回溯解决。回溯相当于穷举搜索，穷举所有情况对比得到最优解，因此时间复杂度较高，为指数级别，只能用于解决小规模问题<br />在重复子问题上，动态规划和分治算法区别明显：分治算法要求分解后的子问题不能有重复子问题，动态规划正好相反，正是为了解决分解后子问题有重复而存在<br />贪心实际上动态规划的一种特殊情况，具有贪心选择性：通过局部最优解能产生全局最优选择</p><h1 id="总结-6"><a class="anchor" href="#总结-6">#</a> 总结</h1><p>总之，比较推荐，图文并茂。就算之前知道的，说不定都会有新的认识</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;例行总结一下时间：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;/blogimages/2023/2023-06-04/Snipaste_2023-06-04_20</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>烤箱、厨师机与电饭锅</title>
    <link href="https://wangjiaying.top/2023/06/04/%E7%83%A4%E7%AE%B1%E5%8E%A8%E5%B8%88%E6%9C%BA%E4%B8%8E%E7%94%B5%E9%A5%AD%E9%94%85/"/>
    <id>https://wangjiaying.top/2023/06/04/%E7%83%A4%E7%AE%B1%E5%8E%A8%E5%B8%88%E6%9C%BA%E4%B8%8E%E7%94%B5%E9%A5%AD%E9%94%85/</id>
    <published>2023-06-04T09:44:03.000Z</published>
    <updated>2023-06-04T11:55:06.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>事情是这样的：前几天不知道为什么，突然想吃蛋糕，然后想自己做。</p><p>正好这几天是每年例行的 618 也开始了，于是就研究着想买点工具</p><p>有时候感觉个人不知道是强迫症还是完美主义，一旦想买什么的，就想买现阶段对自己最『合适』的，也就是性价比最高的 (当然肯定不是最好的，毕竟不谈性价比都是耍流氓，不顾性价比的话哪还需要挑什么对吧？)</p><p>总之，为了『性价比』和适用性，这几天在这个挑选、研究上浪费的时间已经足以让我给它记下一笔了。</p><h1 id="为什么"><a class="anchor" href="#为什么">#</a> 为什么</h1><p>想吃蛋糕，为什么不直接买？</p><p>主要原因有三个：</p><ol><li>太贵</li><li>之前买菜的超市早已经不卖蛋糕了，所以买菜的时候顺便挑一点的做法已经不行了</li><li>网上的袋装版本，也不知道添加了多少科技 (材料也不见得多好)</li></ol><p>相信主要原因... 都知道为啥，有句话说的好：『授之以鱼不如授之以渔』同样的道理</p><h1 id="经过"><a class="anchor" href="#经过">#</a> 经过</h1><p>做蛋糕至少需要哪些器具？</p><ul><li>—— 烤箱、电动打蛋器</li></ul><p>这两样必不可少吧 (虽然有人说还有电饭煲蛋糕，那个...em...)</p><h2 id="烤箱"><a class="anchor" href="#烤箱">#</a> 烤箱</h2><p>然后烤箱，又有机械式、智能的之分，出于作为『新手』的考虑，还是决定选个可以联网的，能有菜单的保险一点，比如小米最新的出烤箱 MKX01M：</p><ul><li>原价 999，现价 699，第三方 599，京东再打折就四百多了，感觉可以买？</li></ul><p>然后又看到还有什么蒸烤一体的？小米也有一个，打折下来好像也贵不了多少</p><p>于是查找相关信息，又去对比两者评论：淘宝评论、京东评论、小米商城评论以及点评啥的。</p><p>什么烤箱更专业，有热管，做出来蛋糕更好吃。而且小米蒸烤一体有点旧了 (2020 年)，属于几年前的款式，底盘蒸发式的。另外评论结果显示也不大好，有人还晒出生锈的图 —— 毕竟就几百块的东西，不能指望太多。<br />烤箱则显示是 2022 年 10 月上市，距离现在也不过半年，根据买新不买旧的原则，加之感觉自己也少用到蒸箱功能，于是决定还是纯烤箱吧。</p><p>总之，先把这个挑好，然后又是打蛋器。</p><h2 id="打蛋器"><a class="anchor" href="#打蛋器">#</a> 打蛋器</h2><p>做蛋糕怎么可能手打 —— 我以前还真试过手动，总之结果很惨不忍睹... 因此一个电动的是必须的</p><p>都电动了，一直拿在手上是不是不大对？然后看到还有『台式』版本，感觉这个可以？</p><p>想一想，把蛋放进去，机器一开，只需要等几分钟就可以直接烤，蛋糕就出来了，是不是很方便？</p><p>越想越激动，经过慎重挑选，最终定下了一个顺然的打蛋器 (加入购物车)，几十块的</p><p>因为经过多方研究，发现台式打蛋器的轴并不会移动，只会旋转，网上有人说：打发的时候边缘根本 打 不 到！</p><p>这种坑还好提前发现了，于是果断还是把一个正常的电动打蛋器加入了购物车。</p><h2 id="厨师机"><a class="anchor" href="#厨师机">#</a> 厨师机</h2><p>上面提到了台式打蛋器的缺点，在不知道哪个评论或者文章？接收到一个信息：厨师机</p><p>厨师机就跟台式打蛋器差不多，不过这东西不但能打蛋，还能和面</p><p>经过对相关视频的观察，可以发现标记为  <code>厨师机</code>  的商品，其轴不但旋转，而且是可以移动的</p><p>不是很相信手动操作的打蛋器，决定直接买个厨师机，于是又从厨师机里开始挑选：</p><p>这个牌子就多了，什么顺然、志高、康佳、ACA、等等... 及一堆杂牌</p><p>然后查找相关信息：了解到噪音、电机、机体之类的区别</p><p>例如大多  <code>家用</code>  厨师机功率都有标高的嫌疑，直流电机会比交流电机噪音低 —— 然而大多数都是什么一千多瓦的交流电机，一千多瓦？</p><p>根据网上信息表示，要挑就挑直流的：于是找到一个  <code>最便宜</code>  的直流电机，牌子是康佳的，至少看着感觉应该... 是靠谱的吧？(还有一些没听说的杂牌的，感觉就算了)</p><p>当然我其实没有任何概念，秉承谨慎的原则，又去反复找  <code>直流电机</code> 、 <code>交流电机</code>  相关评论区的视频，去听噪音，后来又去 B 站找有没有相关可以做对比的视频...<br />—— 总之在这个上面花的时间比选烤箱还多，主要原因就是没有什么 <span class="spoiler" title="你知道得太多了！">比较便宜的</span> 大牌做这个的。<span class="spoiler" title="你知道得太多了！">(也不能说没有，还是有网友推荐的大牌，但是推荐的都是... 太贵了......)</span><br />(我挑个一两百的都挑几天，看到还有几千上万的家用版，还有不少销量，真是刷新认知)</p><h2 id="电饭锅"><a class="anchor" href="#电饭锅">#</a> 电饭锅</h2><p>以前买的美的电饭锅已经掉涂层了... 离现在才一年多啊...</p><p>这不是最近在买厨具么，于是也顺手查了一下... 完了，心里出现疙瘩了！</p><p>于是也在想着要不要给它换了，换成无涂层不锈钢？</p><p>商品列表怎么蹦出个透明的电饭锅？小米的？</p><p>叫什么  <code>小米蒸汽电饭锅</code> ，查了下其它就只有九阳做过类似功能的电饭锅的样子，至于小米这款，也是才发布的。</p><p>但是别说， <code>玻璃内胆</code> ，一听起来就比什么涂层或者不锈钢安全对吧？</p><p>然后查查查... 分析了一下，这不就是老式电饭锅，单纯把内胆换成了玻璃么？而且还变得不能煮饭，只能蒸饭了...</p><p>总之，又花了挺多时间研究评论和信息，不过这款因为发布时间不算长，所以信息不是很足。</p><ul><li>—— 但差评倒是有些个：蒸不熟、花的时间长 (1 小时)、甚至还有生锈的、</li></ul><p>加上个价格也不算便宜，除了能联网之外，工作原理感觉跟普通老式电饭煲也没什么差别的，更别说现在大火的 IH 版本 —— 它甚至比一般的 IH 贵</p><p>总之，不像上面的设备，这个设备依然还在观望中... 已经有了就不算什么必需品了，没有必要的东西总是更难以下决定。<span class="spoiler" title="你知道得太多了！">再加上价格不便宜 —— 毕竟太穷了</span></p><p>何况平时在公司吃饭时间更多 —— 至于公司吃饭，甚至是吃的盒饭，家里电饭锅不过是涂层掉了罢了，难道还能比塑料盒饭更差的？</p><h1 id="结语"><a class="anchor" href="#结语">#</a> 结语</h1><p>总之，材料已经准备好了，就等设备到了就可以在下周末尝试一下了：</p><p><img data-src="/blogimages/2023/2023-06-04/1685878492673.Webp" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;事情是这样的：前几天不知道为什么，突然想吃蛋糕，然后想自己做。&lt;/p&gt;
&lt;p&gt;正好这几天是每年例行的 618 也开始了，于是就研究着想买点工具&lt;/p&gt;
&lt;p&gt;有时候</summary>
      
    
    
    
    <category term="其它" scheme="https://wangjiaying.top/categories/%E5%85%B6%E5%AE%83/"/>
    
    
    <category term="生活" scheme="https://wangjiaying.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>DOTS1.0(Metaverse大衍神君系列)-笔记</title>
    <link href="https://wangjiaying.top/2023/05/29/DOTS1-0-Metaverse%E5%A4%A7%E8%A1%8D%E7%A5%9E%E5%90%9B%E7%B3%BB%E5%88%97-%E7%AC%94%E8%AE%B0/"/>
    <id>https://wangjiaying.top/2023/05/29/DOTS1-0-Metaverse%E5%A4%A7%E8%A1%8D%E7%A5%9E%E5%90%9B%E7%B3%BB%E5%88%97-%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-29T07:30:30.000Z</published>
    <updated>2023-06-04T11:58:57.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>主要内容来源于：Metaverse 大衍神君  <code>RoadToDotsTutorials</code>  相关教程，本文为个人笔记<br /><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x3d2hiL1JvYWRUb0RvdHNUdXRvcmlhbHMuZ2l0"> https://github.com/lwwhb/RoadToDotsTutorials.git</span><br /><img data-src="/blogimages/2023/2023-05-29/Snipaste_2023-05-29_16-33-01.jpg" alt="" /><br /> 注：暂且先从语雀笔记搬过来，还会继续进行整理、修改</p><h2 id="dots-是什么"><a class="anchor" href="#dots-是什么">#</a> Dots 是什么？</h2><ul><li>Data-Oriented Technology Stack（面向数据的技术堆栈）</li><li>由 5 个核心包定义构成：<ul><li>C# Job System</li><li>Burst Compiler<ul><li>优化 C# 代码的编译器</li></ul></li><li>Unity Mathematics<ul><li>可以在 JobSystem 使用的数学库，同时针对 burst 编译器特别优化</li></ul></li><li>Unity Collections</li><li>Entities（esc）</li></ul></li><li>其它包<ul><li>Entities.Graphics</li><li>Netcode</li><li>Physics<ul><li>Unity Physics (无状态、确定性)</li><li>Hovak Physics (有状态、不具备确定性，但是更稳定)</li></ul></li><li>Animation(wip)</li><li>Audio(wip)</li></ul></li><li>应用<ul><li>需要多线程加载、通讯、并行</li><li>CPU 密集型都可以使用</li><li>充分利用现代 CPU 的多核、及缓存效率</li></ul></li><li>学习方法<ul><li>看、查、学、改、调、写、交流</li></ul></li><li>程序设计方法<ul><li>指令化编程</li><li>函数化编程</li><li>过程化编程</li><li>面向对象编程 / 设计 (oop/ood)</li><li>面向数据设计 (dod)<ul><li>本质是面向内存、缓存友好的设计</li><li>开发人员需要考虑需要什么数据以及如何在内存中如何构造和组织数据，以便 cpu 处理数据时能更有效地访问数据</li></ul></li></ul></li><li>缓存层级结构<ul><li>L1 Cache：每个指令处理单元独享（分为数据缓存和指令缓存）</li><li>L2 Cache：核心内多个指令处理单元共享</li><li>L3 Cache：CPU   多个核心共享</li><li>fetch+decode+execution 构成一次 cycle</li><li>因此当某一级缓存未命中时，向下一级缓存取数据要花费数倍时间</li><li><img data-src="/blogimages/2023/2023-05-29/476232314.jpeg" alt="" /></li></ul></li><li>缓存行：一般根据 cpu 结构不同，为 32 或 64 个字节</li><li>Cache 的 3c 与 3r：<ul><li>compulsory misses：首次读取数据时，必然 miss</li><li>capacity misses：缓存空间不足时，连续使用期间访问数据过多的话，无法保存所有活动的数据</li><li>conflict misses：发生访问冲突时，由于数据映射到相同的缓存行，导致缓存抖动<ul><li>缓存抖动发生比较多，一次 cacheline 没有需要的，实际访问数据不连续</li></ul></li><li>rearrange：重新排列（代码、数据），更改布局以增加数据空间的局部性</li><li>reduce：减少（大小、缓存行读取），更小更智能的格式、压缩（如位运算）</li><li>reuse：重用，增加数据的时间和空间的局部性（对齐、连续访问、减少发生缓存抖动几率）</li></ul></li><li>Cache<ul><li>L1 致力于更快的速度，L2 致力于命中率</li><li>Cache 如果做大了取一个字的时候时间就会增加，把 L1 做大后显然命中时间和整个延迟开销会增加</li><li>缓存分层本质是物理距离决定的（价格与平衡）</li></ul></li><li>Cache 层级与排队管理<ul><li>计算机执行类似排队</li><li>dots 设计队列结构</li><li>ecs 组织队列规则</li><li>jobsystem 队列调度</li><li>三级缓存由指令调度需求决定？</li></ul></li><li>面向数据设计需要思考的问题<ul><li>array of structures (AoS) 结构数组 - 面向对象组织</li><li>structure of arrays (SoA) 数组结构 - 面向数据组织</li><li>这分别代表着两种不同的数组组织形式</li></ul></li><li>dots 面向数据设计原则<ul><li>先设计，后编码</li><li>为高效使用内存与缓存而设计</li><li>为 bittable data 设计</li><li>为普通情况设计</li><li>拥抱迭代</li></ul></li></ul><h2 id="ecs"><a class="anchor" href="#ecs">#</a> ECS</h2><ul><li>实体组件系统 (ecs) 架构<ul><li>遵循组合优于继承原则</li><li>面向数据设计</li><li>弱耦合</li><li>常用于游戏开发</li></ul></li><li>本质：组合的是数据的数组，而非对象的数组</li><li>Entity：虽然叫实体，但并非对象，也不是容器，而是一个对象索引的 id、一个标识符，用来指示某个对象的存在，其中并不包含任何数据和逻辑，可通过组件分配某些属性</li><li>conponent：数据的容器 (不是对象的容器)，其中不包含任何逻辑</li><li>注：entity 与 conponent 关系 ——entity 充当数据的标识符或 key 来使用</li><li>system：真正负责对数据进行操作的部分</li></ul><hr /><ul><li>IJobEntity 被自动生成为 IJobChunk</li><li>oop：数组的结构（array of structs）<ul><li>同一个对象放一起</li></ul></li><li>esc：结构数组（structs of array）<ul><li>所有同一类型放一起</li></ul></li><li>chunk 大小固定，于是 archytypes 固定，方便动态插入新数据<ul><li>每个 chunk 数量也应该考虑，否则会出现无效空白内存块</li><li>每个 chunk 还有其它额外数据</li><li>例如只读的加上 readonly 特性，避免 versionnumber 自增（还有参数只读 in）</li></ul></li></ul><hr /><ul><li>archetypes (原型)：依然是一个标识符，标识所有具有相同 conponent 组合的实体类型<ul><li><img data-src="/blogimages/2023/2023-05-29/1940844859.jpeg" alt="1940844859.jpeg" /></li><li>可以理解为不同的 entity 在内存中的布局</li></ul></li><li>archetype chunk：每个 archetype 所标记的内存会被分为固定大小、连续的非托管内存块<ul><li><img data-src="/blogimages/2023/2023-05-29/2050743949.jpeg" alt="2050743949.jpeg" /></li><li>包含共享同一原型的实体组件数组</li><li>默认设置下每个 chunk 为 16kb，实体填充不满也会留白</li><li>方便做数据并行计算，方便做做缓存的 prefetch</li><li>数据对齐同时可以匹配缓存行</li><li>查询时利用纵向纬度分块对齐方式做 slice 切片</li></ul></li><li>world：一系列 entity 的组合，每个 entity 在一个 world 中唯一，统一受 entitymanager 管理（所以通过 id 查找 entity 并不安全）</li><li>entitymanager：负责创建、销毁、修改 世界中的实体</li><li>structural change：所有导致需要重新组织内存块或内容的操作<ul><li>改变结构</li><li>改变 (内存块) 内容</li><li>两个都只能在主线程进行，资源密集型操作，效率差<ul><li>如添加或删除一个 entity 对应的组件导致所属原型发生变化</li><li>创建、销毁实体</li><li>设置 shared component 值</li></ul></li><li>尽量避免</li><li>确定运行时无需修改可在编辑器做 bake 提高效率</li></ul></li><li>query：通过切片方式组织查询，让人感觉上是连续的，但并不会造成内存上的移动</li></ul><h1 id="unity-jobs-system"><a class="anchor" href="#unity-jobs-system">#</a> Unity Jobs System</h1><ul><li>包含 C# Jobs System 和 C++ Jobs System</li><li>安全多线程</li><li>可与 ECS 结合使用，也可单独使用</li><li>Blitable：在 C++ 下与 C# 下内存表述一致的类型<ul><li>C# bool 值占用 4 个字节，c++ 1 字节，不一致</li><li>Jobs 只能使用 Blitable 或 非托管堆数据</li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL3poLWNuL2RvdG5ldC9mcmFtZXdvcmsvaW50ZXJvcC9ibGl0dGFibGUtYW5kLW5vbi1ibGl0dGFibGUtdHlwZXM=">可直接复制到本机结构中的类型和非直接复制到本机结构中的类型 - .NET Framework</span></li></ul></li><li>Allocation Types<ul><li>persistent：长生命周期内存</li><li>tempjob：只在 job 中存在的短生命周期，4 帧以上会收到警告</li><li>temp：一个函数返回前的短生命周期</li></ul></li><li>调度方式<ul><li>run：主线程立即顺序执行</li><li>schedule：单个工作线程或主线程，每个 job 顺序执行</li><li>scheduleparallel：在多个工作线程同时执行，性能最好，但多个工作线程访问同一数据时可能发生冲突</li></ul></li><li>job 可以链式依赖，或同时依赖多个 jobhandle，避免 race condition</li><li>job safety checks：安全检查，在发生 job 访问数据冲突时会抛出异常（仅编辑器生效，可开关，为谨慎性而提供，并不智能）<ul><li>nativedisablecontainersafetyrestriction 特性，关闭对指定数据安全检查</li><li>readonly 特性标签也可以避免安全检查抛出异常</li></ul></li></ul><h1 id="entities"><a class="anchor" href="#entities">#</a> Entities</h1><h2 id="基础"><a class="anchor" href="#基础">#</a> 基础</h2><ul><li>少用分支语句，会造成 cache 不友好</li><li>authoring 模式：编辑器创建<ul><li><p>创建 entitysubscene</p></li><li><p>在 subscene 创建 gameobject 对象</p></li><li><p>为 gameobject 添加默认 conponent 和 自定义 icomponentdata 数据</p></li><li><p>自定义 icomponentdata 完成数据编排</p></li><li><p>authoring-baking (隐式)-runtime</p></li><li><p>baker：用来创建自定义数据</p></li><li><p>bakersystem：运行于 baker 之后，处理复杂 baking 情况，可选处理</p></li></ul></li><li>runtime 模式：完全代码创建<ul><li>创建一个 world</li><li>通过 world 中 entitymanager 创建、管理 entity 对象<ul><li>entity：整形 id 和 version 数据组成的结构体</li></ul></li><li>通过 world 中 entitymanager 创建 entity 对应 conponent<ul><li>icomponent：一个 c# 结构体，可以被 entities id 索引，一般无法被托管对象引用，内存紧密排列。</li></ul></li><li>根据创建的 entity 或 entityarchetype 实例化 entity</li><li>通过 system 实现对应 entity 逻辑管理<ul><li>systembase：托管类，简单，运行于主线程，不能被 burst 编译</li><li>isystem：struct，非托管，可以被 burst 编译，快但更复杂</li></ul></li></ul></li></ul><h2 id="components-类型"><a class="anchor" href="#components-类型">#</a> Components 类型</h2><ul><li>内存类型划分<ul><li>非托管（常用）<ul><li>blitable type</li><li>bool</li><li>char</li><li>blobassetreference</li><li>collections.fixedstring</li><li>collections.fixedlist</li><li>Fixed array</li><li>And so on（不变数据结构、长度、固定大小）</li></ul></li><li>托管<ul><li>可存储如何数据类型，但无法使用 jobs 访问，也无法使用 burst 编译，且声明 data 对象必须是无参数构造函数</li><li>不会存储在 chunk 中，而是所属 world 一个大数组中，chunk 仅存储索引，因此查找 entity 托管类型组件时需要处理额外索引查找工作，更慢</li></ul></li></ul></li><li>功能类型划分<ul><li>一般 component</li><li>shared component</li><li>tag component<ul><li>标识 entity 方便查找</li><li>不占用存储空间，非常好用于分类功能组件</li></ul></li><li>enableable component<ul><li>运行时启用、禁用</li></ul></li><li>cleanup component<ul><li>错误状态防止销毁 entity</li></ul></li><li>singleton component<ul><li>一个 world 下唯一存在（多个 world 可重复）</li></ul></li></ul></li><li>数据访问类型划分<ul><li>按 entity 访问</li><li>按 chunk 访问</li><li>按 element 访问</li></ul></li><li>按接口类型划分<ul><li>Ienableablecomponent</li><li>Isystemstatecomponent</li><li>Isystemstatesharedcomponent</li><li>Icomponentdata</li><li>Isharedcomponentdata</li><li>Ibufferelementdata</li></ul></li><li>entities 包中的数据大类<ul><li>componentdata</li><li>bufferdata</li><li>isharedcomponentdata</li><li>entitydata</li><li>unitycomponentobject</li></ul></li></ul><h2 id="system"><a class="anchor" href="#system">#</a> System</h2><h3 id="类型"><a class="anchor" href="#类型">#</a> 类型</h3><ul><li>isystem：提供对非托管内存访问</li><li>systembase：用于访问存储托管数据</li><li>注：任何 system 都能访问任何 world 下的 entity（不推荐）</li><li>编辑器下，system 窗口会显示每个操作时间消耗，默认小数点 2 位，可设置更高精度</li></ul><h3 id="更新"><a class="anchor" href="#更新">#</a> 更新</h3><ul><li>同 systemgroup 下调整 system 更新顺序<ul><li>[updatebefore]</li><li>[updateafter]</li></ul></li><li>指定 system 到特定的 ComponentSystemGroup 下<ul><li>[updateingroup]</li></ul></li><li>控制 system 的创建与销毁顺序<ul><li>[createbefore]</li><li>[createafter]</li><li>注：被修饰的 system 的销毁顺序与创建顺序相反</li></ul></li><li>禁止 System 被默认创建并添加到默认 ComponentSystemGroup 中<ul><li>[DisableAutoCreation]</li><li>注：被修饰的 System 需手动调用 world.getoncreatesystem 创建，及手动调用 xxxsystem.update 更新</li></ul></li><li>空的 systemgroup 与空的 monobehavior 函数一样，都会有时间开销</li><li>使用 system 注意点<ul><li>不要在 system 中定义 public 数据，应将其组织为 component 数据</li><li>在 system 更新时，尽量采用 system state 中的 getentityquery、getcomponenttypehandle 等访问 chunk component 数组，而不是通过 entitymanager 方法访问 (有额外开销)</li></ul></li></ul><h3 id="遍历与查询"><a class="anchor" href="#遍历与查询">#</a> 遍历与查询</h3><ul><li>dots 程序三大主要工作<ul><li>设计与组织数据</li><li>遍历与查找数据</li><li>修改与更新数据</li></ul></li><li>遍历查询 entity 数据的 5 种方式<ul><li>systemapi.query + foreach<ul><li>只能在 system 调用</li><li>不能存储结果，并在一个或多个 foreach 使用（因为模板类型需要在编译时确定并生成代码）</li><li>只能用于主线程</li><li>不能过滤同时『包含』的 chunk</li><li>有七种重载：iaspect、icomponentdata、dynamicbuff&lt;&gt;、refro&lt;&gt;、refrw&lt;&gt;、enabledrefro&lt;&gt;、enabledtefrw&lt;&gt;</li></ul></li><li>Ijobentity<ul><li>与 Entities.foreach 类似，每个 entity 调用一次</li><li>可在多个 system 重用</li><li>底层通过 ijobchunk 实现</li><li>可通过参数特性修饰查询</li><li>entityindexinquery 特性获取当前 entity 遍历查询索引</li></ul></li><li>Ijobchunk<ul><li>更底层实现，遍历 archetype chunk</li><li>每个 chunk 调用一次</li><li>一般用于不需要遍历每个 chunk 中 entity 的情况或对 chunk 内的 entity 执行多次遍历或以不寻常顺序遍历的情况</li><li>useenabledmask 与 chunkenablemask 辅助过滤 enableable component 未激活的 entity（不会自动过滤）</li></ul></li><li>Entities.foreach<ul><li>只用于 systembase 创建的 system</li><li>定义一个 lambda 表达式</li><li>使用限制较多，一般不用</li></ul></li><li>Manually（手动遍历）<ul><li>entitymanager.getallentities()</li><li>entitymanager.getallchunks()</li><li>限制较小，但性能上不划算</li></ul></li></ul></li></ul><h3 id="system-其它特性"><a class="anchor" href="#system-其它特性">#</a> System 其它特性</h3><ul><li>[requirematchingqueriesforupdate]<ul><li>每个 entity 结果都是空时则强制跳过 system onupdate 调用</li></ul></li><li>state.requireforupdate&lt;&gt;()<ul><li>只有指定组件存在时，该 system 才运行</li></ul></li></ul><h2 id="aspect"><a class="anchor" href="#aspect">#</a> Aspect</h2><ul><li>Aspect 中可包含的数据类型<ul><li>entity</li><li>refrw&lt;&gt;、refro&lt;&gt;</li><li>enanledrefrw 和 enabledrefro</li><li>dynamicbuff&lt;&gt;</li><li>其它 aspect 类型</li><li>注：tranformaspect 是 unity 内置的唯一一个 aspect，封装各种 local、world 坐标系下的旋转、缩放、位置及其它一些组件数据</li></ul></li></ul><h2 id="内置组件"><a class="anchor" href="#内置组件">#</a> 内置组件</h2><h3 id="componentlookupt-随机访问"><a class="anchor" href="#componentlookupt-随机访问">#</a> ComponentLookup<T> 随机访问</h3><ul><li>componentlookup&lt;&gt;<ul><li>本质上是个 nativecontainer</li><li>可使用 job 同时在不同的一组实体上迭代</li><li>[NativeDisableParallelForRestrictionAttribute] 特性可解除对并行写入的限制（如确定每个 job 写入索引不冲突）</li><li>注：若希望在 job 之外访问 entity 组件，可考虑使用 entitymanager.getcomponentdata 做随机访问，避免创建 componentlookup 开销</li></ul></li><li>entitystorageinfolookup<ul><li>测试一个 entity 是否存在</li><li>通过存在的 entity id 获得 entitystorageinfo</li></ul></li></ul><h3 id="entity-command-buffer"><a class="anchor" href="#entity-command-buffer">#</a> Entity Command Buffer</h3><p>可以记录更改实体数据的命令，然后在稍后的主线程回放 ECB 时执行这些命令，基于命令模式设计</p><ul><li>RenderCommandBufer：同步统一执行渲染状态的改变</li><li>EntityCommandBuffer：与 RenderCommandBufer 类似，不过 ECB 是同步统一执行 Entity 相关数据的改变</li><li>Job 中不能直接创建和销毁 Entity</li><li>Job 中不能添加和删除 Entity 组件<ul><li>只能使用 Entity Command Buffer 来处理这些操作</li><li>ECB 具有很多与 EntityManager 相同的方法</li></ul></li><li>ECB 的 Playback 方法必须在主线程调用，记录 ECB 命令的 Job 必须在 Playback 方法调用前完成<ul><li>ECB 需要在调用 Playback 后销毁</li><li>（子线程数据同步至主线程）</li><li>奇偶线程只是记录命令，主线程调用 Playback 才是实际生产</li><li>state.Dependency.Complete();</li><li>ecb.Playback(state.EntityManager);</li><li>ecb.Dispose();</li></ul></li></ul><h3 id="entity-command-buffer-system"><a class="anchor" href="#entity-command-buffer-system">#</a> Entity Command Buffer System</h3><ul><li>使用 ecb 更简便<ul><li>world.getexistingSystemManaged&lt;&gt;().CreateCommandBuffer()</li><li>不需要手动调用 playback 及释放</li></ul></li><li>创建自定义 ECB System 继承自 EntityCommandBufferSystem（通常不需要）</li><li>Unity 提供了默认一些 ECB System（单例），可直接获取使用</li><li>SystemAPI.GetSingleton&lt;T.Singleton&gt;()：<ul><li>BeginInitializationEntityCommandBufferSystem：代表在下一帧开始时创建</li><li>EndInitializationEntityCommandBufferSystem</li><li>BeginSimulationEntityCommandBufferSystem</li><li>EndSimulationEntityCommandBufferSystem</li><li>BeginFixedStepSimulationEntityCommandBufferSystem</li><li>BeginPresentationEntityCommandBufferSystem</li></ul></li></ul><h3 id="dynamicbuffercomponent"><a class="anchor" href="#dynamicbuffercomponent">#</a> DynamicBufferComponent</h3><ul><li>非托管内存下一个可以调整大小的数组</li><li>继承自 IBufferElementData 接口</li><li>capacity：容量，默认 128 字节以内元素，共 8 个元素，每个元素 16bytes<ul><li>可使用 [InternalBufferCapacity] 特性修改</li></ul></li><li>internal ptr：指向缓冲区数据的具体位置</li><li>buffer 长度超过内部容量后，会销毁原本 chunk 数组并移到外部更大 chunk 中，即使缩小也回不去了</li><li>获取：entitymanager.getbuff&lt;&gt;</li><li>structure change 会对 dbc 检索产生影响<ul><li>jobs 读写访问也有影响（只读无所谓）</li></ul></li><li>可使用 ecb 修改 dbc<ul><li>ecb.addbuffer、ecb.setbuffer、ecb.appendbuff</li></ul></li><li>若两个 dbc 大小相同，可以用一个解释另一个（类似于联合）</li></ul><h3 id="enableablecomponent"><a class="anchor" href="#enableablecomponent">#</a> EnableableComponent</h3><ul><li>运行时禁用、启用 entity 对象上某个组件，用于处理频繁修改组件状态的情况</li><li>避免直接增删组件导致的 structural change</li><li>还可以替换一组零大小的 tagcomponent 来表示 entity 状态的情况，以减少 entity archetype 数量，得到更好的 chunk 利用率</li><li>只能用于 icomponentdata、ibufferelementdata 类型并同时继承实现 ienableablecomonent 的接口</li><li>使用 EnableableComponent 不会改变 entity，也不会造成任何数据移动（意味着可以直接在 job 中开启或禁用组件）</li><li>使用具有对 enableable 组件写访问权限的 job 可能会导致线程操作阻塞，即使 job 没有在任何 entity 上启用或禁用组件</li><li>操作<ul><li>entitymanager</li><li>componentlookup</li><li>entitycommandbuffer</li><li>archetypechunk</li><li>的 iscomponentenabled&lt;&gt;、setcomponentenabled&lt;&gt; 启用或禁用</li></ul></li><li>默认情况下通过 createentity 创建的新 entity 会启用所有可用组件，从 prefabs 实例化的 entity 则继承之前组件状态</li><li>查询时，entityquery 会不匹配禁用组件，不过可以手动忽略<ul><li>ignorefilter</li><li>entityqueryoption.ignorecomponentenabledstate 查询</li></ul></li></ul><h3 id="sharecomponent"><a class="anchor" href="#sharecomponent">#</a> ShareComponent</h3><ul><li>共享组件数据存储在与 ecs chunk 分离的数组中</li><li>world 中的 chunk 则存储句柄，用来定位共享组件在分离数组中的值</li><li>同一个 chunk 中实体共享相同的 sharecomponent 的值</li><li><img data-src="/blogimages/2023/2023-05-29/-2144605345.jpeg" alt="-2144605345.jpeg" /></li><li>若更改了 entity 的共享组件值，该 entity 会被移动到新的共享组件的 chunk 中<ul><li>若共享组件值在数据组中存在相等的值，则 entity 被移动至存储现在有值索引的 chunk 中</li><li>否则，添加新值到共享组件值中，并将 entity 移动到存储新值索引的新的 chunk 中</li><li><img data-src="/blogimages/2023/2023-05-29/-1348735719.jpeg" alt="-1348735719.jpeg" /></li><li>意味着更改共享组件值一定会带来 structual change</li><li>应尽量避免频繁更新</li><li>避免大量有独特值的共享组件 (会导致不同共享值的实体被分割，出现空 chunk 块)</li><li>避免实体具有多个共享组件类型组合，避免 archetype 碎片化 (可以想象成 shader 的关键字，与其增长速度是一样的，也会造成内存碎片化)</li></ul></li><li>分为托管与非托管类型的 sharedcomponent<ul><li>根据组件中存储的数据的 blitable type 类型划分</li><li>托管与非托管类型的共享组件分开存储</li><li>非托管：继承 isharedcomponentdata（可选继承 iequatable）</li><li>托管：除继承 isharedcomponentdata ，还必须实现 iequatable，并实现 equals 及 gethashcode</li></ul></li><li>因为共享同一 ShareComponent 的 entity 会被放入一个 chunk，因此也可以利用这一点进行分组（当然需要注意内存碎片化问题）</li><li>进阶用法<ul><li>不同 world 使用共享组件共享同一个托管对象</li><li>共享组件内包含对象引用类型或指针的情况</li></ul></li></ul><h3 id="blobasset"><a class="anchor" href="#blobasset">#</a> BlobAsset</h3><ul><li>Blob (binary large object):：是 unity 中存储数据的一种格式，为流式传输优化的二进制数据片，在内存中是存储连续字节块中的不可变的非托管二进制数据</li><li>只读，创建时设置后不可变</li><li>一次性分配，可以用 memcpy 重新定位，不能包含虚类对象数据</li><li>unity 的 blobification 框架可以更紧密打包数据，借助 reduce copy 减少重复数据，并使 blob asset 可以 relocatable 重新定位从磁盘直接读取</li><li>dots 中的 Blob asset<ul><li>同样可以有效优化数据存储与内存使用</li><li>dots 下不能直接使用，而是通过 blobAssetRef</li><li>当不需要时，需通过调用 blobAssetReference dispose 释放</li><li>bake entity 引用的 blob asset 会与场景一起序列化加载</li><li>注意与 sharecomponent 差异</li><li><img data-src="/blogimages/2023/2023-05-29/-683181080.jpeg" alt="-683181080.jpeg" /></li><li>dota 中 blob 数据类型<ul><li>普通 blitable type 数据类型</li><li>blobString</li><li>blobArray</li><li>blobPtr</li></ul></li></ul></li></ul><h3 id="cleanupcomponent"><a class="anchor" href="#cleanupcomponent">#</a> CleanupComponent</h3><ul><li>当销毁一个包含该组件的 entity 时，unity 会删除所有非该组件的其它组件，实际上这个 entity 还存在</li><li>该组件不会随 entity 复制到另一个 world 中</li><li>主要用于在创建实体后帮助初始化或销毁实体后帮助清理</li><li>根据继承不同，分为不同类型<ul><li>例如分为托管和非托管类型、dynamic buffer 类型、shared component 类型</li></ul></li><li>在 dots 创建 entity<ul><li>4 种方法：</li><li><ol><li>通过 ibaker 接口将 prefab bake 成原型，然后运行时通过 entitymanager 根据原型实例化新的 entity 对象</li></ol><ul><li>使用简单，好理解，不过在 world 中会有额外一个原型存在</li></ul></li><li><ol start="2"><li>entitymanager.CreateEntity()</li></ol><ul><li>然后添加 requestentityprefabloaded 即 prefab 异步加载并转化为 entity 的组件</li><li>组件加载转化完成后，会在 entity 上自动添加 prefabloadedresult 组件，可以从该组件上的 prefabroot 字段拿到 prefab 转化后的 entity</li></ul></li><li><ol start="3"><li>混合方式</li></ol><ul><li>直接将 prefab 数组引用在 baker 中保存至 componentdata 中</li><li>通过继承 systembase 的 system 直接使用 instantiate 实例化</li><li>该方法本质上还是 gameobject 处理，无法利用 dots 的数据结构优势（不推荐）</li></ul></li><li><ol start="4"><li>完全动态创建（entity graphics 核心包）</li></ol></li></ul></li></ul><h3 id="chunkcomponent"><a class="anchor" href="#chunkcomponent">#</a> ChunkComponent</h3><ul><li>按 chunk 而不是按 entity 存储的组件</li><li>同样继承 icomponentdata</li><li>使用一组不同的 api 进行操作</li><li>如果只是想只读，使用 query 查询时传入 chunkcomponentreadonly</li><li>在 entity 上添加或删除 chunkcomponent 会导致 structual change</li><li>在执行 job 时由于其按 chunk 存储，一般用 ijobchunk 而不是 ijobentity</li><li><img data-src="/blogimages/2023/2023-05-29/1201698463.jpeg" alt="1201698463.jpeg" /></li><li>具有相同 archetype 的 entity，指向在 chunk 中同一个 chunkcomponent，否则指向同一 chunk 不同的 chunkcomponent</li><li><img data-src="/blogimages/2023/2023-05-29/-854237890.jpeg" alt="-854237890.jpeg" /></li></ul><h1 id="entities-graphics-包"><a class="anchor" href="#entities-graphics-包">#</a> Entities Graphics 包</h1><ul><li>充当 dots 与 unity 现有渲染架构的桥梁</li><li>使用 ecs entity 而不是 gameobject 来改善大型场景中运行时内存布局与性能</li><li>保持 unity 现有工作流的兼容与易用性</li></ul><h2 id="gameobject-转化系统"><a class="anchor" href="#gameobject-转化系统">#</a> GameObject 转化系统</h2><ul><li>将 gameobject 转化为等效 dots entity 的系统，支持编辑器与运行时转化换</li><li>meshrender meshfilter-&gt;rendermesh</li><li>lodgroup-&gt;meshlodgroupcomponent</li><li>transform-&gt;localtoworld</li><li>最好的运行时实例化 entity 方式<ul><li>prefabs</li><li>rendermeshutility.addcomponent api</li></ul></li><li>不要手动添加渲染组件，效率低，有可能与未来 entity graphics 包不兼容</li><li>不推荐 monobehavior 创建 entity</li><li>运行时创建 entity<ul><li>entity graphics 渲染需要包含最小组件集</li><li>推荐 rendermeshutility.addcomponent api—— 不过这是一个主线程 api，不适合创建大量实体，最好通过原型实例化克隆现有实体</li></ul></li></ul><h2 id="material-覆写"><a class="anchor" href="#material-覆写">#</a> Material 覆写</h2><p>两种方法：</p><ul><li>使用 material override asset</li><li>使用 c# burst code（推荐）<ul><li>定义的 componentdata 类用 materialproperty 特性修饰</li></ul></li><li>禁用渲染<ul><li>disablerender tag 组件</li><li>仅仅是不渲染，实际还在更新</li><li>会导致 structural change</li></ul></li></ul><h2 id="batchrendergroup-api"><a class="anchor" href="#batchrendergroup-api">#</a> BatchRenderGroup API</h2><ul><li>GPUInstancing<ul><li>DrawMeshInstanced：有 1024 个数量限制</li><li>DrawMeshInstancedIndirect：有兼容性和剔除方面限制</li><li>BatchRenderGroup</li></ul></li><li>(BRG) 是一个用于执行可自定义的高性能实例对象渲染接口，可以提前设置批次，使用描述如何加载网格和材质的共享元数据来设置实例组</li><li>当 Unity 渲染 BatchRenderGroup 时，会调用 OnPerformCulling 回调执行可见性剔除，并可声明一个可变大小绘制命令列表，描述如何渲染 BatchRenderGroup  可见部分</li><li>每个绘制命令都指示 Unity 使用特定的网格和材质渲染给定批次中的一组实例</li><li>Entities Graphics 就是构建在 BatchRenderGroup API 之上的，此 API 将 Entities Graphics 连接到 Unity 引擎后端渲染<ul><li>注：其实 BatchRenderGroup API 可以脱离 Dots 直接脚本调用</li></ul></li></ul><h3 id="用途"><a class="anchor" href="#用途">#</a> 用途</h3><ul><li>渲染 DOTS 实体</li><li>渲染大量使用单个 GameObject 的资源密集型环境对象 (如程序化放置的植物或岩石)</li><li>渲染自定义地形，可使用不同的网格或材质显示不同级别的详细信息</li></ul><h3 id="使用限制"><a class="anchor" href="#使用限制">#</a> 使用限制</h3><ul><li>不支持 BuildIn 管线，需要 SRPBatcher 选项开启</li><li>不能剔除 BRG 的变体<ul><li>BatchRenderGroup Variants 需要设置为 KeepAll</li><li>URP 最好在设置中直接关闭 StripUnusedVariants 避免被剔除变体</li></ul></li><li>需要开启 unsafe 选项（允许不安全代码）</li><li>主流平台基本都支持 BRG 接口，不过 Android 上需要 Vulkan 支持<ul><li>OpenGL 下可以使用 const buffer 处理一些不兼容情况，但是渲染提升并不明显<ul><li>opengle 和 opengles 上只能使用 ConstantBuffer，其他的都是使用 RawBuffer</li></ul></li><li>所以最好选用 Vulkan 图形 API</li></ul></li></ul><h3 id="创建流程"><a class="anchor" href="#创建流程">#</a> 创建流程</h3><ol><li>创建 BatchRenderGroup 实例，使用 OnPerformCulling 的实现进行初始化 (主要入口)<ul><li>Visibility Culling：基于 BatchCullingContext 参数确定哪些渲染实例对象可见，输出实际绘制命令以渲染这些实例</li><li>OnPerformCulling 逻辑可在回调实现，也可以在 BurstJob 完成 (更高效)</li></ul></li><li>向 BRG 中注册网格和材质<ul><li>Mesh 与 Material 是 Unity 托管 C# 对象，不能在 Burst C# 使用，必须预先注册 (与 EntitiesGraphicsSystem 一致)</li><li>通过 BatchRenderGroup.RegisterMesh/BatchRenderGroup.RegisterMaterial 注册，其返回 BatchMeshID 与 BatchMaterialID (是包含 Burst 兼容句柄的普通数据结构体)</li><li>即使用 BRG 前必须先注册对象 Mesh 与 Material，且材质必须支持 DOTS Instancing</li></ul></li><li>创建批次 Batch<ul><li>绘制命令之前需要为每个实例提供数据，如变化矩阵、光照探针系数、光照贴图、纹理坐标等</li><li>BRG 使用 Batch 的概念，每个 Batch 都有一组元数据和一个 GraphicsBuffer 的概念，批处理中的每个实例都共享这些数据</li><li>通过 BatchRenderGroup.AddBatch 接受元数据值的数组以及 GraphicsBuffer 的句柄，Unity 会将 Batch 中的数据传递给 Shader (未传入默认为 0)，并将 GraphicsBuffer 绑定为 unity_DOTSInstanceData</li><li>注 1：创建 Batch 元数据后不能修改，若想修改必须创建新的替换 (可通过 SetBatchBuffer 随时修改 Batch 的 GraphicsBuffer)—— 即数据的 Layout 不能修改，但数据内容可以修改</li><li>注 2：创建 Batch 时不需要指定大小，相反、必须确保 Shader 能够正确处理传递给它的实例索引：意味着 SRP Shader 在传递的索引处的缓冲区必须有有效的实例数据</li></ul></li><li>创建绘制命令 DrawCommands<ul><li>创建绘制命令需要使用 BatchRenderGroup.OnPerformCulling 回调和回调参数<ul><li>BatchCullingOutput 参数包含一个带单个元素的 NativArray，可以直接修改其内容，不需要复制数据</li><li>NativeArray 中的元素是个 BatchCullingOutputDrawCommands 结构，它包含实际绘制命令</li><li>OnPerformCulling 回调中生成任意数量的绘制命令，可以是只使用一个网格和材质的简单命令，也可以是使用成千上万个网格和材质的复杂命令</li><li>为提供最大灵活性，Unity 不会预先分配 BatchCullingOutputDrawCommands 输出结构中的数组而是将其存储为原始的指针<ul><li>这样就可以更轻松低从 Burst Job 中分配和使用（需要使用 UnsafeUtility.Malloc 和 Allocator.TempJob 分配器来分配数组）</li><li>另外在 OnPerformCulling 回调中不会释放这些数据内存，而是在 Unity 使用绘制命令完成渲染后释放</li></ul></li></ul></li></ul></li></ol><h2 id="hybrid-entities"><a class="anchor" href="#hybrid-entities">#</a> Hybrid Entities</h2><ul><li>允许将 MonoBehavior 组件附加到 DOTS Entity，而不需要将其转化为 ComponentData<ul><li>转换系统将调用 AddBybridComponent 将托管组件附加到 DOTS Entity 上</li></ul></li><li>默认情况会禁用 Camera 组件转换，因为场景主 Camera 不能是 HybridEntity<ul><li>需要启用，可使用宏 HYBRID_ENTITY_CAMERA_CONVERSION</li></ul></li><li>当 Unity 更新 DOTS LocalToWorld 时，都会更新 HybridEntity 转换</li></ul><h1 id="unity-physics"><a class="anchor" href="#unity-physics">#</a> Unity Physics</h1><ul><li>是一个完整的确定性的刚体物理系统</li><li>功能上仅是 Physics 或 Havok 的子集</li><li>完全使用 HPC# 编写，遵循 DOTS 整体设计理念</li><li>遵循最小依赖性和完全可控制性</li></ul><p>特性</p><ul><li>无状态：该帧信息不会被缓存到下一帧</li><li>模块化</li><li>高性能</li><li>互通性</li></ul><h2 id="物理模拟顺序"><a class="anchor" href="#物理模拟顺序">#</a> 物理模拟顺序</h2><ul><li>获取实体上组件当前状态</li><li>检测激活实体边界，进行快速碰撞检测</li><li>根据碰撞器形状计算确切接触点</li><li>基于碰撞点、质量、摩擦系数、弹性等参数做出碰撞反应</li><li>处理碰撞结果，并根据 Joint 等限制结算出刚体新的速度</li><li>根据动力学物理的线速度和角速度按时间步长移动物理体</li><li>将新的变换 Transform 应用到该物体实体上</li></ul><h2 id="设置方式"><a class="anchor" href="#设置方式">#</a> 设置方式</h2><ul><li>PhysicsSharp 组件 + PhysicsBody 组件</li><li>PhysicsSharp 组件 + RigidBody 组件<ul><li>底层实际通过 Authoring 将 RigidBody 转换为 PhysicsBody 组件</li></ul></li><li>其设置不受 ProjectSetting 中 Physics 全局设置影响了<ul><li>可以在场景添加 PhysicsStep 用作场景的全局物理设置</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;主要内容来源于：Metaverse 大衍神君  &lt;code&gt;RoadToDotsTutorials&lt;/code&gt;  相关教程，本文为个人笔记&lt;br /&gt;
&lt;span</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/categories/Unity3D/"/>
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/tags/Unity3D/"/>
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DOTS" scheme="https://wangjiaying.top/tags/DOTS/"/>
    
  </entry>
  
  <entry>
    <title>优化博客加载、添加文章统计等</title>
    <link href="https://wangjiaying.top/2023/05/28/%E6%B7%BB%E5%8A%A0%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%BB%9F%E8%AE%A1/"/>
    <id>https://wangjiaying.top/2023/05/28/%E6%B7%BB%E5%8A%A0%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%BB%9F%E8%AE%A1/</id>
    <published>2023-05-28T04:19:26.000Z</published>
    <updated>2023-06-04T11:42:34.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本来最开始只是因为  <code>JsDeliver</code>  ... 又又又挂了，导致部分用到的 CDN 在家里访问不了 —— 本来上次就已经把大部分脚本引用从  <code>JsDeliver</code>  切换到  <code>Staticfile</code>  了，然而还是有少几个在  <code>Staticfile</code>  没有的导致没法换<br />然后就发现，一旦这『少数』脚本出了问题，网页就会一直卡在那儿等它... 等半天真的是</p><p>于是就想办法搞，比如 fancybox、justifiedGallery、jquery、valine、whatwg-fetch 等</p><h1 id="处理"><a class="anchor" href="#处理">#</a> 处理</h1><p>之前  <code>fancybox</code> 、 <code>justifiedGallery</code> 、 <code>jquery</code>  三个是由原  <code>Shoka</code>  作者合并申请的：</p><blockquote><p>#! DO NOT EDIT THE FOLLOWING  <code>vendors</code>  SETTINGS<br />#! UNLESS YOU KNOW WHAT YOU ARE DOING<br />#! Script dependencies will be combined with jsDelivr (<span class="exturl" data-url="aHR0cDovL2Nkbi5qc2RlbGl2ci5uZXQ=">cdn.jsdelivr.net</span>)</p></blockquote><p>于是先是把合并的拆开，找地方再把拆开的给一一引用起来，弄好后又发现新问题：右键页面空白处，也会弹出图片菜单，开始还以为我引用搞出问题了，结果测试半天发现，不是  <code>fancybox</code>  那一坨的问题...</p><p>找不到原因了，反正也基本没用过，于是干脆直接删了，然后禁用图片点击</p><p>而后，又回到最开始界面卡加载慢的原因： <code>whatwg-fetch</code>  ，查到原仓库，看到描述说是为了兼容  <code>polifill</code>  而写的，另外已经两年没更新了</p><p>这个 CDN 国内找了几个都没有，考虑到目前新浏览器已经是自己支持  <code>fetch</code>  操作了，于是调了一阵子还是将其『瘦身』掉了</p><h1 id="页顶大图修改"><a class="anchor" href="#页顶大图修改">#</a> 页顶大图修改</h1><p>然后去搜索了一下网上同样使用  <code>Shoka</code>  的，结果基本全挂了，少数几个还能正常访问的，例如 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbg==">lavenderdh</span></p><p>然后... 看到<span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbi9wb3N0cy8zOTI4OTY2Mjg3Lw=="> lavenderdh 文章</span> ，是说把页顶图片放大至全屏的修改 —— 这个本来以前刚换  <code>Shoka</code>  的时候就见过，这次感觉：哎，还不错，于是加上了</p><h1 id="添加文章统计"><a class="anchor" href="#添加文章统计">#</a> 添加文章统计</h1><p>然后，顺便翻了下博主的主页 —— 虽然看着已经很久没更新了，不过页面的文章统计功能这次吸引了我的注意，再一翻，竟然还写了相关文章记录的，于是参考着给我的也加上。</p><p>跟着步骤还是挺顺利，然而博主的嵌入方式有点不优雅... 好像有点问题，我想把这功能加入主题配置中，然后改成按需加载。</p><p>于是... 花费的研究时间就足以让我也写篇文章记录一下了。</p><h2 id="图表显示问题"><a class="anchor" href="#图表显示问题">#</a> 图表显示问题</h2><p>首先，图表显示有点问题，例如统计图只显示当前一个月的、饼图重叠等...</p><p>比如：</p><p><img data-src="/blogimages/2023/2023-05-28/Snipaste_2023-05-31_11-09-37.jpg" alt="" /></p><p>跟着博主参考的链接进去看了下，一通改，算是修好了</p><h2 id="发布日历显示问题"><a class="anchor" href="#发布日历显示问题">#</a> 发布日历显示问题</h2><p>这个功能该是博主 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbi9zdGF0aXN0aWNzLw==">lavenderdh</span> 自己加的，然而在我这有些问题 —— 博主上边显示的是  <code>每一年</code>  的，到我这又不对劲，就只有一年的了</p><p>另外整体显示极小：大概是因为一年日期的网格，没法填满宽度导致的</p><p>后面对比了下网页源码上图表数据代码：</p><p>我的 (博主博文贴出来的)：</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token literal-property property">series</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'heatmap'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token literal-property property">coordinateSystem</span><span class="token operator">:</span> <span class="token string">'calendar'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token literal-property property">calendarIndex</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token literal-property property">data</span><span class="token operator">:</span> $<span class="token punctuation">&#123;</span>datePosts<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">]</span></pre></td></tr></table></figure><p>博主的：</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token literal-property property">series</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'heatmap'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token literal-property property">coordinateSystem</span><span class="token operator">:</span> <span class="token string">'calendar'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token literal-property property">calendarIndex</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token literal-property property">data</span><span class="token operator">:</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'heatmap'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token literal-property property">coordinateSystem</span><span class="token operator">:</span> <span class="token string">'calendar'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token literal-property property">calendarIndex</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token literal-property property">data</span><span class="token operator">:</span> </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'heatmap'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token literal-property property">coordinateSystem</span><span class="token operator">:</span> <span class="token string">'calendar'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token literal-property property">calendarIndex</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token literal-property property">data</span><span class="token operator">:</span> </pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">]</span></pre></td></tr></table></figure><p>这代码完全不一样了好吧... 其它诸如格子大小不对劲、偏移导致年份、星期显示不出来也是，可能是博主后面改了，没更新博文</p><p>于是对比着生成的 HTML 网页源码改了下，把显示宽度问题解决了，至于统计多年提交... 想了想放弃了，显示一年也行吧，还要 Git 上提交记录不也只展示最近一年么？</p><p>—— 不然改起来又要研究咋动态去生成 (不然总不可能直接写死的吧？也许还真是写死的...？看着 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbi9zdGF0aXN0aWNzLw==">lavenderdh 的统计页面</span> 切换主题的代码，手动设置了三个日历的数据)<br /> 在这里浪费的时间够多了，本来是因为昨天在写 <a href="/2023/05/27/Cinemachine%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" title="Cinemachine文档整理翻译">Cinemachine文档整理翻译</a> 文章的时候，本地预览看到网页显示比较慢，结果......</p><h2 id="延迟加载执行问题"><a class="anchor" href="#延迟加载执行问题">#</a> 延迟加载执行问题</h2><p>原本的嵌入方式，第一次 fetch 页面（不是刷新），会导致什么都没有，白屏<br />主要原因是：操作代码是 JS，而且嵌入网页中的，引用却是外部的 Script：<span class="exturl" data-url="aHR0cHM6Ly9jZG4uc3RhdGljZmlsZS5vcmcvZWNoYXJ0cy81LjQuMi9lY2hhcnRzLm1pbi5qcw==">https://cdn.staticfile.org/echarts/5.4.2/echarts.min.js</span></p><p>导致在  <code>echarts</code>  本身的 Script 还没拉取下来之前，先一步执行自己的逻辑代码，就要遭（这是分析了一阵流程发现的）</p><ul><li>博主说的解决方式是直接全局引用  <code>echarts</code> ，这个后续我也尝试过</li></ul><p>首先，按照原本的做法把功能弄了进来，并且修改为了配置模式：</p><figure class="highlight yml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># statistics 文章统计功能</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token key atrule">postStatistics</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token key atrule">beginDate</span><span class="token punctuation">:</span> 2015<span class="token punctuation">-</span><span class="token number">12</span> <span class="token comment">#开始统计日期</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token key atrule">tagCount</span><span class="token punctuation">:</span> <span class="token number">10</span> <span class="token comment">#统计标签个数</span></pre></td></tr></table></figure><p>然后，意图采用延迟加载的方式去解决这个问题，发现没能解决，也是这时候有点意识到问题了</p><p>想了想又研究着改成全局加载做尝试，然而发现  <code>echarts</code>  这东西... 内容有点丰富，单文件都  <code>999KB</code> ，约等于  <code>1M</code>  大小了</p><p>要是只有几十 KB 我倒无所谓了，但这种大小全局加载，就感觉太不优雅了，还是想改成  <code>按需加载</code>  的方式</p><p>Shako 自带的延迟加载逻辑一样不行（ <code>vendorJs(XX)</code> ）</p><p>后面又想到，既然现在的主要问题是内嵌入网页的代码先执行导致，那么将两者都变成外部引用呢？</p><p>如果尝试的话，问题就变成如何动态生成可以被链接的代码了，因为  <code>Shoka</code>  默认是把所有生成代码合并成一个  <code>app.js</code> ，加那里边又是代码膨胀了</p><hr /><p>最后加到了新创建的那个  <code>charts.js </code>  里边</p><p>主要是  <code>echarts-init</code>  执行初始化，其中代码是调用生成动态的那几个图表函数：</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">&lt;</span>script id<span class="token operator">=</span><span class="token string">"echartsInit"</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">function</span> <span class="token function">switchPostChart</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      <span class="token comment">// 这里为了统一颜色选取的是 “明暗模式” 下的两种字体颜色，也可以自己定义</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token keyword">let</span> color <span class="token operator">=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">'data-theme'</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token string">'#fff'</span> <span class="token operator">:</span> <span class="token string">'#000'</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'posts-calendar'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>          <span class="token keyword">let</span> postsCalendarNew <span class="token operator">=</span> postsCalendarOption</pre></td></tr><tr><td data-num="7"></td><td><pre>          postsCalendarNew<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="8"></td><td><pre>          postsCalendarNew<span class="token punctuation">.</span>title<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="9"></td><td><pre>          postsCalendarNew<span class="token punctuation">.</span>visualMap<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="10"></td><td><pre>          postsCalendarNew<span class="token punctuation">.</span>calendar<span class="token punctuation">.</span>itemStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="11"></td><td><pre>          postsCalendarNew<span class="token punctuation">.</span>calendar<span class="token punctuation">.</span>yearLabel<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="12"></td><td><pre>          postsCalendarNew<span class="token punctuation">.</span>calendar<span class="token punctuation">.</span>monthLabel<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="13"></td><td><pre>          postsCalendarNew<span class="token punctuation">.</span>calendar<span class="token punctuation">.</span>dayLabel<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="14"></td><td><pre>          postsCalendar<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>postsCalendarNew<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'posts-chart'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>          <span class="token keyword">let</span> postsOptionNew <span class="token operator">=</span> postsOption</pre></td></tr><tr><td data-num="18"></td><td><pre>          postsOptionNew<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="19"></td><td><pre>          postsOptionNew<span class="token punctuation">.</span>title<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="20"></td><td><pre>          postsOptionNew<span class="token punctuation">.</span>xAxis<span class="token punctuation">.</span>axisLine<span class="token punctuation">.</span>lineStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="21"></td><td><pre>          postsOptionNew<span class="token punctuation">.</span>yAxis<span class="token punctuation">.</span>axisLine<span class="token punctuation">.</span>lineStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="22"></td><td><pre>          postsChart<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>postsOptionNew<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'tags-chart'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>          <span class="token keyword">let</span> tagsOptionNew <span class="token operator">=</span> tagsOption</pre></td></tr><tr><td data-num="26"></td><td><pre>          tagsOptionNew<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="27"></td><td><pre>          tagsOptionNew<span class="token punctuation">.</span>title<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="28"></td><td><pre>          tagsOptionNew<span class="token punctuation">.</span>xAxis<span class="token punctuation">.</span>axisLine<span class="token punctuation">.</span>lineStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="29"></td><td><pre>          tagsOptionNew<span class="token punctuation">.</span>yAxis<span class="token punctuation">.</span>axisLine<span class="token punctuation">.</span>lineStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="30"></td><td><pre>          tagsChart<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>tagsOptionNew<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'categories-chart'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>          <span class="token keyword">let</span> categoriesOptionNew <span class="token operator">=</span> categoriesOption</pre></td></tr><tr><td data-num="34"></td><td><pre>          categoriesOptionNew<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="35"></td><td><pre>          categoriesOptionNew<span class="token punctuation">.</span>title<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="36"></td><td><pre>          categoriesOptionNew<span class="token punctuation">.</span>legend<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="37"></td><td><pre>          categoriesChart<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>categoriesOptionNew<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="38"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>  document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">"theme"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>switchPostChart<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">venderJs</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="42"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">[</span><span class="token string">'echartload'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="44"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>      <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>    <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>    script<span class="token punctuation">.</span>onload <span class="token operator">=</span> script<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>      script<span class="token punctuation">.</span>onload <span class="token operator">=</span> script<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>      script <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>    script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'$&#123;hexo.theme.config.vendors.js.echart&#125;'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>    window<span class="token punctuation">[</span><span class="token string">'echartload'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>    document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="58"></td><td><pre>  <span class="token function">venderJs</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="59"></td><td><pre>    <span class="token function">Do_postsCalendar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>    <span class="token function">Do_postsChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="61"></td><td><pre>    <span class="token function">Do_tagsChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="62"></td><td><pre>    <span class="token function">Do_categoriesChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>外面统计页面，就只保持最低限度的几个 HTML 配置了：</p><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>---</pre></td></tr><tr><td data-num="2"></td><td><pre>title: 文章统计</pre></td></tr><tr><td data-num="3"></td><td><pre>date: 2023-5-28</pre></td></tr><tr><td data-num="4"></td><td><pre>copyright: false</pre></td></tr><tr><td data-num="5"></td><td><pre>echart: true</pre></td></tr><tr><td data-num="6"></td><td><pre>---</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">&lt;!-- 文章发布日历 --></span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>posts-calendar<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">border-radius</span><span class="token punctuation">:</span> 8px<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span> <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">&lt;!-- 文章发布时间统计图 --></span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>posts-chart<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">border-radius</span><span class="token punctuation">:</span> 8px<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span> <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">&lt;!-- 文章标签统计图 --></span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tags-chart<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">border-radius</span><span class="token punctuation">:</span> 8px<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span> <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">&lt;!-- 文章分类统计图 --></span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>categories-chart<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">border-radius</span><span class="token punctuation">:</span> 8px<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 450px<span class="token punctuation">;</span> <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">&lt;!-- 初始化使用 --></span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>echarts-init<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><p>效果如下所示：</p><!-- 文章发布日历 --><div id="posts-calendar" style="border-radius: 8px; height: 300px; padding: 10px;"></div><!-- 文章发布时间统计图 --><div id="posts-chart" style="border-radius: 8px; height: 300px; padding: 10px;"></div><!-- 文章标签统计图 --><div id="tags-chart" style="border-radius: 8px; height: 300px; padding: 10px;"></div><!-- 文章分类统计图 --><div id="categories-chart" style="border-radius: 8px; height: 450px; padding: 10px;"></div><!-- 初始化使用 --><div id="echarts-init"></div><h2 id="标签统计图显示不全"><a class="anchor" href="#标签统计图显示不全">#</a> 标签统计图显示不全</h2><p>主要发生在刻度过多时 —— 我加了个自定义的标签的配置，然后随便配了个  <code>15</code>  就出现了</p><p>参考 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTc3NzMwL2FydGljbGUvZGV0YWlscy8xMDkzMDc1OTU=">柱状图 x 轴坐标显示不全</span> 可以解决 (但是压缩起来叠加会很难看，我又去掉了)</p><h2 id="其它"><a class="anchor" href="#其它">#</a> 其它</h2><h3 id="hexo-系统变得缓慢"><a class="anchor" href="#hexo-系统变得缓慢">#</a> Hexo 系统变得缓慢</h3><p>原因似乎是因为  <code>charts</code>  注册的  <code>after_render:html</code>  会对项目中生成的每个  <code>HTML</code>  作解析判断<br />想加入页面开关避免无谓解析呢，但是貌似已经获取不到  <code>page.XXX</code>  这种信息了，相当于页面已经渲染完毕，因此只能在最开始多判断一层，少解析一些速度会快点</p><h3 id="图表没有去重"><a class="anchor" href="#图表没有去重">#</a> 图表没有去重</h3><p>导致子分类会被单独归为另外一类，得做一次去重</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>其它还修了一波其它问题，比如  <code>vendorJS</code>  函数会反复插入  <code>js</code>  脚本的 BUG (不知道是不是我改出来的)</p><p>就这样</p><p>对于  <code>echats</code>  统计功能，虽然不能说封装完美，至少做到了  <code>按需加载</code> ，不会因为第一次  <code>fetch</code>  进统计页面白屏，也不会因为一个页面使用就必须始终加载 —— 感觉这样才优雅一些</p><p>如果用我修改的主题的话，只需要新建一个  <code>statistics</code>  页面，直接就可以用了，统计开始时间也在  <code>config</code>  配置中：</p><figure class="highlight yml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># statistics 文章统计功能</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token key atrule">postStatistics</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token key atrule">beginDate</span><span class="token punctuation">:</span> 2015<span class="token punctuation">-</span><span class="token number">12</span> <span class="token comment">#开始统计日期</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token key atrule">tagCount</span><span class="token punctuation">:</span> <span class="token number">10</span> <span class="token comment">#统计标签个数</span></pre></td></tr></table></figure><p>周末时间折腾了一天搞这个，还是挺心疼的... 终于弄完了，这两天本来计划趁周末把算法之美收尾，然后将阅读笔记复习一遍上传博客的，结果尽搞其它去了...</p><p>一通操作下来，虽然感觉我已经可以做到自动生成 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbi9zdGF0aXN0aWNzLw==">lavenderdh 的统计页面</span> 那种多年分的日历图<br />貌似其实挺简单的：理论上通过  <code>JSON.stringify</code>  将对应字典转换成  <code>json</code>  赋值给  <code>series</code>   <code>heatmap</code>  就行了， <code>tagsChart</code>  就是一个很好的示例</p><p>不过考虑了下时间关系和本身效果 —— 还是先算了，本来也不是很重要的效果</p><p>今天待会儿先把博客弄规矩，以及 <a href="/2023/05/27/Cinemachine%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" title="Cinemachine文档整理翻译">Cinemachine文档整理翻译</a> 再过一遍看有没有写的不通畅的，然后把 DOTS 笔记也上传一下</p><p>将算法之美的笔记整理成文章... 只能等明天或者后天再说了</p><p>不过... 这个 <span class="exturl" data-url="aHR0cHM6Ly9lY2hhcnRzLmFwYWNoZS5vcmcvZXhhbXBsZXMvemgvaW5kZXguaHRtbCNjaGFydC10eXBlLXBpZQ==">echarts</span> 确实厉害，效果相当好，以后有需要没准也用得上</p><h1 id="参考文章"><a class="anchor" href="#参考文章">#</a> 参考文章</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbi9wb3N0cy8zMjY1MTczNzAxLw==">Shoka 主题：新增文章统计页面</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmV1cmtvbi5jb20vcG9zdC8xMjEzZWY4Mi5odG1s">Hexo 博客文章统计图</span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;本来最开始只是因为  &lt;code&gt;JsDeliver&lt;/code&gt;  ... 又又又挂了，导致部分用到的 CDN 在家里访问不了 —— 本来上次就已经把大部分脚本引</summary>
      
    
    
    
    <category term="博客" scheme="https://wangjiaying.top/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客" scheme="https://wangjiaying.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Cinemachine文档整理翻译</title>
    <link href="https://wangjiaying.top/2023/05/27/Cinemachine%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    <id>https://wangjiaying.top/2023/05/27/Cinemachine%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/</id>
    <published>2023-05-27T11:51:46.000Z</published>
    <updated>2023-06-04T11:42:34.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>主要内容来源于官方 Cinemachine2.8 英文文档：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5jaW5lbWFjaGluZUAyLjgvbWFudWFsL0NpbmVtYWNoaW5lVXNpbmcuaHRtbA==">https://docs.unity3d.com/Packages/com.unity.cinemachine@2.8/manual/CinemachineUsing.html</span></p><p>花了一个星期，学习之余，借助翻译软件一边看一边验证（顺便翻译，注：并不完全按照文档来的）</p><h1 id="virtual-camera"><a class="anchor" href="#virtual-camera">#</a> Virtual Camera</h1><h2 id="基本情况"><a class="anchor" href="#基本情况">#</a> 基本情况</h2><p>首先，场景中一般只有一个 Unity 相机（或者单独分离的 UI 相机），但可以有多个虚拟相机（不过一般只有一个活动）</p><p>虚拟相机应该算是  <code>Cinemachine</code>  中主要的一个组件，在某个虚拟相机处于活动状态时， <code>Cinemachine</code>  会将其移动和旋转等控制同步到 Unity 相机上。</p><ul><li>一般只有一个活动虚拟相机会控制 Unity 相机，除非设置了从一个虚拟摄像机到下一个虚拟摄像机进行混合操作，处于混合状态下的情况。</li></ul><p>虚拟相机的主要功能有：</p><ul><li>控制场景中的 Unity 相机位置</li><li>将 Unity 相机对准目标</li><li>向 Unity 相机添加程序噪声，模拟诸如手持效果或车辆震动之类的东西</li></ul><p>虚拟相机本身消耗很少，不过如果场景对性能敏感也可以直接禁用不需要的虚拟相机。<br />建议对于每个镜头都使用独立的虚拟相机进行拍摄，然后再进行剪切或混合，例如：</p><ul><li>对于两个角色交换对话的过场动画，使用三个虚拟相机：一个相机用于两个角色的中间镜头，另一个虚拟相机用于每个角色的特写镜头，使用 Timeline 将音频与虚拟摄像机同步</li><li>复制一个现有的虚拟摄像机，使两个虚拟摄像机在场景中处于相同的位置，对于第二个虚拟相机，更改 FOV 或拍摄视图。当玩家进入触发空间时，Cinemachine 会从第一个虚拟摄像机混合到第二个虚拟摄像机以强调动作的变化</li></ul><p>另外 Cinemachine 支持正交摄影机，将 Unity 摄像机的投影设置为正交投影时，Cinemachine 会自动进行调整适应，在镜头的虚拟相机属性中，FOV 被 OrthographicSize 取代</p><ul><li>在正交环境中，旋转相机通常没有意义。因此 Cinemachine 提供了 FramingTransposer 来处理取景和构图，而无需旋转摄像机</li></ul><h2 id="创建方式"><a class="anchor" href="#创建方式">#</a> 创建方式</h2><p>在 Unity 菜单中选择 GameObject &gt; Cinemachine &gt; Virtual Camera</p><ul><li>在场景创建 Virtual Camera 时，若主相机没有 CinemachineBrain，会自动挂一个 CinemachineBrain 上去，主相机及与虚拟相机位置会自动同步并保持一致</li></ul><h2 id="通用属性"><a class="anchor" href="#通用属性">#</a> 通用属性</h2><h3 id="移动或瞄准"><a class="anchor" href="#移动或瞄准">#</a> 移动或瞄准</h3><p>虚拟相机有两个主要目标：</p><ul><li>Follow 目标指定一个 GameObject 供虚拟相机移动<ul><li>指定 Follow 后，则虚拟相机位置会与跟随对象以 FollowOffset 偏移保持一致 (取决于 Body 配置)</li></ul></li><li>LookAt 目标指定要瞄准的 GameObject<ul><li>指定 LookAt 后，则虚拟相机朝向会始终朝向于 LookAt 对象 (取决于 Aim 配置)</li></ul></li></ul><p>主要参数有 Aim、Body 和 Noise 的配置，用于指定虚拟相机如何为位置、旋转和其它属性设置动画</p><ul><li>当 Cinemachine Brain 或 Timeline 将 Unity 摄像机的控制权转移到虚拟摄像机时，虚拟摄像机将这些设置应用于 Unity 摄像机</li><li>在任何时候，每个虚拟相机都可能处于以下状态之一：<ul><li>Live：Virtual Camera 主动控制具有 Cinemachine Brain 的 Unity 摄像机。当 Cinemachine Brain 从一个虚拟摄像机混合到另一个虚拟摄像机时，两个虚拟摄像机都是活动的，混合完成后，只有一个活动虚拟摄像机</li><li>Standby：Virtual Camera 不控制 Unity 相机，但仍然跟随并瞄准目标，并在每一帧更新。处于此状态的虚拟摄像头已激活，其优先级与实时虚拟摄像头相同或更低</li><li>Disabled：Virtual Camera 不控制 Unity 相机并且不主动跟随或瞄准其目标。这种状态下的虚拟相机没有性能消耗，停用其游戏对象即可禁用。不过即使禁用，如果参与混合或者被 Timeline 调用，虚拟相机仍然可以控制 Unity 相机</li></ul></li></ul><p>Cinemachine 包括各种算法来控制移动和瞄准，每个算法都解决一个特定的问题，并且如果有特殊需要也可以进行自定义</p><ul><li>Cinemachine 将这些算法实现为 CinemachineComponent 对象，可使用 CinemachineComponent 类来实现自定义移动或瞄准行为</li></ul><p>Body 配置提供了以下用于在场景中移动虚拟相机的算法：</p><ul><li>Transposer (默认)：以与 Follow 目标的固定关系移动，具有可选的阻尼</li><li>3rd Person follow：围绕玩家水平和垂直旋转的相机，指向跟随目标</li><li>Do Nothing：虚拟相机不会跟随移动 (但是会瞄准)</li><li>Framing Transposer：以固定的屏幕空间关系移动到 Follow 目标，可选择阻尼</li><li>Orbital Transposer：以可变关系移动到 Follow 目标，可选择接受玩家输入</li><li>Tracked Dolly：沿着预定义的路径移动</li><li>Hard Lock to Target：将相机位置设置为与跟随目标一致</li></ul><p>Aim 配置提供了以下用于旋转虚拟相机以面向 LookAt 目标的程序算法：</p><ul><li>Composer：将 Look At 目标保持在相机框架中，并具有构图限制</li><li>Group Composer：在相机画面中保留多个 Look At 目标</li><li>Do Nothing：不旋转虚拟相机</li><li>POV：根据用户的输入旋转虚拟相机</li><li>Same As Follow Target：将相机的旋转设置为跟随目标的旋转</li><li>Hard Look At：将注视目标保持在相机框架的中心</li></ul><h3 id="主要属性"><a class="anchor" href="#主要属性">#</a> 主要属性</h3><ul><li>Solo：似乎只是编辑器使用，可以暂时切换到当前的这个虚拟相机进行预览</li><li>Game Window Guides：在游戏视图中切换构图提示框的可见性 (就是点开 Aim 之后的区域显示)</li><li>Save During Play：选中以在播放模式下应用更改，使用此功能可以播放模式直接微调虚拟相机，这是一个全局属性，适用于所有虚拟相机</li><li>Priority：此虚拟相机对于下一个镜头选择的重要程度，较高的值表示较高的优先级。<ul><li>Cinemachine Brain 从所有激活的虚拟摄像机中选择下一个实时虚拟摄像机，并且与当前实时虚拟摄像机具有相同或更高的优先级。使用带 Timeline 控制时，此属性无效</li></ul></li><li>Follow：跟随目标对象，Body 属性使用此目标来更新 Unity 相机的位置。将此属性留空可以手动控制虚拟相机变换的位置，例如在 Timeline 中为虚拟相机设置动画</li><li>Look At：瞄准的目标对象。 Aim 属性使用此目标来更新 Unity 相机的旋转</li><li>Standby Update：控制虚拟相机不活动时更新频率</li><li>Position Blending：与此虚拟相机混合位置的方式<ul><li>Linear (线性)</li><li>Spherical (球形)：如果有注视目标，则围绕注视位置进行球形混合</li><li>Cylindrical (圆柱形)：如果有注视目标，则围绕注视位置进行圆柱混合，垂直坐标被线性插值</li></ul></li><li>Lens：在 Unity 相机属性中的对应项<ul><li>Field Of View</li><li>Presets：常用镜头预设，可以点击下拉菜单选择或保存</li><li>Orthographic Size：使用的 Unity 相机是正交相机时有用</li><li>Near Clip Plane</li><li>Far Clip Plane</li><li>Dutch (荷兰角度 / 斜角镜头)：将相机相对于场景倾斜，以度为单位在 z 轴上倾斜 Unity 相机。此属性是虚拟相机独有的</li><li>Mode Override：当 Cinemachine 激活此虚拟摄像机时，允许选择不同的摄像机模式应用于 Unity 摄像机<ul><li>None</li><li>Orthographic：正交相机模式</li><li>Perspective：透视相机模式</li><li>Physical：物理相机模式</li></ul></li><li>Blend Hint：混入或混出虚拟相机位置的提示（暂时不知道具体做什么）</li><li>Inherit Position：启用后，只要此虚拟摄像机活动，就会强制初始位置与 Unity 摄像机的当前位置相同（如果可能）</li><li>Extensions：向虚拟相机添加额外行为的组件<ul><li>Cinemachine 自带了部分扩展，继承 CinemachineExtension 类可以创建自己的自定义扩展</li></ul></li></ul></li></ul><h2 id="body-properties"><a class="anchor" href="#body-properties">#</a> Body properties</h2><p>使用 Body 属性指定在场景中移动虚拟相机的方法</p><h3 id="3rd-person-follow"><a class="anchor" href="#3rd-person-follow">#</a> 3rd Person Follow</h3><p>第三人称跟随会将相机保持在相对于 Follow 目标的恒定位置和距离，跟踪目标的移动和旋转，并直接提供了相机与目标间的障碍检测功能。</p><ul><li>ShoulderOffset：如同名字一样，偏移<ul><li>当其 X 值有值的时候，后续 CameraSide 才有效</li></ul></li><li>CameraSide：当 ShoulderOffset X 轴有值时，该项才有效，影响往左偏还是往右偏 (0~1)<ul><li>实测若 0.5 则不变，也就是居中，当这个不为 0.5 时，ShoulderOffset X 才有效</li></ul></li><li>Vertical Arm Length：手相对于肩的垂直偏移。当相机垂直旋转时，臂长会影响跟随目标的屏幕位置，对于第一人称相机，这可以设置为 0</li><li>Camera Radius：指定相机在不调整其位置的情况下可以接近可碰撞障碍物的距离</li><li>Damping Into Collision：指定相机如何移动以校正遮挡，数字越大越慢</li><li>Damping From Collision：返回正常位置速度，数字越大，相机恢复速度越慢</li></ul><h3 id="framing-transposer"><a class="anchor" href="#framing-transposer">#</a> Framing Transposer</h3><p>专为 2D 和正交相机而设计</p><ul><li>这种虚拟相机机身算法将相机以固定的屏幕空间关系移动到跟随目标<ul><li>还可以指定偏移量、阻尼和合成规则</li><li>Framing Transposer 仅更改相机在空间中的位置，不会重新定向或以其他方式瞄准相机</li></ul></li><li>注 1：Framing Transposer 忽略 LookAt 目标 - 仅使用 Follow 目标，如果同时使用了 Aim 相关操作可能会有冲突</li><li>注 2：Framing Transposer 专为 2D 和正交相机而设计，但它也适用于透视相机和 3D 环境<ul><li>该算法首先沿相机 Z 轴移动相机，直到 Follow 目标与相机的 X-Y 平面相距达到所需的距离。然后它在 X-Y 平面中移动相机，直到跟随目标位于相机屏幕上的所需点</li></ul></li></ul><p>主要属性</p><ul><li>Lookahead Time<ul><li>根据目标的运动调整虚拟相机与跟随目标的偏移量</li><li>Cinemachine 预测目标将在未来这么多秒的时间点</li><li>此功能对嘈杂的动画很敏感，会放大噪音，从而导致不良的相机抖动。如果在目标运动时相机抖动不可接受，请调低此属性，或使目标动画更平滑</li></ul></li><li>Lookahead Smoothing<ul><li>预测算法的平滑度。较大的值可以消除抖动的预测并增加预测滞后</li></ul></li><li>Screen X/Y：相机跟随目标的屏幕位置</li><li>Camera Distance：跟踪距离</li><li>Dead Zone Width/Height：在此范围时，不移动相机</li><li>Dead Zone Depth：如果跟随目标与相机距离在此距离内，不沿其 z 轴移动相机</li><li>Soft Zone Width/Height：当目标在此范围内时，移动相机以将目标框在 DeadZone 内，阻尼属性影响相机移动的速率</li><li>Bias X/Y：软区的中心的偏移</li></ul><h3 id="hard-lock-to-target"><a class="anchor" href="#hard-lock-to-target">#</a> Hard Lock to Target</h3><p>将虚拟相机机身直接设置为 Follow 目标的位置</p><ul><li>换句话说，目标充当虚拟相机的安装点</li></ul><h3 id="orbital轨道-transposer"><a class="anchor" href="#orbital轨道-transposer">#</a> Orbital (轨道) Transposer</h3><p>可以选择接受玩家输入，允许玩家动态控制相机相对于目标的位置<br />这种虚拟相机机身算法将 Unity 相机移动到虚拟相机的跟随目标的可变关系中</p><ul><li>看着是绕目标的一个『圆环』轨道</li><li>可以设置移动限制角度范围，可选超出则停止或 Wrap 到另一个角度</li><li>Orbital Transposer 引入了航向的概念，即目标移动或面向的方向<ul><li>Orbital Transposer 尝试定位相机，使其指向与前进方向相同的方向</li><li>默认情况下，此位置位于目标的正后方，可通过调整 Heading-&gt;Bias 属性来控制这种关系</li></ul></li><li>Heading：指定如何计算 Follow 目标的航向<ul><li>Definition<ul><li>Position Delta：根据上次更新和当前帧的目标位置差异计算航向</li><li>Velocity：选择速度以使用目标刚体的速度，如果目标没有 Rigidbody 组件，则恢复为 Position Delta</li><li>Target Forward：使用目标的本地 Forward 轴作为航向</li><li>World Forward：使用恒定的世界空间 Forward 作为航向</li></ul></li><li>Velocity Filter Strength：在定义中使用 Position Delta 或 Velocity 时控制速度的平滑度</li><li>Bias：相对于航向放置相机的轨道中的角度偏移，以度为单位</li></ul></li><li>Recenter To Target Heading：勾选后，当玩家没有输入时控制自动重新居中<ul><li>注：当 Definition 选 Position Delta 或 Velocity 时可能没用</li></ul></li><li>X Axis：航向控制，此处的设置控制相机响应玩家输入的行为<ul><li>Wrap：如果选中，则轴在最小值和最大值处环绕，形成一个循环</li><li>Speed Mode：轴如何响应输入<ul><li>MaxSpeed（默认值）：限制轴可以改变的最大速度，与输入无关</li><li>InputValueGain：将输入值乘以 MaxSpeed</li></ul></li><li>Invert：反向</li></ul></li></ul><h3 id="tracked-dolly"><a class="anchor" href="#tracked-dolly">#</a> Tracked Dolly</h3><ul><li>限制虚拟相机沿预定义路径移动，使用路径位置属性指定将虚拟相机放置在路径上的位置</li><li>使用 Auto-Dolly 模式将虚拟相机移动到路径上最接近 Follow 目标的位置。启用后，Auto-Dolly 会自动将虚拟相机的位置动画化到路径上最接近目标的位置<ul><li>注：提示：使用 Auto-Dolly 模式时请谨慎选择路径形状，这在围绕某个点形成弧形的路径上会出现问题。作为一个极端的例子，考虑一个以 Follow 目标为中心的完美圆形路径。路径上的最近点变得不稳定，因为圆形路径上的所有点都同样接近目标，在这种情况下，将 Follow 目标移动一小段距离会导致相机在轨道上移动很远的距离</li></ul></li><li>Path Position：沿路径放置相机的位置，可直接设置或启用 Auto-Dolly，采用 Position Units 指定的单位</li><li>Position Units：路径位置的度量单位<ul><li>Path Units：沿途使用路标，值 0 表示路径上的第一个路点，1 表示第二个路点，依此类推</li><li>Distance：使用沿路径的距离</li><li>Normalized：值 0 表示路径的开始，1 表示路径的结束</li></ul></li><li>Path Offset：相机相对于路径的位置偏移</li><li>X/Y/Z Damping：移动阻尼，影响移动速度，越大越慢</li><li>Camera Up：如何为虚拟相机设置朝向<ul><li>Default：不修改虚拟相机的朝向，但会使用 Cinemachine Brain 中的 World Up Override 属性控制 (如果有的话)</li><li>Path：在当前点使用路径的朝向</li><li>Path No Roll：在当前点使用路径的朝向，但不旋转校正</li><li>Follow Target：使用 Follow 目标变换中的朝向</li><li>Follow Target No Roll：使用来自 Follow 目标变换的向上矢量，但不旋转校正</li></ul></li><li>Pitch/Yaw/Roll Damping：旋转阻尼，小数字使相机更灵敏，数字越大，相机响应越慢</li><li>Auto Dolly：控制如何自动移动相机，使用此功能需要有 Follow target<ul><li>Enabled：启用自动移动<ul><li>注意：这可能会对性能产生一些影响，具体取决于 Search Resolution 参数</li></ul></li><li>Position Offset：从路径上最近的点到跟随目标的偏移量，以 Position Units 为单位</li><li>Search Radius：当前段两侧的段数。对整个路径使用 0。当路径的形状相对于目标位置导致路径上的最近点变得不稳定时，使用较小的数字</li><li>Search Resolution：Cinemachine 通过将路径分成许多直线片段来搜索，数字越大，结果越准确。数值越高性能消耗也越大</li><li>注：该功能可以配合 DollyCart 使用（Cinemachine-&gt;DollyTrackWithCart，DollyCart 能够自动跟随路径点移动），再配合循环路点就可以无限环绕了</li></ul></li></ul><h4 id="cinemachine-path"><a class="anchor" href="#cinemachine-path">#</a> Cinemachine Path</h4><ul><li>是一个定义世界空间路径的组件，由一组路径点组成</li><li>使用 Bezier 插值来计算路点之间的位置以获得平滑且连续的路径，路径经过所有路点</li><li>可调整的控制属性相对 SmoothPath 更多</li><li>主要属性<ul><li>Resolution：路径采样分辨率</li><li>Looped：使路径循环封闭</li><li>Selected Waypoint：当前选中路径点的属性信息</li><li>Prefer Tangent Drag：当切线和位置的 Gizmo 在场景视图中重合时，选中以使用 Gizmo 作为路点的切线</li><li>Path Details<ul><li>Position：路径局部空间中的位置（即相对于路径对象本身）</li><li>Tangent：与位置的偏移量，它定义了路径点处曲线的切线</li><li>Roll：此路点的路径旋转，其他方向轴是从切线和 World Up 推断出来的（影响不会传递给其它路径点，只影响该路径点相连的两条边）</li></ul></li></ul></li></ul><h4 id="cinemachine-smooth-path推荐"><a class="anchor" href="#cinemachine-smooth-path推荐">#</a> Cinemachine Smooth Path (推荐)</h4><ul><li>是一个定义世界空间路径的组件，由一组路点组成</li><li>使用 Bezier 插值来计算路点之间的位置以获得平滑且连续的路径，路径经过所有路点</li><li>与 Cinemachine Path 不同，一阶和二阶连续性得到保证，这意味着不仅位置而且沿路径动画的对象的角速度都将是平滑和连续的，但也因此使我们对路径位置的控制更少</li><li>主要属性<ul><li>Waypoints：定义的所有路径点列表，使用贝塞尔曲线进行插值<ul><li>Position：路径点在在局部路径空间中的位置</li><li>Roll：此路点的路径旋转，其他方向轴是从切线和 World Up 推断出来的（影响会传递给其它路径点）</li></ul></li></ul></li></ul><p>注：可以设置为循环路点</p><h4 id="cinemachine-dolly-cart"><a class="anchor" href="#cinemachine-dolly-cart">#</a> Cinemachine Dolly Cart</h4><p>CinemachineDollyCart 是一个组件，可使用它沿着 Cinemachine Path 或 Cinemachine Smooth Path 路径为游戏对象设置路径移动动画，或作为虚拟相机的跟随目标<br />主要属性</p><ul><li>Path：路径</li><li>Update Method：当速度不为零时何时移动，使用 Update 进行正常的 MonoBehaviour 更新，使用 Fixed Update 进行与物理模块 FixedUpdate () 同步的更新，或 LateUpdate</li><li>Position Units：位置的度量单位<ul><li>Path Units：沿途使用路标，值 0 表示路径上的第一个路点，1 表示第二个路点，依此类推</li><li>Distance：使用沿路径的距离，根据路径的 Resolution 属性对路径进行采样。，Cinemachine 会创建一个距离查找表并存储在内部缓存中</li><li>Normalized：使用归一化 0~1 作为首尾</li></ul></li><li>Speed：以此速度移动，该值根据 PositionUnits 进行解释</li><li>Position：当前处于路径中的位置，可以直接设置动画，或者如果速度不为零，将自动更新，该值根据 PositionUnits 进行解释</li></ul><h3 id="transposer"><a class="anchor" href="#transposer">#</a> Transposer</h3><p>该算法将虚拟相机以固定偏移量移动到跟随目标，可应用阻尼</p><ul><li>固定偏移量可以有多种模式选择</li></ul><p>参数</p><ul><li>Binding Modes：绑定模式定义了 Unity 用来解释相机与目标的偏移量和阻尼的坐标空间<ul><li>Lock To Target：使虚拟相机使用 Follow 目标的本地坐标，当目标旋转时，相机也随之旋转以保持偏移并保持目标的相同视图</li><li>Lock To Target No Roll：使虚拟相机使用 Follow 目标的本地坐标，但不进行 Roll 的旋转 (实测是不受对象的 Z 轴旋转了)</li><li>Lock To Target On Assign：在激活虚拟相机或分配目标时，使虚拟相机的方向与 Follow 目标的局部坐标匹配。此偏移量在世界空间中保持不变。相机不随目标旋转</li><li>Lock To Target With World Up：使虚拟相机使用倾斜和滚动为 0 的跟随方式，此绑定模式忽略除 Yaw 之外的所有目标旋转</li><li>World Space：偏移量在世界空间中解释为相对于跟随目标的原点，目标旋转时相机不会改变位置</li><li>Simple Follow With World Up：此模式模拟人类摄像师在被指示跟随目标时将采取的行动，相机尝试尽可能少地移动以与目标保持相同的距离；相机相对于目标的方向无关紧要。无论目标的方向如何，相机都会尝试与其保持相同的距离和高度</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5jaW5lbWFjaGluZUAyLjgvbWFudWFsL0NpbmVtYWNoaW5lQmluZGluZ01vZGVzLmh0bWw=">https://docs.unity3d.com/Packages/com.unity.cinemachine@2.8/manual/CinemachineBindingModes.html</span></li></ul></li><li>Follow Offset：相对于跟随目标的距离</li><li>X/Y/Z Damping：响应阻尼</li><li>Pitch/Yaw/Roll Damping：旋转阻尼</li></ul><h2 id="aim-properties"><a class="anchor" href="#aim-properties">#</a> Aim properties</h2><p>使用该属性下的设置指定虚拟相机如何旋转</p><h3 id="do-nothing"><a class="anchor" href="#do-nothing">#</a> Do Nothing</h3><p>本身什么都不做，可以用于静态镜头或直接使用自定义脚本设置旋转动画</p><h3 id="composer"><a class="anchor" href="#composer">#</a> Composer</h3><p>此虚拟相机始终旋转相机以面向注视目标</p><ul><li>Center On Activate：选中后，当相机变为活动状态时，强制相机位于屏幕中央，否则位于最近的 DeadZone 边缘</li><li><img data-src="/blogimages/2023/2023-05-27/1.png" alt="" /></li><li>Tracked Object Offset：从 Look At 目标的中心偏移，可用于当所需区域不是被跟踪对象的中心时，微调跟踪目标位置</li><li>Lookahead Time：根据注视目标的运动调整偏移量，该算法预估目标将在未来指定时间运动 (秒)<ul><li>测试：随着值的增加，当物体运动时，追踪的中心点变了，处于预估位置</li><li>此功能对嘈杂的动画很敏感。它会放大噪声，导致不希望出现的相机抖动。如果在目标运动时相机抖动不可接受，请调低此属性或使目标动画更平滑</li></ul></li><li>Lookahead Smoothing：控制 Lookahead Time 算法的平滑度，较大的值可以消除预测抖动并增加预测滞后</li><li>Lookahead Ignore Y：预测计算忽略沿 Y 轴的移动</li><li>Horizontal/Vertical  Damping：相机在屏幕方向上跟随目标的响应速度，较小的数字会让相机旋转更灵敏、快速，以将目标保持在 DeadZone 内。对更重、响应更慢的相机使用更大的数字</li><li>Screen X/Y：DeadZone 中心的屏幕位置，摄像机旋转保持目标处于这里</li><li>Dead Zone Width/Height：在该区域中相机忽略目标的任何移动，也不会更新其旋转。这对于忽略较小的目标移动很有用</li><li>Soft Zone Width/Height：如果目标出现在屏幕的这个区域，相机将旋转以将保持于 DeadZone</li><li>Bias X/Y：SoftZone 相对于 DeadZone 的偏移</li></ul><h3 id="group-composer"><a class="anchor" href="#group-composer">#</a> Group Composer</h3><p>这种 Virtual Camera Aim 算法将相机瞄准多个游戏对象</p><ul><li>它的行为与 Composer 相同并且具有相同的设置</li><li>如果 Look At 目标是 Cinemachine Target Group，可以调整 FOV 和摄像机距离，以确保正确瞄准目标组</li></ul><h4 id="cinemachine-target-group"><a class="anchor" href="#cinemachine-target-group">#</a> Cinemachine Target Group</h4><p>使用 Cinemachine Target Group 将多个游戏对象视为单个 Look At 目标， Target Group 与虚拟相机 Group Composer 算法结合使用</p><ul><li>Position Mode<ul><li>Group Center：使用包含目标组所有对象的轴对齐边界框的中心</li><li>Group Average：使用目标组中各个对象位置的加权平均值</li></ul></li><li>Rotation Mode<ul><li>Manual：使用目标组变换的旋转属性中指定的值 (推荐)</li><li>Group Average：目标组中所有对象方向的加权平均值</li></ul></li><li>Update Method<ul><li>Update：在正常的 MonoBehaviour Update () 方法中更新</li><li>Fixed Update：在 FixedUpdate () 中与物理模块同步更新</li><li>Late Update：在 MonoBehaviour LateUpdate () 中更新</li></ul></li><li>Targets<ul><li>Weight：对象权重，不能为负</li><li>Radius：对象半径，用于计算边界框，不能为负</li></ul></li></ul><h3 id="hard-look-at"><a class="anchor" href="#hard-look-at">#</a> Hard Look At</h3><p>旋转虚拟相机以将注视目标始终保持在相机框架的中心</p><h3 id="pov"><a class="anchor" href="#pov">#</a> POV</h3><p>这种 Virtual Camera Aim 算法会根据用户的输入来控制相机旋转</p><ul><li>Vertical/Horizontal  Axis：控制虚拟相机旋转<ul><li>Value：当前相机瞄准的轴的度数，以度为单位。可接受的值为 -90 到 90</li><li>Value Range：虚拟相机垂直轴可允许旋转的最小和最大度数</li><li>Wrap：如果选中，轴环绕 ValueRange 范围形成一个循环</li><li>Speed Mode：轴如何响应输入<ul><li>MaxSpeed（默认值）：限制轴可以改变的最大速度，与输入无关</li><li>InputValueGain：将输入值乘以 MaxSpeed</li></ul></li><li>Accel Time：加速时间</li><li>Decel Time：减速时间</li><li>Input Axis Name：在 Unity 输入管理器中指定的该轴的名称，要禁用则将此属性设置为空字符串</li><li>Input Axis Value：输入轴的值。值为 0 表示没有输入，可以直接从自定义输入系统驱动它，或者也可以设置输入轴名称并让值由 Unity 输入管理器驱动</li><li>Invert：在使用 InputAxisName 输入的值之前反转原始值</li></ul></li><li>Vertical/Horizontal  Recentering：当玩家没有输入时控制自动返回居中</li></ul><h3 id="same-as-follow-target"><a class="anchor" href="#same-as-follow-target">#</a> Same As Follow Target</h3><p>与目标旋转保持一致</p><ul><li>当与 Body 属性中的 Hard Lock to Target 算法一起使用时，该算法使虚拟相机匹配控件 GameObject 的路径和旋转</li></ul><h2 id="noise使用噪声模拟相机抖动"><a class="anchor" href="#noise使用噪声模拟相机抖动">#</a> Noise：使用噪声模拟相机抖动</h2><p>现实世界中的物理相机一般比较笨重，由摄像师手持或安装在例如移动的车辆等不稳定的物体上<br />可以使用噪声属性来模拟这些真实世界的效果：例如在跟随奔跑的角色时添加相机抖动</p><ul><li>在每次帧更新时，Cinemachine 都会添加与摄像机运动分开的噪声以跟随目标</li><li>噪声不会影响相机在未来帧中的位置，这种分离可确保阻尼等属性按预期运行</li></ul><p>Cinemachine 包含一个基本多通道 Perlin 组件，可以将 Perlin 噪声添加到虚拟摄像机的运动中</p><h3 id="属性设置"><a class="anchor" href="#属性设置">#</a> 属性设置</h3><ul><li>Noise Profile：要使用的噪声配置文件资产</li><li>Amplitude Gain：应用于噪声曲线中定义的振幅的增益<ul><li>使用 1 以使用噪声配置文件中定义的振幅，将此设置为 0 可禁用</li><li>提示：设置此属性的动画可使噪声效果上下倾斜</li></ul></li><li>Frequency Gain：应用于噪声配置文件中定义的频率的系数<ul><li>使用 1 以使用噪声配置文件中定义的频率</li><li>使用较大的值可以更快地摇动相机</li><li>提示：设置此属性的动画可使噪声效果上下倾斜</li></ul></li><li>Pivot Offset：旋转相机时，在应用旋转噪声时将相机的枢轴偏移指定的 x、y 和 z 距离。这会产生一些与旋转噪声相对应的位置变化</li></ul><h3 id="噪声配置文件"><a class="anchor" href="#噪声配置文件">#</a> 噪声配置文件</h3><p>噪声配置文件是定义相机噪声程序曲线的资源</p><ul><li>Basic Multi Channel Perlin 组件将噪声配置文件应用于相机的移动， Cinemachine 在计算出摄像机的位置后应用噪声移动</li><li>可以设置位置、旋转的振幅、频率以合成随机噪声效果</li></ul><p>注：</p><ul><li>对于振幅，对更宽的镜头使用更大的值以显着地抖动相机。对于长焦镜头，使用较小的振幅值，因为较窄的 FOV 会放大效果</li><li>对于频率，典型的低频范围为 0.1-0.5 Hz，中频范围为 0.8-1.5，高频范围为 3-4。最高有用频率取决于游戏的帧速率。游戏通常以 30 或 60Hz 运行，高于游戏帧速率的噪声频率介于奈奎斯特速率之间。换句话说，它们不会被直接跟踪<ul><li>例如，如果游戏以 60 帧 / 秒的速度运行并且将频率设置为 100，将获得不连贯的相机噪音</li><li>这是因为游戏无法渲染比帧速率更快的物体</li></ul></li></ul><p>参数</p><ul><li>Preview Time：在检查器的图形中显示的秒数，用于编辑时在检查器中预览时长</li><li>Preview Height：预览框高度</li><li>Animated：预览噪声波动的移动表示</li><li>Position Noise：相机移动的所有轴的所有噪声层的图形表示<ul><li>Frequency：噪声层中波的频率，以 Hz 为单位</li><li>Amplitude：噪声层中波的振幅（高度），以距离为单位</li><li>Non-random wave if checked：选中以从噪声层中移除 Perlin 噪声 (随机化频率和振幅，同时保持在所选值的附近)，没有 Perlin 噪声会使用常规正弦波</li></ul></li><li>Rotation Noise：相机旋转所有轴的所有噪声层的图形表示（设置同位置）</li></ul><h2 id="虚拟相机之间的混合"><a class="anchor" href="#虚拟相机之间的混合">#</a> 虚拟相机之间的混合</h2><p>使用混合属性指定 CinemachineBrain 组件如何在虚拟摄像机之间执行混合</p><ul><li>Cinemachine 混合不是淡入淡出、擦除或溶解，而是执行从一个虚拟摄像机到下一个虚拟摄像机时 Unity 摄像机的位置、旋转和其他设置的平滑动画</li><li>对于特定虚拟摄像机之间的混合，使用 CinemachineBrain 组件中的自定义混合列表，使用 CinemachineBrain 中的默认混合属性来指定没有自定义混合的虚拟摄像机之间的混合<ul><li>From 和 To 设置是基于<strong>名称</strong>的，而不是引用</li><li>这意味着 Cinemachine 通过将名称与设置相匹配来查找摄像机，而非链接到特定的游戏对象，内置下拉菜单可用于从当前场景中选择虚拟摄像机，或者直接在文本框中输入名称，如果名称与当前场景中的任何虚拟摄像机都不匹配，则该字段将以黄色突出显示</li></ul></li><li>当 Cinemachine 开始从一个虚拟摄像机过渡到另一个虚拟摄像机时，它将在此资设置中查找与即将到来的过渡相匹配的条目，并应用该混合定义<ul><li>如果未找到，则将应用 CinemachineBrain 的 DefaultBlend 设置</li><li>如果在资产设置中找到读个匹配，Cinemachine 将选择具有最强特异性的一个。例如，如果从 vcam1 混合到 vcam2，并且自定义混合资产包含 vcam1-to-AnyCamera 的条目和 vcam1-to-vcam2 的另一个条目，则 vcam1-to-vcam2 条目将适用</li><li>如果 Custom Blends 资产中的多个条目与即将到来的过渡具有同样强烈的特异性，那么找到的第一个将适用</li></ul></li></ul><h3 id="属性"><a class="anchor" href="#属性">#</a> 属性</h3><ul><li>From：要混合的虚拟摄像机的名称。使用名称 <strong>ANY CAMERA</strong> 从任何虚拟相机进行混合。此属性仅适用于自定义混合</li><li>To：要混合到的虚拟摄像机的名称。使用名称 <strong>ANY CAMERA</strong> 混合到任何虚拟相机。此属性仅适用于自定义混合</li><li>Style Default Blend：混合曲线<ul><li>Cut：没有混合，直接切换</li><li>Ease In Out：S 型曲线，过渡平缓流畅</li><li>Ease In：从传出的虚拟摄像机中线性 (Linear) 淡出，并缓和到混入新的虚拟摄像机中</li><li>Ease Out：缓和淡出虚拟摄像机，并线性混合到新的虚拟摄像机中</li><li>Hard In：从旧的虚拟摄像机中缓出，并加速进入新的虚拟摄像机</li><li>Hard Out：加速离开旧的的虚拟摄像机，并缓缓进入新的虚拟摄像机</li><li>Linear：线性混合</li><li>Custom：自定义曲线</li></ul></li><li>Time：混合的持续时间（以秒为单位）</li></ul><h2 id="composing-a-shot拍摄视图"><a class="anchor" href="#composing-a-shot拍摄视图">#</a> Composing a shot（拍摄视图）</h2><p>Framing Transposer、Composer 和 Group Composer 算法定义相机框架中的区域，以供构图：</p><ul><li>空区 (Dead zone)：Cinemachine 将目标保留在画面中的区域</li><li>软区 (Soft zone)：如果目标进入画面的这个区域，相机将重新定向以将其放回盲区。根据阻尼设置中指定的时间，它会缓慢或快速地执行此操作</li><li>屏幕 (Screen)：死区中心的屏幕位置。 0.5 是屏幕的中心。</li><li>阻尼 (Damping)：模拟真实摄像师在操作重型物理摄像头时引入的滞后。阻尼指定相机在跟踪目标时目标进入软区时快速或缓慢地做出反应。使用较小的数字来模拟更灵敏的相机，快速移动或瞄准相机以将目标保持在盲区内。较大的数字模拟较重的摄像机，值越大，Cinemachine 越允许目标进入软区</li></ul><p><img data-src="/blogimages/2023/2023-05-27/2.png" alt="" /></p><p>如上图所示：</p><ul><li>空白区域表示空区 (Dead zone)<ul><li>(没大明白)</li></ul></li><li>蓝色区域表示软区 (Soft zone)</li><li>红色区域表示目标永远不会进入的禁区，黄色方块表示目标</li></ul><p>调整这些区域可以获得各种相机行为，例如使用更大的阻尼值来模拟更大、更重的相机，或者扩大软区和死区以在相机框架的中间创建一个不受目标运动影响的区域。例如用于动画循环之类的事情、比如如果不希望目标移动一点点相机就跟踪目标</p><h1 id="分组虚拟像机"><a class="anchor" href="#分组虚拟像机">#</a> 分组虚拟像机</h1><p>分组摄像机可以同时管理多个虚拟摄像机，但从 CinemachineBrain 和 TimeLine 的角度来看，只将其当做单个虚拟摄像机对象</p><h2 id="freelook-camera"><a class="anchor" href="#freelook-camera">#</a> FreeLook Camera</h2><p>该组件可以接受玩家输入<br /> Cinemachine Free Look Camera 组件提供第三人称视角的相机体验</p><ul><li>该组件沿着由三个独立的摄像机装置指定的位置围绕其主体运行：顶部、中部和底部</li><li>三个部位，每个部位都定义一个围绕目标的环，具有自己独立的设置，与常规虚拟相机的属性相同</li><li>接受玩家输入时，会根据对应输入在轨道之间进行混合</li></ul><p>沿 x 轴和 y 轴使用玩家输入</p><ul><li>x 轴控制沿着顶部、中间或底部水平轨道的轨道位置，就像轨道转置器一样</li><li>y 轴控制垂直位置，使用样条曲线确定相机之间的位置</li></ul><p>整体上是一个圆环，可视作处于目标周围一个圆的表面的移动<br />主要属性</p><ul><li>Binding Modes：同 Transposer 的模式</li><li>Spline Curvature：连接钻机轨道的线的曲率，这条线决定了 y 轴上的最终位置</li><li>Height, Radius：Top、Middle 和 Bottom 三个环相对于 Follow 目标的半径和高度</li></ul><h2 id="cinemachine-mixing-camera"><a class="anchor" href="#cinemachine-mixing-camera">#</a> Cinemachine Mixing Camera</h2><p>Cinemachine 混合摄像机组件使用其子虚拟摄像机的加权平均值来计算 Unity 摄像机的位置和其他属性<br /> Mixing Camera 最多管理八个子虚拟摄像机，通过场景右键创建时，会自动添加两个子虚拟相机</p><ul><li>在 Mixing Camera 组件中，这些 Virtual Cameras 是固定的插槽，而不是动态数组</li><li>Mixing Camera 使用此实现来支持 Timeline 中的权重动画，Timeline 不能为数组元素设置动画</li></ul><p>主要属性</p><ul><li>Child Camera Weights：虚拟相机的重量，注意将一个相机的权重设置为 1 不会将其他权重设置为零。任何单个相机的权重贡献是它的权重除以所有子权重的总和</li><li>Mix Result：子虚拟相机权重的图形表示，每个子相机的条形的浅色部分代表其对混合相机最终位置的贡献比例，当条形完全变暗时，摄像机对混合摄像机的位置将没有任何影响</li></ul><h2 id="cinemachine-blend-list-camera"><a class="anchor" href="#cinemachine-blend-list-camera">#</a> Cinemachine Blend List Camera</h2><p>Cinemachine 混合列表摄像机组件在其子虚拟摄像机之间执行一系列混合或剪切</p><ul><li>当混合列表相机被激活时，它会执行其指令列表，激活列表中的第一个子虚拟相机，保持指定的时间，然后剪切或混合到下一个子对象，依此类推</li><li>混合列表摄像机保留到最后一个虚拟摄像机，直到 CinemachineBrain 或时间轴停用混合列表摄像机</li></ul><p>提示：使用 Blend List Camera 而不是 Timeline 以获得更简单的自动序列<br />通过场景右键创建时，会自动添加两个子虚拟相机<br />主要属性</p><ul><li>Follow：子虚拟相机移动的默认目标，当子虚拟相机没有指定跟踪目标时，BlendList 相机使用这个目标，如果子虚拟相机都定义了自己的目标，则可以为空</li><li>LookAt：Unity 相机瞄准的默认目标，当子虚拟相机没有指定跟踪目标时，BlendList 相机使用这个目标，如果子虚拟相机都定义了自己的目标，则可以为空</li><li>Loop：启用后，子虚拟摄像机将无限循环，而不是停在列表中的最后一个虚拟摄像机上</li><li>Hold：到达位置后的停止时间，停止指定时间后继续</li></ul><h2 id="cinemachine-clear-shot-camera"><a class="anchor" href="#cinemachine-clear-shot-camera">#</a> Cinemachine Clear Shot Camera</h2><p>该组件在其子虚拟相机中选择拍摄目标时，选取镜头质量最好的相机，使用 ClearShot 设置场景的复杂多摄像机覆盖范围，以保证目标的清晰视野<br />这个功能很强大，具有 CinemachineCollider 扩展的虚拟相机子项分析场景中的目标障碍物、最佳目标距离等， ClearShot 使用此信息来选择最适合激活的一个</p><ul><li>如果多个子摄像头的镜头质量一样，Clear Shot 摄像头会选择优先级最高的一个</li><li>还可以定义清晰镜头子相机之间的自定义混合</li></ul><p>注 1：『镜头质量』应该指没有被障碍物遮挡<br />注 1：如果想要为所有虚拟摄像机子项使用单个 CinemachineCollider，可以直接将 CinemachineCollider 扩展添加到 ClearShot 对象，而非每个子虚拟摄像机单独挂。这样这个 CinemachineCollider 扩展会适用于所有的子相机（如同每个相机都有个单独的 Collider 扩展一样）</p><ul><li>通过场景创建的 ClearShotCamera 会创建一个子虚拟相机，默认创建的子相机会默认附带一个 CinemachineCollider，但是其 AvoidObstacles 默认是没有启用的！需要注意</li></ul><p>主要属性</p><ul><li>Activate After：在当前相机已经不是最佳视野相机后 (碰到障碍物)，至少等待指定时间才会切换到另外的相机</li><li>Min Duration：在当前相机已经不是最佳视野相机后 (碰到障碍物)，且该相机已经保持了指定时间，才可以切到新相机去</li><li>Randomize Choice：如果多个虚拟摄像机的镜头质量相同，选择这些中的一个随机摄像机。否则使用子虚拟相机的顺序及其优先级为准</li><li>Priority：优先级</li></ul><h2 id="cinemachine-state-driven-camera"><a class="anchor" href="#cinemachine-state-driven-camera">#</a> Cinemachine State-Driven Camera</h2><p>状态驱动摄像机，该组件会在动画目标更改状态时激活子虚拟相机</p><ul><li>例如，角色的本地运动系统和轨道相机<ul><li>当角色跑动时相机晃动幅度更大会让游戏对玩家来说感觉更生动，而当其行走时，则使用阻尼值更大的虚拟相机</li></ul></li></ul><p>属性里的动画目标指的是一个由 AnimatorController 控制的 Animator 组件的对象</p><ul><li>状态驱动相机有一个列表，可以将子虚拟相机分配给对应动画状态</li></ul><p>主要属性</p><ul><li>Animated Target：包含 AnimatorController 的对象</li><li>Layer：要在动画目标中检测的动画层</li><li>State：虚拟相机将映射到的动画状态</li><li>Wait：进入此状态后激活虚拟相机的延迟（以秒为单位），即新的动画状态激活时间指定时间后，相机才切换过去</li><li>Min：虚拟相机在激活后必须保持活动状态的最短时间（以秒为单位）</li></ul><h1 id="相机扩展"><a class="anchor" href="#相机扩展">#</a> 相机扩展</h1><p>扩展是增强虚拟相机行为的组件，Cinemachine 默认包含了一些扩展，也可以通过继承自 CinemachineExtension 类来创建自定义扩展</p><h2 id="默认扩展"><a class="anchor" href="#默认扩展">#</a> 默认扩展</h2><h3 id="cinemachine-collider"><a class="anchor" href="#cinemachine-collider">#</a> Cinemachine Collider</h3><p>碰撞处理<br />它对虚拟相机的最终位置进行后处理，以尝试与虚拟相机的目标保持清晰的视线，主要通过将相机推离阻挡视线的游戏对象来实现这一点</p><ul><li>主要功能包括碰撞检测、镜头质量评估</li><li>注：使用 PhysicsRaycaster 进行碰撞检测</li></ul><p>主要属性</p><ul><li>Collide Against：碰撞检测层级</li><li>Transparent Layers：忽略的层级</li><li>Ignore Tag：带有此标签的障碍物将被忽略</li><li>Minimum Distance From Target：与跟踪目标的距离小于该数值的障碍物会被忽略</li><li>Avoid Obstacles：选中后，在目标被障碍物遮挡时才会移动相机进行避障</li><li>Distance Limit：经试验看着是 从相机到目标 发射射线的距离，配置 0 则直连无限制</li><li>Camera Radius：检测到障碍物并进行避障时，与障碍物保持的距离</li><li>Strategy：避障策略<ul><li>Pull Camera Forward：沿 Z 轴向前移动相机，直到它位于距离目标最近的障碍物前面</li><li>Preserve Camera Height：将相机移动到另一个视角，同时尝试将相机保持在其原始高度</li><li>Preserve Camera Distance：将相机移动到另一个视点，同时尝试将相机保持在与目标的原始距离（比如往左或往上之类的偏同样距离）</li></ul></li><li>Smoothing Time：将相机保持在离目标最近的点的最小时间，可用于在有很多障碍物的环境中减少相机的过度移动 (开启避障时可用)</li><li>Damping：障碍消失后，将相机返回到正常位置的阻尼</li><li>Damping When Occluded：移动相机以避开障碍物的阻尼</li><li>Optimal Target Distance：如果大于零，则当目标更接近此距离时，镜头质量评分更高，将此属性设置为 0 可禁用此功能</li><li>Minimum Occlusion Time：遮挡至少持续了指定时间才进行避障操作</li><li>Maximum Effort：要处理的障碍物数量的上限，较高的数字可能会影响性能。在大多数环境中，四 (4) 次就足够了</li></ul><h3 id="cinemachine-confiner"><a class="anchor" href="#cinemachine-confiner">#</a> Cinemachine Confiner</h3><p>使用该扩展将摄像机的位置限制在一个区域（对于正交相机，还有一个附加选项可以限制屏幕边缘）</p><p>主要属性</p><ul><li>Confine Mode：使用 2D bounding 或 3D bounding 进行操作</li><li>Bounding Volume：一个 Collider 碰撞体</li><li>Confine Screen Edges：在正交相机将屏幕边缘限制在该区域，未选中时仅限制相机中心（透视模式无效）</li></ul><h3 id="cinemachine-follow-zoom"><a class="anchor" href="#cinemachine-follow-zoom">#</a> Cinemachine Follow Zoom</h3><p>此扩展调整镜头的 FOV，使目标物体在屏幕上保持恒定大小，而不管相机和目标位置如何<br />主要属性</p><ul><li>Width：在目标距离处以世界单位保持的视野宽度。将自动调整 FOV，使得不管两者距离如何，对象在视野中都具有同样的大小</li><li>Min FOV：FOV 调整下限</li><li>Max FOV：FOV 调整上限</li></ul><h3 id="cinemachine-pixel-perfect"><a class="anchor" href="#cinemachine-pixel-perfect">#</a> Cinemachine Pixel Perfect</h3><p>Pixel Perfect Camera 和 Cinemachine 都会修改相机的正交尺寸，在一个场景中一起使用这两个系统会导致它们争夺对相机的控制权并产生不需要的结果，CinemachinePixelPerfect 扩展用于解决这种不兼容问题</p><ul><li>注：<ul><li>Pixel Perfect Camera：2D Pixel Perfect 包中包含 Pixel Perfect Camera 组件，可确保像素图像在不同分辨率下始终保持锐利清晰，并在运动中保持稳定</li></ul></li><li>看着是处理 2D Sprites 的</li></ul><h3 id="cinemachine-post-processing"><a class="anchor" href="#cinemachine-post-processing">#</a> Cinemachine Post Processing</h3><p>该扩展用于将 Postprocessing V2 配置文件附加到虚拟摄像机</p><ul><li>注：对于 HDRP 和 URP 7 及更高版本，PostProcessing 包已弃用，由 HDRP 和 URP 直接实现， URP 用 CinemachineVolumeSettings 扩展代替</li></ul><h3 id="cinemachine-volume-settings"><a class="anchor" href="#cinemachine-volume-settings">#</a> Cinemachine Volume Settings</h3><p>使用该扩展可以将 HDRP/URP VolumeSettings 配置文件附加到虚拟摄像机<br />该扩展可以指定一个 VolumeSettingsProfile 资源，在激活时应用于虚拟摄像机。如果摄像机正在与另一个虚拟摄像机混合，则混合权重也会应用于设置效果<br />主要属性</p><ul><li>Focus Tracking：如果配置文件具有适当的重载，则会将基本焦距设置为从所选目标到相机的距离。然后 Focus Offset 字段将修改该距离<ul><li>None</li><li>Look At Target：相对于 LookAt 目标的焦点偏移</li><li>Follow Target：相对于 Follow 目标的焦点偏移</li><li>Custom Target：相对于自定义目标的焦点偏移</li><li>Camera：相对于相机的焦点偏移</li></ul></li><li>Focus Offset：当 Focus Tracking 不是 None 时有效，将最中心点从聚焦目标的位置偏移<ul><li>要求后处理包括 DepthOfField</li></ul></li></ul><h3 id="cinemachine-storyboard"><a class="anchor" href="#cinemachine-storyboard">#</a> Cinemachine Storyboard</h3><p>Cinemachine Storyboard 在屏幕空间中将静止图像放置在 Unity 摄像机的输出之上，故事板可以简化动画，可以以故事版 (原画) 为基准，对场景进行构建<br />可随时使用 Storyboard 组件中的属性来隐藏和显示图像，并可以在全局级别禁用，以将其与 Unity 相机的实际渲染进行比较<br />主要属性</p><ul><li>Storyboard Global Mute：启用后，所有故事板都将全局禁用</li><li>Show Image：切换故事板图像的可见性</li><li>Aspect：图像显示模式<ul><li>Best Fit：保持垂直和水平比例，在不裁剪图像的情况下，将图像在屏幕上尽可能大地显示</li><li>Crop Image To Fit：保持垂直和水平比例，调整图像大小以填满屏幕，必要时进行裁剪</li><li>Stretch To Fit：调整图像大小以填满屏幕，必要时会拉伸填充</li></ul></li><li>Mute Camera：该项可以防止虚拟相机更新 Unity 相机，使用此功能可防止时间轴将相机混合到场景中的意外位置</li><li>Waveform Monitor：打开波形监视器窗口</li></ul><h3 id="cinemachine-3rd-person-aim"><a class="anchor" href="#cinemachine-3rd-person-aim">#</a> Cinemachine 3rd Person Aim</h3><p>这个扩展被认为是第三人称相机的一部分<br />为了保持瞄准精度，此扩展故意消除所有旋转噪音，并强制仔细瞄准目标点，不过如果噪声影响相机位置而不是旋转，那么相机位置噪声依然有效</p><ul><li>如果 AimTargetReticle (准星) 不为空，则此扩展将从 Follow 目标的位置投射一条射线，并找到与该射线碰撞的第一个对象。然后，Aim Target Reticle 对象将被放置在游戏视图中的那个点上，以指示玩家在开枪时会击中什么</li><li>注：如果检测到的对象足够近以致于由于玩家和相机之间的偏移而受到视差的影响，则该点可能与相机所看到的不同</li></ul><p>主要属性</p><ul><li>Aim Collision Filter：检测层</li><li>Ignore Tag：忽略标签对象</li><li>Aim Distance：物体检测射线投射多远</li><li>Aim Target Reticle：是一个 2D 对象，将定位在游戏视图中的光线投射命中点（如果有）上方，或者如果未检测到命中点，则将保留在屏幕中央。可以为空，在这种情况下屏幕上不会出现指示符</li></ul><h3 id="cinemachine-recomposer"><a class="anchor" href="#cinemachine-recomposer">#</a> Cinemachine Recomposer</h3><p>这个扩展是 CinemachineVirtualCamera 的附加模块，它为相机合成添加了最后的调整。主要用于 Timeline 的环境，如果希望在其中手动调整程序或记录的相机瞄准的输出的话<br />所有这些属性都可以在 Timeline 中进行动画处理<br />主要属性</p><ul><li>Apply After：当此虚拟相机处于活动状态时要激活的设置<ul><li>Body：相机已定位但尚未旋转时</li><li>Aim：相机已旋转和定位，但未应用噪声或碰撞解决方案时</li><li>Noise：已定位、旋转相机，并已应用噪点和其他校正后</li><li>Finalize：在所有标准虚拟相机处理发生后应用</li></ul></li><li>Tilt：将垂直旋转添加到相机的当前旋转</li><li>Pan：将水平旋转添加到相机的当前旋转</li><li>Dutch：为当前相机的旋转添加倾斜（局部 Z 旋转）</li><li>Zoom Scale：缩放当前相机视野 (FOV) 大小</li><li>Follow Attachment：当该值小于 1 时，跟随目标的阻尼会增加，当该值为零时，阻尼是无限的</li><li>Look At Attachment：当该值小于 1 时，注视目标 (旋转) 阻尼会增加，当该值为零时，阻尼是无限的</li></ul><h1 id="multiple-unity-cameras"><a class="anchor" href="#multiple-unity-cameras">#</a> Multiple Unity cameras</h1><p>分屏和画中画效果需要使用多个 Unity 相机，每个 Unity 摄像机在玩家屏幕上呈现自己的视图<br /><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5jaW5lbWFjaGluZUAyLjgvbWFudWFsL0NpbmVtYWNoaW5lTXVsdGlwbGVDYW1lcmFzLmh0bWw="> https://docs.unity3d.com/Packages/com.unity.cinemachine@2.8/manual/CinemachineMultipleCameras.html</span><br /> 注意将 Culling Mask 设置为适当的层</p><h1 id="cinemachine-brain"><a class="anchor" href="#cinemachine-brain">#</a> Cinemachine Brain</h1><p>属于 Unity 相机上的一个组件，用于监控场景中所有活动的虚拟相机<br />将虚拟摄像机或其他 Cinemachine 对象添加到场景时，如果 Unity 相机上尚无 Cinemachine Brain 组件，Unity 会自动添加一个<br />如果想切换到下一个虚拟相机，可以激活或禁用对应的虚拟相机对象，Cinemachine Brain 会选择最近激活的虚拟相机，并在之前虚拟相机和新激活的虚拟相机之前进行剪切或混合</p><ul><li>注 1：可以利用 Cinemachine Brain 实时响应动态游戏事件，在游戏逻辑中控制优先级，这对于实时游戏玩法特别有用，因为其中的动作并不总是可以预测的</li><li>注 2：使用 Timeline 在可预测的情况下编排摄像机，例如过场动画。 Timeline 覆盖 Cinemachine Brain 优先级系统，提供精确的帧摄像机控制</li></ul><p>注：使用 Timeline 控制虚拟相机时，Timeline 会覆盖 CinemachineBrain 做出的决定<br />主要属性</p><ul><li>Blend Update Method：何时混合并更新主相机<ul><li>Late Update：在 MonoBehaviour LateUpdate 中 (默认)</li><li>Fixed Update：仅当更新方法为 FixedUpdate 并且在混合时看到抖动时才使用此设置</li></ul></li><li>Default Blend：当没有明确定义两个虚拟相机之间的混合时使用的默认混合方式</li><li>Custom Blends：包含场景中特定虚拟相机 (取决于名字) 之间混合的自定义设置的资源引用</li><li>Camera Cut Event：当虚拟相机激活并且没有混合时会触发此事件</li><li>Camera Activated Event：当虚拟相机激活时会触发此事件，如果涉及混合，则事件会在混合的第一帧触发</li></ul><h1 id="cinemachine-and-timeline"><a class="anchor" href="#cinemachine-and-timeline">#</a> Cinemachine and Timeline</h1><p>使用时间轴在虚拟相机之间激活、停用和混合。在时间轴中，将 Cinemachine 与其他游戏对象和资产相结合，以交互方式实现和调整丰富的过场动画，甚至是交互式过场动画。</p><ul><li>注：对于简单的镜头序列，最好使用 Cinemachine Blend List Camera 而不是 Timeline</li></ul><p>Timeline 会覆盖 CinemachineBrain 做出的基于优先级的决定，当 Timeline 结束时，控制返回给 CinemachineBrain</p><ul><li>可以使用 CinemachineShotClip 控制 Timeline 中的虚拟摄像机，每个镜头剪辑都指向一个虚拟相机以激活然后停用，使用一系列镜头剪辑来指定每个镜头的顺序和持续时间</li><li>将 Clip 彼此相邻放置可以在两个虚拟摄像机之间切换，重叠 Clip 可以在两个虚拟摄像机之间混合</li></ul><p>创建</p><ul><li>在场景中创建一个空的 GameObject，它可以作为创建时间轴资源和实例</li><li>在场景中选择对象，点击 Timeline 窗口的 Create 可以创建一个本地资源</li><li>可以单击锁按钮锁定 TImeline 窗口，以便更轻松地添加和调整轨道</li><li>将带有 CinemachineBrain 组件的 Unity 摄像机拖到时间轴编辑器上，然后从下拉菜单中选择 “Create Cinemachine Track”</li></ul><p>将 CinemachineShotClips 添加到 Cinemachine 轨道：</p><ul><li>在 CinemachineTrack 中，右键单击并选择 Add Cinemachine Shot Clip</li><li>执行以下操作之一：<ul><li>将已存在的虚拟相机添加到引用上</li><li>点击 Create 创建一个新的相机</li></ul></li><li>在时间轴编辑器中，调整镜头剪辑的顺序、持续时间、剪切和混合</li><li>调整虚拟相机的属性以将其放置在场景中并指定瞄准或跟随的目标</li><li>要为 VirtualCamera 的属性设置动画，需要为其创建一个 AnimationTrack 并像任何其他 GameObject 一样设置动画</li><li>组织 Timeline 轨道以微调场景</li></ul><h1 id="top-down-games"><a class="anchor" href="#top-down-games">#</a> Top-down games</h1><p>Cinemachine Virtual Cameras 以人类摄像机操作者及其操作真实摄像机的方式为蓝本</p><ul><li>因此，它们对上 / 下轴很敏感，并且总是尽量避免将滚动 (Roll 旋转) 引入相机取景</li><li>由于这种敏感性，虚拟相机避免长时间直线上升或下降。如果 Look At 目标长时间直线上升或下降，那么将不会始终得到所需的结果</li></ul><p>如果目的是构建一个 Top-down 的游戏，其中摄像机直接向下看，最佳做法是重新定义向上的方向，以供摄像机使用。为此可以将 CinemachineBrain 中的 WorldUpOverride 属性设置为一个游戏对象，该对象的本地向上指向希望虚拟摄像机正常向上的方向，这适用于该 CinemachineBrain 控制的所有虚拟摄像机</p><h1 id="alternative-input-systems"><a class="anchor" href="#alternative-input-systems">#</a> Alternative Input Systems</h1><p>一些 Cinemachine 组件（例如 FreeLook、POV、OrbitalTransposer）需要用户输入来定位或定向摄像机<br />默认情况下，Cinemachine 通过查询标准 Unity Input.GetAxis (name) 获取用户输入</p><ul><li>Cinemachine 定义了一个接口：Cinemachine.AxisState.IInputAxisProvider</li><li>如果将实现此接口的 MonoBehaviour 添加到虚拟相机或 FreeLook，则将调用自定义的脚本输入而不是标准输入系统</li></ul><p>CinemachineInputProvider 是一个输入源重载，它会使虚拟相机使用新的 UnityEngine.Input 包而不是标准的 Unity 输入系统来获取输入，当项目中安装了 UnityEngine.Input 包时可用</p><h1 id="cinemachine-impulse"><a class="anchor" href="#cinemachine-impulse">#</a> Cinemachine Impulse</h1><p>Cinemachine Impulse 生成并管理相机抖动以响应游戏事件</p><ul><li>例如使用 Impulse 在一个 GameObject 与另一个 GameObject 发生碰撞或场景中的某物爆炸时使 CinemachineVirtualCamera 抖动</li></ul><p>Impulse 分为三部分：</p><ul><li>Raw vibration signal：多达 6 个维度的振动曲线：X、Y、Z、pitch、roll、yaw</li><li>Impulse Source：从场景空间中的一个点发出原始振动信号的组件，并定义信号特征，如持续时间、强度和范围</li><li>ImpulseListener：一种 Cinemachine 扩展，允许虚拟摄像机侦测到脉冲信号，并通过震动对其做出反应</li></ul><p>要在场景中设置和使用 Impulse，请执行以下操作：</p><ul><li>将 Cinemachine Impulse Source 或 Cinemachine Collision Impulse Source 组件添加到一个或多个要触发相机震动的游戏对象</li><li>将原始信号连接到脉冲源，这些可以是 6D 噪声配置文件、3D 固定信号或自定义信号类型</li><li>将 Cinemachine Impulse Listener 扩展添加到一个或多个 Cinemachine 虚拟摄像机，以便它们可以检测脉冲并对其做出反应<ul><li>注：不能直接 AddComponent 添加，而得在虚拟相机的 AddExtension 添加才有效，试了好一会才发现问题</li></ul></li></ul><h2 id="cinemachine-impulse-sources"><a class="anchor" href="#cinemachine-impulse-sources">#</a> Cinemachine Impulse Sources</h2><p>脉冲源是从场景空间中的一个点发出振动信号的组件，游戏事件可以导致脉冲源从事件发生的地方发出信号，事件触发脉冲源，脉冲源产生脉冲，带有 Impulse Listener 扩展的虚拟摄像机通过震动对脉冲做出反应<br />自带两种脉冲源组件：</p><ul><li>Cinemachine Collision Impulse Source：对象碰撞或触发区域触发脉冲生成</li><li>Cinemachine Impulse Source：碰撞以外的事件触发脉冲</li></ul><p>使用示例</p><ul><li>巨人的每只脚上，使巨人走路时地面震动</li><li>在击中目标时爆炸的射弹上</li><li>在 gelatin planet 的表面上，当有东西接触到它时会摇晃</li></ul><p>关键属性（Implus Type 为 Legacy 才有）</p><ul><li>振幅 (<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5jaW5lbWFjaGluZUAyLjgvbWFudWFsL0NpbmVtYWNoaW5lSW1wdWxzZVNvdXJjZU92ZXJ2aWV3Lmh0bWwjQW1wbGl0dWRl">Amplitude</span>)：原始脉冲信号的振幅，控制每次撞击的振动强度</li><li>旋转和方向 (<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5jaW5lbWFjaGluZUAyLjgvbWFudWFsL0NpbmVtYWNoaW5lSW1wdWxzZVNvdXJjZU92ZXJ2aWV3Lmh0bWwjT3JpZW50YXRpb24=">Orientation and direction</span>)：脉冲可以转换信号，使振动与产生振动的冲击方向一致<ul><li>为了产生逼真的振动，最强脉冲信号应该沿着冲击轴，并且其振幅（或强度）应该与冲击力成正比</li><li>在下图中，振动的主轴 (A) 与锤子撞击墙壁 (B) 时的行进方向一致：</li></ul></li><li><img data-src="/blogimages/2023/2023-05-27/3.png" alt="" /><ul><li>注：不需要为每个可能的冲击方向和强度单独定义信号，而是使用 “局部空间” 的概念来定义原始信号</li><li>Impulse 假定冲击的主要方向是 “向下”，因此作为一般规则，信号应该沿 Y 轴施加更多振动（6D 抖动噪音预设就是这样做的），然后可以依靠局部空间旋转和缩放来为每次撞击发生产生正确的振动</li></ul></li><li>时间膜 (<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5jaW5lbWFjaGluZUAyLjgvbWFudWFsL0NpbmVtYWNoaW5lSW1wdWxzZVNvdXJjZU92ZXJ2aWV3Lmh0bWwjVGltZUVudmVsb3Bl">Time envelope</span>)：控制信号的起音、维持和衰减，使信号淡入和淡出到适当的强度并具有有限的持续时间<ul><li>现实世界中的撞击产生的振动会变强，直到达到峰值强度，然后减弱，直到振动停止。这个周期需要多长时间取决于影响的强度以及所涉及的游戏对象的特性</li></ul></li><li>空间范围 (<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5jaW5lbWFjaGluZUAyLjgvbWFudWFsL0NpbmVtYWNoaW5lSW1wdWxzZVNvdXJjZU92ZXJ2aWV3Lmh0bWwjU3BhdGlhbFJhbmdl">Spatial range</span>)：控制信号在完全淡出之前在场景中传播的距离</li></ul><h2 id="fixed-signals"><a class="anchor" href="#fixed-signals">#</a> Fixed Signals</h2><p>CinemachineFixedSignal 可以定义简单的 3D 曲线，使用三个轴的曲线进行信号自定义</p><ul><li>Inspector 显示每个轴的曲线预览，单击预览窗格可为该轴定义自己的曲线，如果留空则不会沿该轴移动</li><li>注：点击齿轮按钮可以选择将当前曲线添加到曲线预设库中</li></ul><h2 id="cinemachine-impulse-listener"><a class="anchor" href="#cinemachine-impulse-listener">#</a> Cinemachine Impulse Listener</h2><p>主要用于使虚拟摄像机侦测到脉冲振动信号并对其做出反应</p><ul><li>在现实世界中，一些相机的安装不如其他相机牢固，因此更容易晃动，可以通过 Impulse Listener 的 Gain 属性放大或衰减脉冲振动信号来模拟</li></ul><p>另外，可通过 CinemachineImpulseChannels 可以对信号源进行过滤</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>果然最好的学习方式还是跟着官方文档走一遍（前提是文档足够全面），现在 unity 的文档感觉也是详细了很多，总体还是挺顺利，多数都有详细解释，搞不清楚跟着操作一遍也能了解个七七八八<br />一边看，一边试验，这样走下来基本各项功能就感觉熟悉了 —— 因此决定继续，下一个就是 Timeline，然后是 DOTS 或 URP</p><h1 id="参考文档"><a class="anchor" href="#参考文档">#</a> 参考文档</h1><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5jaW5lbWFjaGluZUAyLjgvbWFudWFsL0NpbmVtYWNoaW5lVXNpbmcuaHRtbA==">https://docs.unity3d.com/Packages/com.unity.cinemachine@2.8/manual/CinemachineUsing.html</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;主要内容来源于官方 Cinemachine2.8 英文文档：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9kb2NzLnVua</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/categories/Unity3D/"/>
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/tags/Unity3D/"/>
    
  </entry>
  
  <entry>
    <title>渲染基础-Unity3D-笔记</title>
    <link href="https://wangjiaying.top/2023/05/12/%E5%9B%BE%E5%BD%A2%E5%9F%BA%E7%A1%80-Unity3D/"/>
    <id>https://wangjiaying.top/2023/05/12/%E5%9B%BE%E5%BD%A2%E5%9F%BA%E7%A1%80-Unity3D/</id>
    <published>2023-05-12T09:36:44.000Z</published>
    <updated>2023-06-04T11:42:34.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>部分来源于网络，并注明来源（已丢失除外），性能优化、批处理则主要整理自 Unity 官方文档<br />注 1：参考文档均在对应位置标注，文章末尾也贴了对应链接<br />注 2：对文章内容，后续可能会还会进行调整</p><h1 id="硬件"><a class="anchor" href="#硬件">#</a> 硬件</h1><h2 id="gpu的渲染架构"><a class="anchor" href="#gpu的渲染架构">#</a> GPU 的渲染架构</h2><h3 id="imrimmediate-mode-rendering主要用于pc平台"><a class="anchor" href="#imrimmediate-mode-rendering主要用于pc平台">#</a> IMR（Immediate Mode Rendering，主要用于 PC 平台）</h3><ul><li>即渲染模式。每个像素渲染的时候直接访问 DRAM，并写入到 FrameBuffer 上。PC 平台的显卡都是 IMR 架构</li></ul><h3 id="tbrtile-based-rendering基于tile渲染主要用于移动平台"><a class="anchor" href="#tbrtile-based-rendering基于tile渲染主要用于移动平台">#</a> TBR（Tile-Based Rendering，基于 Tile 渲染，主要用于移动平台）</h3><p>为了减少 GPU 访问 SystemMemory 的次数（延迟高、功耗高），将屏幕分成一小块儿一小块儿，确保这一小块渲染所需要的绝大部分数据都能同时装进小小的 OnChip memory，从而实现整个渲染大部分操作都可以在带宽较高的 OnChip memory 上完成</p><ul><li>大幅减少对显存带宽的消耗</li></ul><p>TBR 是以牺牲执行效率为代价，换来功耗降低。在移动平台直接访问 FrameBuffer 会有很大的带宽开销，进而影响功耗。所以 TBR 把屏幕分成格子之后，每个格子可以访问 SRAM（OnChip memory），一整块都访问好之后，再整理转移回 DRAM</p><ul><li>大部分手机的 GPU 用的都是手机的 System memory 和一块容量很小的，带宽比 System memory 更高的专供 OnChip memory<ul><li>SRAM，GPU 的 OnChip memory</li><li>DRAM，显存，离 GPU 较远，容量大访问速度慢</li></ul></li><li>从 GPU 直接对 FrameBuffer 的访问，就相当于一辆货车大量的在家（GPU）和市中心超市（DRAM）之间往返运输。带宽的消耗和发热量之大，是手机上无法接受的<ul><li>对移动平台而言，功耗是第一位。因为功耗意味着发热量、耗电量、芯片大小等等。</li><li>对功耗影响最大的是带宽。所以对移动芯片而言，第一考虑的不是渲染性能，而是如何通过缓存减少带宽消耗。即，减少对显存的访问</li></ul></li><li>实际上直接对 DRAM 进行读写速度是最快的。TBR 需要一块儿块儿的绘制然后往 DRAM 拷贝。可以简单理解为 TBR 是牺牲了执行效率，来解决更重要也更难处理的带宽功耗</li></ul><h4 id="其它"><a class="anchor" href="#其它">#</a> 其它</h4><ul><li>DeferredRenderingPath：对 Tile-Based GPUs (移动平台) 启用了 NativeRenderPass 选项的有优化，没启用要避免。原理是 合并 GBuffer 和光照通道存储至 Title Memery 中以优化延迟渲染，NativeRenderPass 在 Tile-Based GPUs 应该启用<ul><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NzQ1NDAzMjk=">URP 延迟渲染 + Native Renderpass 踩坑记录</span></li></ul><blockquote><p>利用移动端 TB (D) R 的硬件架构，相比于传统延迟管线在 basepass 结束后将 gbuffer store 回 system memory, 之后再在 lightpass 中 load 回来这种带宽压力极大的方案，Native Renderpass 可以在每个 tile 的 basepass 结束后将 gbuffer 保存在 On-Chip Memory 上，以供接下来的 lightpass 直接使用，直接优化掉了两个 pass 之间的 store/load 操作，极大减缓了带宽压力，这种形式的 rt 也被称之为 memoryless</p></blockquote></li></ul><h3 id="tbdrtile-based-deferred-rendering-针对tbr做了进一步优化主要是powervr在用"><a class="anchor" href="#tbdrtile-based-deferred-rendering-针对tbr做了进一步优化主要是powervr在用">#</a> TBDR（Tile-Based Deferred Rendering 针对 TBR 做了进一步优化，主要是 PowerVR 在用）</h3><p>基于 Tile 的延迟渲染。只对玩家能看到的像素做 pixel shader。通过 HSR 将不可见的点剔除掉。大幅减少对显存带宽的消耗</p><ul><li>IOS 一般都是 TBDR</li><li>HSR (隐藏面消除) Hidden Surface Removal，TBDR 新增的一个阶段，在光栅化阶段真正开始前实现像素级裁剪。</li></ul><p>TBDR，相对于 IMR，多了一个 FrameData 的数据，里面包含了有效信息，可以进行剔除操作</p><h3 id="mrtmulti-render-targets"><a class="anchor" href="#mrtmulti-render-targets">#</a> MRT(Multi Render Targets)</h3><p>OpenGL ES 多目标渲染，OpenGL ES 3.0 新特性，它允许应用程序一次渲染到多个缓冲区。</p><h2 id="early-z"><a class="anchor" href="#early-z">#</a> Early-Z</h2><p>在执行像素着色器之前，先进行一轮深度测试，避免会被深度测试剔除的片元，执行复杂的像素着色器的逻辑。这样可以减少显存带宽的消耗</p><ul><li>如果没有 Early-Z，那么很有可能屏幕上一个像素点会被渲染七八次，显存带宽消耗成倍的增加</li><li>discard 或 clip 会导致 Early-Z Culling 无效</li></ul><h2 id="渲染顺序"><a class="anchor" href="#渲染顺序">#</a> 渲染顺序</h2><ul><li>不透明物体，离摄像机近的先绘制，这样它会因为 ZTest 剔除掉后面的渲染内容，性能更好</li><li>半透明物体，必须从后往前画，先画离摄像机远的物体，才能保证渲染结果正确</li><li>Shader 非常复杂的模型，尽量后绘制。更加容易被 Z-Culling 剔除掉</li><li>不透明物体 (2000)----AlphaTest 物体 (2450)---- 半透明物体 (3000)，这个渲染顺序有利于 HSR 或者 Early-Z 的优化<ul><li>Alpha-Test 在不透明物体绘制完毕之后再绘制，可以避免 Alpha-Test 导致 EarlyZ 失效，最后绘制，至少不会影响到之前不透明物体的 EarlyZ</li><li>RenderQueue2500，区分了不透明和半透明。半透明物体（2500 以上）永远在不透明物体（2500 以下）后绘制<ul><li>如果物体的 RenderQueue 在 2500 的同一侧，则 sortingOrder 优先级更高：</li><li>Camera Depth &gt; Sorting Layer &gt; Order In Layer &gt; RenderQueue &gt; 距离相机的距离</li></ul></li></ul></li></ul><h1 id="性能状态"><a class="anchor" href="#性能状态">#</a> 性能状态</h1><h2 id="drawcall"><a class="anchor" href="#drawcall">#</a> DrawCall</h2><p>通常情况下，DrawCall 的准备工作比 DrawCall 本身更耗费资源</p><ul><li>准备 DrawCall：CPU 设置资源并更改 GPU 上的内部设置，即渲染状态<ul><li>对渲染状态的更改（例如切换到不同的材质）是图形 API 执行的资源密集型操作</li><li>由于渲染状态更改是资源密集型的，因此对其进行优化非常重要。优化渲染状态更改的主要方法是减少它们的数量</li></ul></li><li>优化：<ul><li>减少 DrawCall 调用数量，这同样会减少改变渲染状态的次数</li><li>合批：如果可以使用相同的渲染状态来执行多个 DrawCall，那么就可以将 DrawCall 组合在一起，而不需要执行太多的渲染状态更改</li></ul></li><li>Unity 提供优化：<ul><li>GPU instancing</li><li>Static batching、Dynamic batching</li><li>SRP Batcher</li><li>手动合批</li></ul></li></ul><p>注：对于移动设备，Drawcall 不只影响 CPU，还会影响到 GPU</p><ul><li>在 PC 上 Drawcall 和顶点数量对 GPU 没有太多严重影响。但是对于 TBDR，DrawCall 过多意味着 FrameData 数据过多，严重情况下可能会出现内存放不下的情况，这种情况下对 FrameData 的访问速度奇慢<br /><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9vcHRpbWl6aW5nLWRyYXctY2FsbHMuaHRtbA=="> Unity - Manual: Optimizing draw calls</span></li></ul><h2 id="setpasscall"><a class="anchor" href="#setpasscall">#</a> SetPassCall</h2><p>渲染 Pass 的数量：一帧中切换 Shader Pass 的次数，一个 Shader 可能包含多个用于渲染的 Pass，每个 Pass 都需要 Unity 绑定一个新的着色器，必然会带来 CPU 开销</p><ul><li>内置渲染管线：是所有材质球的渲染 Pass 的数量</li><li>URP：渲染不同 Pass 的数量，与内置管线以材质球为准不一样，以 Shader 和关键字都一样为准，其中渲染的 Pass 通道</li><li>注：经测试，两个同一个 Sahder 材质，内置渲染管线启用禁用时，Batches 和 SetPassCall 均发生变化，而 URP 仅 Batches 发生变化<br /><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9SZW5kZXJpbmdTdGF0aXN0aWNzLmh0bWw="> Unity - Manual: The Rendering Statistics window</span></li></ul><h2 id="降低-cpu-渲染成本"><a class="anchor" href="#降低-cpu-渲染成本">#</a> 降低 CPU 渲染成本</h2><ul><li>通常，CPU 渲染时间的最大消耗是向 GPU 发送渲染命令的成本</li><li>渲染命令包括 DrawCall (绘制几何图形的命令)、以及在绘制几何图形之前更改 GPU 设置的命令</li><li>可考虑优化方式<ul><li>减少渲染的对象数量<ul><li>远景使用天空盒模拟</li><li>剔除</li><li>缩小相机的远裁剪平面</li><li>Camera.layerCullDistances</li></ul></li><li>减少渲染每个对象的次数<ul><li>使用光照贴图</li><li>前向渲染中，减少实时光 (影响物体) 数量</li><li>注意实时阴影的使用，非常耗性能</li></ul></li><li>合批<ul><li>减少准备和发送渲染命令所需的工作量</li></ul></li></ul></li><li>上面的优化方式，部分既可减轻 CPU 负担，也可以同时降低 GPU 消耗 (如减少渲染对象数量)</li></ul><h2 id="降低-gpu-渲染消耗"><a class="anchor" href="#降低-gpu-渲染消耗">#</a> 降低 GPU 渲染消耗</h2><ul><li>像素填充率问题<ul><li>降低片段着色器的复杂度</li><li>减少 overdraw ：UI、粒子和 Sprite</li><li>动态分辨率 (DynamicResolution)</li></ul></li><li>内存带宽问题：一般由于纹理过多或分辨率过大<ul><li>启用 3D 空间对象纹理的 Mipmap，会增加内存使用量和存储空间，但可以提高运行时 GPU 的性能</li><li>选择合适的压缩格式减小内存中纹理大小</li></ul></li><li>顶点处理问题<ul><li>降低顶点着色器的复杂度</li><li>优化网格</li><li>LOD，会增加内存使用，但可以提高 GPU 效率</li></ul></li><li>降低帧率，可以考虑比如打开静态 UI 后，降低帧率，即按需渲染<ul><li>OnDemandRendering：独立于所有其他子系统（如物理、输入或动画）来控制和查询有关应用程序渲染速度（注：独立于 Application.targetFrameRate）<br /><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9PcHRpbWl6aW5nR3JhcGhpY3NQZXJmb3JtYW5jZS5odG1s">Unity - Manual: Graphics performance fundamentals</span></li></ul></li></ul><h1 id="批处理"><a class="anchor" href="#批处理">#</a> 批处理</h1><p>Unity 批处理顺序：</p><ul><li>SRP Batcher and static batching<ul><li>注：Unity 还支持与 SRP Batch 兼容的 GameObjects 的静态批处理</li></ul></li><li>GPU instancing</li><li>Dynamic batching</li></ul><h2 id="静态批处理static-batching"><a class="anchor" href="#静态批处理static-batching">#</a> 静态批处理 (Static batching)</h2><ul><li>两种方式，一种是编辑器标记 Static Batching，一种是运行时代码调用 StaticBatchingUtility 接口合并<ul><li>编辑器标记的方式会在打包时统一合并，增加磁盘空间</li><li>代码合并则消耗运行时 CPU，且必须启用 Mesh 的 read/write</li></ul></li><li>增加磁盘空间、内存消耗、运行时无法移动<ul><li>将组合的 Mesh 转换到世界空间，并为它们构建一个共享顶点和索引缓冲区，使得一个 DrawCall 可以将合批对象都绘制出来</li><li>每个游戏对象都会创建一个 Mesh 副本，并将每个副本插入组合的 Mesh 中，意味着就算同一实例也会导致额外内存</li></ul></li><li>好处如同名字一样，按照官方说法，可以显著降低 DrawCall 开销，对于可见的 Mesh 执行更轻量级的 DrawCall</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9zdGF0aWMtYmF0Y2hpbmcuaHRtbA==">Unity - Manual: Static batching</span></li><li>注：需要先启用 PlayerSetting StaticBatching 选项</li><li>具有相同材质的对象才能进行批处理、对象不能为负缩放</li></ul><h2 id="动态批处理dynamic-batching"><a class="anchor" href="#动态批处理dynamic-batching">#</a> 动态批处理 (Dynamic batching)</h2><p>运行时每帧在 CPU 上动态合并网格，只有当合并消耗小于 DrawCall 消耗时才是一种优化，在现代图形 API，例如 IOS (Apple Metal) 上，基本上是消耗大于收益</p><ul><li>注：在现代消费类硬件上，动态批处理在 CPU 上所做的工作可能大于 DrawCall 本身的开销。这会对性能产生负面影响（言外之意就是不要用了，HDRP 已经移除支持）</li><li>注：需要先启用 PlayerSetting DynamicBatching 选项</li></ul><p>限制</p><ul><li>具有相同材质的对象才能进行批处理 (除 shadow caster rendering 外)</li><li>对象不能为负缩放</li><li>使用顶点属性低于 900 个，例如 Shader 同时使用 顶点位置、顶点法线、UV0、UV1 和顶点切线，则 Unity 只能批处理 180 个顶点 (900/5=180)</li><li>如果有光照贴图，必须指向同一个地方 (可忽略)</li><li>多 Pass 支持也有问题，例如只有第一个 Pass 生效，后续额外的像素光是无效的</li></ul><h2 id="手动合批"><a class="anchor" href="#手动合批">#</a> 手动合批</h2><ul><li>使用 API Mesh.CombineMeshes</li><li>注：手动合批的网格无法单独剔除</li></ul><h2 id="gpu-instancing"><a class="anchor" href="#gpu-instancing">#</a> GPU instancing</h2><ul><li>两种方式，一种是直接由 Unity 引擎自动处理，一种是使用代码一次性绘制<ul><li>支持 MaterialPropertyBlock 修改 Shader 中定义的 Instancing 属性</li></ul></li><li>材质自带的与 SRPBatcher 不兼容，优先 SRPBatcher<ul><li>如果开启了 SRP Batcher ，需要移除 Shader 中对 SRP Batcher 的兼容性<ul><li>只要 UnityPerMaterial 常量缓冲区中不存在材质属性，就会使着色器与 SRP Batcher 不兼容</li><li>使用 MaterialPropertyBlock 也会使 SRP Batcher 不兼容</li></ul></li></ul></li><li>注：使用完全相同的材质渲染大量相同的网格，GPU 实例化可能比 SRP Batcher 更高效</li></ul><h3 id="api"><a class="anchor" href="#api">#</a> API</h3><ul><li>Graphics.RenderMeshInstanced：可以使用实例化着色器多次渲染同一网格<ul><li>注 1：RenderParams.worldBounds 可以自定义边界</li><li>注 2：该接口一次最多只能渲染 1023 个实例</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL1NjcmlwdFJlZmVyZW5jZS9HcmFwaGljcy5SZW5kZXJNZXNoSW5zdGFuY2VkLmh0bWw=">Unity - Scripting API: Graphics.RenderMeshInstanced</span></li></ul></li><li>Graphics.RenderMeshIndirect：使用 commandBuffer 命令进行实例化渲染 (对实例数量没有限制)<ul><li>注 1：RenderParams.worldBounds 可以自定义边界</li><li>注 2：要求支持  compute shaders，着色器中有额外取值方式需求</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL1NjcmlwdFJlZmVyZW5jZS9HcmFwaGljcy5SZW5kZXJNZXNoSW5kaXJlY3QuaHRtbA==">Unity - Scripting API: Graphics.RenderMeshIndirect</span></li></ul></li><li>注：其它还有 DrawMeshInstanced、DrawMeshInstancedIndirect (可以直接做剔除) 等 API 效果同上，不过据说 RenderMeshInstanced 接口更新，例如接受 NativeArray</li><li>注：可通过 SystemInfo.supportsInstancing 判断平台是否支持</li><li>缺点：Unity 会自动计算此网格的所有实例的边界，并会将该网格的所有实例作为单个实体进行剔除和排序 (所以优先级才在 SRPBatcher 之下吧)</li></ul><h3 id="兼容性"><a class="anchor" href="#兼容性">#</a> 兼容性</h3><ul><li>OpenGL ES 3.0+(3.1 均没问题)</li><li>IOS 的 Metal 均支持 (Metal 从 iPhone 5s 开始支持)</li><li>具有相同材质、同一个 Mesh 的对象才能进行批处理</li></ul><h2 id="srp-batcher"><a class="anchor" href="#srp-batcher">#</a> SRP Batcher</h2><ul><li>支持 mesh 或 skinned mesh（非粒子）</li><li>不支持 MaterialPropertyBlock，使用 MaterialPropertyBlock 会导致 SRP Batcher 兼容失败</li><li>允许不同材质，同一个 Shader，同样的变体即可</li><li>支持代码启用禁用：GraphicsSettings.useScriptableRenderPipelineBatching = true</li></ul><h3 id="工作原理"><a class="anchor" href="#工作原理">#</a> 工作原理</h3><p>一般优化 DrawCall 的方式是减少调用数量，而 SRP Batcher 则主要减少了绘制调用之间的渲染状态更改<br /><img data-src="/blogimages/2023/2023-05-12/1.png" alt="" /><br /> SRP Batcher 通过一系列组合将 bind 和 draw 命令合并，每个命令序列称为 SRP Batch<br /> 为优化性能，一个 SRP Batch 应包含尽可能多的 bind and draw 命令 (少用 Shader 变体)<br /> 当检测到新的材质时，CPU 会绑定相关属性到 GPU 常量缓冲区 (constant buffers)，使材质属性持久保存在显存中，若材质没有发生更改，SRP Batcher 就不会更改渲染状态</p><ul><li>所有材质均持久存在于 GPU 的显存 (常量缓冲区) 中</li><li>随后 CPU 再使用专门方式在 GPU 大型常量缓冲区进行每个物体的属性更新或管理<br /><img data-src="/blogimages/2023/2023-05-12/2.png" alt="" /></li><li>当 Shader 发生变化时，只需要<ul><li>重新绑定 Material CBUFFER (材质属性)</li><li>重新绑定 large CBUFFER (物体属性)</li><li>然后就可以执行新的渲染 (DrawCall)<br /><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9TUlBCYXRjaGVyLmh0bWw=">Unity - Manual: Scriptable Render Pipeline Batcher</span></li></ul></li></ul><h2 id="batchrenderergroupbrg"><a class="anchor" href="#batchrenderergroupbrg">#</a> BatchRendererGroup(BRG)</h2><p>物体不会参与到 Unity 场景 Render 的剔除，他真正的是管理每一个物体的剔除，也就是说如果有 1000 个小物体他们会分别计算剔除。最重要的是，RenderBatchGroup 给你的是一组相机参数，这意味着我们能在这里能对于每个 View 分别做 LOD 相关的东西</p><ul><li>比 GPU Instancing 更高效，并且可以在 CPU 上使用多线程、可以自定义剔除等</li><li>建立在 SRP Batcher 之上</li><li>要求<ul><li>需要禁用变体剔除选项，避免 Shader 中 DOTS Instancing 变体被剔除</li><li>需要启用不安全代码 (Allow unsafe code)</li></ul></li><li>兼容性：OpenGL, GLES and WebGL 暂不支持</li><li><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS51bml0eS5jb20vdGhyZWFkcy9uZXctYmF0Y2hyZW5kZXJlcmdyb3VwLWFwaS1mb3ItMjAyMi0xLjEyMzA2Njkv">https://forum.unity.com/threads/new-batchrenderergroup-api-for-2022-1.1230669/</span></li></ul><h3 id="使用步骤"><a class="anchor" href="#使用步骤">#</a> 使用步骤</h3><ul><li>创建 BatchRendererGroup 实例</li><li>new BatchRendererGroup(this.OnPerformCulling, IntPtr.Zero);</li><li>注册 Mesh 和材质<ul><li>可以重复注册，内部使用引用计数维护注册数量，注册一次递增 1，注销一次减 1，引用计数达到 0 内部才会才真的注销</li><li>已注册 Mesh 或 Material 的 RegisterMesh 或 RegisterMaterial 调用返回与上一次调用相同的 BatchMeshID 或 BatchMaterialID（若彻底注销后，重复注册返回不同 id）<br /><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjIuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9iYXRjaC1yZW5kZXJlci1ncm91cC1jcmVhdGluZy1hLXJlbmRlcmVyLmh0bWw=">Unity - Manual: Creating a renderer with BatchRendererGroup</span></li></ul></li></ul><h2 id="dots-instancing"><a class="anchor" href="#dots-instancing">#</a> DOTS Instancing</h2><p>DOTS 实例化比传统实例化更具有优势</p><ul><li>实例数据存储在 GraphicsBuffer 中，并在 GPU 上保持持久性<ul><li>这意味着 Unity 不需要在每次渲染实例时再次设置它，仅在实例实际更改时设置数据</li><li>注：传统的实例化需要一个引擎在每帧为每个实例设置所有数据</li></ul></li><li>设置实例数据的过程与设置 DrawCall 调用是分开的<ul><li>DrawCall 消耗更低</li><li>BRG 通过 SRP Batcher 一个特殊的快速通道使得每个 DrawCall 只做最少工作</li><li>可以更好地控制在每次绘制调用中渲染什么</li></ul></li><li>绘制调用的大小不再受常量或统一缓冲区中可以容纳多少实例数据的限制<ul><li>BRG 可以通过一个 DrawCall 来渲染更多的实例数量</li><li>注：实例索引的数量仍然限制了绘制调用的大小，因为每个索引仍然需要一些数据。然而，一个索引消耗的内存远远少于一组完整的实例化属性，这意味着更多的实例可以放在一个常量或统一的缓冲区中。例如，每个索引需要 16 个 byte，因此如果特定平台上缓冲区的内存限制为 64kb，则缓冲区中可以容纳 4096 个索引</li></ul></li><li>如果每个实例对给定的属性使用相同的值，则可以让所有实例从内存中的同一位置加载该值。这样可以节省内存和复制每个实例的值所花费的 GPU 周期数</li></ul><p>要求</p><ul><li>#pragma target 4.5 或更高<ul><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTkuNC9NYW51YWwvU0wtU2hhZGVyQ29tcGlsZVRhcmdldHMuaHRtbA==">着色器编译目标级别 - Unity 手册</span></li></ul></li><li>#pragma multi_compile _DOTS_INSTANCING_ON</li><li>声明 DOTS Instanced 属性块</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjIuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9kb3RzLWluc3RhbmNpbmctc2hhZGVycy5odG1s">Unity - Manual: DOTS Instancing shaders</span></li></ul><h1 id="光照"><a class="anchor" href="#光照">#</a> 光照</h1><h2 id="阴影"><a class="anchor" href="#阴影">#</a> 阴影</h2><p>阴影贴图本质上是从光源视角投射的纹理<br />注 1：URP 中，额外光源若选顶点光照则不能设置阴影<br />注 2：内置渲染管线未找到直接设置顶点光</p><h3 id="cascaded-shadow-mapscsm"><a class="anchor" href="#cascaded-shadow-mapscsm">#</a> Cascaded Shadow Maps(CSM)</h3><p>使用多张阴影贴图实现阴影的一种技术</p><ul><li>阴影贴图的缺点：空间中对象在阴影图比例太小，采样精度不够，产生锯齿 (增加阴影图分辨率可以改善，但治标不治本，同时也会增加内存消耗)<ul><li>而且一张阴影图会导致近处物体采样精度不够，远处物体采样精度浪费</li></ul></li><li>问题是阴影贴图分辨率低，级联阴影的关键就是生成和使用不同精细度的阴影贴图</li></ul><p>基础的阴影贴图方法对于大型场景渲染显得力不从心，由于阴影贴图分辨率问题，很容易出现阴影抖动和锯齿边缘现象<br /> Cascaded Shadow Maps (CSM) 方法根据对象到观察者的距离提供不同分辨率的深度纹理来解决上述问题</p><ul><li>在一张阴影贴图中捕捉所有对象需要阴影贴图具有非常高的分辨率</li><li>使用多张阴影贴图就可以解决这个问题，对于近处的场景使用较高分辨率的阴影贴图，对于远处的场景使用粗糙的阴影贴图，在两张阴影贴图过渡的地方选择其中一张使用</li></ul><p>注：实时阴影，仅适用于平行光 (大场景最好至少 2 个，默认是 1 个 - 即仅一张)<br /> 注：因为需要多张阴影，因此会增加 DrawCall<br /><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MzY4OTk4Nw==">Cascaded Shadow Maps (CSM) 实时阴影的原理与实现</span><br /><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMDU0NDIvYXJ0aWNsZS9kZXRhaWxzLzExNzQyNzM5NQ=="> Unity 实时阴影实现 ——Cascaded Shadow Mapping_unity 阴影</span></p><h3 id="bias"><a class="anchor" href="#bias">#</a> Bias</h3><p>阴影偏移，解决自遮挡阴影瑕疵 (Shadow acne) 而提出<br />因为 DepthMap 分辨率的关系，每个 Depth 像素对应地面上的一小块区域，而不是一个点</p><ul><li>这块区域中，如果都按照这个 Depth 值进行计算的话，就有的地方比 Depth 值大，有的地方比 Depth 值小，所以就会重现交错</li><li>（因此除 Bias 外也可以通过提升 DepthMap 的分辨率解决，但是...）<ul><li>当光源离得特别远的时候，你从光源角度看，整个场景可能都挤在几个像素里，特别的小，所以没办法只通过调整深度图的分辨率来控制 (MipMap？Cascade？)</li></ul></li></ul><p>因此在和 ShadowMap 中离散化的深度比较时，将这个深度加大一点点，这样只有当 ShadowMap 中的深度显著大于计算出来的深度时，才判断为产生阴影<br />注：若 Bias 值太大也会有副作用，例如会导致对象的底部与阴影有一定的距离，造成 &quot;浮空&quot; 的错觉<br /><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQ5MDkwMzIx">关于 Shadow Mapping 产生的 Shadow Acne，我的理解是不是有问题？ - 知乎</span></p><h1 id="渲染方式"><a class="anchor" href="#渲染方式">#</a> 渲染方式</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTc0NzUwMjg=">浅谈延迟渲染、移动 GPU 架构和 Metal</span></p><ul><li>前向渲染是一种非常直接的渲染方式，我们提交的 mesh，经过 vs、gs、fs 等 shader，直接绘制到 color buffer 等待输出到屏幕，很线性的 Per-Object/Per-Light 方式进行绘制。—— 光照对性能影响很大<ul><li>前向渲染渲染 n 个物体在 m 个光源下的着色，复杂度为 O (n*m) 次。</li></ul></li><li>延迟渲染 (Deferred Rendering)，即延迟着色（Deferred Shading），顾名思义，是将着色计算延后进行处理的一种渲染方法，可以将延迟渲染 ( Deferred Rendering) 理解为先将所有物体都先绘制到屏幕空间的缓冲（即 G-buffer，Geometric Buffer，几何缓冲区）中，再逐光源对该缓冲进行着色的过程，从而避免了因计算被深度测试丢弃的片元着色而产⽣的不必要的开销<ul><li>对应于前向渲染 O (m*n) 的复杂度，经典的延迟渲染复杂度为 O (n+m)</li><li>延迟管线下多了深度、法线、颜色等几张 G-Buffer。这些都是屏幕大小的尺寸的 Render Target，所带来的内存以及带宽压力很大</li><li>延迟渲染有以下特点：<ul><li>内存开销较大</li><li>读写 G-buffer 的内存带宽用量是性能瓶颈。</li><li>对透明物体的渲染存在问题。在这点上需要结合前向渲染进行渲染。</li><li>对多重采样抗锯齿（MultiSampling Anti-Aliasing, MSAA）的支持不友好，主要因为需开启 MRT。</li><li>由于 Deferred Shading 的 Deferred 阶段是在完全基于 G-Buffer 的屏幕空间进行，这也导致了物体材质信息的缺失，这样在处理多变的渲染风格时就需要额外的操作。</li></ul></li><li>针对上文的问题，业界有主流有两种优化方式：<ul><li>Light Pre-Pass 即 Deferred Lighting 延迟光照技术，通过减少经典延迟渲染所使用的 G-Buffer 数量来提高性能</li><li>分块延迟渲染，tile-based Deferred Rendering。该方法通过可以在一次绘制处理多个光源，以及来降低对 G-Buffer 的读写开销</li></ul></li></ul></li><li>影响功耗的最大因素是什么？带宽。</li></ul><h2 id="前向渲染forwardpass"><a class="anchor" href="#前向渲染forwardpass">#</a> 前向渲染 (ForwardPass)</h2><h3 id="渲染方式-2"><a class="anchor" href="#渲染方式-2">#</a> 渲染方式</h3><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTc0NzUwMjg=">浅谈延迟渲染、移动 GPU 架构和 Metal</span></p><ul><li>先渲染 ShadowMap</li><li>然后从近至远渲染不透明物体</li><li>最后从远至近渲染透明物体</li><li>因为有深度测试，因此先渲染近处物体可以提前剔除不可见像素，透明物体则相反，需要混合叠加，因此由远及近</li><li>unity 规定，2500 以下对象由近及远，以上由远及近</li><li>earlyz：几何阶段与片元着色器阶段之间（光栅化之后，片元着色器之前），不过最终还是会走一次正常的后置深度测试</li><li>若检测到在片元着色器存在抛弃片元和改写深度的操作，则 earlyz 优化将被弃用</li><li>例如使用了 alphatest 渲染物体（因为片元是在片元着色器丢弃的，丢弃后，它之后的片元就得显示，若进行了 earlyz 就会出问题）</li></ul><h3 id="前向实时剔除"><a class="anchor" href="#前向实时剔除">#</a> 前向实时剔除</h3><ul><li>前向渲染是逐对象渲染，若一个物体挡住了另一个物体，执行的渲染就无效了，为了解决这些问题，也提出了一些解决方法：如 Early-z 、Z-Prepass 、 Hi-Z</li><li>Early-z：在光栅化阶段，每个模型的深度就已经写入深度缓存了，先进行深度剔除再计算光照</li><li>Z-Prepass：首先把整个场景中的模型都渲染一遍，全部都写入 Z-Buffer ，这次渲染除了 Z-Buffer 其他的信息都不计算。然后再渲染一遍场景，这次渲染关闭深度写入，每个像素和 Z-Buffer 中已经存在的深度信息进行对比，只有通过测试的像素才会计算光照。这种方法虽然避免了无效的光照计算，但是却执行了两次顶点着色器，所以最好是在场景中物体的光照计算非常复杂但是顶点数量却不是很多的情况下使用。</li><li>Hi-Z ：上面两种方法都是在 GPU 段进行的，而 Hi-Z 这种方法是在 CPU 端进行的，在几何体被提交到 GPU 之前会进行遮挡测试，如果几何体被别的物体遮挡了就不会提交到 GPU</li></ul><h3 id="光照-2"><a class="anchor" href="#光照-2">#</a> 光照</h3><ul><li>多一个光源就会多一个 DrawCall，是因为重要光源的原因，在 ForwardPass 渲染路径中，默认最多支持 4 个 逐像素的重要光源 (可设置)，光源默认 Auto ，将光源设置为 Net Important 即可减少该消耗。(不重要的顶点光源同样是限制 4 个，Shader 中 unity_LightColor [4]--&gt; 仅 BasePass)</li><li>BasePass（LightMode=ForwardBase）：最重要逐像素平行光源 (_LightColor0)+ 不重要光源 (unity_LightColor [4])+LightMap + 环境光</li><li>AdditionalPass（LightMode=ForwardAdd）：其它逐像素重要光源 (_LightColor0) 在额外 Pass 渲染，与前者叠加，多一个就会导致多一份 DrawCall</li></ul><h3 id="阴影forward"><a class="anchor" href="#阴影forward">#</a> 阴影 (Forward)</h3><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVGZsNk1VUHRPVk5EQzJDeTNhWGpIQQ==">游戏中的动态阴影</span></p><ul><li>分为两部分，自己接收阴影以及投射阴影，MeshRender 上也可以单独设置</li><li>是否有阴影跟三个条件有关：(1) Shader 中的 接收投射阴影 Pass；(2) Render 上的接收投射开关；(3) 光源是否设置阴影</li><li>Shader 中阴影投射 Pass 必须：<ul><li>打 Tags {&quot;LightMode&quot;:&quot;ShadowCaster&quot;}，标记该 Pass 专用于阴影投射</li><li>增加预编译指令 #pragma multi_compile_shadowcaster</li><li>在顶点、片段中调用 Unity 提供的预定义进行处理：V2F_SHADOW_CASTER、TRANSFER_SHADOW_CASTER_NORMALOFFSET、SHADOW_CASTER_FRAGMENT<ul><li>V2F_SHADOW_CASTER：顶点到片段数据变量</li><li>TRANSFER_SHADOW_CASTER_NORMALOFFSET：在顶点 Shader 函数中计算了 物体顶点世界坐标 - 光源坐标，即当前顶点到光源向量，然后再转 clip 裁剪空间</li><li>SHADOW_CASTER_FRAGMENT：在片段 Shader 函数中将顶点到光源向量转长度，计算深度（光源设置的 shadowbias 就在这里用的：长度 + unity_Light_ShadowBias.x）</li></ul></li><li>Shader 中阴影接收 Pass 必须：<ul><li>打 Tags {&quot;LightMode&quot;:&quot;ForwardBase&quot;}，标记该 Pass 为向前渲染</li><li>增加预编译指令 #pragma multi_compile_fwdbase</li><li>在顶点、片段中调用 Unity 提供的预定义进行处理：SHADOWCOORDS (1)、<ul><li>SHADOWCOORDS (ID)：ID 是个数值，表示使用的 TEXCOORD+ID，保存顶点函数通过 ComputeScreenPos (o.pos) 计算的 showCoord</li><li>TRANFER_SHADOW (o)：通过顶点 clip 裁剪空间坐标计算屏幕空间阴影采样坐标 ComputeScrrenPos (o.pos)</li><li>SHADOW_ATTENUATION (i)：根据 showCoord 采样阴影颜色，返回叠加的阴影强度值。</li></ul></li></ul></li></ul></li><li>Forward：<ul><li>在光源位置渲染一张深度图，然后找物体 Shader 中的特殊的 阴影投射 Pass</li><li>在正常渲染时，判断当前深度是否大于阴影深度，叠加阴影颜色</li></ul></li><li>仅在使用像素光照的情况下才渲染法线贴图、光照剪影和实时阴影。此外，在像素模式下渲染时，聚光灯形状和点光源高光看起来要好得多。</li><li>CSM (Cascaded Shadows Map)：级联阴影，将摄像机前面空间分成多个层级，分别 (以不同分辨率) 绘制各个层级物体阴影深度，合成一张连续的 CSM 贴图</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTguNC9NYW51YWwvTGlnaHRQZXJmb3JtYW5jZS5odG1s">https://docs.unity.cn/cn/2018.4/Manual/LightPerformance.html</span></li></ul><h2 id="延迟渲染deferred"><a class="anchor" href="#延迟渲染deferred">#</a> 延迟渲染 (Deferred)</h2><ul><li>延迟渲染就是把光照计算延迟到深度测试之后的渲染方式，只渲染可见的像素，不会有无效的计算。</li><li>延迟渲染的思路就是先把几何体的信息都渲染到二维空间中（G-Buffer），然后把 G-Buffer 整体进行光照计算，G-Buffer 中存在的信息都是会最终呈现在屏幕上的，不会有无效计算。<ul><li>Z-prepass 也是先渲染出深度缓存进行深度测试后再计算光照的，和延迟渲染有什么不同？最大的不同点就在于 G-buffer ，Z-prepass 在深度测试后也还是按照一个几何体渲染完再进行下一个这种方式来渲染的 ，延迟渲染是几何体的信息传递到 G -buffer 之后就和几何体没多大关系了，接下来的操作都是对 G-buffer 进行的。</li></ul></li><li>G-Buffer：不同的引擎处理可能不一样，例如 PBR 会有深度、颜色、法线、世界空间坐标、模板、金属、粗糙、高光这些信息</li><li>缺点：<ul><li>前向渲染只需要深度缓冲和最终的颜色缓冲就够了，延迟渲染需要缓存的信息实在太多了，这造成了带宽的开销大幅增加。</li><li>对于半透明无能为力，所有半透明的物体都需要等待不透明物体以延迟渲染完成之后，在用前向渲染的方式渲染半透明物体。</li><li>无法记录通过半透明对象可见的对象和当前对象本身的深度和法线</li></ul></li><li><strong>分块延迟渲染</strong>：<ul><li>虽然延迟渲染已经把光照数量和三角形数量不再关联了，但是当场景中的光源数量不断上升之后，就算是延迟渲染也有点撑不住。</li><li>这时就需要分块延迟渲染，它的思路是把 G-Buffer 分成很多个小块，分析每个小块受到哪些光源的影响，然后逐个分块进行着色，那些受光源影响的数量少的小块就不需要那么多的光照计算了。这种渲染方式在光源数量少的情况下效果不明显，但是光源数量越多它优化的性能也就越多。</li></ul></li></ul><h3 id="前向与延迟渲染路径比较"><a class="anchor" href="#前向与延迟渲染路径比较">#</a> 前向与延迟渲染路径比较</h3><ul><li>后处理方式不同。需要深度信息进行后处理时：前向渲染需要单独渲染一张深度图；延迟渲染直接从 G-buffer 中的深度图进行计算。</li><li>着色计算不同（shader）。延迟渲染光照计算统一在 Lighting Pass 里计算，只能用一个光照模型，需要其它光照模型只能切换 Pass。</li><li>抗锯齿方式不同</li></ul><h2 id="forward-渲染"><a class="anchor" href="#forward-渲染">#</a> Forward+ 渲染</h2><p>思路是将屏幕划分为一个一个的块儿，控制每个块儿的影响灯光数量，从而减轻运算压力，让前向渲染也可以处理多光源的情况。</p><h1 id="后期处理"><a class="anchor" href="#后期处理">#</a> 后期处理</h1><h2 id="抗锯齿"><a class="anchor" href="#抗锯齿">#</a> 抗锯齿</h2><ul><li>MSAA (Multi Sample AA)：基于多边形抗锯齿，增加像素采样数 (增加额外显存及带宽开销)，只能用于 Forward，有 2X、4X</li><li>FXAA (Fast Approximately AA)：后处理抗锯齿，图形边缘进行柔化，速度很快但会糊。</li><li>SMAA (Subpixel Morphological)：后处理形态抗锯齿，改进了对模型边缘的判定算法，效果比 FXAA 更好，但是消耗比 FXAA 高一倍</li><li>TAA (Temporal AA)：时域抗锯齿，子像素采样点分布到多帧，需要运动矢量 (motion vectors)，原理是，通过 Motion Vector，找到上一帧的当前像素点的信息，然后混合，抖动投影矩阵的做法被称为 Jitter<ul><li>涉及两个 pass：渲染动态物体的运动矢量至速度缓存与 TAA</li></ul></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTkuNC9NYW51YWwvUG9zdFByb2Nlc3NpbmctQW50aWFsaWFzaW5nLmh0bWw=">抗锯齿 (Anti-aliasing) - Unity 手册</span><ul><li>Unity Quality 内置的就是 MSAA， 在 URP 中，渲染管线可以设置 MSAA，相机后处理可以选择 FXAA、SMAA，两者可以叠加。URP 不自带 TAA (缺少正确的 Motion Vectors)，【TAA 与 MSAA 不能叠加 -- 待定】</li><li>官方推荐：FXAA -- 移动端，SMAA、TAA-- 桌面和主机</li><li>Post Processing v2 倒是支持 TAA，但是 URP 集成的 PP 没有支持 (缺少 Motion Vectors 数据)，且内置的 Post Processing 替代了 PPv2 (<span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS51bml0eS5jb20vdGhyZWFkcy9wb3N0LXByb2Nlc3NpbmctYW5kLXVycC10aGUtcGxhbi43OTU0NTYv">post-processing-and-urp-the-plan</span>)</li><li>速度快慢：FXAA-&gt;SMAA-&gt;MSAA-&gt;TAA</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxlbWVudDNkcy5jb20vZm9ydW0ucGhwP21vZD12aWV3dGhyZWFkJmFtcDt0aWQ9MzkwMzEy">U3D 各种抗锯齿哪个好？各自特点是什么？性能如何？什么平台用什么合适？</span></li></ul></li></ul><h2 id="屏幕效果"><a class="anchor" href="#屏幕效果">#</a> 屏幕效果</h2><ul><li>Bloom 效果<ul><li>提取亮度、模糊处理、以及合并光晕</li><li>提取原图像，给定一个阈值，使用高斯模糊阈值范围上的图像。再与原图相加，获得 bloom 效果</li></ul></li><li>景深<ul><li>近距离模糊</li><li>焦点范围清晰</li><li>远距离模糊</li><li>注：可能需要用到深度，另外听说还有种物理景深算法</li></ul></li></ul><h1 id="性能优化"><a class="anchor" href="#性能优化">#</a> 性能优化</h1><ul><li>减少提交次数 DrawCall，减少数据交换量，带宽优化、也是显存优化、</li><li><strong>减少 CPU 与 GPU 的数据同步</strong>。减少 CPU 与 GPU 的数据同步也是一个方向，怪物尽可能由 GPU 绘制，最大可能减少数据同步，以达到最高异步效率</li><li>可变分辨率</li><li>Shader：避免不同数据类型混用或者叫避免不必要的精度转换，例如 half 和 float，精度转换也是有消耗的<ul><li>现在新型 GPU fixed 可能已经没了，等价于 Half</li><li>3D 贴图开启 Mipmap，以空间换时间</li><li>使用 Bilinear 代替 Trilinear 过滤</li><li>减少 Anisotropic 过滤采样数量</li></ul></li><li>使用 LightMap，如果实在要使用实时阴影，可以考虑 Subtractive + 低分辨率阴影配合正确的阴影级联 (cascade) 设置 (级联仅适用于方向光)</li><li>BVH</li></ul><h1 id="渲染调试"><a class="anchor" href="#渲染调试">#</a> 渲染调试</h1><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9GcmFtZURlYnVnZ2VyLmh0bWw=">FrameDebugger</span></p><h1 id="其它-2"><a class="anchor" href="#其它-2">#</a> 其它</h1><h2 id="模型"><a class="anchor" href="#模型">#</a> 模型</h2><ul><li>网格主要由：顶点、三角形索引数组、UV 三个基础数据组成</li></ul><h2 id="动画"><a class="anchor" href="#动画">#</a> 动画</h2><ul><li>分为两种：一种是用一种算法改变顶点位置，为顶点动画；另一种是用骨骼影响网格顶点，为骨骼动画。两种方式都是通过在每一帧偏移模型网格上的顶点，让模型变形从而实现动画，最终原理其实一样。</li><li>传统骨骼动画：每个顶点都有骨骼权重数据（被哪些骨骼影响，权重多少），在 unity 中可以设置每个顶点最多受四个骨骼权重影响 —— 传统骨骼动画由骨骼点与顶点权重数据计算得到，顶点与骨骼数量越多，有效权重数据越多，cpu 消耗也越大</li><li>skinmesh：bindposes 为旋转矩阵，是为了实现父节点旋转位移时更快计算出子节点的位移旋转的变化矩阵（父子节点有相对位置关系，相对位置，相对角度，相对比例不变）</li><li>传统骨骼动画计算：CPU 计算骨架 -&gt;GPU 顶点蒙皮</li><li>贴图骨骼动画：动画信息存储为图片，VertexShader 通过 tex2dlod 采样 (贴图模式采用 Point)<ul><li>通过 CPU 计算全单位 Mask 图：播放哪个动画，第几帧。一张贴图包含所欲单位实时状态信息，只有一次数据同步。</li></ul></li><li>大批量实例化绘制 (GPU Instancing)：DrawMeshInstanced，该函数一般用于加速静态物体，批量一次性绘制一个 Mesh 多次。由于动态物体有动画，难以完全一致 (当对象足够多的时候，当前帧动画可能一致就能用了)，形成动画对象大批量实例化技术。</li><li>批量化 GPU 阴影</li></ul><h2 id="urp"><a class="anchor" href="#urp">#</a> URP</h2><ul><li>URP 多相机使用：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTE2Mzg5NTk=">https://zhuanlan.zhihu.com/p/351638959</span></li><li>Depth Priming (Pre-Z Pass)：OverDraw 过度绘制可以启用，但是要避免在 Tile-Based GPUs (移动平台)，提高半透明物体效率？<ul><li>优化 OverDraw，会增加 DrawCall，需要判断是否是正优化。</li><li>只能用于 Forward，自定义 Shader 需要手动添加 DepthOnly Pass</li><li>手机上与 MSAA 同时开启会比 DrawCall 开销还要大</li><li>DrawCall 或其它图形 API 调用</li></ul></li><li>RenderingDebuger：URP 调试工具</li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTYzOTczMzQ=">URP 配置 — 保姆级新手指南</span></li></ul><p>光照</p><ul><li>注：额外光源若选顶点光照则不能设置阴影</li></ul><h1 id="参考文档"><a class="anchor" href="#参考文档">#</a> 参考文档</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvYngwOXNjbmExVDJkV0RSVmlKejBWQQ==">图形学基础篇</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNjM5NDQ1MzE=">(十)、图形渲染进阶知识</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9GcmFtZURlYnVnZ2VyLmh0bWw=">FrameDebugger</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NzQ1NDAzMjk=">URP 延迟渲染 + Native Renderpass 踩坑记录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9vcHRpbWl6aW5nLWRyYXctY2FsbHMuaHRtbA==">Unity - Manual: Optimizing draw calls</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9SZW5kZXJpbmdTdGF0aXN0aWNzLmh0bWw=">Unity - Manual: The Rendering Statistics window</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9PcHRpbWl6aW5nR3JhcGhpY3NQZXJmb3JtYW5jZS5odG1s">Unity - Manual: Graphics performance fundamentals</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9zdGF0aWMtYmF0Y2hpbmcuaHRtbA==">Unity - Manual: Static batching</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL1NjcmlwdFJlZmVyZW5jZS9HcmFwaGljcy5SZW5kZXJNZXNoSW5zdGFuY2VkLmh0bWw=">Unity - Scripting API: Graphics.RenderMeshInstanced</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL1NjcmlwdFJlZmVyZW5jZS9HcmFwaGljcy5SZW5kZXJNZXNoSW5kaXJlY3QuaHRtbA==">Unity - Scripting API: Graphics.RenderMeshIndirect</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9TUlBCYXRjaGVyLmh0bWw=">Unity - Manual: Scriptable Render Pipeline Batcher</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS51bml0eS5jb20vdGhyZWFkcy9uZXctYmF0Y2hyZW5kZXJlcmdyb3VwLWFwaS1mb3ItMjAyMi0xLjEyMzA2Njkv">https://forum.unity.com/threads/new-batchrenderergroup-api-for-2022-1.1230669/</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjIuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9iYXRjaC1yZW5kZXJlci1ncm91cC1jcmVhdGluZy1hLXJlbmRlcmVyLmh0bWw=">Unity - Manual: Creating a renderer with BatchRendererGroup</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTkuNC9NYW51YWwvU0wtU2hhZGVyQ29tcGlsZVRhcmdldHMuaHRtbA==">着色器编译目标级别 - Unity 手册</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjIuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9kb3RzLWluc3RhbmNpbmctc2hhZGVycy5odG1s">Unity - Manual: DOTS Instancing shaders</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MzY4OTk4Nw==">Cascaded Shadow Maps (CSM) 实时阴影的原理与实现</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMDU0NDIvYXJ0aWNsZS9kZXRhaWxzLzExNzQyNzM5NQ==">Unity 实时阴影实现 ——Cascaded Shadow Mapping_unity 阴影</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQ5MDkwMzIx">关于 Shadow Mapping 产生的 Shadow Acne，我的理解是不是有问题？ - 知乎</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTc0NzUwMjg=">浅谈延迟渲染、移动 GPU 架构和 Metal</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTc0NzUwMjg=">浅谈延迟渲染、移动 GPU 架构和 Metal</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVGZsNk1VUHRPVk5EQzJDeTNhWGpIQQ==">游戏中的动态阴影</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTguNC9NYW51YWwvTGlnaHRQZXJmb3JtYW5jZS5odG1s">https://docs.unity.cn/cn/2018.4/Manual/LightPerformance.html</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTkuNC9NYW51YWwvUG9zdFByb2Nlc3NpbmctQW50aWFsaWFzaW5nLmh0bWw=">抗锯齿 (Anti-aliasing) - Unity 手册</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS51bml0eS5jb20vdGhyZWFkcy9wb3N0LXByb2Nlc3NpbmctYW5kLXVycC10aGUtcGxhbi43OTU0NTYv">post-processing-and-urp-the-plan</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxlbWVudDNkcy5jb20vZm9ydW0ucGhwP21vZD12aWV3dGhyZWFkJmFtcDt0aWQ9MzkwMzEy">U3D 各种抗锯齿哪个好？各自特点是什么？性能如何？什么平台用什么合适？</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9GcmFtZURlYnVnZ2VyLmh0bWw=">FrameDebugger</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTE2Mzg5NTk=">https://zhuanlan.zhihu.com/p/351638959</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTYzOTczMzQ=">URP 配置 — 保姆级新手指南</span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;部分来源于网络，并注明来源（已丢失除外），性能优化、批处理则主要整理自 Unity 官方文档&lt;br /&gt;
注 1：参考文档均在对应位置标注，文章末尾也贴了对应链接&lt;</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/categories/Unity3D/"/>
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/tags/Unity3D/"/>
    
    <category term="图形学" scheme="https://wangjiaying.top/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="性能优化" scheme="https://wangjiaying.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>字节单位转换计算</title>
    <link href="https://wangjiaying.top/2023/05/11/%E5%AD%97%E8%8A%82%E5%8D%95%E4%BD%8D%E8%BD%AC%E6%8D%A2%E8%AE%A1%E7%AE%97/"/>
    <id>https://wangjiaying.top/2023/05/11/%E5%AD%97%E8%8A%82%E5%8D%95%E4%BD%8D%E8%BD%AC%E6%8D%A2%E8%AE%A1%E7%AE%97/</id>
    <published>2023-05-11T03:40:14.000Z</published>
    <updated>2023-05-14T10:21:22.436Z</updated>
    
    <content type="html"><![CDATA[<p>这几天看《算法之美》的时候，看到有一个问题是：如何设计一个数据结构，可以在 100M 内存的限制下快速在 1000 万 个数据中查找指定数据？(每个数据占 8B)</p><p>问题不重要，里面描述的时候，有一个说明是：  <code>1000万</code>  个数据正好  <code>80M</code>  左右</p><p>然后就在想，为什么是 80M？B 是 bit 还是 byte ？怎么一下子估算的？</p><p>一时没想明白</p><p>后来仔细想了下，这个估算起来，其实有比较简便的规则的</p><p>例如，正常的字节转换单位，按照『严格』转换方式如下：</p><table><thead><tr><th style="text-align:center">单位 (B)</th><th style="text-align:center">千</th><th style="text-align:center">万</th><th style="text-align:center">十万</th><th style="text-align:center">百万</th><th style="text-align:center">千万</th><th style="text-align:center">亿</th><th style="text-align:center">十亿</th></tr></thead><tbody><tr><td style="text-align:center">bytes</td><td style="text-align:center">1024</td><td style="text-align:center">10240</td><td style="text-align:center">102400</td><td style="text-align:center">1024000</td><td style="text-align:center">10240000</td><td style="text-align:center">102400000</td><td style="text-align:center">1024000000</td></tr><tr><td style="text-align:center">KB</td><td style="text-align:center">1</td><td style="text-align:center">10</td><td style="text-align:center">100</td><td style="text-align:center">1000</td><td style="text-align:center">10000</td><td style="text-align:center">100000</td><td style="text-align:center">1000000</td></tr><tr><td style="text-align:center">MB</td><td style="text-align:center">/</td><td style="text-align:center">/</td><td style="text-align:center">0.09765625</td><td style="text-align:center">0.9765625</td><td style="text-align:center">9.765625</td><td style="text-align:center">97.65625</td><td style="text-align:center">976.5625</td></tr><tr><td style="text-align:center">G</td><td style="text-align:center">/</td><td style="text-align:center">/</td><td style="text-align:center">/</td><td style="text-align:center">/</td><td style="text-align:center">/</td><td style="text-align:center">0.095367431640625</td><td style="text-align:center">0.95367431640625</td></tr></tbody></table><ul><li>1024B=1KB</li><li>10240B=10KB</li><li>102400B=100KB</li><li>1048576B=1MB</li><li>10485760B=10MB</li><li>104857600B=100MB</li><li>1073741824B=1024MB=1G</li></ul><p>要是用人脑强行算，这可真是感觉相当恼火<br />但是一般来说，我们自己通过人脑算的时候，场景都在于想知道个大概容量，也就是『估算』<br />若只是估算，那么要求不必那么精确，比如 1024 其实可以约等于简化为 1000，然后相互以整数转化计算，这样感觉就简单多了：</p><ul><li>千字节≈1KB</li><li>万字节≈10KB</li><li>十万字节≈100KB</li><li>百万字节≈1MB</li><li>千万字节≈10MB</li><li>亿字节≈100MB</li><li>十亿字节≈1000MB≈1G</li></ul><table><thead><tr><th style="text-align:center">单位 (B)</th><th style="text-align:center">千</th><th style="text-align:center">万</th><th style="text-align:center">十万</th><th style="text-align:center">百万</th><th style="text-align:center">千万</th><th style="text-align:center">亿</th><th style="text-align:center">十亿</th></tr></thead><tbody><tr><td style="text-align:center">bytes</td><td style="text-align:center">千</td><td style="text-align:center">万</td><td style="text-align:center">十万</td><td style="text-align:center">百万</td><td style="text-align:center">千万</td><td style="text-align:center">亿</td><td style="text-align:center">十亿</td></tr><tr><td style="text-align:center">KB</td><td style="text-align:center">1</td><td style="text-align:center">10</td><td style="text-align:center">100</td><td style="text-align:center">千</td><td style="text-align:center">万</td><td style="text-align:center">十万</td><td style="text-align:center">百万</td></tr><tr><td style="text-align:center">MB</td><td style="text-align:center">/</td><td style="text-align:center">/</td><td style="text-align:center">0.1</td><td style="text-align:center">1</td><td style="text-align:center">10</td><td style="text-align:center">100</td><td style="text-align:center">千</td></tr><tr><td style="text-align:center">G</td><td style="text-align:center">/</td><td style="text-align:center">/</td><td style="text-align:center">/</td><td style="text-align:center">/</td><td style="text-align:center">/</td><td style="text-align:center">0.1</td><td style="text-align:center">1</td></tr></tbody></table><p>想想之前碰到  <code>超大量</code>  字节转化计算的时候，要么在脑袋里开始一层层计算，要么就想着用计算器  <code>X/1024/1024</code>  就感觉有点头疼</p><p>如今想如果用这么个  <code>估算</code>  方式，感觉就好办多了。</p><p>总之，对于容量转换</p><ul><li>当前级转下一级，都是十转 0.1，千转 1</li><li>下下级就是：十万转 0.1、百万转 1</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这几天看《算法之美》的时候，看到有一个问题是：如何设计一个数据结构，可以在 100M 内存的限制下快速在 1000 万 个数据中查找指定数据？(每个数据占 8B)&lt;/p&gt;
&lt;p&gt;问题不重要，里面描述的时候，有一个说明是：  &lt;code&gt;1000万&lt;/code&gt;  个数据正好</summary>
      
    
    
    
    <category term="理论研究" scheme="https://wangjiaying.top/categories/%E7%90%86%E8%AE%BA%E7%A0%94%E7%A9%B6/"/>
    
    
    <category term="数学" scheme="https://wangjiaying.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>《设计模式与游戏完美开发》-笔记</title>
    <link href="https://wangjiaying.top/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%AE%8C%E7%BE%8E%E5%BC%80%E5%8F%91-%E7%AC%94%E8%AE%B0/"/>
    <id>https://wangjiaying.top/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%AE%8C%E7%BE%8E%E5%BC%80%E5%8F%91-%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-01T08:56:13.000Z</published>
    <updated>2023-05-02T12:26:22.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>这本书是紧接着《CLR VIR C#》 开始的，依然是回家的时候看，顺便在手机语雀上记笔记：</p><p><img data-src="/blogimages/2023/2023-05-01/Snipaste_2023-05-01_17-07-25.png" alt="" /></p><p>今天是 2023 年 5 月 1 日<br />也算是过了一遍了，这本书其实不是很厚 —— 至少跟 《CLR VIR C#》 相比就薄多了，也花了差不多一个月，主要是因为每周加两天班变成了常驻，另外还在追 DOTS1.0 的教程，导致时间上更短了。<br />这两天五一放假 (实际上前一天 28 号就提前请假了)，然后回来从责任链模式继续看，认真专心点，还是挺快的。</p><p>本文总结的主要是部分重要的理论描述，—— 文字上的，毕竟是手机记录。很多重要概念的还是得结合代码。</p><h1 id="简介"><a class="anchor" href="#简介">#</a> 简介</h1><ul><li>Gof：《设计模式》一书由四人合著（Gang of Four），代表 23 种设计模式</li><li>23 种设计模式可分为三大类<ul><li>生成模式（creational）<ul><li>产生对象的过程及方式</li></ul></li><li>结构模式（structural）<ul><li>类或对象之间组合的方式</li></ul></li><li>行为模式（behavioral）<ul><li>类或对象之间互动或责任分配的方式</li></ul></li></ul></li><li>六大设计原则<ul><li>开闭原则</li><li>里氏替换原则</li><li>依赖倒置原则</li><li>单一职责原则</li><li>迪米特法则</li><li>接口隔离原则</li><li>合成复用原则（六大原则有七个是常识对吧？）</li></ul></li></ul><h1 id="设计模式"><a class="anchor" href="#设计模式">#</a> 设计模式</h1><h1 id="状态模式state"><a class="anchor" href="#状态模式state">#</a> 状态模式（state）</h1><p>让一个对象的行为随着内部状态的改变而变化，而该对象也像是换了类一样</p><ul><li>当某个对象状态改变时，虽然其『表现的行为』会有所变化，但对于其它对象来说，并不会因为这样的变化而改变对它的『操作方法』或『信息沟通』的方式</li><li>即对象与外界的对应方式不会发生改变，一切只发生在对象内部</li><li>例子：场景管理</li><li>其它应用<ul><li>角色 AI</li><li>服务器连接状态</li><li>关卡进行状态</li><li>等</li></ul></li></ul><h1 id="单例模式singleton"><a class="anchor" href="#单例模式singleton">#</a> 单例模式（singleton）</h1><p>『确认类只有一个对象，并提供一个全局的方法来获取这个对象』<br />生活中许多物品都是唯一的：地球是唯一的、太阳是唯一的 等</p><ul><li>同时只存在一个对象</li><li>提供一个快速获取这个对象的方法</li></ul><p>哪些系统类适合以单例模式实现，需要精挑细选<br />缺点：</p><ul><li>不必为 如何传递对象、设置对象引用 而进行过多考虑，容易造成『单例癖』，过于沉迷单例模式带来的直接访问好处，导致设计思考不周，造成单例滥用</li><li>单例模式违反了 开闭原则，因为获取的是直接实现类</li><li>单例出现继承，出现 白马非马 问题</li></ul><h1 id="外观模式facade"><a class="anchor" href="#外观模式facade">#</a> 外观模式（facade）</h1><p>为子系统定义一组统一的接口，这个高级接口会让子系统更容易被使用</p><ul><li>以简单的行为操作复杂的接口，所使用的接口就是以外观模式定义的高级接口</li><li>重点在于，能将系统内部的互动细节隐藏起来，并提供一个简单方便的接口</li><li>优点<ul><li>减少耦合度、易于分工开发、增加系统安全性</li><li>随着开发需求变更，任何子系统的修改都被限制在系统内部</li></ul></li><li>注意<ul><li>由于将所有子系统集中于外观模式接口类中，会导致该类变得过于庞大，因此可以继续拆分</li></ul></li></ul><h1 id="中介者模式mediator"><a class="anchor" href="#中介者模式mediator">#</a> 中介者模式（mediator）</h1><p>定义一个接口用来封装一群对象的互动行为，中介者通过移除对象之间的引用，减少它们之间的耦合度，并能改变它们之间的互动独立性</p><ul><li>每一个系统除了会引用与之相关的类型外，无论是对信息获取或传递，都只通过中介者完成</li><li>这使得每一个系统对外依赖度缩小到只有一个类</li></ul><p>注意：</p><ul><li>避免担任过多中介者角色而出现 操作接口爆炸 的情况</li><li>可以搭配其它设计模式：如观察者模式</li></ul><p>其它应用：</p><ul><li>网络引擎，如通过中介者沟通，方便更换 tcp 或 udp 等连接方式</li></ul><h1 id="gameloop"><a class="anchor" href="#gameloop">#</a> GameLoop</h1><p>不继承 Monobehavior ，自己控制更新逻辑，包括游戏更新的时间点和方式</p><h1 id="桥接模式bridge"><a class="anchor" href="#桥接模式bridge">#</a> 桥接模式（Bridge）</h1><p>将抽象与实现分离，使二者可以独立地变化<br />注：并非 『依赖倒置原则』的另一个解释：定义一个接口类，然后将实现部分在子类完成<br />可以将两个群组有效分离，让两个群组彼此互不影响<br />如：</p><ul><li>角色 (不同角色) 与武器 (不同武器)</li><li>渲染引擎（不同渲染图形，不同平台选择 dx、opengl 等）</li></ul><h1 id="策略模式strategy"><a class="anchor" href="#策略模式strategy">#</a> 策略模式（Strategy）</h1><ul><li>将复杂的公式独立出来成为一个群组，之后可以按情况来决定使用的计算公式策略，提高了系统应用的灵活程度</li><li>由一群没有任何关系的类所组成，不知彼此的存在</li><li>是由封装计算算法而形成的一种设计模式，算法之间不存在任何依赖关系，有新增算法可以马上加入或替换</li><li>应用：<ul><li>属性系统</li><li>熟练度系统</li><li>登录策略</li></ul></li></ul><h1 id="模板方法模式template-method"><a class="anchor" href="#模板方法模式template-method">#</a> 模板方法模式（template method）</h1><p>在一个操作方法中定义算法流程，其中某些步骤由子类完成，模板方法模式让子类在不变更原有算法流程的情况下，还能重新定义其中步骤</p><ul><li>定义算法流程中，某些步骤需要由执行时 『当下环境』来决定</li><li>定义算法的流程中，针对每个步骤都提供了预设方案，但有时这个步骤中处理会出现『更好的解决方法』</li><li>优点：将可能出现重复的 算法流程 ，从子类提升到父类中，减少重复的发生，并且也开发了子类参与算法中各个步骤的执行或优化</li><li>注意：开放流程的平衡，开放太多并要求子类全部实现，反而造成困难</li><li>应用：<ul><li>登录流程</li><li>RPG 释放法术流程</li><li>释放技能流程</li><li>攻击流程</li></ul></li></ul><h1 id="工厂方法模式factory-method"><a class="anchor" href="#工厂方法模式factory-method">#</a> 工厂方法模式（factory method）</h1><p>定义一个可以产生对象的接口，但是让子类决定要产生哪一个类的对象。工厂方法模式让类的实例化程序延迟到子类中实施<br />将类产生流程集合管理的模式</p><ul><li>能针对对象产生流程制定规则</li><li>减少客户端参与对象生成过程，尤其是对象生产过程比较复杂的，降低生产耦合</li></ul><p>C# 支持泛型，泛型工厂比较方便<br />优点：将类群组对象的产生流程整合于同一个类下实现，并提供唯一的工厂方法，让项目内 对象产生流程 更加独立</p><ul><li>不过，类群组过多时，无论使用哪种方式，都存在工厂子类爆量或 switch case 语句过长问题</li></ul><p>应用：</p><ul><li>UI 管理器</li><li>角色工厂</li><li>资源加载工厂<ul><li>真机资源加载与编辑器资源加载方式</li></ul></li><li>武器工厂</li><li>属性生产工厂</li><li>当产生对象时，需要<ul><li>复杂的流程</li><li>需要加载外部资源</li><li>有对象上限或管理</li><li>可重复使用</li><li>就可以考虑采用工厂方法模式，将对象产生及相关初始化集中在一个地方，让对象的产生与管理更有效率</li></ul></li></ul><h1 id="建造者模式builder"><a class="anchor" href="#建造者模式builder">#</a> 建造者模式（builder）</h1><p>『将一个复杂对象的构建流程与它的对象表现分离出来，让相同的构建流程可以产生不同的对象行为表现』<br />工厂方法模式将生产对象全部集中管理，为了使生产对象过程更有效率和弹性，通常可以搭配建造者模式</p><ul><li>将复杂的构建流程独立出来，并将整个流程分成几个步骤，其中每个步骤可以是一个功能组件的设置，也可以是参数指定，并在一个构建方法中讲这些步骤串接起来</li><li>定义一个专门实现这些步骤的实现者，这些实现者知道如何完成每一部分，并能接受参数决定要产出功能，但不知道整个流程要组装的是什么</li><li>主要：流程分析安排、功能分开实现</li></ul><h1 id="享元模式flyweight"><a class="anchor" href="#享元模式flyweight">#</a> 享元模式（flyweight）</h1><p>『使用共享的方式，让一大群小规模对象能更有效地运行』</p><ul><li>享元模式用来解决 大量且重复对象 的管理问题，特别是 虽小却大量重复对象</li></ul><p>应用：</p><ul><li>道具属性（感觉并不合适）</li></ul><h1 id="组合模式composite"><a class="anchor" href="#组合模式composite">#</a> 组合模式（composite）</h1><p>『将对象以树状结构组合，用以表现部分 - 全体的层次关系，让客户端在操作各个对象或组合对象时是一致的』</p><h1 id="命令模式command"><a class="anchor" href="#命令模式command">#</a> 命令模式（command）</h1><p>『将请求封装成为对象，让你可以将客户端的不同请求参数化，并配合队列、记录、复原等方法来执行请求的操作』</p><ul><li>请求的封装<ul><li>封装参数，亦可封装执行</li></ul></li><li>请求的操作<ul><li>存储：排序、排队、移动、删除、暂缓执行等</li><li>记录：可记录已执行记录，查看过去执行流程和轨迹</li><li>复原：若请求执行了反向操作，则可将已执行请求复原</li></ul></li></ul><p>可以独立排队执行<br />注意：使用命令模式也要注意情况，例如是否需要排队执行、命令被对象化后，是否对其还有管理需求。<br />其它应用</p><ul><li>网络 client/server 数据传递，侧重执行与记录</li></ul><h1 id="责任链模式chain-of-responsibility"><a class="anchor" href="#责任链模式chain-of-responsibility">#</a> 责任链模式（chain of responsibility）</h1><p>『让一群对象都有机会来处理一项请求，以减少请求发送者与接收者之间的耦合度。将所有的接收者对象串联起来，让请求沿着串接传递，直到有一个对象可以处理为止』</p><ul><li>可以解决请求的接收者对象，能够了解请求并判断自身能否解决</li><li>接收者对象的串联：将每一个可能解决问题的接收者串接，对于被串接的接收者来说，若判断自身无法解决，则利用串接机制传递请求给下一个</li><li>请求自动转移：发出请求后，请求会自动往下转移传递，不需要发送者特别转换</li></ul><p>注：</p><ul><li>责任链模式根据需求，其实也可以不必从头开始判断</li><li>该模式让信息判断上有一致的操作接口，不必因不同接收者而执行 类转换操作</li><li>让所有信息接收者都有机会可以判断是否提供服务或将需求转为下一个，对后续系统修改维护也有利</li></ul><h1 id="观察者模式observer"><a class="anchor" href="#观察者模式observer">#</a> 观察者模式（observer）</h1><p>『在对象之间定义一个一对多的连接方法，当一个对象变换状态时，其它关联对象都会自动收到通知』<br />观察者模式与命令模式相似，都是希望 『事件发生』与『功能执行』之间不要有太多依赖<br />例如：</p><ul><li>社交软件上的 关注 功能</li><li>早期的 报社 - 订阅</li></ul><p>信息的 『推』 与 『拉』<br />主题（subject）改变时，改变内容如何让观察者（observer）得知，运行方式分为两种：</p><ul><li>推（push）：主题将变动内容主动 “推” 给观察者。一般在调用观察者进行通知时，同时将更新内容当做参数传递给观察者。<ul><li>优点：省去观察者再向主题查询操作，主题也不需要定义额太多额外接口供查询调用</li><li>缺点：如果推送内容过多，容易使观察者收到不必要信息或造成查询困难，也可能降低系统性能</li></ul></li><li>拉（pull）：主题变动时，只是先通知观察者当前内容已发生变动，观察者按照系统需求，再向主题查询所需信息<ul><li>优点：观察者更知道自己需要哪些信息，避免获取到不必要的冗余信息</li><li>缺点：主题必须提供查询方式，容易造成主题接口方法过多</li></ul></li></ul><p>一般为字典，key 为枚举或整型，value 为一个观察者类，或直接是个回调。<br />采用观察者类的方式，可能造成过多观察者类，因此采用回调可以更有效减少类的产生。<br />其它应用：</p><ul><li>机关</li><li>剧情触发</li></ul><h1 id="备忘录模式memento"><a class="anchor" href="#备忘录模式memento">#</a> 备忘录模式（memento）</h1><p>『在不违反封装的原则下，获取一个对象内部状态并保留在外部，让该对象可以在日后恢复到原先保留时的状态』<br />接口隔离原则 (isp)：除非必要，否则类应该尽量减少对外显示的内部数据结构，减少对外公布的操作方法</p><ul><li>为了不违背封装的原则，其数据由类主动提供</li><li>即让有记录保存需求的类，自行产生要保存的数据，外界完全不用了解这些记录产生的过程和来源</li></ul><h1 id="访问者模式visitor"><a class="anchor" href="#访问者模式visitor">#</a> 访问者模式（visitor）</h1><p>『定义一个能够在一个对象结构中对所有元素执行的操作，访问者让你可以定义一个新的操作，而不必更改到被操作元素的类接口』<br />重点：定义一个新的操作，而不必更改到被操作元素的类接口<br />优点</p><ul><li>新增功能只需要实现新的访问者</li><li>增加系统稳定性，减少对类接口不必要修改</li></ul><p>缺点</p><ul><li>被访问者封装性变差：因为需要尽可能提供所有可能的操作和信息</li></ul><p>其它应用</p><ul><li>需要使用 遍历所有对象 的功能</li><li>道具包</li><li>可使用角色</li></ul><h1 id="装饰模式decorator"><a class="anchor" href="#装饰模式decorator">#</a> 装饰模式（decorator）</h1><p>『动态地附加额外的责任给一个对象，装饰模式提供了一个灵活的选择，让子类可以用来扩展功能』<br />装饰模式具有很高的灵活度和透明性，可以一直不断地包覆下去<br />应用：</p><ul><li>属性前缀、后缀</li><li>网络协议加密</li><li>等</li></ul><p>优点在于不必更改太多现有实现类就能完成功能强化<br />注：适用于 目标已经存在，而装饰需求之后 出现的情况，不应滥用，过多装饰堆砌也会增加复杂度。</p><h1 id="适配器模式adapter"><a class="anchor" href="#适配器模式adapter">#</a> 适配器模式（adapter）</h1><p>『将一个类的接口转换成为客户端期待的类接口。适配器模式让原本接口不兼容的类能一起合作』<br />优点：不必使用复杂的方法，就能将两个不同接口的类对象交换使用。<br />应用：</p><ul><li>第三方库隔离职责</li><li>UI 组件适配</li></ul><h1 id="代理模式proxy"><a class="anchor" href="#代理模式proxy">#</a> 代理模式（proxy）</h1><p>『提供一个代理者位置给一个对象，好让代理者可以控制存取这个对象』<br />类似装饰模式，不用之处在于：</p><ul><li>对代理模式来说，它可以选择新功能是否执行；而装饰模式则是一定会一并执行</li><li>即代理模式是按职权『有选择』是否需要将需求转交给原始类。</li><li>而装饰模式则是必须在原始类被调用之前或之后，按照自己职权『增加』原始类没有的功能</li><li>与适配器模式差异：适配器着重在于『不同实现的转换』</li></ul><p>使用场景</p><ul><li>远程代理 (remote proxy)：常见于网页浏览器中代理服务器的设置</li><li>虚拟代理 (virtual proxy)：可作为 延后加载 功能的实现，让资源可以在真正要使用时才进行加载操作，其它情况都只是虚拟代理所呈现的一个假象</li><li>保护代理 (protection proxy)：代理者有职权可以控制是否要真正取用原始对象的资源</li><li>智能引用 (smart reference)：主要用于强化 C/C++ 语言对于指针控制的功能，减少内存遗失 (memory leak) 和空指针 (null pointer) 等问题</li></ul><p>优点</p><ul><li>可判断是否要将原始类的工作交由代理者类来执行，可以免去修改原始类的接口及实现</li></ul><p>其它应用</p><ul><li>临时资源代理呈现</li><li>服务器玩家在不同地图区块信息同步</li></ul><h1 id="其它模式"><a class="anchor" href="#其它模式">#</a> 其它模式</h1><ul><li>迭代器模式<ul><li>在不知道集合内部细节的情况下，提供一个按序方法存取一个对象集合体的每一个单元</li><li>C# 已直接提供支持</li></ul></li><li>原型模式<ul><li>使用原型对象来产生指定类的对象，所以产生对象时，是使用复制原型对象来完成</li><li>例如实例化</li></ul></li><li>解释器模式<ul><li>定义一个程序设计语言所需要的语句，并提供解释来解析执行</li></ul></li><li>抽象工厂模式<ul><li>工厂方法模式：定义一个可以产生对象的接口，但是让子类决定要产生哪一个类的对象。工厂方法模式让类的实例化延迟到子类执行</li><li>抽象工厂模式：提供一个能够建立整个类群组或有关联的对象，而不必指明它们的具体类</li><li>即：例如两组继承统一抽象工厂的工厂，根据不同环境调用哪一种生成不同的两组对象</li></ul></li></ul><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>不知道为啥，作者是把 abstract 父类命名为接口，也就是说，这本书所说的接口是将继承关系的抽象父类称为接口，所以其实并没有使用语言『规则』上的『接口』。抽象类虽然可以将方法实现延迟到子类，但它是单继承且依然代表一类对象，它的子类必然还是具有父类所有成员的。</p><p>整书完整贴代码还是挺多的，也就是更多偏向于展示作者的代码，理论反而比较少，基本结构大概就是：描述《P 级阵地》需求 -&gt;（硬编码示例）-&gt; 引用 Gof 下对应设计模式的描述 -&gt; 想如何设计 -&gt; 然后代码 -&gt; 结论</p><p>要是之前没有概念、并且想从实践入手的话，可以考虑一看（可能需要多一点耐心，代码还是比较基础）<br />但也因为上面说的原因，有些代码有些冗余。例如，访问者模式下的示例，要是利用泛型就不用写那么多方法及手动调用了。<br />当然，也可能是作者是为了『更简单』描述出原理。</p><p>本书将一整个 23 种设计模式全都囊括且给出了游戏应用示例 —— 说实话，除了这一本和另一本叫《游戏编程模式》的之外，我还没见到另外以『游戏』作为设计模式讲解的书 (如果有的话，希望提醒下)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;这本书是紧接着《CLR VIR C#》 开始的，依然是回家的时候看，顺便在手机语雀上记笔记：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;/blogimages/2</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C#与XLua交互原理研究</title>
    <link href="https://wangjiaying.top/2023/04/27/CS%E4%B8%8EXLua%E4%BA%A4%E4%BA%92%E5%8E%9F%E7%90%86%E7%A0%94%E7%A9%B6/"/>
    <id>https://wangjiaying.top/2023/04/27/CS%E4%B8%8EXLua%E4%BA%A4%E4%BA%92%E5%8E%9F%E7%90%86%E7%A0%94%E7%A9%B6/</id>
    <published>2023-04-27T08:40:38.000Z</published>
    <updated>2023-06-04T11:42:34.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>很久以前也有拿着 XLua C# 这边的源码看过，网上也找过资料... 就是搞不大清楚。</p><p>可惜没人提醒，后来才想明白，直接硬看 C# 这边的源码是不行的，想明白 C# 与 XLua 的交互原理，至少得先了解 C/C++ 与 Lua 的交互原理</p><p>—— 毕竟 C# 与 XLua 交互，依然是基于中间的 C API，了解了那边的概念，再看 C# 与 XLua 交互原理，才好理解。</p><h1 id="基本介绍"><a class="anchor" href="#基本介绍">#</a> 基本介绍</h1><ul><li>Lua 虚拟机由 C/C++ 实现，因此它可以直接与宿主进行通信</li><li>C# 则可以依靠 C API 通过 P/Invoke 方式调用 Lua 虚拟机函数</li><li>即 C# 可以借助 C/C++ 来与 Lua 进行数据通信</li><li>XLua 相关 P/Invoke 调用接口位于  <code>LuaDLL.cs</code>  文件</li></ul><h2 id="lua-和-cc-的数据交互"><a class="anchor" href="#lua-和-cc-的数据交互">#</a> Lua 和 C/C++ 的数据交互</h2><ul><li>基础：Lua 提供的一个虚拟栈</li><li>两者所有类型的数据交换都通过这个栈完成</li><li>Lua 提供了两种索引方式操作虚拟栈<ul><li>正数索引：1 表示栈底</li><li>反向索引：-1 表示栈顶</li></ul></li><li>例如：<ul><li><table><thead><tr><th style="text-align:center">正向索引</th><th style="text-align:center">反向索引</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">-1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">-2</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">-3</td></tr></tbody></table></li></ul></li></ul><h2 id="lua-调用-cc-函数"><a class="anchor" href="#lua-调用-cc-函数">#</a> Lua 调用 C/C++ 函数</h2><ul><li>将 C++ 的函数包装成可供 Lua 调用的格式<ul><li>接收一个 Lua 状态机指针 ( <code>IntPtr</code> ) 的静态方法，该方法返回值为 int，表示方法返回值数量</li></ul></li><li>在 Lua 环境注册包装好的函数</li><li>Lua 调用<ul><li>首先通过  <code>lua_gettop</code>  获取 Lua 参数数量 (因为可能有重载)</li><li>继续通过正数索引从  <code>1</code>  开始在 Lua 栈上获取具体参数值</li><li>执行实际函数功能</li><li>将返回值压栈</li><li>包装函数的返回值为 int，表示返回值数量</li></ul></li></ul><h2 id="cc-调用-lua-函数"><a class="anchor" href="#cc-调用-lua-函数">#</a> C/C++ 调用 Lua 函数</h2><ul><li>使用  <code>lua_getglobal(xlua_getglobal)</code>  来获取函数，然后将其压入栈</li><li>若函数有参则依次将函数的参数也压入栈</li><li>调用  <code>lua_pcall</code>  让虚拟机执行函数<ul><li>参数分别为：<ul><li>虚拟机指针</li><li>参数个数</li><li>返回值个数</li><li>错误处理函数，0 表示无，表示错误处理函数在栈中的索引</li></ul></li><li>如果运行出错， <code>lua_pcall</code>  会返回一个非零的结果</li><li>若调用完毕没有出错，则可以通过 Lua 虚拟栈从中取出调用结果</li></ul></li></ul><h1 id="基元类型传递"><a class="anchor" href="#基元类型传递">#</a> 基元类型传递</h1><p>对于 bool、int 这样简单的值类型可以直接通过 C API 传递，见 LuaDLL.cs</p><ul><li>xlua_pushinteger</li><li>lua_pushboolean</li><li>lua_pushnumber</li><li>xlua_pushuint</li></ul><h1 id="对象类型传递"><a class="anchor" href="#对象类型传递">#</a> 对象类型传递</h1><h2 id="基本流程"><a class="anchor" href="#基本流程">#</a> 基本流程</h2><p>C# 与 Lua 交互依然还是依靠 C API 通过 P/Invoke 进行，为了正确的和 Lua 通讯，C# 与 Lua 通过相互保存的索引保持引用</p><p>对于 C# 对象，Lua 这边通过 Table 模拟，C# 对象在 Lua 对应的就是一个  <code>userdata</code> ，利用对象索引保持与 C# 对象的联系</p><ul><li>传递到 Lua 的只是 C# 对象的一个索引，并需要注册 C# 类型信息到 Lua 以便使用</li><li>其中，对象的基本信息通过  <code>XLua_Gen_Initer_Register__</code>  中初始化通过调用  <code>ObjectTranslator.DelayWrapLoader</code>  注册到 Lua 侧</li><li><code>userdata</code> ：特指 C# 对象在 Lua 这边对应的代理 userdata<ul><li>为  <code>userdata</code>  设置的元表表示的实际是对象的类型信息，可以称为 “代理”</li></ul></li><li>在将 C# 对象传递到 Lua 以后，还需要告知 Lua 该对象的类型信息，比如对象类型有哪些成员方法，属性或是静态方法等。将这些都注册到 Lua 后，Lua 才能正确的调用</li><li>对于  <code>userdata</code>  转  <code>index</code> ，主要由两个 C API 提供： <code>LuaAPI.xlua_tocsobj_safe</code> （实际上为 C API： <code>lua_touserdata</code> ）、 <code>LuaAPI.xlua_gettypeid</code> （实际上为 C API  <code>lua_getmetatable</code> ）从 Lua 虚拟栈取值<ul><li>注：取出的是代理对象在 C# 侧的 ObjectPool 实例对象数组索引</li></ul></li></ul><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>LUA_API <span class="token keyword">int</span> <span class="token function">xlua_tocsobj_safe</span><span class="token punctuation">(</span>lua_State <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> <span class="token operator">*</span>udata <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">lua_touserdata</span> <span class="token punctuation">(</span>L<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>udata <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">lua_getmetatable</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token function">lua_pushlightuserdata</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tag<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token function">lua_rawget</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">lua_isnil</span> <span class="token punctuation">(</span>L<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token function">lua_pop</span> <span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token keyword">return</span> <span class="token operator">*</span>udata<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token function">lua_pop</span> <span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>LUA_API <span class="token keyword">int</span> <span class="token function">xlua_tocsobj_fast</span> <span class="token punctuation">(</span>lua_State <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">int</span> <span class="token operator">*</span>udata <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">lua_touserdata</span> <span class="token punctuation">(</span>L<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>udata<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">return</span> <span class="token operator">*</span>udata<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>LUA_API <span class="token keyword">int</span> <span class="token function">xlua_gettypeid</span><span class="token punctuation">(</span>lua_State <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">int</span> type_id <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">lua_type</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> idx<span class="token punctuation">)</span> <span class="token operator">==</span> LUA_TUSERDATA<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">lua_getmetatable</span> <span class="token punctuation">(</span>L<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token function">lua_rawgeti</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">lua_type</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> LUA_TNUMBER<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                type_id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">lua_tointeger</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token function">lua_pop</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token keyword">return</span> type_id<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>类型的元表数据是通过  <code>ObjectTranslator</code>   <code>getTypeId</code>  函数调用之前注册的  <code>delayWrap</code>  回调生成并注册到 Lua 侧的 (或通过反射生成)<br /> 主要的两个方法代码如下：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//ObjectTranslator.cs</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">internal</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">getTypeId</span><span class="token punctuation">(</span><span class="token class-name">RealStatePtr</span> L<span class="token punctuation">,</span> <span class="token class-name">Type</span> type<span class="token punctuation">,</span> <span class="token keyword">out</span> <span class="token class-name"><span class="token keyword">bool</span></span> is_first<span class="token punctuation">,</span> <span class="token class-name">LOGLEVEL</span> log_level <span class="token operator">=</span> LOGLEVEL<span class="token punctuation">.</span>WARN<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name"><span class="token keyword">int</span></span> type_id<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    is_first <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>typeIdMap<span class="token punctuation">.</span><span class="token function">TryGetValue</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> <span class="token keyword">out</span> type_id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// no reference</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span>IsArray<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>common_array_meta <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"Fatal Exception! Array Metatable not inited!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">return</span> common_array_meta<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">MulticastDelegate</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">IsAssignableFrom</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>common_delegate_meta <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"Fatal Exception! Delegate Metatable not inited!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token function">TryDelayWrapLoader</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">return</span> common_delegate_meta<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>        is_first <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token class-name">Type</span> alias_type <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        aliasCfg<span class="token punctuation">.</span><span class="token function">TryGetValue</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> <span class="token keyword">out</span> alias_type<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        LuaAPI<span class="token punctuation">.</span><span class="token function">luaL_getmetatable</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> alias_type <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token punctuation">?</span> type<span class="token punctuation">.</span>FullName <span class="token punctuation">:</span> alias_type<span class="token punctuation">.</span>FullName<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>LuaAPI<span class="token punctuation">.</span><span class="token function">lua_isnil</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//no meta yet, try to use reflection meta</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pop</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">TryDelayWrapLoader</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> alias_type <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token punctuation">?</span> type <span class="token punctuation">:</span> alias_type<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                LuaAPI<span class="token punctuation">.</span><span class="token function">luaL_getmetatable</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> alias_type <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token punctuation">?</span> type<span class="token punctuation">.</span>FullName <span class="token punctuation">:</span> alias_type<span class="token punctuation">.</span>FullName<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token keyword">else</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"Fatal: can not load metatable of type:"</span> <span class="token operator">+</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token comment">// 循环依赖，自身依赖自己的 class，比如有个自身类型的静态 readonly 对象。</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>typeIdMap<span class="token punctuation">.</span><span class="token function">TryGetValue</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> <span class="token keyword">out</span> type_id<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>            LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pop</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        <span class="token keyword">else</span></pre></td></tr><tr><td data-num="45"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">IsEnum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="47"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>                LuaAPI<span class="token punctuation">.</span><span class="token function">xlua_pushasciistring</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token string">"__band"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>                LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pushstdcallcfunction</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> metaFunctions<span class="token punctuation">.</span>EnumAndMeta<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>                LuaAPI<span class="token punctuation">.</span><span class="token function">lua_rawset</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>                LuaAPI<span class="token punctuation">.</span><span class="token function">xlua_pushasciistring</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token string">"__bor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>                LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pushstdcallcfunction</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> metaFunctions<span class="token punctuation">.</span>EnumOrMeta<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>                LuaAPI<span class="token punctuation">.</span><span class="token function">lua_rawset</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">IEnumerable</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">IsAssignableFrom</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="56"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>                LuaAPI<span class="token punctuation">.</span><span class="token function">xlua_pushasciistring</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token string">"__pairs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="58"></td><td><pre>                LuaAPI<span class="token punctuation">.</span><span class="token function">lua_getref</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> enumerable_pairs_func<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="59"></td><td><pre>                LuaAPI<span class="token punctuation">.</span><span class="token function">lua_rawset</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="61"></td><td><pre>            LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pushvalue</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="62"></td><td><pre>            type_id <span class="token operator">=</span> LuaAPI<span class="token punctuation">.</span><span class="token function">luaL_ref</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> LuaIndexes<span class="token punctuation">.</span>LUA_REGISTRYINDEX<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>            LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pushnumber</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> type_id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="64"></td><td><pre>            LuaAPI<span class="token punctuation">.</span><span class="token function">xlua_rawseti</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="65"></td><td><pre>            LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pop</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="66"></td><td><pre></pre></td></tr><tr><td data-num="67"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">IsValueType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="68"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="69"></td><td><pre>                typeMap<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>type_id<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="70"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="71"></td><td><pre></pre></td></tr><tr><td data-num="72"></td><td><pre>            typeIdMap<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> type_id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="73"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="74"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="75"></td><td><pre>    <span class="token keyword">return</span> type_id<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="76"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="77"></td><td><pre></pre></td></tr><tr><td data-num="78"></td><td><pre><span class="token comment">// 已加载类型列表</span></pre></td></tr><tr><td data-num="79"></td><td><pre><span class="token class-name">Dictionary<span class="token punctuation">&lt;</span>Type<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">></span></span> loaded_types <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Dictionary<span class="token punctuation">&lt;</span>Type<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="80"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> <span class="token function">TryDelayWrapLoader</span><span class="token punctuation">(</span><span class="token class-name">RealStatePtr</span> L<span class="token punctuation">,</span> <span class="token class-name">Type</span> type<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="81"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="82"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>loaded_types<span class="token punctuation">.</span><span class="token function">ContainsKey</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="83"></td><td><pre>    loaded_types<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="84"></td><td><pre></pre></td></tr><tr><td data-num="85"></td><td><pre>    LuaAPI<span class="token punctuation">.</span><span class="token function">luaL_newmetatable</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> type<span class="token punctuation">.</span>FullName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先建一个 metatable，因为加载过程可能会需要用到</span></pre></td></tr><tr><td data-num="86"></td><td><pre>    LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pop</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="87"></td><td><pre></pre></td></tr><tr><td data-num="88"></td><td><pre>    <span class="token class-name">Action<span class="token punctuation">&lt;</span>RealStatePtr<span class="token punctuation">></span></span> loader<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="89"></td><td><pre>    <span class="token class-name"><span class="token keyword">int</span></span> top <span class="token operator">=</span> LuaAPI<span class="token punctuation">.</span><span class="token function">lua_gettop</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="90"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>delayWrap<span class="token punctuation">.</span><span class="token function">TryGetValue</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> <span class="token keyword">out</span> loader<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="91"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="92"></td><td><pre>        delayWrap<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="93"></td><td><pre>        <span class="token function">loader</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="94"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="95"></td><td><pre>    <span class="token keyword">else</span></pre></td></tr><tr><td data-num="96"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="97"></td><td><pre><span class="token preprocessor property">#<span class="token directive keyword">if</span> !GEN_CODE_MINIMIZE &amp;&amp; !ENABLE_IL2CPP &amp;&amp; (UNITY_EDITOR || XLUA_GENERAL) &amp;&amp; !FORCE_REFLECTION &amp;&amp; !NET_STANDARD_2_0</span></pre></td></tr><tr><td data-num="98"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>DelegateBridge<span class="token punctuation">.</span>Gen_Flag <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>type<span class="token punctuation">.</span><span class="token function">IsEnum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">Delegate</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">IsAssignableFrom</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> Utils<span class="token punctuation">.</span><span class="token function">IsPublic</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="99"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="100"></td><td><pre>            <span class="token class-name">Type</span> wrap <span class="token operator">=</span> ce<span class="token punctuation">.</span><span class="token function">EmitTypeWrap</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="101"></td><td><pre>            <span class="token class-name">MethodInfo</span> method <span class="token operator">=</span> wrap<span class="token punctuation">.</span><span class="token function">GetMethod</span><span class="token punctuation">(</span><span class="token string">"__Register"</span><span class="token punctuation">,</span> BindingFlags<span class="token punctuation">.</span>Static <span class="token operator">|</span> BindingFlags<span class="token punctuation">.</span>Public<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="102"></td><td><pre>            method<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> <span class="token punctuation">&#123;</span> L <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="103"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="104"></td><td><pre>        <span class="token keyword">else</span></pre></td></tr><tr><td data-num="105"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="106"></td><td><pre>            Utils<span class="token punctuation">.</span><span class="token function">ReflectionWrap</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> type<span class="token punctuation">,</span> privateAccessibleFlags<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="107"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="108"></td><td><pre><span class="token preprocessor property">#<span class="token directive keyword">else</span></span></pre></td></tr><tr><td data-num="109"></td><td><pre>        Utils<span class="token punctuation">.</span><span class="token function">ReflectionWrap</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> type<span class="token punctuation">,</span> privateAccessibleFlags<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="110"></td><td><pre><span class="token preprocessor property">#<span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num="111"></td><td><pre><span class="token preprocessor property">#<span class="token directive keyword">if</span> NOT_GEN_WARNING</span></pre></td></tr><tr><td data-num="112"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">Delegate</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">IsAssignableFrom</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="113"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="114"></td><td><pre><span class="token preprocessor property">#<span class="token directive keyword">if</span> !</span><span class="token return-type class-name">XLUA_GENERAL</span></pre></td></tr><tr><td data-num="115"></td><td><pre>            UnityEngine<span class="token punctuation">.</span>Debug<span class="token punctuation">.</span><span class="token function">LogWarning</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"&#123;0&#125; not gen, using reflection instead"</span><span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="116"></td><td><pre><span class="token preprocessor property">#<span class="token directive keyword">else</span></span></pre></td></tr><tr><td data-num="117"></td><td><pre>            System<span class="token punctuation">.</span>Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"Warning: &#123;0&#125; not gen, using reflection instead"</span><span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="118"></td><td><pre><span class="token preprocessor property">#<span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num="119"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="120"></td><td><pre><span class="token preprocessor property">#<span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num="121"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="122"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">!=</span> LuaAPI<span class="token punctuation">.</span><span class="token function">lua_gettop</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="123"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="124"></td><td><pre>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"top change, before:"</span> <span class="token operator">+</span> top <span class="token operator">+</span> <span class="token string">", after:"</span> <span class="token operator">+</span> LuaAPI<span class="token punctuation">.</span><span class="token function">lua_gettop</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="125"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="126"></td><td><pre></pre></td></tr><tr><td data-num="127"></td><td><pre>    <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> nested_type <span class="token keyword">in</span> type<span class="token punctuation">.</span><span class="token function">GetNestedTypes</span><span class="token punctuation">(</span>BindingFlags<span class="token punctuation">.</span>Public<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="128"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="129"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nested_type<span class="token punctuation">.</span><span class="token function">IsGenericTypeDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="130"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="131"></td><td><pre>            <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="132"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="133"></td><td><pre>        <span class="token function">GetTypeId</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> nested_type<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="134"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="135"></td><td><pre>    </pre></td></tr><tr><td data-num="136"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="137"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol><li>先判断是否生成过对应元数据，若存在这直接返回  <code>typeIdMap</code>  字典中 type 对应的  <code>type_id</code></li></ol><ul><li>注：数组是单独处理的， <code>LuaEnv</code>  构造函数最后调用的注册</li></ul><ol start="2"><li>若没有则先判断是否有生成代码，没有则反射 ( <code>ReflectionWrap</code> ) 填充元表</li></ol><ul><li>反射时注册的 __call 元方法是个公共的  <code>ObjectTranslator.methodWrapsCache.GetConstructorWrap</code>  反射创建对象的操作回调</li><li>反射创建的对象通过  <code>PushAny</code>  加入  <code>ObjectPool</code> （这里会判断实际类型去调用合适的添加操作，例如字符串直接调用  <code>lua_pushstring</code> ，基元类型调用  <code>pushPrimitive</code>  等）</li><li>注：该方法会递归调用，若对象类型中有嵌套的公共类型，则递归注册</li></ul><p>那么，Lua 如何知道调用呢？</p><ul><li>可以注意到  <code>Lua</code>  调用  <code>C#</code>  都是通过  <code>CS.XXX</code>  的方式进行的（因为我自己项目不是 XLua 项目，所以是看示例那些看的）</li><li>而在  <code>LuaEnv.cs</code>  的构造方法中，会有  <code>AddBuildin(&quot;CS&quot;, StaticLuaCallbacks.LoadCS)</code>  的注册</li><li>我怀疑这个是否就是将『CS』 注册为 Lua 侧的一个空表以当做命名空间？</li><li>当  <code>Lua</code>  使用  <code>CS.XXX</code>  的时候，就会到这边来查询</li></ul><h2 id="对象实例成员注册"><a class="anchor" href="#对象实例成员注册">#</a> 对象实例成员注册</h2><p>生成代码中，通过  <code>Utils.BeginObjectRegister</code>  注册对象基本信息至 Lua 元表中</p><ul><li><p>如方法数量、getter_count、setter_count</p><ul><li>注：指实例方法及实例字段，静态变量和方法不在此列</li><li>注：一个实例字段会被分别生成为  getter 与 setter 的静态 wrap 方法</li></ul></li><li><p>以及比较重要的  <code>__gc</code>  元方法等</p><ul><li>如果给对象设置了 __gc 元方法，那么当对象被 gc 回收时将会调用它的 __gc 元方法</li><li>C# 注册主要是为了当 Lua 回收 Lua 侧对应的 C# Table 对象后，同时可以允许回收 C# 这边的实际对象 (移除 C# 侧的缓存引用)</li></ul></li></ul><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//Utils.cs</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">//BeginObjectRegister 注册实例对象数据方法</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>translator<span class="token punctuation">.</span><span class="token function">HasCustomOp</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> type <span class="token operator">!=</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name"><span class="token keyword">decimal</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    LuaAPI<span class="token punctuation">.</span><span class="token function">xlua_pushasciistring</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token string">"__gc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pushstdcallcfunction</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> translator<span class="token punctuation">.</span>metaFunctions<span class="token punctuation">.</span>GcMeta<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    LuaAPI<span class="token punctuation">.</span><span class="token function">lua_rawset</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">//StaticLuaCallbacks.cs </span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">//Lua 侧代理对象被回收后执行的回调</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">MonoPInvokeCallback</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">LuaCSFunction</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">LuaGC</span><span class="token punctuation">(</span><span class="token class-name">RealStatePtr</span> L<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">try</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token class-name"><span class="token keyword">int</span></span> udata <span class="token operator">=</span> LuaAPI<span class="token punctuation">.</span><span class="token function">xlua_tocsobj_safe</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>udata <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token class-name">ObjectTranslator</span> translator <span class="token operator">=</span> ObjectTranslatorPool<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span> translator <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                translator<span class="token punctuation">.</span><span class="token function">collectObject</span><span class="token punctuation">(</span>udata<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">return</span> LuaAPI<span class="token punctuation">.</span><span class="token function">luaL_error</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token string">"c# exception in LuaGC:"</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>然后注册实例字段、方法</p><ul><li>多个重载方法会被注册为一个静态 wrap 函数<br />调用  <code>Utils.EndObjectRegister</code>  完成实例字段、方法注册</li></ul><h2 id="对象静态成员注册"><a class="anchor" href="#对象静态成员注册">#</a> 对象静态成员注册</h2><p>调用  <code>Utils.BeginClassRegister</code>  注册创建该类型实例的回调及静态字段访问方法 static_getter_count、static_setter_count 数量</p><ul><li>若传递了创建实例类型的回调，则会注册到 Lua 的  <code>__call</code>  元方法中 (当 table 名字做为函数名字的形式被调用的时候，会调用 __call 函数)</li></ul><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//Utils.cs</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">//BeginClassRegister 注册静态数据时传递，注册创建对象实例回调</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>creator <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    LuaAPI<span class="token punctuation">.</span><span class="token function">xlua_pushasciistring</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token string">"__call"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token preprocessor property">#<span class="token directive keyword">if</span> </span><span class="token return-type class-name">GEN_CODE_MINIMIZE</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    translator<span class="token punctuation">.</span><span class="token function">PushCSharpWrapper</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> creator<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token preprocessor property">#<span class="token directive keyword">else</span></span></pre></td></tr><tr><td data-num="9"></td><td><pre>    LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pushstdcallcfunction</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> creator<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token preprocessor property">#</span><span class="token return-type class-name">endif</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    LuaAPI<span class="token punctuation">.</span><span class="token function">lua_rawset</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>注：代码生成始终会生成  <code>__CreateInstance</code>  即上述代码中  <code>creator</code>  这个回调，哪怕是静态类。<br />区别在于静态类要是调到了，是会直接报错的：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">MonoPInvokeCallbackAttribute</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">LuaCSFunction</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">__CreateInstance</span><span class="token punctuation">(</span><span class="token class-name">RealStatePtr</span> L<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> LuaAPI<span class="token punctuation">.</span><span class="token function">luaL_error</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token string">"TestS does not have a constructor!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>然后  <code>Lua</code>  侧创建时，例如官方  <code>LuaCallCs.cs</code>  示例中通过  <code>local newGameObj2 = CS.UnityEngine.GameObject('helloworld')</code>  创建了一个新的  <code>GameObejct</code>  对象，此时就是通过  <code>Lua</code>  侧被注册的  <code>__call</code>  元方法回调调用到  <code>UnityEngineGameObjectWrap</code>  中的  <code>__CreateInstance</code>  方法而创建的一个新对象</p><p>创建出新对象后，该对象会被代表该  <code>Lua</code>  状态机的  <code>ObjectTranslator.ObjectPool</code>  所缓存</p><ul><li><code>ObjectPool</code>  默认容量为  <code>512</code> ，若超出则会双倍扩容</li></ul><p>随后，通过  <code>LuaAPI.xlua_pushcsobj</code>  将返回的索引、C# 对象类型对应的 Lua 元表  <code>type_id</code>  等信息推送至 Lua 虚拟栈上，Lua 那边取值并用  <code>userdata</code>  缓存下来</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>LUA_API <span class="token keyword">void</span> <span class="token function">xlua_pushcsobj</span><span class="token punctuation">(</span>lua_State <span class="token operator">*</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> meta_ref<span class="token punctuation">,</span> <span class="token keyword">int</span> need_cache<span class="token punctuation">,</span> <span class="token keyword">int</span> cache_ref<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span><span class="token operator">*</span> pointer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">lua_newuserdata</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token operator">*</span>pointer <span class="token operator">=</span> key<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    </pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>need_cache<span class="token punctuation">)</span> <span class="token function">cacheud</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> key<span class="token punctuation">,</span> cache_ref<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">lua_rawgeti</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> LUA_REGISTRYINDEX<span class="token punctuation">,</span> meta_ref<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">lua_setmetatable</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>最后就是：</p><ul><li>注册静态方法及字段</li><li>调用  <code>Utils.EndClassRegister</code>  结束静态字段、方法注册</li></ul><h2 id="其它"><a class="anchor" href="#其它">#</a> 其它</h2><ul><li>xlua_pushlstring<ul><li>需要注意的是，LuaAPI 中封装了重载的接口，直接传递  <code>string</code>  类型的话</li><li>会通过转化为 UTF8 编码的 bytes 数组传递</li><li>有大小为  <code>256</code>  的数组缓存，小于该字节的走缓存，否则直接 GetBytes 转成字节数组传递</li></ul></li><li><code>decimal</code>  也是单独通过 LuaAPI.xlua_pushstruct 处理的</li></ul><h1 id="数据交互-lua-调-c"><a class="anchor" href="#数据交互-lua-调-c">#</a> 数据交互 - Lua 调 C#</h1><ol><li>首先通过  <code>getTypeId</code>  注册 C# 对象信息至 Lua 侧，并通过一个索引 (userdata) 保持联系</li><li>Lua 这边调用 C 函数时的参数会被自动的压栈 (若为实例对象，则会将对象索引压栈至第一位)</li><li>然后，通过上述注册的元表信息，例如自动生成的  <code>__Register</code>  延迟注册的代码：</li></ol><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">__Register</span><span class="token punctuation">(</span><span class="token class-name">RealStatePtr</span> L<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">ObjectTranslator</span> translator <span class="token operator">=</span> ObjectTranslatorPool<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">System<span class="token punctuation">.</span>Type</span> type <span class="token operator">=</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">Test</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    Utils<span class="token punctuation">.</span><span class="token function">BeginObjectRegister</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> L<span class="token punctuation">,</span> translator<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    </pre></td></tr><tr><td data-num="7"></td><td><pre>    Utils<span class="token punctuation">.</span><span class="token function">RegisterFunc</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> Utils<span class="token punctuation">.</span>METHOD_IDX<span class="token punctuation">,</span> <span class="token string">"Test1"</span><span class="token punctuation">,</span> _m_Test1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    </pre></td></tr><tr><td data-num="9"></td><td><pre>    Utils<span class="token punctuation">.</span><span class="token function">RegisterFunc</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> Utils<span class="token punctuation">.</span>GETTER_IDX<span class="token punctuation">,</span> <span class="token string">"Name"</span><span class="token punctuation">,</span> _g_get_Name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    Utils<span class="token punctuation">.</span><span class="token function">RegisterFunc</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> Utils<span class="token punctuation">.</span>SETTER_IDX<span class="token punctuation">,</span> <span class="token string">"Name"</span><span class="token punctuation">,</span> _s_set_Name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    Utils<span class="token punctuation">.</span><span class="token function">EndObjectRegister</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> L<span class="token punctuation">,</span> translator<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    Utils<span class="token punctuation">.</span><span class="token function">BeginClassRegister</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> L<span class="token punctuation">,</span> __CreateInstance<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    Utils<span class="token punctuation">.</span><span class="token function">RegisterFunc</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> Utils<span class="token punctuation">.</span>CLS_IDX<span class="token punctuation">,</span> <span class="token string">"Test2"</span><span class="token punctuation">,</span> _m_Test2_xlua_st_<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    Utils<span class="token punctuation">.</span><span class="token function">RegisterFunc</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> Utils<span class="token punctuation">.</span>CLS_IDX<span class="token punctuation">,</span> <span class="token string">"Test4"</span><span class="token punctuation">,</span> _m_Test4_xlua_st_<span class="token punctuation">)</span><span class="token punctuation">;</span>     </pre></td></tr><tr><td data-num="18"></td><td><pre>    </pre></td></tr><tr><td data-num="19"></td><td><pre>    Utils<span class="token punctuation">.</span><span class="token function">EndClassRegister</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> L<span class="token punctuation">,</span> translator<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>C# 这边的字段、方法都会被生成为 wrap 过的静态方法 (字段为两个 get、set 静态方法)<ul><li>Wrap 方法主要将 Lua 的访问或赋值操作转换成函数调用形式</li><li>生成的 wrap 方法是一个接收有一个参数，即接受 Lua 状态机指针 ( <code>System.IntPtr</code> ) 的静态方法</li></ul></li></ul><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 实例字段被编译而成的 getter，可视作普通实例方法的调用</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span><span class="token function">MonoPInvokeCallbackAttribute</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">LuaCSFunction</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">_g_get_Name</span><span class="token punctuation">(</span><span class="token class-name">RealStatePtr</span> L<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">ObjectTranslator</span> translator <span class="token operator">=</span> ObjectTranslatorPool<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    </pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">Test</span> gen_to_be_invoked <span class="token operator">=</span> <span class="token punctuation">(</span>Test<span class="token punctuation">)</span>translator<span class="token punctuation">.</span><span class="token function">FastGetCSObj</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pushstring</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> gen_to_be_invoked<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">System<span class="token punctuation">.</span>Exception</span> gen_e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> LuaAPI<span class="token punctuation">.</span><span class="token function">luaL_error</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token string">"c# exception:"</span> <span class="token operator">+</span> gen_e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol start="4"><li>生成的静态 Wrap 方法从 Lua 虚拟栈通过正数索引取参数值，然后调用实际方法，填入方法参数</li><li>实例方法编译出来的 lua 调用的方法，会先取缓存列表中实例对象，然后调用对应方法</li><li>重载函数必须通过同名函数被调用时传递的参数数量 (或类型) 来判断到底应该调用哪个函数</li></ol><ul><li><code>LuaAPI.lua_gettop(L)</code>  获取参数数量（静态与实例均如此，当然若没有重载会省略这一步）</li><li>后续<ul><li>实例对象从  <code>index 1</code>  获取对象类型索引 (userdata)，从  <code>index 2</code>  开始获取实际方法参数值</li><li>静态调用直接从  <code>index 1</code>  开始获取参数值</li></ul></li></ul><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 这是原本就是静态的方法</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span><span class="token function">MonoPInvokeCallbackAttribute</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">LuaCSFunction</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">_m_Test4_xlua_st_</span><span class="token punctuation">(</span><span class="token class-name">RealStatePtr</span> L<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token class-name"><span class="token keyword">int</span></span> _a <span class="token operator">=</span> LuaAPI<span class="token punctuation">.</span><span class="token function">xlua_tointeger</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token class-name"><span class="token keyword">bool</span></span> _b <span class="token operator">=</span> LuaAPI<span class="token punctuation">.</span><span class="token function">lua_toboolean</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token class-name"><span class="token keyword">string</span></span> _c <span class="token operator">=</span> LuaAPI<span class="token punctuation">.</span><span class="token function">lua_tostring</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       </pre></td></tr><tr><td data-num="10"></td><td><pre>            Test<span class="token punctuation">.</span><span class="token function">Test4</span><span class="token punctuation">(</span> _a<span class="token punctuation">,</span> _b<span class="token punctuation">,</span> _c <span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span>       </pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">System<span class="token punctuation">.</span>Exception</span> gen_e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span> LuaAPI<span class="token punctuation">.</span><span class="token function">luaL_error</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token string">"c# exception:"</span> <span class="token operator">+</span> gen_e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>函数返回值为 int，代表返回值数量</p><ol start="7"><li>当 Lua 调用时，会调用 C# 这边的 Wrap 静态方法，并通过索引获取到对应对象，再调用指定方法</li></ol><ul><li>函数通过 Lua 中的栈来接受 Lua 传递的参数，参数以正序入栈（第一个参数数量首先入栈）<ul><li>因此，当函数开始的时候， <code>lua_gettop(L)</code>  可以返回函数收到的参数个数</li><li>并根据正数索引从 <code>索引 1</code>  开始取值</li></ul></li></ul><h1 id="数据交互-c-调-xlua"><a class="anchor" href="#数据交互-c-调-xlua">#</a> 数据交互 - C# 调 XLua</h1><ul><li>可以通过数据映射进行</li><li>映射对象继承自  <code>LuaBase</code> ，如果是接口，并标记了  <code>[CSharpCallLua]</code>  特性，则会由  <code>XLua</code>  自动生成继承了  <code>LuaBase</code>  的桥接代码，该代码与  <code>LuaTable</code>  原理一致</li><li>主要通过  <code>luaenv.Global</code>  全局  <code>_G</code>  表获取数据并映射至  <code>C#</code>  这边类型<ul><li>根据  <code>Tutorial.CSCallLua</code>  示例，对于引用类型映射 (即两边修改同步) 主要有 标记特性接口 和 LuaTable、委托 (加入过生成列表，见  <code>LuaFunction.cs</code> )</li><li>否则普通的类型或直接取值，均通过值传递 (获取后就无关联)</li></ul></li><li>映射原理<ul><li>例如  <code>Lua 侧 Table</code>  被映射为  <code>C# LuaTable</code>  类型</li><li><code>LuaTable</code>  继承自  <code>LuaBase</code></li><li><code>LuaBase</code>  中构造函数接受两个参数：<ul><li><code>reference</code> ：Lua 中对象索引</li><li><code>luaenv</code> ：指定的 Lua 运行环境</li></ul></li><li>C# 这边通过调用  <code>LuaAPI.luaL_ref(L)</code>  将指定对象放入一张  <code>LUA_REGISTRYINDEX</code>  的全局表</li></ul></li></ul><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//ObjectCasters.cs</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">object</span></span> <span class="token function">getLuaTable</span><span class="token punctuation">(</span><span class="token class-name">RealStatePtr</span> L<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> idx<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">object</span></span> target<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>LuaAPI<span class="token punctuation">.</span><span class="token function">lua_type</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> idx<span class="token punctuation">)</span> <span class="token operator">==</span> LuaTypes<span class="token punctuation">.</span>LUA_TUSERDATA<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name"><span class="token keyword">object</span></span> obj <span class="token operator">=</span> translator<span class="token punctuation">.</span><span class="token function">SafeGetCSObj</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">return</span> <span class="token punctuation">(</span>obj <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> obj <span class="token keyword">is</span> <span class="token class-name">LuaTable</span><span class="token punctuation">)</span> <span class="token punctuation">?</span> obj <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>LuaAPI<span class="token punctuation">.</span><span class="token function">lua_istable</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pushvalue</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">LuaTable</span><span class="token punctuation">(</span>LuaAPI<span class="token punctuation">.</span><span class="token function">luaL_ref</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">,</span> translator<span class="token punctuation">.</span>luaEnv<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>因为  <code>LuaBase</code>  保存了对象在  <code>LUA_REGISTRYINDEX</code>  表的索引，因此可以再其中通过索引获取  <code>Lua</code>  侧对象，然后再通过虚拟栈进行交互</p><ul><li>也就是说  <code>reference</code>  指的不是栈上索引，而是这个全局表 ( <code>LUA_REGISTRYINDEX</code> ) 中的索引</li><li>根据相关信息解释，对于该全局表，C 代码可以自由使用，但 Lua 代码不能访问</li></ul><p>当获取值时，通过  <code>LuaAPI.lua_getref(L, luaReference)</code>  传入存储的  <code>reference</code>  获取</p><ul><li>见源码  <code>public partial class LuaTable</code>  中的  <code>Get</code>  方法</li><li>也就是说对于映射的引用类型，并非是直接通过虚拟栈 (Lua 为每次函数调用都新分配了一个栈，因此在离开作用域之后，栈索引就失效了)</li><li>而是通过保存对象在  <code>LUA_REGISTRYINDEX</code>  中的索引实现映射，在实际调用相关方法或字段时，通过存储的索引获取对应 Lua 表，再通过虚拟栈进行交互</li><li>注：映射后函数调用与取值都是类似流程，区别在于函数调用会推入参数，调用  <code>LuaAPI.lua_pcall</code> 。见官方  <code>Tutorial.CSCallLua.ItfD</code>  生成的  <code>TutorialCSCallLuaItfDBridge.add</code>  方法 (委托啥的一样，反正都先要在 Table 取到)</li></ul><p>当对象在  <code>C#</code>  这边被回收时，通过  <code>LuaBase</code>  析构函数的  <code>Dispose</code>  方法，调用  <code>luaenv</code>  的  <code>ObjectTranslator.ReleaseLuaBase</code>  将对象从  <code>LUA_REGISTRYINDEX</code>  表中删除 (随后该对象就能受  <code>Lua</code>  侧的垃圾回收了)</p><h1 id="垃圾回收相关"><a class="anchor" href="#垃圾回收相关">#</a> 垃圾回收相关</h1><p>C# 和 Lua 都有各自的垃圾回收机制，为了避免冲突，当使用了对方代理对象时，代理对象会被缓存，并在 <code>真实对象</code> 被回收后，移除缓存，使 <code>代理对象</code> 也能被回收</p><h2 id="lua-传递至-c-的对象"><a class="anchor" href="#lua-传递至-c-的对象">#</a> Lua 传递至 C# 的对象</h2><p><code>Lua</code>  传递至  <code>C#</code>  的对象，会通过  <code>LuaAPI.luaL_ref</code>  保持引用 (取值也是通过这个) 而不被回收</p><ul><li><code>C#</code>  这边对象被回收后，将其从  <code>LUA_REGISTRYINDEX</code>  表中移除使其可以被  <code>Lua</code>  垃圾管理器回收</li></ul><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ReleaseLuaBase</span><span class="token punctuation">(</span><span class="token class-name">RealStatePtr</span> L<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> reference<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">bool</span></span> is_delegate<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>is_delegate<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        LuaAPI<span class="token punctuation">.</span><span class="token function">xlua_rawgeti</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> LuaIndexes<span class="token punctuation">.</span>LUA_REGISTRYINDEX<span class="token punctuation">,</span> reference<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>LuaAPI<span class="token punctuation">.</span><span class="token function">lua_isnil</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pop</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">else</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pushvalue</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            LuaAPI<span class="token punctuation">.</span><span class="token function">lua_rawget</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> LuaIndexes<span class="token punctuation">.</span>LUA_REGISTRYINDEX<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>LuaAPI<span class="token punctuation">.</span><span class="token function">lua_type</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> LuaTypes<span class="token punctuation">.</span>LUA_TNUMBER <span class="token operator">&amp;&amp;</span> LuaAPI<span class="token punctuation">.</span><span class="token function">xlua_tointeger</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> reference<span class="token punctuation">)</span> <span class="token comment">//</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token comment">//UnityEngine.Debug.LogWarning("release delegate ref = " + luaReference);</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pop</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// pop LUA_REGISTRYINDEX[func]</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pushnil</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                LuaAPI<span class="token punctuation">.</span><span class="token function">lua_rawset</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> LuaIndexes<span class="token punctuation">.</span>LUA_REGISTRYINDEX<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// LUA_REGISTRYINDEX[func] = nil</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token keyword">else</span> <span class="token comment">//another Delegate ref the function before the GC tick</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pop</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// pop LUA_REGISTRYINDEX[func] &amp; func</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>        LuaAPI<span class="token punctuation">.</span><span class="token function">lua_unref</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> reference<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        delegate_bridges<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>reference<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token keyword">else</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        LuaAPI<span class="token punctuation">.</span><span class="token function">lua_unref</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> reference<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="c-传递至-lua-的对象"><a class="anchor" href="#c-传递至-lua-的对象">#</a> C# 传递至 Lua 的对象</h2><p>至于  <code>C#</code>  传递至  <code>Lua</code>  的对象，我们知道 C# 这边对象在 Lua 侧会被注册为元表</p><ul><li>在我们生成的元表数据，即 C# 对象的 Wrap 代码 (或反射生成) 的时候，就会将相关对象被 Lua 回收的回调注册到 Lua 中</li></ul><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>LuaAPI<span class="token punctuation">.</span><span class="token function">xlua_pushasciistring</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token string">"__gc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pushstdcallcfunction</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> translator<span class="token punctuation">.</span>metaFunctions<span class="token punctuation">.</span>GcMeta<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>LuaAPI<span class="token punctuation">.</span><span class="token function">lua_rawset</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>其中的  <code>translator.metaFunctions.GcMeta(StaticLuaCallbacks)</code>  就是当对象在  <code>Lua</code>  那边回收后，会将回收对象压栈，然后回调到  <code>C#</code>  这边注册的静态函数</p><p>随后， <code>C#</code>  这边通过回调传过来的  <code>Lua</code>  状态机指针，通过正向索引从  <code>Lua</code>  虚拟栈中获取到对应对象索引，从缓存列表移除，后续该对象就会受  <code>C#</code>  垃圾回收器回收</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">MonoPInvokeCallback</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">LuaCSFunction</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">LuaGC</span><span class="token punctuation">(</span><span class="token class-name">RealStatePtr</span> L<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">try</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name"><span class="token keyword">int</span></span> udata <span class="token operator">=</span> LuaAPI<span class="token punctuation">.</span><span class="token function">xlua_tocsobj_safe</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>udata <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token class-name">ObjectTranslator</span> translator <span class="token operator">=</span> ObjectTranslatorPool<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span> translator <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                translator<span class="token punctuation">.</span><span class="token function">collectObject</span><span class="token punctuation">(</span>udata<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">return</span> LuaAPI<span class="token punctuation">.</span><span class="token function">luaL_error</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token string">"c# exception in LuaGC:"</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h1 id="问题关于调用初始化"><a class="anchor" href="#问题关于调用初始化">#</a> 问题：关于调用初始化</h1><p>目前有点搞不清楚的问题就是：  <code>CS.UnityEngine.GameObject()</code>  这种代码，实际上是什么时候被初始化的？</p><p>在 C# 这边源码中可以明显看到，自动生成的  <code>wrap</code>  代码是在  <code>XLua_Gen_Initer_Register__</code>  通过  <code>ObjectTranslator.DelayWrapLoader</code>  注册的 —— 也就是说并不会立即加载</p><ul><li>在调用  <code>ObjectTranslator.GetTypeId</code>  才会判断是否注册过元表数据，判断是否反射或调用生成的 wrap 代码进行注册</li></ul><p>例如上面提到过的官方示例  <code>local newGameObj2 = CS.UnityEngine.GameObject('helloworld')</code>  创建了一个新的  <code>GameObejct</code>  对象，在调用的时候这个元表应该还没被初始化设置到 Lua 侧</p><p>所以应该还有一个东西，让它可以在没有找到的时候，调用 ObjectTranslator.GetTypeId 注册的基本元表数据</p><ul><li>目前怀疑是： <code>LuaEnv</code>  构造函数中的对  <code>__index</code>  设置的  <code>StaticLuaCallbacks.MetaFuncIndex</code>  回调，但是看着又.... 不大确定，因为这里看着是固定加载索引为 2 的 Type，虽然调用了  <code>GetTypeId</code> ，不过难道不是只会初始化这一个吗？调用的指定类型呢？光看 C# 这边代码还是相当有点疑惑。</li></ul><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//StaticLuaCallbacks.cs 文件</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span><span class="token function">MonoPInvokeCallback</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">LuaCSFunction</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">MetaFuncIndex</span><span class="token punctuation">(</span><span class="token class-name">RealStatePtr</span> L<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">try</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">ObjectTranslator</span> translator <span class="token operator">=</span> ObjectTranslatorPool<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name">Type</span> type <span class="token operator">=</span> translator<span class="token punctuation">.</span><span class="token function">FastGetCSObj</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token class-name">Type</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">return</span> LuaAPI<span class="token punctuation">.</span><span class="token function">luaL_error</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token string">"#2 param need a System.Type!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">//UnityEngine.Debug.Log("============================load type by __index:" + type);</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">//translator.TryDelayWrapLoader(L, type);</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        translator<span class="token punctuation">.</span><span class="token function">GetTypeId</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        LuaAPI<span class="token punctuation">.</span><span class="token function">lua_pushvalue</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        LuaAPI<span class="token punctuation">.</span><span class="token function">lua_rawget</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">System<span class="token punctuation">.</span>Exception</span> e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">return</span> LuaAPI<span class="token punctuation">.</span><span class="token function">luaL_error</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token string">"c# exception in MetaFuncIndex:"</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment">//ObjectTranslator.cs 文件</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">internal</span> <span class="token return-type class-name"><span class="token keyword">object</span></span> <span class="token function">FastGetCSObj</span><span class="token punctuation">(</span><span class="token class-name">RealStatePtr</span> L<span class="token punctuation">,</span><span class="token class-name"><span class="token keyword">int</span></span> index<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">getCsObj</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> index<span class="token punctuation">,</span> LuaAPI<span class="token punctuation">.</span><span class="token function">xlua_tocsobj_fast</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">object</span></span> <span class="token function">getCsObj</span><span class="token punctuation">(</span><span class="token class-name">RealStatePtr</span> L<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> index<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> udata<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token class-name"><span class="token keyword">object</span></span> obj<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>udata <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>LuaAPI<span class="token punctuation">.</span><span class="token function">lua_type</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">!=</span> LuaTypes<span class="token punctuation">.</span>LUA_TUSERDATA<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token class-name">Type</span> type <span class="token operator">=</span> <span class="token function">GetTypeOf</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name"><span class="token keyword">decimal</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>            <span class="token class-name"><span class="token keyword">decimal</span></span> v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>            <span class="token function">Get</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token keyword">out</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>            <span class="token keyword">return</span> v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>        <span class="token class-name">GetCSObject</span> <span class="token keyword">get</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> custom_get_funcs<span class="token punctuation">.</span><span class="token function">TryGetValue</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> <span class="token keyword">out</span> <span class="token keyword">get</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="48"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">get</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>        <span class="token keyword">else</span></pre></td></tr><tr><td data-num="52"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>objects<span class="token punctuation">.</span><span class="token function">TryGetValue</span><span class="token punctuation">(</span>udata<span class="token punctuation">,</span> <span class="token keyword">out</span> obj<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="57"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="58"></td><td><pre><span class="token preprocessor property">#<span class="token directive keyword">if</span> !UNITY_5 &amp;&amp; !XLUA_GENERAL &amp;&amp; !UNITY_2017 &amp;&amp; !UNITY_2017_1_OR_NEWER &amp;&amp; !UNITY_2018</span></pre></td></tr><tr><td data-num="59"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> obj <span class="token keyword">is</span> <span class="token class-name">UnityEngine<span class="token punctuation">.</span>Object</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>obj <span class="token keyword">as</span> <span class="token class-name">UnityEngine<span class="token punctuation">.</span>Object</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="60"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="61"></td><td><pre>            <span class="token comment">//throw new UnityEngine.MissingReferenceException("The object of type '"+ obj.GetType().Name +"' has been destroyed but you are still trying to access it.");</span></pre></td></tr><tr><td data-num="62"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="64"></td><td><pre><span class="token preprocessor property">#<span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num="65"></td><td><pre>        <span class="token keyword">return</span> obj<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="66"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="67"></td><td><pre>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="68"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>也许还有另一个可能？那就是这里其实是指的虚拟栈正数索引？但是感觉又不像.... 上边使用 index 传入 GetTypeOf 获取类型的方法如下：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//ObjectTranslator.cs 文件</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">Type</span> <span class="token function">GetTypeOf</span><span class="token punctuation">(</span><span class="token class-name">RealStatePtr</span> L<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">int</span></span> idx<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">Type</span> type <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token class-name"><span class="token keyword">int</span></span> type_id <span class="token operator">=</span> LuaAPI<span class="token punctuation">.</span><span class="token function">xlua_gettypeid</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>type_id <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        typeMap<span class="token punctuation">.</span><span class="token function">TryGetValue</span><span class="token punctuation">(</span>type_id<span class="token punctuation">,</span> <span class="token keyword">out</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> type<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里通过  <code>LuaAPI.xlua_gettypeid</code>  获取 type_id，然而 type_id 需求我们先注册了 (也就是) 才会有.... 陷入循环了？</p><p>还是说通过  <code>ObjectTranslator.OpenLib</code>  处理的？</p><p>后面还有诸如  <code>AddBuildin(&quot;CS&quot;, StaticLuaCallbacks.LoadCS)</code>  的代码，看着是将『CS』这个注册为一个 Lua 表当做命名空间？所以 Lua 那边调用，都是通过 CS. 调用的</p><p>疑惑.... 我们项目本身并不是 XLua 的，所以其实也不是很熟，研究了几天倒是一堆揣测。</p><hr /><h2 id="对猜想的测试"><a class="anchor" href="#对猜想的测试">#</a> 对猜想的测试</h2><p>突然想到 XLua C# 这边不是可以直接调试的么，何不直接调调看？硬看代码，不如实际来测试下看看。</p><h3 id="猜测一staticluacallbacksmetafuncindex-初始化"><a class="anchor" href="#猜测一staticluacallbacksmetafuncindex-初始化">#</a> 猜测一：StaticLuaCallbacks.MetaFuncIndex 初始化</h3><p>实际调试了一下， 初始化 Lua 虚拟机就向  <code>__index</code>  注册的  <code>StaticLuaCallbacks.MetaFuncIndex</code>  确实被调用到了</p><p>然后通过在 LuaCallCs 示例的 Lua 脚本前加上 print ，并查看 print 与 StaticLuaCallbacks.MetaFuncIndex 调用顺序：</p><ul><li>注：print 是在 LuaEnv 初始化时，通过  <code>LuaAPI.lua_pushstdcallcfunction(rawL, StaticLuaCallbacks.Print)</code>  注册的功能函数。</li><li>结果 GameObject 创建完了，后续 print 都来了都没执行</li></ul><p>该猜测 Pass</p><h3 id="猜测二objecttranslatoropenlib-中注册的某个处理"><a class="anchor" href="#猜测二objecttranslatoropenlib-中注册的某个处理">#</a> 猜测二：ObjectTranslator.OpenLib 中注册的某个处理</h3><p>直接在  <code>ObjectTranslator.getTypeId</code>  方法里边打断点，所有对象使用先必然先通过这里注册基本元数据，直接查看什么时候来的、怎么来的。<br />然后来到了... 之前猜测的  <code>ObjectTranslator.OpenLib</code>  中注册的  <code>import_type</code> ，即  <code>StaticLuaCallbacks.ImportType</code>  函数中：</p><p><img data-src="/blogimages/2023/2023-04-27/image1.png" alt="" /></p><p>（这好像就符合第二个猜测了）</p><p>然后进入  <code>TryDelayWrapLoader</code>  ，因为之前我生成过代码，所以  <code>delayWrap</code> ，即之前提到过的生成代码注册的列表存在对应类型：</p><p><img data-src="/blogimages/2023/2023-04-27/image2.png" alt="" /></p><p>所以，在 Lua 侧调用不存在对象时，会调到 C# 侧的  <code>import_type</code>  代码，对类型进行实际注册，使其可以被调用。</p><ul><li>注：LuaEnv init_xlua 会有初始化 __index 元方法的 lua 代码，其中会判断调用 import_type</li></ul><p>然后，若 Lua 代码通过  <code>__call</code>  方式调用，则 C# 调用对象注册的创建对应实例方法，创建对应实例，并两者映射起来。</p><ul><li>后续，不管是调用方法，还是获取变量，均通过正常交互流程进行了！</li></ul><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>最后，再来梳理一下流程：</p><p>Lua 调 C#</p><ul><li>首先，在创建一个  <code>LuaEnv</code>  环境时，会保存该环境返回的指针，并注册一些初始的公共静态函数<ul><li>例如生成的 wrap 代码的延迟注册回调  <code>__Register</code>  从  <code>XLuaGenAutoRegister.cs</code>  添加至  <code>D</code> elayWrapLoader`<ul><li>注：结构体、枚举等自定义值类型会在  <code>WrapPusher.cs</code>  中单独注册类型（前提是加了  <code>[XLua.LuaCallCSharp]</code> 、 <code>[GCOptimize]</code>  这类  <code>XLua</code>  的特性、或者加到  <code>GenConfig</code>  也可以）</li></ul></li><li>当  <code>Lua</code>  调用时，若对应类型还未进行实际数据注册，则会调到  <code>ObjectTranslator.OpenLib</code>  中注册的  <code>import_type</code>  ，在该方法中调用注册的  <code>__Register</code>  回调去实际注册对象<ul><li>实例对象的创建方法  <code>__CreateInstance</code>  也是在此 ( <code>__Register回调</code> ) 通过注册到  <code>Lua</code>  侧  <code>__call</code>  元方法进行</li></ul></li><li>而后，就可以实际工作了，查询  <code>typeIdMap</code>  是否存在对应类型，不存在则调用  <code>TryDelayWrapLoader</code>  进行类型实际初始化<ul><li>注：数组是单独处理的， <code>LuaEnv</code>  构造函数最后调用的注册</li><li>注：若没有生成代码，则反射调用，由  <code>Utils.ReflectionWrap</code>  方法注册，即公共的反射调用回调替代生成代码</li></ul></li><li>调用时还会区分静态和非静态的实例调用 (虽然都是注册的静态 wrap 方法，但实际操作还是有区别的)：</li><li>当  <code>Lua</code>  调过来的时候，会传递  <code>LuaEnv</code>  的指针，</li><li>实例调用：<ul><li>通过字典查询得到实际  <code>LuaEnv</code>  对应的  <code>ObjectTranslator</code></li><li>通过正数索引  <code>1</code>  从  <code>Lua虚拟栈</code> 获取对象索引，然后使用索引从  <code>ObjectTranslator</code>  获取  <code>C#</code>  侧实例对象<ul><li>若有调用方法有重载，则通过  <code>lua_gettop</code>  获取参数数量</li></ul></li><li>通过正数索引  <code>2</code>  开始获取实际参数</li></ul></li><li>静态调用：<ul><li>当  <code>Lua</code>  调过来的时候，直接以正数索引从  <code>1</code>  开始取参数值<ul><li>若有调用方法有重载，则通过  <code>lua_gettop</code>  获取参数数量</li></ul></li></ul></li><li>调用实际方法</li><li>将方法调用结果压栈</li><li>返回调用方法后，方法的返回值数量</li><li>Lua 侧拿到调用结果</li></ul></li><li>所以，静态字段或方法与实例的调用流程是一样的</li><li>两者的主要区别是：是否需要通过额外对象索引参数去查找实际对象</li></ul><p>C# 调用 Lua 则通过映射实现</p><ul><li><code>luaenv.Global</code>  (初始化映射的  <code>Lua _G</code>  表)</li><li>然后后续则通过调用  <code>luaenv.Global.Get</code>  从  <code>_G</code>  表获取数据，并映射至  <code>C#</code>  侧对应对象结构<ul><li>继承  <code>LuaBase</code>  (添加特性会自动生动对应 wrap 代码) 通过引用映射，两边保持对应索引<ul><li>调用对象时，通过去 LUA_REGISTRYINDEX 获取对应对象，并通过虚拟栈传递信息进行实际调用</li></ul></li><li>没有继承  <code>LuaBase</code>  的 会通过值传递，获取一次值后两边就无关系了</li></ul></li></ul><p>C# 侧缓存的 Lua 对象被缓存至  <code>LUA_REGISTRYINDEX</code>  表<br /> Lua 侧创建的 C# 对象被缓存至  <code>ObjectTranslator.ObjectPool</code></p><p>避免相互之前 GC 导致对象回收，当一边的代理对象被回收后，通知对面从缓存表移除缓存，然后执行真实对象的回收。</p><p>最后：</p><ul><li>对于静态方法，只需要根据虚拟机的  <code>RealStatePtr</code>  指针直接调用 C API 去  <code>Lua虚拟栈</code> 取值，然后调用实际方法即可。</li><li>然而对于实例对象， 除了根据  <code>RealStatePtr</code>  去字典查询一次虚拟机  <code>ObjectTranslator</code>  外，还得在  <code>ObjectTranslator.objects</code>  中通过对象索引查找实际对象（当然因为  <code>ObjectPool</code>  是数组结构，其实还是挺快的），然后通过正向索引从  <code>Lua虚拟栈</code> 获取参数并调用</li><li>因此实例对象的调用，会比静态方法、字典慢些 —— 另外要是只有一个虚拟机环境的需求，是否可以直接把通过字典查  <code>Lua虚拟机</code> 这一步给省掉？毕竟这一步主要是为支持多虚拟机环境，如果没用多虚拟机环境感觉好像可以？</li></ul><p>可能写得稍微有点重复啰嗦，毕竟是一边看一边猜测，又一边修改的，不过也算加深映象了。虽然我自己项目还是纯 C# 在搞，不过毕竟公司在推 XLua，研究这个主要是避免别人问起来，都说不出什么深点的原理。</p><h1 id="参考文档"><a class="anchor" href="#参考文档">#</a> 参考文档</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxODI2MzY0NDEwL2FydGljbGUvZGV0YWlscy84ODYyNDgyNA==">【最详细易懂】C++ 和 Lua 交互总结 鹅厂程序小哥的博客 - CSDN 博客</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA3ODI2NDQvYXJ0aWNsZS9kZXRhaWxzLzc5NjQxMjg0">lua_pcall 详解_lua lua_pcall_俊哥兜里有糖的博客 - CSDN 博客</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82ZTgzZjFjZjkwYmY=">为什么调用 lua_pcall</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyYXJob3cvYXJ0aWNsZS9kZXRhaWxzLzIwNDU1NDkx">在 C 语言中调用 lua 实现的回调函数_luaapi.lua_getref 是干什么的_superarhow 的博客 - CSDN 博客</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMzk4NzExNg==">lua gc 对象复活</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20venNiNTE3L3AvNjQxODkyOS5odG1s">Lua 与 C 交互之 LUA_REGISTRYINDEX（3） - RubbyZhang - 博客园</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaXdpbml3aW4vcC8xNTMwNzM2OC5odG1s">深入 xLua 实现原理之 Lua 如何调用 C# - iwiniwin - 博客园</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaXdpbml3aW4vcC8xNTMyMzk3MC5odG1s">深入 xLua 实现原理之 C# 如何调用 Lua - iwiniwin - 博客园</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYm9va3N0YWNrLmNuL3JlYWQvbHVhLTUuMy9zcGlsdC40MC5zcGlsdC4xLjUubWQ=">5.1 函数和类型 - luaL_newstate - 《Lua 5.3 参考手册》 - 书栈网・BookStack</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTk1MzQzMDMzOTc3Nzk4Njcw">Lua 与 C 语言的互相调用 - 掘金</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTUyNzc4Mjg=">lua 源码编译及与 C/C++ 交互调用细节剖析</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYnlmZWkvcC82Mzg5Nzg1Lmh0bWw=">lua_touserdata - byfei - 博客园</span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;很久以前也有拿着 XLua C# 这边的源码看过，网上也找过资料... 就是搞不大清楚。&lt;/p&gt;
&lt;p&gt;可惜没人提醒，后来才想明白，直接硬看 C# 这边的源码是不行</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/categories/Unity3D/"/>
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/tags/Unity3D/"/>
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="XLua" scheme="https://wangjiaying.top/tags/XLua/"/>
    
  </entry>
  
  <entry>
    <title>对列表容器中值类型引用传参的一点测试</title>
    <link href="https://wangjiaying.top/2023/04/14/%E5%AF%B9%E5%88%97%E8%A1%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E4%BC%A0%E5%8F%82%E7%9A%84%E4%B8%80%E7%82%B9%E6%B5%8B%E8%AF%95/"/>
    <id>https://wangjiaying.top/2023/04/14/%E5%AF%B9%E5%88%97%E8%A1%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E4%BC%A0%E5%8F%82%E7%9A%84%E4%B8%80%E7%82%B9%E6%B5%8B%E8%AF%95/</id>
    <published>2023-04-14T08:13:21.000Z</published>
    <updated>2023-06-04T11:42:34.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>最近做项目优化，在整理主界面的按钮问题的时候，用到了只读结构体，这个结构体会保存于一个列表中，并采用  <code>in</code>  对列表中的值进行引用传递。</p><p>然后突后面然想到，保存于列表中的值类型，真的能直接被引用吗？</p><p>毕竟  <code>List</code>  数据结构本身由于存在扩容问题，因此是不允许直接返回其中数据引用的。</p><p>那么我们就有理由怀疑：实际类型为  <code>List</code>  容器中，采用下标取出的对象作为引用传递时，它可能依然会在栈上新建一个临时变量，然后再将其作为引用传递过去。那么这里就还是存在一个额外拷贝开销了。</p><p>于是考虑了一下，并且也比较好奇，于是就想着用  <code>ILSpy</code>  进行反编译查看生成的  <code>IL</code>  代码，以确定是否真的如猜测所示。</p><h1 id="列表类型"><a class="anchor" href="#列表类型">#</a> 列表类型</h1><p>首先，源代码如下所示：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token keyword">struct</span> <span class="token class-name">MainRightButtonItem</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 省略......</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">RefreshButton</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> index<span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token class-name">MainRightButtonItem</span> buttonData<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 省略......</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">/// &lt;summary></span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">/// 刷新按钮状态数据</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">/// &lt;/summary></span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">RefreshButtons</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _buttonDataList<span class="token punctuation">.</span>Count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token function">RefreshButton</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> _buttonDataList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这是一个最简单的  <code>for循环</code> ，循环中通过下标取  <code>List</code>  并直接传递至  <code>RefreshButton</code>  方法中， <code>RefreshButton</code>  本身接收的则是一个  <code>MainRightButtonItem</code>  的引用地址。</p><p>编译为  <code>IL</code>  代码后如下所示：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>IL_0000<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="2"></td><td><pre>IL_0001<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="3"></td><td><pre>IL_0002<span class="token punctuation">:</span> br<span class="token punctuation">.</span>s IL_001e</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// loop start (head: IL_001e)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    IL_0004<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    IL_0005<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    IL_0006<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    IL_0007<span class="token punctuation">:</span> ldfld <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">.</span>List`<span class="token number">1</span><span class="token operator">&lt;</span>valuetype BottonListHolder<span class="token operator">/</span>MainRightButtonItem<span class="token operator">></span> BottonListHolder<span class="token punctuation">::</span><span class="token class-name">_buttonDataList</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    IL_000c<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    IL_000d<span class="token punctuation">:</span> callvirt instance <span class="token operator">!</span><span class="token number">0</span> <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">.</span>List`<span class="token number">1</span><span class="token operator">&lt;</span>valuetype BottonListHolder<span class="token operator">/</span>MainRightButtonItem<span class="token operator">></span><span class="token punctuation">::</span><span class="token function">get_Item</span><span class="token punctuation">(</span>int32<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    IL_0012<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    IL_0013<span class="token punctuation">:</span> ldloca<span class="token punctuation">.</span>s <span class="token number">1</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    IL_0015<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> BottonListHolder<span class="token punctuation">::</span><span class="token function">RefreshButton</span><span class="token punctuation">(</span>int32<span class="token punctuation">,</span> valuetype BottonListHolder<span class="token operator">/</span>MainRightButtonItem<span class="token operator">&amp;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    IL_001a<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    IL_001b<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    IL_001c<span class="token punctuation">:</span> <span class="token keyword">add</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    IL_001d<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    IL_001e<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    IL_001f<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    IL_0020<span class="token punctuation">:</span> ldfld <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">.</span>List`<span class="token number">1</span><span class="token operator">&lt;</span>valuetype BottonListHolder<span class="token operator">/</span>MainRightButtonItem<span class="token operator">></span> BottonListHolder<span class="token punctuation">::</span><span class="token class-name">_buttonDataList</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    IL_0025<span class="token punctuation">:</span> callvirt instance int32 <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">.</span>List`<span class="token number">1</span><span class="token operator">&lt;</span>valuetype BottonListHolder<span class="token operator">/</span>MainRightButtonItem<span class="token operator">></span><span class="token punctuation">::</span><span class="token function">get_Count</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    IL_002a<span class="token punctuation">:</span> blt<span class="token punctuation">.</span>s IL_0004</pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment">// end loop</span></pre></td></tr></table></figure><h2 id="分析"><a class="anchor" href="#分析">#</a> 分析</h2><p><code>loop start</code>  之后就是循环体，在  <code>IL_0015</code>  处的指令可以看出来，确实是传递的一个  <code>MainRightButtonItem</code>  的引用，这个跟想象的一样，没什么问题。</p><p>接着就需要确认它之前有没有将值拷贝到栈上的操作：</p><p>从  <code>IL_0007</code>  开始，首先将列表加载至栈上<br />接着  <code>IL_000d</code>  调用列表的  <code>get_Item</code>  方法 (索引器) 并传入下标<br />关键就在于  <code>Stloc_1</code>  和  <code>Ldloca_S </code>  指令：</p><blockquote><p>Stloc_1：从计算堆栈顶部弹出当前值，并将其存储在索引 1 处的局部变量列表中。<br />Ldloca_S：将位于特定索引处的局部变量的地址加载到计算堆栈上（短格式）。</p></blockquote><p>看这指令解释... 貌似还是执行了复制操作？</p><h2 id="对比非引用传参"><a class="anchor" href="#对比非引用传参">#</a> 对比非引用传参</h2><p>与上述唯一不同的是，调用的  <code>RefreshButtonCopy</code>  方法没有标记为引用传参，关键  <code>IL</code>  代码如下：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>IL_0007<span class="token punctuation">:</span> ldfld <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">.</span>List`<span class="token number">1</span><span class="token operator">&lt;</span>valuetype BottonListHolder<span class="token operator">/</span>MainRightButtonItem<span class="token operator">></span> BottonListHolder<span class="token punctuation">::</span><span class="token class-name">_buttonDataList</span></pre></td></tr><tr><td data-num="2"></td><td><pre>IL_000c<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="3"></td><td><pre>IL_000d<span class="token punctuation">:</span> callvirt instance <span class="token operator">!</span><span class="token number">0</span> <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">.</span>List`<span class="token number">1</span><span class="token operator">&lt;</span>valuetype BottonListHolder<span class="token operator">/</span>MainRightButtonItem<span class="token operator">></span><span class="token punctuation">::</span><span class="token function">get_Item</span><span class="token punctuation">(</span>int32<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>IL_0012<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> BottonListHolder<span class="token punctuation">::</span><span class="token function">RefreshButtonCopy</span><span class="token punctuation">(</span>int32<span class="token punctuation">,</span> valuetype BottonListHolder<span class="token operator">/</span>MainRightButtonItem<span class="token punctuation">)</span></pre></td></tr></table></figure><p>看起来竟然还比引用传递少了两条指令！</p><h1 id="数组类型"><a class="anchor" href="#数组类型">#</a> 数组类型</h1><p>首先，数组结构的模式。</p><p>原代码：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">MainRightButtonItem<span class="token punctuation">[</span><span class="token punctuation">]</span></span> items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MainRightButtonItem</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> items<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token function">RefreshButton</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编译为  <code>IL</code>  代码如下：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>IL_0000<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span>s <span class="token number">10</span></pre></td></tr><tr><td data-num="2"></td><td><pre>IL_0002<span class="token punctuation">:</span> newarr BottonListHolder<span class="token operator">/</span><span class="token class-name">MainRightButtonItem</span></pre></td></tr><tr><td data-num="3"></td><td><pre>IL_0007<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="4"></td><td><pre>IL_0008<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="5"></td><td><pre>IL_0009<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="6"></td><td><pre>IL_000a<span class="token punctuation">:</span> br<span class="token punctuation">.</span>s IL_001e</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// loop start (head: IL_001e)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    IL_000c<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    IL_000d<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    IL_000e<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    IL_000f<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    IL_0010<span class="token punctuation">:</span> ldelema BottonListHolder<span class="token operator">/</span><span class="token class-name">MainRightButtonItem</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    IL_0015<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> BottonListHolder<span class="token punctuation">::</span><span class="token function">RefreshButton</span><span class="token punctuation">(</span>int32<span class="token punctuation">,</span> valuetype BottonListHolder<span class="token operator">/</span>MainRightButtonItem<span class="token operator">&amp;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    IL_001a<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    IL_001b<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    IL_001c<span class="token punctuation">:</span> <span class="token keyword">add</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    IL_001d<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    IL_001e<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    IL_001f<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    IL_0020<span class="token punctuation">:</span> <span class="token class-name">ldlen</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    IL_0021<span class="token punctuation">:</span> <span class="token class-name">conv<span class="token punctuation">.</span>i4</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    IL_0022<span class="token punctuation">:</span> blt<span class="token punctuation">.</span>s IL_000c</pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment">// end loop</span></pre></td></tr></table></figure><p>对于  <code>ldelema</code>  指令文档解释为：</p><blockquote><p>ldelema：将位于指定数组索引的数组元素的地址作为 &amp; 类型（托管指针）加载到计算堆栈的顶部。</p></blockquote><ol><li>对象引用 array 被推送到堆栈上。</li><li>索引值 index 被推送到堆栈上。</li><li>index 并从 array 堆栈中弹出；将查找存储在位置 index array 的地址。</li><li>地址被推送到堆栈上。</li></ol><p>可知这是一个对数组特异化的引用取值指令，表明此处确定是引用传递，与预想一致。</p><h1 id="性能测试"><a class="anchor" href="#性能测试">#</a> 性能测试</h1><p>对于  <code>List</code>  的结构体容器引用传参及非引用传参的性能，目前就有点拿不准了，于是还是走测试流程，实际比较一下吧。</p><p>这里直接使用  <code>Unity3D</code>  的  <code>TestRunner</code> ，代码如下：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RefStruckTest</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">List<span class="token punctuation">&lt;</span>Data<span class="token punctuation">></span></span> testList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">List<span class="token punctuation">&lt;</span>Data<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Data<span class="token punctuation">[</span><span class="token punctuation">]</span></span> testArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Data</span><span class="token punctuation">[</span><span class="token number">10000000</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Test</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TestListRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> testList<span class="token punctuation">.</span>Count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token function">InvokeRef</span><span class="token punctuation">(</span>testList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Test</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TestListCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> testList<span class="token punctuation">.</span>Count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token function">InvokeCopy</span><span class="token punctuation">(</span>testList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Test</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TestArrayRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> testArray<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token function">InvokeRef</span><span class="token punctuation">(</span>testArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">Test</span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TestArrayCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> testArray<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>            <span class="token function">InvokeCopy</span><span class="token punctuation">(</span>testArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre></pre></td></tr><tr><td data-num="45"></td><td><pre>    <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">InvokeRef</span><span class="token punctuation">(</span><span class="token keyword">in</span> <span class="token class-name">Data</span> data<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="46"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="47"></td><td><pre></pre></td></tr><tr><td data-num="48"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="49"></td><td><pre></pre></td></tr><tr><td data-num="50"></td><td><pre>    <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">InvokeCopy</span><span class="token punctuation">(</span><span class="token class-name">Data</span> data<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="51"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="52"></td><td><pre></pre></td></tr><tr><td data-num="53"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="54"></td><td><pre></pre></td></tr><tr><td data-num="55"></td><td><pre></pre></td></tr><tr><td data-num="56"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token keyword">struct</span> <span class="token class-name">Data</span></pre></td></tr><tr><td data-num="57"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="58"></td><td><pre>        <span class="token keyword">readonly</span> <span class="token class-name"><span class="token keyword">long</span></span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">,</span> w<span class="token punctuation">,</span> k<span class="token punctuation">,</span> n<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="59"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="60"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>结果：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>TestArrayCopy <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span>073s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>TestArrayRef <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span>061s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>TestListCopy <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span>000s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>TestListRef <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span>000s<span class="token punctuation">)</span></pre></td></tr></table></figure><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>在  <code>IL</code>  代码分析中，对于  <code>List</code>  容器来说，可以看出直接传递的方式反而比引用传递少两条指令，但实际性能测试结果显示，引用传递的的方式性能还是更好。</p><p>另外，数组的性能更好 —— 至少在仅取值和传递方面不是一个级别的，这估计跟  <code>CLR</code>  对数组本身的优化支持、以及  <code>List</code>  索引实际还走了一道属性取值也有关系。</p><p>后续估计还得再研究一下  <code>Stloc_1</code>  和  <code>Ldloca_S</code>  两条指令深一点的功用。</p><p>例如，我们是否有理由怀疑：</p><ol><li>引用传递只执行了一次复制，调用者的方法栈上，然后传递引用</li><li>复制传递方式则至少执行两次复制，即调用者的方法栈上，然后再复制一份传递至调用方法</li></ol><p>因此虽然上述两条指令执行了赋值，依然造成了上述实际的性能差异，也就是说，引用传递怎么都还是比直接复制传参省一些。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;最近做项目优化，在整理主界面的按钮问题的时候，用到了只读结构体，这个结构体会保存于一个列表中，并采用  &lt;code&gt;in&lt;/code&gt;  对列表中的值进行引用传递。</summary>
      
    
    
    
    <category term="C#" scheme="https://wangjiaying.top/categories/C/"/>
    
    
    <category term="C#" scheme="https://wangjiaying.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>《CLR VIR C#》笔记(下)-多线程</title>
    <link href="https://wangjiaying.top/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://wangjiaying.top/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-04-06T05:33:15.000Z</published>
    <updated>2023-06-04T11:42:34.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>《CLR VIR C#》 这本书太厚，笔记也记得太多，因此还是分成两篇上传</p><p>这是第二篇，主要记录多线程相关章节笔记</p><h1 id="第二十六章-线程基础"><a class="anchor" href="#第二十六章-线程基础">#</a> 第二十六章 线程基础</h1><ul><li>进程：进程是应用程序要使用的资源集合<ul><li>每个进程都有一个虚拟地址空间，确保在一个进程中使用的代码和数据无法由另一个进程访问</li><li>以此确保应用程序实例的健壮性以及安全性</li></ul></li><li>线程：对 CPU 进行虚拟化<ul><li>每个进程都有自己专用线程</li><li>确保应用程序代码陷入死循环时仅 冻结 与代码关联的进程</li></ul></li><li>Windows 永远不会调度进程，而只是调度线程</li><li>线程开销<ul><li>线程内核对象</li><li>线程环境块（TEB）</li><li>用户模式栈<ul><li>存储传给方法的局部变量和实参</li><li>还包含一个地址：指出方法返回时，继续运行的地址</li><li>默认 1M 内存</li></ul></li><li>内核模式栈<ul><li>32 位 12KB</li><li>64 位 24KB</li></ul></li><li>DLL 线程连接和线程分离通知<ul><li>windows 下任何时候在进程中创建线程，都会调用进程中加载的所有非托管 DLL 的 DllMain 方法</li></ul></li></ul></li><li>上下文切换<ul><li>系统在所有线程（逻辑 CPU）之间共享物理 CPU</li><li>任何时刻只将一个线程分配给一个 CPU，该线程能运行一个 时间片 (量程) 的长度</li><li>时间片到期就会将上下文切换到另一个线程</li><li>切换操作<ul><li>将 cpu 寄存器值保存到当前正在运行的线程内核对象内部的一个上下文结构中</li><li>从现有线程集合选出一个线程调度，若该线程由另一个进程拥有，在执行任何代码前还必须切换 cpu 『看见』虚拟地址空间</li><li>将所选上下文结构中的值加载到 cpu 寄存器中</li></ul></li><li>Windows 大约每 30 毫秒执行一次上下文切换，上下文切换是净开销，主要是为了给用户提供一个健壮的、响应灵敏的操作系统</li><li>新线程还可能执行不在高速缓存中的代码，而导致重新缓存，下一次切换又会导致这种问题</li><li>注：一个时间片结束，若系统决定调度同一个线程，那么就不会发生上下文切换（尽量避免上下文切换）</li></ul></li><li>垃圾回收 GC 线程<ul><li>clr 暂停所有线程，遍历它们的栈以查找根以便对堆中对象进行标记</li><li>然后再次遍历它们的栈 (有的对象可能在压缩期间发生移动) 更新它们的根</li><li>因此减少线程数量可以提升垃圾器回收性能</li></ul></li><li>调试器也会挂起所有线程，并在单步执行后恢复所有线程，因此线程越多，调试体验越差</li><li>停止浪费<ul><li>如果只关心性能，那么任何机器最优线程数就是 cpu 数目</li><li>一个线程至少都是 1M 的内存开销，什么都不做的情况下也会白白占用</li></ul></li><li>使用线程的理由<ul><li>可响应性（gui）</li><li>性能（多 cpu）</li></ul></li><li>线程调度和优先级<ul><li>可使用 Microsoft Spy++ 查看每个线程被上下文切换到的次数</li><li>抢占式调度，使用算法判断在什么时候调度哪些线程多长时间</li><li>每个线程都分配了 0 (最低)~31 (最高) 的优先级</li><li>较高优先级线程总是抢占较低优先级线程（总是调度更高优先级线程）</li><li>较高优先级线程开启时，会立即挂起低优先级线程</li><li>0 页线程：系统启动创建，唯一一个，用于将 ram 空闲页清零</li><li>应用程序开发人员不直接处理这些优先级，而是通过优先级类进行</li><li>Idle、Below Normal、normal、above normal、high、realme（仅管理员和 power 权限）</li><li>高优先级线程在其生存周期的大多数时间都应处于等待状态，这样才不至于影响系统总体响应能力</li><li>clr 为自己保留了 idle 和 time-critical 优先级，clr 的终结器线程以 time-critical 优先级运行</li></ul></li><li>前台线程和后台线程<ul><li>应该进程停止时，clr 强制终止仍在运行的任何后台线程</li></ul></li><li>线程是比较宝贵的资源，最好使用线程池</li></ul><h1 id="第二十七章-计算限制的异步操作"><a class="anchor" href="#第二十七章-计算限制的异步操作">#</a> 第二十七章 计算限制的异步操作</h1><ul><li>线程池<ul><li>每 clr 一个线程池</li><li>由 clr 控制的所有 appdomain 共享</li><li>clr 初始化时池中没有线程，内部维护一个操作请求队列（记录项）</li><li>应用程序执行一个异步操作时，追加一个记录项到队列，线程池内部从该队列提取记录项</li><li>池中没有线程时，创建新线程，并在执行完毕后返回池内</li><li>如果应用程序发出许多请求，线程池会尝试用该线程重复处理，不过发出请求速度远超处理速度，则会导致生成新的线程</li><li>当池内线程空闲一段时间后，线程会醒来终止自己以释放资源</li></ul></li><li>执行上下文<ul><li>每个线程都关联了一个执行上下文数据结构</li><li>上下文流动会有一点性能消耗，可用 ExecutionContext.SupressFlow 类阻止</li></ul></li><li>协作取消和超时<ul><li>协作式：要取消的操作必须显式支持取消</li><li>CancellationTokenSource</li><li>要执行一个不允许被取消操作，也可以传递 CancellationToken.None 静态实例<ul><li>CanBeCancelled 返回 false</li><li>一般 CancellationTokenSource 获取的的 token 会返回 true</li></ul></li><li>向 CancellationTokenSource 登记回调方法，将由调用 register 的线程调用回调<ul><li>若 useSynchonizationContext 设置为 true，则可能通过调用线程的 SynchonizationContext 执行</li></ul></li><li>多个 CancellationTokenSource 可以链接起来</li><li>可支持延迟取消</li></ul></li><li>Task<ul><li>Task.Run 接受的取消令牌，只能处理在调度前的取消（没什么用），想取消运行中任务必须任务内显式取消</li><li>子线程异常，可以注册 TaskScheduler.UnobservedTaskException 以进行处理</li></ul></li><li>任务完成时自动启动新任务<ul><li>伸缩性良好的软件不应使线程阻塞，调用 wait、或在任务未完成时调用 result 属性</li><li>task.result 属性内部会调用 wait</li><li>使用 continuewith<ul><li>可以指定新任务只有在第一个任务被取消时才执行，等（TaskContiniationOptions）</li></ul></li></ul></li><li>任务启动子任务<ul><li>TaskCreationOptions.AttachToParent：将一个 task 与其创建者关联，除非子任务都完成，否则父线程不认为已结束</li><li>延续任务也可以使用：TaskContiniationOptions.AttachToParent 将延续任务指定成子任务</li></ul></li><li>任务内部揭秘<ul><li>一系列构成任务状态字段，如代表 task 的唯一 id（从 1 开始，以 1 递增，首次查询对象该属性时分配）</li><li>补充状态<ul><li>cancellationtoken</li><li>continuewithtask 集合</li><li>为抛出未处理异常的子任务准备的 task 对象集合</li></ul></li><li>若不需要任务的附加功能，threadpool.queueuserworkitem 资源利用率更好</li></ul></li><li>任务工厂<ul><li>可以用于创建一组共享相同配置的 task 对象</li><li>TaskFactory</li><li>TaskFactory<TResult></li><li>continuewhenall、continuewhenany 无论如何都会执行延续任务，不受 taskcontinuatuonoption 标志中会导致取消的枚举控制</li></ul></li><li>任务调度器<ul><li>taskschedule 负责执行调度任务</li><li>fcl 提供两个调度器类型<ul><li>线程池任务调度器<ul><li>taskschedule.default</li></ul></li><li>同步上下文任务调度器</li></ul></li><li>默认情况下，所有任务均使用线程池任务调度器</li><li>同步上下文调度器适合提供了 gui 的应用程序，用于将所有任务都调度给 gui 线程<ul><li>该调度器不使用线程池</li><li>可使用 taskschedule.fromcurrentsynchrolizationcontext 方法获得其引用</li><li>任务调度器将任务放到 gui 线程的队列中</li></ul></li></ul></li><li>Parallel<ul><li>for、foreach</li><li>for 更快</li><li>invoke</li><li>调用方法都有接受 ParallelOptions 参数的重载<ul><li>默认并发操作最大数目为 -1（可用 cpu 数）</li></ul></li><li>委托重载版本：<ul><li>localinit：处理一个工作项前调用<ul><li>经测试为线程池每个 Task 调用一次</li></ul></li><li>body：处理的每一项都调用一次<ul><li>经测试为循环中每个对象都会调用一次</li></ul></li><li>localFinally：处理好每个任务工作项后调用 (即使主体委托异常也会调用)<ul><li>经测试为线程池每个 Task 调用一次</li></ul></li></ul></li><li>parallel 所有方法都让调用线程一块参与处理</li><li>参数 parallelloopstate<ul><li>stop：告诉循环停止处理更多工作<ul><li>其它处于运行中的任务也 应该 停止，IsStopped 属性返回 true</li></ul></li><li>break：告诉循环不再处理当前项之后的项<ul><li>循环确保当前项之前项处理好后返回</li></ul></li><li>上述两个选项都会导致后续循环不再 执行</li><li>Break 和 Stop 都不能停止已经开始的项，只能防止新任务的开始</li><li>lowestbreackiteration：调用过 break 方法最低的项，若无则为 null</li></ul></li></ul></li><li>PLINQ<ul><li>AsParallel：并行执行</li><li>AsSequential：切换回顺序执行</li><li>ForAll</li><li>AsOrdered：保持数据项顺序，会降低性能</li><li>WithDegreeOfParallelism：允许指定最多允许多少个线程处理，默认每个内核一个线程查询</li></ul></li><li>timer 类 定时器<ul><li>使用 threadpool.queueuserworkitem，参数 period timeoutinfinity + 回调完成手动 change 方法避免（回调耗时太长而在未结束时就）重复调用</li><li>垃圾回收时会终止 timer，因此需要存在一个引用</li></ul></li><li>asnyc 异步方法中：使用 taskdelay+await，避免线程上下文切换（异步 delay 方法使其回归池中直接执行其它任务）</li><li>不建议设置线程池线程限制</li><li>线程调度<ul><li>threadpool.queueuserworkitem 和 timer 总是将自己放入全局队列，工作线程采用先进先出 (FIFO) 方式从队列取出（因此会有线程同步锁）</li><li>默认 taskscheduler 调度</li><li>每个 task 默认进入全局队列</li><li>每个工作线程有自己的本地队列，调度一个 task 时，该 task 被添加到调用线程本地队列</li><li>工作线程先检查本地队列，通过后入先出 (LIFO) 从本地队列取出任务（本地队列无需同步锁）</li><li>工作线程若发现本地队列空了，会尝试从另一个工作线程『偷取』一个 task（会有同步锁）</li><li>线程池默认工作者线程等于 cpu 数，然后监视任务完成速度，若完成事件过长 (事件未公布)，则会创建更多线程</li></ul></li></ul><h1 id="第二十八章-io-限制的异步操作"><a class="anchor" href="#第二十八章-io-限制的异步操作">#</a> 第二十八章 I/O 限制的异步操作</h1><ul><li>若线程不发生阻塞，在调用异步方法后，线程回到线程池较好的情况是根本不发生线程切换，并立即处理下一个任务</li><li>在线程池线程调用 thread.sleep (或等待线程同步锁) 可能会让线程池觉得 cpu 不饱和，而创建额外线程</li><li>而阻塞线程可能醒来，发生上下文切换（该项线程池有优化，不会立即让其处理任务，以减少上下文切换的可能）</li><li>线程越少，垃圾回收速度越快（挂起所有线程、扫描所有线程根，对线程池空闲线程来说处于它们栈顶，扫描根花费更少）</li><li>线程池判断线程数超过需要数量，会允许多余线程终止自身回收资源</li><li>异步操作：少量线程执行大量操作</li><li>异步函数<ul><li>一旦将方法标记为 async，编译器就会将方法转换为一个实现了状态机的一个类型</li><li>因此运行线程执行状态机中一些代码并返回，而不必一次性执行结束</li><li>await 操作符实际会在 Task 对象上调用 continuewith 传递用于恢复状态机的方法，然后线程返回（所以说异步方法本身不开启新线程，await 操作符等待的是另外开启了新线程的 task）</li><li>将来该 task 执行完毕后，线程池某个线程激活 continueeith 回调方法，造成一个线程恢复状态机</li><li>若 await 等待有返回值，编译器会生成代码查询 task 对象 result 属性并将结果赋值给接收返回值的变量</li><li>注 1：方法标记为 async 后，编译器会生成相关代码，在状态机开始前创建对应的一个 task 对象，并在状态机执行完毕时自动完成<ul><li>有返回值的 task 对象，执行完毕后将 result 属性设置为方法返回值</li></ul></li><li>注 2：await 之前代码由一个线程执行，之后代码可能由另一个线程执行</li></ul></li><li>异步函数转换为状态机<ul><li>实参和局部变量被编译为状态机的字段</li><li>任何时候使用 await 操作符都会获取操作数，并尝试在它上面调用 getwaiter 方法 (可能是实例或扩展方法)</li><li>调用 getwaiter 返回称为 awaiter (等待者) 对象，它将被等待对象与状态机沾合起来</li><li>状态机获得 awaiter 后，查询其 iscompleted 属性<ul><li>若操作已以同步方式完成属性将返回 true，作为优化状态机将继续执行并调用 awaiter 的 getresult 方法</li></ul></li><li>若操作以异步方式完成，则返回 false，状态机 awaiter 的 oncompleted 方法并传递委托 (引用状态机的 movenext 方法)</li><li>将来 awaiter 在任务完成时调用委托以执行 movenext，状态机根据相关字段到达代码正确位置 (上次离开位置)</li><li>回到离开位置后，调用 awaiter 的 getresult 方法获取结果并继续执行</li></ul></li><li>异步函数扩展性<ul><li>编译器可以在 await 任何操作数上调用 getawaiter（所以操作数不一定是 task 对象，可以是提供了 getawaiter 的任意类型）</li></ul></li><li>异步函数在返回 void 时，编译器会生成状态机，但是不再创建 task 对象</li><li>beginxxx、endxxx 方法已过时，可通过 task.factory.fromasync 将其转变为基于 task 的模型</li><li>异步函数的异常<ul><li>若状态机出现未处理异常，代表异步函数的 task 对象会因未处理异常而完成，等待该 task 的代码会看见异常</li><li>返回 void 的异步函数由于没有 task，出现的异常由编译器生成的代码捕获，并于调用者同步上下文重新抛出（若调用者为 gui 线程则会造成进程终止）</li></ul></li><li>若异步操作执行很快，await 操作符生成的代码会做检测，如果异步操作在线程返回前完成，则阻止线程返回，直接执行下一行代码</li><li>task.run 可以接受标记为 async 的异步 lambda 表达式</li><li>应用程序及线程处理模型<ul><li>gui 应用程序引入的线程处理模型中 ui 元素只能由创建它的线程更新<ul><li>当异步操作完成时，由一个线程池线程完成 task 对象并恢复状态机</li><li>对于某些应用程序模型没问题，但对另一些如 gui 应用程序就会有问题</li><li>因此线程池必须以某种方式告诉 gui 线程更新 ui 元素</li></ul></li><li>synchronizationcontext 派生对象将应用程序模型连接到它的线程处理模型<ul><li>等待一个 task 时会获取调用线程的 synchronizationcontext 对象</li><li>线程池线程完成 task 后，会使用该 synchronizationcontext 对象，确保为应用程序模型使用正确的线程处理模型</li><li>所以当 gui 线程等待一个 task 时，await 操作符后面的代码保证在 gui 线程上执行，使代码能更新 ui 元素</li></ul></li></ul></li></ul><h1 id="第二十九章-基元线程同步构造"><a class="anchor" href="#第二十九章-基元线程同步构造">#</a> 第二十九章 基元线程同步构造</h1><ul><li>一个线程池线程阻塞时，线程池会创建额外线程，创建、销毁和调度线程所需时间比较昂贵 —— 不要阻塞拥有的线程，使它们能重用于执行其它任务<ul><li>假定一个线程池线程试图获取一个它暂时无法获取的锁（导致阻塞），线程池就可能创建一个新的线程</li><li>当阻塞线程再次运行时，会与创建的新线程一块运行，导致 cpu 需要调度比核心数更多的线程，增加上下文切换的几率</li></ul></li><li>多个线程同时访问共享数据时，线程同步能防止数据损坏</li><li>多线程测试应该在 cpu 核心尽量多的机器上测试，因为 cpu 核心数量越多，多个线程同时访问资源的概率越大</li><li>应尽可能避免线程同步<ul><li>只读访问是没问题的</li></ul></li><li>基元用户模式和内核模式构造<ul><li>应尽量使用基元用户模式构造：它们使用特殊 cpu 指令协调线程（意味着协调是在硬件发生，所以更快）<ul><li>但是用户模式构造在等待构造过程中，线程会一直浪费 cpu 时间</li></ul></li><li>基元内核模式构造<ul><li>由操作系统系统自身提供</li><li>要求在应用程序的线程中调用由操作系统内核实现的函数</li><li>将线程从用户模式切换为内核模式（或相反）会导致巨大的性能损失（因此要避免使用）</li><li>优点：线程通过内核模式构造获取其它线程拥有资源时，Windows 会阻塞线程以避免它浪费 cpu 时间</li></ul></li><li>对于一个构造上等待的线程，若拥有构造线程不释放<ul><li>用户模式构造：线程将一直在一个 cpu 上运行，形成 活锁</li><li>内核模式构造：线程将一直阻塞，形成 死锁</li><li>于是有了 混合构造</li></ul></li></ul></li><li>用户模式构造<ul><li>易变构造（volatile construct）<ul><li>在特定时间，它在包含一个简单数据类型的变量上执行原子性的读 『或』 写操作</li></ul></li><li>互锁构造（interlocked construct）<ul><li>在特定时间，它在包含一个简单数据类型的变量上执行原子性的读 『和』 写操作</li></ul></li><li>所有易变和互锁构造都要求传递对包含简单数据类型的一个变量的引用（内存地址）</li><li>易变构造详情<ul><li>Volatile.Write：方法强迫变量的值在调用时写入。此外，按照编码顺序，之前的加载和存储操作必须在调用 volatile 方法『之前』发生（调用之前其它变量的写入修改必须先完成，但不保证其它变量的写入执行顺序）</li><li>Volatile.Read：方法强迫变量的值在调用时读取。此外，按照编码顺序，之后的加载和存储操作必须在调用 volatile 『之后』发生（调用方法之后的其它变量的读取都必须在这方法之后执行，但不保证后续其它变量的读取执行顺序）</li><li>注 1：简单来说，当线程通过共享内存相互通信时，调用 volatile.write 来写入最后一个值，调用 volatile.read 来读取第一个值</li><li>注 2：每个方法执行的都是一个 原子读取 或 原子写入</li><li>为简化操作，c# 编译器提供了 volatile 关键字：jit 编译器确保对易变字段的所有访问都是以易变读取或写入方式执行，该关键字还告诉 c# 和 jit 编译器不将字段缓存到 cpu 的寄存器中，确保所有读写操作都在 ram 中进行</li><li>volatile 关键字可能会比 volatile 方法更慢（因为线程可能并不要求在所有地方访问都是易变的），不支持以传引用方式传递 volatile 变量</li></ul></li><li>互锁构造详情<ul><li>每个方法都执行一次 原子读取 及 写入操作</li><li>每个 interlocked 方法都建立了完整的内存栅栏（memory fence）<ul><li>即调用某个 interlocked 方法之前的任何变量写入都在这个方法之前执行，而这个调用之后的任何变量读取都在这个调用之后读取</li></ul></li></ul></li><li>简单的自旋锁：通过在 while 循环中通过 interlocked 修改值一直判断直到成功</li><li>interlocked anything 模式：在 interlocked 基础操作上，例如 interlocked.CompareExchange 执行更丰富的操作</li><li>结构体的 spanwait、spanlock 不要标记为 readonly，因为内部会有状态修改</li><li>spanwait<ul><li>内部调用 thread 的 sleep、yield、spanwait 方法</li><li>sleep 休眠时间并不一定精确</li><li>sleep (0)：告诉系统表示放弃线程当前时间片的剩余部分，强迫系统调度另一个线程</li><li>yield：要求 Windows 在当前 cpu 上调度另一个线程（若没有则返回 false，调用 yield 的线程继续运行）</li><li>调用 yield 介于 sleep (0) 和 sleep (1) 之间：sleep (0) 不允许较低优先级线程运行、sleep (1) 则总是强迫进行上下文切换（由于内部系统计时器解析度原因，sleep 至少 1ms）</li><li>thread.spanwait：强迫当前线程暂停，使 cpu 有机会切换到另一个线程运行（实际执行一个特殊 cpu 指令，非超线程 cpu 会被忽略？）</li></ul></li></ul></li><li>乐观并发模式<ul><li>假设多线程操作互不干涉</li><li>在提交数据更新前，检查数据是否被修改</li><li>若被修改，则回滚重新执行</li><li>适用于数据争用不大，冲突较少环境，偶尔回滚事物成本低于读取数据时锁定数据的成本</li><li>do～while 循环中执行操作，并使用 interlocked.compareexchsnge 判断是否修改成功，修改失败则重新执行代码块</li></ul></li><li>内核模式构造<ul><li>为什么慢：要求操作系统配合、在内核对象上调用的每个方法都造成调用线程从托管代码转换为本机用户模式代码，再转换为本机内核模式代码，然后，还要朝相反方向一路返回（这些转换耗费更多 cpu 时间）</li><li>优点：发生竞争时，没有竞争赢的线程会阻塞，能更有效节省资源</li><li>WaitHandle<ul><li>EventWaitHandle（事件）<ul><li>AutoResetEvent</li><li>ManualResetEvent</li></ul></li><li>Semaphore（信号量）</li><li>Mutex（基于事件和信号量）</li></ul></li><li>在一个内核模式构造上调用的每个方法都代表一个完整的内存栅栏</li><li>所有这些类的构造器都在内部调用 win32 的 createevent、createsemaphore 或 openmutex 并传递一个 string 实参</li><li>内核模式构造的一个常见用途是创建在任何时刻只允许它的一个实例运行的应用程序</li><li>事件（event）<ul><li>其实只是由内核维护的 boolean 变量，事件为 false ，在事件上等待的线程就阻塞；事件为 true ，就解除阻塞</li><li>自动重置事件 (AutoResetEvent)：为 true 时只唤醒一个阻塞的线程 (因为在解除第一个阻塞线程时，内核将事件自动重置回 false，造成其余线程继续阻塞)</li><li>手动重置事件 (ManualResetEvent)：解除正在等待它的所有线程的阻塞，因为内核不会将事件自动重置回 false</li></ul></li><li>信号量 (semaphore)<ul><li>其实就是由内核维护的 int32 变量</li><li>信号量为 0 时，等待的线程会阻塞</li><li>信号量大于 0 时，解除阻塞</li><li>在信号量上等待的线程解除阻塞时，内核自动从信号量计数减 1</li><li>同时信号量还关联一个最大计数</li><li>自动重置事件在行为上和最大计数为 1 的信号量相似，区别在于：自动重置事件连续多次调用 set 无妨，信号量上连续多次调用 release 会使内部计数一直递增（超过最大计数会抛出异常）</li></ul></li><li>互斥体 (mutex)<ul><li>与 autoresetevent 及 计数为 1 的 semaphore 类似</li><li>三者都是一次只释放一个正在等待的线程</li><li>互斥体有一些额外逻辑，造成比其它构造更复杂<ul><li>查询并记录调用线程 id，确保调用 releasemutex 的是获取 mutex 的线程（如果不是就会抛出异常）</li><li>拥有 mutex 的线程因为任何原因终止，在 mutex 上等待的线程会被唤醒并抛出异常</li><li>mutex 还维护一个递归计数，指出拥有该 mutex 线程拥有了它多少次：拥有线程再次在 mutex 上等待会递增计数，releasemutex 递减计数，只有计数变成 0，另一个线程才能成为 mutex 的拥有者 zc</li><li>即 mutex 对象支持递归</li><li>因此 mutex 会更慢</li></ul></li></ul></li></ul></li><li>套间（apartment）<ul><li>定义了一组对象的逻辑组合，这些对象共享同一组并发性和重入限制</li><li>应该线程想要使用 com，必须先进入一个套间</li><li>com 规定，只有运行在对象套间中的线程才能访问该对象</li><li>STA（单线程套间）、MTA（多线程套间）</li></ul></li></ul><h1 id="第三十章-混合线程同步构造"><a class="anchor" href="#第三十章-混合线程同步构造">#</a> 第三十章 混合线程同步构造</h1><ul><li>为了提升应用程序总体性能，可以让一个现在在用户模式 自旋 一小段时间，再让线程转换为内核模式</li><li>在 clr 中，对任何锁方法的调用都构成了一个完整的内存栅栏<ul><li>在栅栏之前写入的任何变量都必须在栅栏之前完成</li><li>在栅栏之后的任何变量读取都必须在栅栏之后开始</li></ul></li><li>monitor 与同步块<ul><li>monitor 提供了支持自旋、线程所有权、和递归的互斥锁</li><li>堆中每个对象都可以关联一个名为 同步块 的数据结构</li><li>同步块包含字段，为内核对象、拥有线程的 id、递归计数及等待线程计数提供相应字段</li><li>monitor 接受任何堆对象引用，其方法对指定对象的同步块中字段进行操作</li><li>为堆中每个对象都关联一个同步块数据结构很浪费，为节省内存 clr 团队采用一种更经济的方式提供上述功能<ul><li>clr 在初始化时在堆中分配一个同步块数组</li><li>每当一个对象在堆中创建时，都有两个额外字段与其关联：类型指针 (包含类型的类型对象的内存地址)、同步块索引 (包含同步块数组中的一个整数索引)</li><li>一个对象在构造时，其同步块索引初始化为 -1，表明不引用任何同步块</li><li>调用 monitor.enter 时，clr 在数组种找到一个空白同步块，并设置对象的同步块索引，使其引用同步块</li><li>调用 monitor.exit 时，会检查是否有其它任何线程正在等待使用对象的同步块</li><li>若没有线程在等待它，同步块就自由了，exit 将对象同步块索引设回 -1</li><li>自由同步块将来可以被另一个对象关联复用</li><li>注：因此每个对象的同步块索引都隐式为公共的，因此推荐使用私有锁</li></ul></li><li>问题<ul><li>变量能引用一个代理对象 (派生自 marshalbyrefobject)，但锁定的是代理对象而不是代理引用的实际对象</li><li>传递类型对象引用，类型对象以 appdomain 中立方式加载的话，线程就会跨越进程中所有 appdomain 在那个类型上获取锁，破坏了 appdomain 提供的隔离能力</li><li>字符串可以留用，跨越 appdomain 传递字符串时传递的是引用，字符串关联的同步块索引可变（所以不要用字符串做锁）</li><li>传递值类型会导致装箱，每次都相当于是不同对象</li><li>MethodImpl (MethodImplOptions.Synchronized) 特性会导致方法被 monitor 包围，若为实例方法，实例类型会被传递、若为静态方法，类型的类型对象会被传递，造成锁定 appdomain 中立类型（不要使用该特性）</li><li>调用类型构造器（静态构造器）时 clr 为了确保只有一个线程初始化类型对象及其静态字段，也会加锁，也可能会有问题 —— 因此尽量避免使用类型构造器，或使其尽量简短</li></ul></li><li>不建议使用 lock 语句<ul><li>其中使用 try catch 捕获异常，可能会导致线程访问损坏数据</li><li>这也会导致性能降低</li></ul></li><li>lockTaken 变量：假设一个线程进入 try 块，且在调用 monitor.enter 前退出，就不应该调用 finally 种的 exit 释放锁，该变量初始化为 false ，enter 将其设为 true，以解决这个问题（spinlock 也支持这个模式）</li></ul></li><li>ReaderWriterLockSlim<ul><li>一个线程向数据写入时，阻塞请求访问的其它所有线程</li><li>一个线程从数据读取时，其它请求读取线程运行进入，请求写入线程被阻塞</li><li>请求写入线程执行完毕后，要么解除一个写入线程阻塞，要么解除所有读取线程阻塞</li><li>请求读取的所有线程结束后，解除一个请求写入线程阻塞</li><li>该类支持线程所有权和递归功能，不过这个功能代价较高且很少需要，可以在构造函数传入 lockrecursionpolicy.norecursion<ul><li>注：为了以线程安全维护这些信息，内部甚至要使用一个 互斥的自旋锁</li></ul></li><li>提供方法将 reader 线程升级为 writer 线程（降低性能，一般也没什么用）</li><li>自己实现一个读写锁会更快：要么允许一个 writer 线程访问，要么允许多个 reader 线程访问</li></ul></li><li>Countdownevent<ul><li>使用一个 manualeventresetdlim</li><li>阻塞一个线程，直到内部计数器变成 0（行为与 semaphore 相反）</li><li>一旦其 currentcount 变成 0 后，就不能再更改了（再更改会抛出异常，tryaddcount 会返回 false）</li></ul></li><li>Barrier<ul><li>这个类型用于处理比较稀有问题，一般用不上</li><li>控制的一系列线程需要并行工作，以在一个算法不同阶段推进</li><li>当 clr 使用垃圾回收器服务器版本时，gc 算法为每个内核都创建一个线程</li></ul></li><li>线程同步构造小结<ul><li>代码尽量不阻塞任何线程</li><li>避免多个线程同时操作数据</li><li>尽量使用 volatile 和 interlocked 方法（或 视情况使用 interlocked anything 模式）</li><li>不要刻意把线程 打上标签：即不要创建用于特定任务的线程，而应该从线程池出租短暂时间</li><li>要在一些列操作中原子性地操作状态，可以使用 monitor，也可使用 readerwriter 锁代替 monitor，不过需要清楚场景。另外还有 spinlock 比 monitor 快，不过更可能浪费 cpu 时间</li></ul></li><li>双检锁技术（double-check locking）<ul><li>经常用于 将单例推迟到首次请求该对象时进行</li><li>单例延迟初始化前提是：可能根本不需要创建单例，否则在类构造器中创建单实例对象更经济和简单</li><li>在锁操作中，创建的变量对象可能被更换顺序<ul><li>想法是：生成对象 (分配内存)- 调用构造器初始化 - 赋值</li><li>实际有可能：生成对象 (分配内存)- 赋值 - 调用构造器</li><li>正常情况没事，但要是在给变量赋值后，调用构造器之前另一个线程访问了就有问题了</li><li>为解决这种极端问题，可以使用 volatile 方法为变量赋值（将变量直接标记为 volatile 也可以，但是会使所有读取操作具有易变性，导致性能无谓损害）</li></ul></li></ul></li><li>可能根本不需要创建单例可以使用双检锁，否则可以使用 贪婪模式，利用 clr 保证对调用类构造器的线程安全性特点：首次访问类的任何成员都会调用类构造器<ul><li>缺点：若类定义了其它任何静态成员，就会在访问其它任何静态成员时创建 单例 对象</li></ul></li><li>懒加载模式<ul><li>Lazy 泛型：也可以传递线程安全枚举支持<ul><li>executionandpublication 使用双检锁技术</li><li>publicationonly 使用 interlocked.compareexchange 技术</li></ul></li><li>LazyInotializer 静态方法</li></ul></li><li>条件变量模式<ul><li>自旋：让线程连续 自旋，反复测试条件</li><li>但是自旋会浪费 cpu 时间，而且不能对构成复合条件的多个变量进行原子性的测试</li><li>monitor 支持根据一个复合条件来同步操作，而且不会浪费 cpu 资源：wait、pulse (解除等待最久线程)、pulseall</li></ul></li><li>异步的同步构造<ul><li>避免阻塞线程，否则 cpu 会创建更多线程处理任务，使用异步函数等待互斥资源</li><li>semaphoreslim<ul><li>waitasync</li><li>一般创建最大计算为 1 可实现保护资源的互斥访问</li><li>与 monitor 类似，只是不支持线程所有权和递归（正好）</li></ul></li><li>reader-writer 语义：concurrentexclusiveschedulerpair</li></ul></li><li>并发集合类<ul><li>尽量不要调用阻塞接口</li><li>concurrentstack、concurrentqueue<ul><li>内部使用 interlocked 方法操纵集合</li></ul></li><li>concurrentbag<ul><li>每个线程一个迷你集合，使用 interlocked 添加数据至迷你集合</li><li>试图取出数据时，先检查调用线程的迷你集合，若没有，再使用 monitor 检查其它线程的迷你集合（『窃取』数据项）</li></ul></li><li>concurrentdictionary<ul><li>内部使用 monitor，不过对数据项进行操作时，锁只被占用极短时间</li></ul></li><li>concurrentstack、concurrentqueue 和 concurrentbag 都实现了 iproducerconsumercollection 接口，可通过 blockingcollection 转变为一个阻塞集合（生产者 - 消费者 模式）<ul><li>尽量不要使用，它们生命意义就在于阻塞线程</li><li>内部使用 semaphoreslim 进行控制</li><li>completeadding 方法通知消费者不再生产，造成 getconsumingenumerable 的一个 foreach 循环终止</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;《CLR VIR C#》 这本书太厚，笔记也记得太多，因此还是分成两篇上传&lt;/p&gt;
&lt;p&gt;这是第二篇，主要记录多线程相关章节笔记&lt;/p&gt;
&lt;h1 id=&quot;第二十六章</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C#" scheme="https://wangjiaying.top/tags/C/"/>
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《CLR VIR C#》笔记(上)</title>
    <link href="https://wangjiaying.top/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8A/"/>
    <id>https://wangjiaying.top/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8A/</id>
    <published>2023-04-06T05:27:19.000Z</published>
    <updated>2023-06-04T11:42:34.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本来计划的是 3 月份就看完，结果 4 月 2 号了还剩两章，虽然这跟到后面看得更仔细有关，但是公司上个月突然要求加起班来也有关系，导致每周上班时间只有两天可以提前回家看书。</p><p>不过，在昨天 清明节 总算把这本书看完了！</p><p>看了下语雀的笔记创建记录：</p><p><img data-src="/blogimages/2023/2023-04-06/Snipaste_2023-04-06_13-30-02.jpg" alt="" /></p><p>已经记不起什么时候开始看的，笔记是 2 月 27 日创建的，以这个时间点开始也一个月出头了，基本上回家就是看这本书</p><p>刚拿到手感觉是真厚，最开始做笔记只按照分类记录了重点：后面觉得这样不大行，越记就越庞大</p><p>而且书的章节本身其实可以看做就是有根据功能分门别类的，于是从第九章开始，以章节划分开始记录</p><ul><li><p>因为是用手机记录的，所以有的英文字母用的小写</p></li><li><p>《CLR VIR C#》 太厚了，由于记录太多，分成了成两篇上传</p></li></ul><p>总的来说，值得一看，获益良多。</p><h1 id="基本名称"><a class="anchor" href="#基本名称">#</a> 基本名称</h1><ul><li>FCL：framework class library</li><li>CTS：common type system</li><li>CLI：cts 和其它组件提交给 ECMA 形成（公共语言基础结构）</li><li>CLS：公共语言规范，common language specification，语言互操作的标准规范，为支持不同语言互操作，详细定义了一个最小功能集，是 clr/cts 的子集。规定类型成员要么是字段（数据），要么是方法（行为）<ul><li>CLSCompliantAttribute 可以标记类中公共成员必须符合 cls 规范（但是反射可以强行访问非公共、不合 cls 的自字段）</li></ul></li><li>CIL：Common Intermediate Language 通用中间语言，是介于源代码和本机机器指令中间的代码</li><li>蓝色体 代表关键字，浅蓝色体 代表类型，比如大写 string 表示基元类型</li><li>值类型 equals 最好重写，内置反射调用</li><li>友元程序集</li><li>dynamic 基元类型<ul><li>实际上就是 Object</li><li>字段、参数或返回类型若使用 dynamic，编译器会附加 dynamicattribute 特性（局部变量使用不会附加特性，因为限制在方法内部使用）</li><li>所有表达式都能隐式转为 dynamic：因为所有表达式最终都生成从 Object 派生的类型</li><li>虽然 Object 不允许隐式转换为其它类型，但是 dynamic 可以，不过运行时会额外验证转型保证类型安全性</li></ul></li><li>分部类（partial）</li><li>分部方法<ul><li>若没有对分部方法 实现，调用分部方法的代码会直接被编译器优化掉，也不会生成分部方法的元数据：包括调用方法传递参数造成的计算也会被优化掉，可以提高性能</li><li>只能在分部类或结构中声明</li><li>分部方法只能返回 void，参数不能用 out 标记：因为方法在运行时可能不存在</li><li>如果附加了特性，编译器会合并两个方法的特性（参数特性也一样）</li><li>分部方法被视为 private（不过编译器简直添加访问修饰符？）</li></ul></li><li>csp（component software programming） 是 oop 发展极致结果</li><li>system.appdomain</li><li>显式接口方法实现 (EIMI)：将定义方法的接口名称作为方法名前缀（explicit interface method implementation）</li><li>基类还是接口？<ul><li>『属于』 和 『能做』 的关系</li></ul></li></ul><h1 id="其它"><a class="anchor" href="#其它">#</a> 其它</h1><ul><li>clr 基于栈</li><li>操作符重载：public static （type） operator（操作符）</li><li>转换操作符重载：一种类型转换为另一种类型</li><li>要求参数类型和返回类型二者其一必有定义转换方法类型相同</li><li>隐式：public static implicit operator （return type）（in type）</li><li>显式：public static explicit operator （return type）（in type）</li><li>c# 编译器检测到代码正在使用的某个类型对象实际期望的是另一种类型对象，则查找能隐式转换操作符方法，若找到则生成调用方法代码（显式也一样）</li><li>使用强制类型转换表达式时，c# 生成代码调用显式操作符重载方法，使用 c# as is 时则不会调用</li><li>扩展方法：<ul><li>实际上是对一个静态方法的调用（所以不会对调用实例做 null 检查，扩展方法可能接受 null 实例）</li><li>可以为接口定义扩展方法</li><li>可以为委托类型定义扩展方法</li><li>可以为枚举添加扩展方法</li><li>扩展方法是静态方法，若作为委托，编译器是耍了小花招的，生成特殊代码来处理引用的静态方法传递第一个 this (调用实例) 参数</li><li>编译器会先搜索类型自身或基类是否存在对应参数实例方法，没有找到就会搜索所有静态文件找到对应扩展方法，并生成 il 代码调用静态方法</li><li>在 c# 中，一旦用 this 关键字标记了某个静态方法的第一个参数，编译器就会在内部向该方法应用 extensionattribute 特性，并持久化存储在元数据中，任何静态类只要包含了至少一个扩展方法，其元数据也会应用该特性，同理任何程序集只要包含了一个符合上述特点的静态类，元数据也会应用该特性 —— 以加快编译器搜索速度：可以只扫描指定程序集 - 指定静态类 - 指定扩展方法</li><li>扩展一个类型时，其派生类也会被扩展</li><li>扩展方法不能引用它们正在扩展的类的私有成员或受保护成员，因此不能完全替代更传统的类继承</li></ul></li><li>decimal 是个类</li><li>内联代码？</li><li>委托实际只是提供了 4 个方法的一个类定义<ul><li>构造器、invoke 方法、begininvoke 方法、endinvoke 方法</li></ul></li><li>协变指定返回类型的兼容性</li><li>逆变指定参数的兼容性</li><li>convert.changetype</li></ul><h1 id="il"><a class="anchor" href="#il">#</a> IL</h1><ul><li>call：可调用静态方法，实例方法和虚方法<ul><li>调用实例方法和虚方法必须指定引用了对象的变量，该指令假定该变量不为 null</li></ul></li><li>callvirt：可调用实例方法和虚方法，不能调用静态方法（需要对变量做 null 检查，因此比 call 慢）<ul><li>并且调用虚实例方法时，还需要检查发出调用对象的实际类型，然后以多态方式调用</li></ul></li><li>编译器会在程序集方法定义表中用标志 (flag) 指明方法是实例方法、虚方法、静态方法<ul><li>调用这些方法时，编译器会判断对应方法定义的标志 (flag) 生成对应调用指令</li></ul></li><li>c# 用 callvirt 指令调用所有实例方法</li><li>编译器调用值类型定义的方法时，倾向于使用 call 指令<ul><li>因为值类型实例的本质保证永不为 null</li><li>并且要是以虚方式调用值类型中虚方法，会导致值类型装箱</li></ul></li><li>无论 call 还是 callvirt 都接受隐藏的 this 实参作为方法第一个参数（操作的对象）</li><li>设计类型应该尽量减少虚方法数量：<ul><li>~ 调用虚方法比非虚方法更慢：clr 必须在运行时查找对象类型，以判断要调用的方法由哪个类型定义（密封类可由 jit 优化调用，因为不需要判断是否还有派生类重载）</li><li>密封类型的虚方法调用，会被优化，性能更好</li><li>一旦将某个方法、属性或事件设置为 virtual，基类就会丧失对其行为和状态的部分控制权</li><li>~jit 不能内嵌（inline）虚方法</li><li>new virtual 可以重写虚方法</li></ul></li><li>内联函数：<ul><li>MethodImpl(MethodImplOptions.AggressiveInlining)</li></ul></li></ul><h1 id="类"><a class="anchor" href="#类">#</a> 类</h1><ul><li><p>字段定义时<strong>直接赋值</strong>，称为 内联初始化</p></li><li><p>内联初始化：指在代码中直接赋值来初始化，而不是将对构造器的调用写出来</p></li><li><p>实际上 c# 是在构造器中初始化的，这只是提供的一种简化语法</p></li><li><p>使用内联语法而非构造器中赋值，会有一些性能问题需要考虑</p></li><li><p>有多个构造器时，每个构造器都会被插入内联变量初始化代码，然后调用基类构造方法，最后插入构造方法自身的代码（因此存在 代码膨胀效应）—— 若是在构造函数中自己初始化，可以复用同样的初始化构造函数，以减少这种情况</p></li><li><p>对引用类型标记 readonly，只是单纯这个地址引用不可变，其内部数据依然可变</p></li><li><p>反序列化使用 getuninitializedobject 为对象分配内存，避免调用构造器（另外，memberclone 也不会导致调用）</p></li><li><p>避免在构造函数中调用虚方法：因为父类构造函数初始化更早，子类若重写了虚方法的行为不可预测</p></li><li><p>声明为密封类可提高性能，JIT 就不再需要考虑其他的可能性而放开手脚进行优化：</p><ul><li>密封类型的虚方法调用，会被优化，性能更好</li><li>数组是支持协变的：JIT 在将一个项目分配到数组之前必须检查对象的类型。当使用密封类型时，JIT 可以取消检查</li><li>数组转换成 Span：与数组同理</li><li>当对象类型转换时：当转换到一个非密封的类型时，运行时必须检查层次结构中的所有类型</li></ul></li><li><p>编译器自动生成的代码都是 sealed 密封类</p></li></ul><h1 id="值类型"><a class="anchor" href="#值类型">#</a> 值类型</h1><ul><li>值类型没有默认无参构造函数（所以也不支持内联初始化语法）</li><li>并且不允许定义无参构造函数（但是 clr 允许）</li><li>值类型的构造函数只有显式调用才会执行</li><li>结构体构造函数中，可以允许直接：this=new xxx () 初始化所有字段，然后再覆盖</li></ul><h1 id="静态构造方法类型构造器"><a class="anchor" href="#静态构造方法类型构造器">#</a> 静态构造方法（类型构造器）</h1><ul><li>只能定义一个无参的静态构造方法，由 clr 在类型第一次被访问时调用</li><li>只能访问静态字段（用来初始化它们）</li><li>结构体（值类型）静态字段也可以使用内联初始化语法</li><li>类型构造器调用比较麻烦：jit 在编译一个方法时，会查看代码中引用了哪些类型，任何一个类型定义了静态构造器，编译器会检查当前 appdomain 是否已经执行过，若没有执行，则添加执行代码调用<ul><li>初始化调用时，clr 会使用互斥线程同步锁保证同一个 appdomain 只会初始化一次</li><li>所以是线程安全的，因此单例可以这样整？饿汉模式？</li></ul></li><li>！值类型的构造方法可能不会被调用</li></ul><h1 id="工具"><a class="anchor" href="#工具">#</a> 工具</h1><ul><li>*.rsp：响应文件，包含了一组编译器命令行开关的文本文件，使用 csc.exe @my.rsp 代码.cs</li></ul><p>全局 csc.rsp</p><ul><li>AL.exe：程序集链接器</li><li>assemblyversion：非常重要，存储于 assemblydef 清单元数据表，唯一性标识程序集</li></ul><h1 id="第九章-参数"><a class="anchor" href="#第九章-参数">#</a> 第九章 参数</h1><p>可选参数和命名参数</p><ul><li>一旦为参数分配了默认值，编译器会对参数应用 optionalattribute 特性及 defaultparametervalueattribute 特性。<strong>并</strong>生成对应元数据</li><li>后续编译器发现某个方法调用缺失部分实参，就可以确定是否是可选实参，并从元数据提取默认值自动嵌入调用中</li></ul><p>隐式类型局部变量</p><ul><li>var：只能声明局部变量，由编译器推断</li></ul><p>传引用方式向方法传递参数</p><ul><li>out</li><li>ref</li><li>两者生成 il 代码一样，只有元数据有一个 bit 差异：用于记录是 out 还是 ref</li><li>从 il 和 clr 来看：都是导致传递指向实例的一个指针（主要差别在于编译器的验证准则）</li><li>大的值类型可避免复制开销</li></ul><p>可变参数：</p><ul><li>params：必须位于参数最后一位</li><li>编译器会应用 paramarrayattribute 特性</li><li>调用时，若没有找到对应的普通方法，则生成代码构造一个数组来调用它</li><li>会有额外性能开销，例如造成数组分配：数组必须在堆上分配、数组元素必须初始化、数组内存最终会被垃圾回收（传递 null 不会分配）</li></ul><p>参数和返回类型设计规范</p><ul><li>参数尽量指定最弱类型：例如接口比基类更好</li><li>返回类型：最好声明为最强类型 (防止受限特定类型)</li></ul><h1 id="第十章-属性"><a class="anchor" href="#第十章-属性">#</a> 第十章 属性</h1><p>属性看起来和字段类似，但本质是方法<br />取决于属性定义，编译器在程序集生成以下两项或三项：</p><ul><li>代表 get 访问器的方法</li><li>代表 set 访问器的方法<ul><li>set 编译出来的方法会有定义类型的 value 默认参数</li></ul></li><li>程序集元数据会有属性定义 (必然生成)<ul><li>包含一些标志 (flag) 及属性类型等信息</li><li>用于在 属性 这个抽象概念与其访问器方法之间建立一个联系</li><li>clr 不使用这种元数据信息，主要是给编译器或其它工具通过 <strong>PropertyInfo</strong> 来获得信息</li></ul></li></ul><p>自动属性（Automatically Implemented Property）简称 AIP</p><ul><li>其私有字段名由编译器自动生成，因此序列化数据可能出问题</li></ul><p>与字段对比：</p><ul><li>属性不能作为 out 或 ref 传引用</li><li>属性方法可能抛出异常，字段访问永远不会</li><li>属性方法可能花较长时间运行，字段访问总是立即完成</li><li>连续多次调用，属性方法每次可能返回不同值</li><li>属性方法可能需要额外内存，或返回对象并非指向对象状态一部分，造成对返回对象的修改作用不到原始对象上（使用会返回一个拷贝的属性很容易引起混淆）</li></ul><p>如果属性实现了 IEnumerable，属性就被认为是集合</p><p>可以这样初始化：</p>Prop={"1","2","3"}dic={{"1",1},{"2",22},{"3",33}}<hr /><p>匿名类型</p><ul><li>与匿名函数一样，会生成一个新的类</li><li>编译器定义匿名类型时，若发现源代码中定义了多个具有相同结构的匿名类型，会只生成一份类型定义，虽然还是会创建多个实例<ul><li>相同结构：相同名称和类型，指定顺序相同</li></ul></li></ul><p>Tuple</p><ul><li>Tuple.Create 简化代码，自动推断类型</li></ul><p>System.dynamic.ExpandObject<br /> 有参属性</p><ul><li>C# 称为 索引器</li><li>可以将 索引器 看作对 [] 符号的重载</li><li>一个类型可定义多个索引器</li><li>默认索引器名称为 set_Item，使用 IndexerName 特性 可以让编译器为索引器 (属性) 自动生成的名字进行自定义重命名<ul><li>特性本身不进入元数据</li><li>例如 string 的索引器名称是 Chars</li></ul></li></ul><p>性能</p><ul><li>对于简单的 get、set 访问器方法，JIT 会将代码内联（调试版本不会优化）</li></ul><h1 id="第十一章-事件"><a class="anchor" href="#第十一章-事件">#</a> 第十一章 事件</h1><ul><li>委托是不可变的</li><li>事件参数传递：EventArgs</li><li>事件成员：EventHandler</li><li>事件编译出的添加、移除方法利用原子操作，以线程安全的一种模式更新值</li><li>试图删除从未添加的方法，Delegate 内部不会做任何事情（不会抛出异常或警告）</li><li>除了自动生成的三个构造代码，编译器还会在元数据附加记录项，用于建立 &quot;事件&quot; 抽象概念 与 add remove 访问器方法的联系（flag、基础委托类型、访问器方法）<ul><li>不过 clr 本身是不会用这些元数据信息的，只编译器等工具会利用这些元数据信息， EventInfo</li></ul></li><li>通过 +=、-= 移除添加事件，会被编译器编译为调用自动生成的 add、remove 方法</li><li>移除事件时，需要扫描委托列表寻找一个恰当匹配：包装方法和传递方法相同</li><li>可以显式实现事件，避免编译器自动生成代码：事件访问器</li></ul><h1 id="第十二章-泛型"><a class="anchor" href="#第十二章-泛型">#</a> 第十二章 泛型</h1><ul><li>面向对象 代码重用，泛型 算法重用</li><li>泛型引用类型、泛型值类型、泛型接口、泛型委托、泛型方法（不允许泛型枚举类型）</li><li>优势<ul><li>源代码保护</li><li>类型安全</li><li>更清晰代码：编译器强制类型安全性，减少强制类型转换次数</li><li>更好的性能：省略强制类型转换消耗；避免值类型装箱消耗</li></ul></li><li>泛型同样会创建类型对象（type object）内部数据结构：开放类型，开放类型不允许创建实例</li><li>代码引用泛型类型时，指定泛型参数后成为 封闭类型；可仅指定部分泛型参数，会导致创建新的开放类型对象</li><li>泛型的静态构造方法和静态字段，针对每个封闭类型都有一份，不共享</li><li>使用泛型类型并指定类型实参时，实际是在 clr 中定义了一个新的类型对象，新类型派生自泛型父类</li><li>缺点<ul><li>代码爆炸：clr 优化方式是对引用类型进行共享 (都属于指针操作)，但是值类型实参不行，因为可能要用不同的本机 cpu 指令操纵这些值</li></ul></li><li>委托实际只是提供了 4 个方法的一个类定义<ul><li>构造器、invoke 方法、begininvoke 方法、endinvoke 方法</li></ul></li><li>协变量：泛型类型参数可以从一个类更改为它的某个基类</li><li>逆变量：泛型类型参数可以从一个类更改为它的某个派生类</li><li>不变量：泛型参数不能更改</li><li>泛型方法<ul><li>作为 out/ref 实参传递的变量必须具有与方法参数相同类型</li><li>编译器支持在调用泛型方法时进行 类型推断</li><li>有重载时，编译器 (类型推断) 先考虑明确匹配，再考虑泛型匹配 (也可指定泛型实参明确调用泛型方法)</li></ul></li><li>泛型约束<ul><li>限制能指定成泛型实参的类型</li><li>可用于泛型类型的类型参数、泛型方法类型参数</li><li>派生类不能修改重写的虚方法在父类指定过的约束</li><li>主要约束：非密封类的一个引用类型<ul><li>指定类型要么是约束类型相同类型，要么是约束类型的子类</li><li>特殊主要约束：class (引用类型)、struct (值类型)</li></ul></li><li>次要约束：可指定零个或多个次要约束，代表接口类型</li><li>类型参数约束 (裸类型约束)：指定类型实参要么是约束类型，要么是约束类型子类<ul><li>Exp&lt;T,TBase&gt; where T:TBase</li></ul></li><li>构造器约束：new ()，约束类型实参是实现了公共无参构造方法的非抽象类型</li></ul></li><li>default (T)：引用类型设为 null，值类型将所有位设为 0</li><li>泛型类型转型</li><li>与 null 比较（值类型未约束为 struct 情况才能用但始终非 null）</li><li>不允许将类型参数约束为具体值类型<ul><li>因为不可能存在从值类型派生的类型，如果允许约束成具体值类型，还不如不要泛型</li></ul></li><li>泛型类型变量作为操作数使用 (操作符运算)<ul><li>值类型不允许</li></ul></li></ul><h1 id="第十三章-接口"><a class="anchor" href="#第十三章-接口">#</a> 第十三章 接口</h1><ul><li>终极基类 System.Object 定义 4 个公共实例方法：tostring、gethashcode、equals、gettype<ul><li>因此接口也允许调用 Object 方法</li></ul></li><li>Object 派生类继承：<ul><li>方法签名：使代码认为自己是在操作 Object 类实例，但实际操作的可能是其它类实例</li><li>方法实现：使开发人员定义 Object 派生类时不必手动实现 Object 的方法</li></ul></li><li>接口：对一组方法签名进行统一命名<ul><li>因此还可定义事件、无参属性和有参属性 (索引器)，因为它们本质是方法</li></ul></li><li>在 clr 看来，接口定义就是类型定义：clr 会为接口类型对象定义内部数据结构，并能通过反射机制查询接口类型功能</li><li>实现接口的方法若没有显式标记为 virtual，编译器会自动标记为 virtual+sealed<ul><li>派生类不能重写 sealed 方法，但可以重新继承同一接口并提供自己的实现</li></ul></li><li>值类型也可实现零个或多个接口，但值类型的实例转换为接口时会导致装箱<ul><li>因为接口变量是引用，必须指向堆上对象，使 clr 能检查对象的类型对象指针，从而判断对象的确切类型</li><li>调用已装箱值类型方法时，clr 会跟随对象的类型对象指针找到类型对象的方法表，从而调用正确方法</li></ul></li><li>类型加载到 clr 时，会为对象创建并初始化一个方法表<ul><li>类型引入的每个新方法都有对应记录项</li><li>继承的所有虚方法也会添加记录项 (有继承层次基类定义的，也有接口类型定义的)</li></ul></li><li>显式接口方法实现 (EIMI)：将定义方法的接口名称作为方法名前缀<ul><li>不允许指定访问性，编译器生成元数据时，会自动设置为 private</li><li><ol><li>没有文档解释具体实现，没有智能感知支持、2. 值类型实例转换为接口时发生装箱、3. EIMI 不能由派生类调用</li></ol></li></ul></li><li>接口方法理想情况下应该是强类型的</li><li>C# 编译器为接口约束生成特殊 il 指令 (constrained)，导致在值类型上调用接口方法而不装箱（不用接口约束便无法生成，调用接口方法就会导致装箱）<ul><li>指：约束了泛型参数一定得实现某个接口时，实现了接口的值类型可以不装箱放进去？（待测试，搞不清楚）</li><li>例外：值类型实例上调用</li></ul></li></ul><h1 id="第十四章-字符-字符串和文本处理"><a class="anchor" href="#第十四章-字符-字符串和文本处理">#</a> 第十四章 字符、字符串和文本处理</h1><ul><li>字符 (Char)：总是表示成 16 位 Unicode 代码值</li><li>Char getunicodecategory 方法返回一个枚举，标志该字符是由 Unicode 定义的控制字符、货币符号、小写字母、大写字母、标点符号、数学符号或者其它字符<ul><li>同时也提供了一些静态方法用于判断</li></ul></li><li>ToLowerInvariant、ToUpperInvariant：以忽略语言文化方式将字符串转换为小写或大写形式<ul><li>微软对执行大写比较的代码做了优化</li></ul></li><li>Covert 类型转换内部使用了 checked 检查</li><li>字符串<ul><li>直接使用字面值 (literal) 会被编译至元数据，并在运行时加载和引用</li><li>C# 不允许使用 new 操作符从字面值字符串构造 String 对象</li><li>il 中使用 ldstr 从元数据获得字面值字符串构造 String 对象</li><li>字面值字符串连接会被编译时直接连接并放入元数据，非字面值连接则在运行时进行</li></ul></li><li>字符串比较<ul><li>equals</li><li>compare</li><li>startswith</li><li>endswith</li><li>currentculture.compareinfo.compare</li><li>StringComparer：大量不同字符串反复执行同一种比较</li></ul></li><li>字符串留用<ul><li>clr 初始化会创建一个内部哈希表，key 为字符串，value 则为托管堆中的 string 对象引用</li><li>intern、isinterned</li><li>加载时默认留用所有字面值字符串 (可设置，并取决于 clr)</li><li>除非显式调用 intern，否则不要以 字符串已留用 前提写代码</li></ul></li><li>Char 代表一个 16 位 Unicode 码值，但是不一定等同于一个抽象的 Unicode 字符<ul><li>可能需要多个字符表示一个 Unicode 字符</li><li>有的 Unicode 字符需要两个 16 位值表示，称为 高位代理项 和 低位代理项，使其能表示 100 万个以上的字符</li></ul></li><li>stringbuilder<ul><li>字符数组，超过分配大小后，会分配新的字符数组，前一个字符数组会被回收</li><li>只有超出容量或 tostring 会导致分配新的对象</li></ul></li><li>string.format：替换参数花括号中可以使用『:』指定格式化信息</li><li>定制格式化器<ul><li>IFormatProvider</li></ul></li><li>安全字符串：System.Security.SecureString<ul><li>会在内部分配非托管内存，包含一个字符数组，字符经过加密</li><li>调用操作接口时，会先 解密 - 操作 - 加密，因此性能一般</li></ul></li></ul><h1 id="第十五章-枚举类型和位标志"><a class="anchor" href="#第十五章-枚举类型和位标志">#</a> 第十五章 枚举类型和位标志</h1><ul><li>结构：简单来说只是一个结构，其中定义了一组常量和一个实例字段</li><li>枚举类型定义的符号是常量值，编译时会用数值替换符号</li><li>getunderlyingtype：获取容纳枚举类型值的基础类型</li><li>Type.getenumunderlyingtype：同上</li><li>操作符实际作用于内部的 value 实例字段</li><li>IsDefined：通过反射查找，很慢</li><li>Flag 标志：ToString 会自动拼接（不定义该标志，ToString (&quot;F&quot;) 也可以）</li></ul><h1 id="第十六章-数组"><a class="anchor" href="#第十六章-数组">#</a> 第十六章 数组</h1><ul><li>一维 0 基数组 (向量) 性能最好<ul><li>有专用 il 指令处理</li><li>访问元素时不需要从指定索引减去偏移量</li><li>索引检查会在循环外判断</li></ul></li><li>[][]：交错数组 (性能其次)</li><li>[,]：多维数组 (性能不好，最好以交错数组代替)</li><li>Array.Copy：不仅仅是将元素从一个数组复制到另一个<ul><li>方法还能正确处理内存重叠区域</li><li>方法还能在复制每个数组元素时进行必要的类型转换 (如自动装箱拆箱、转型、加宽基元类型)</li><li>BlockCopy：比之更快，不过仅支持基元类型且不提供转型能力</li></ul></li><li>结构体中可使用 fixed 嵌入 (内联) 值类型一维 0 基数组，可在栈上分配（unsafe 代码）</li></ul><h1 id="第十七章-委托"><a class="anchor" href="#第十七章-委托">#</a> 第十七章 委托</h1><ul><li>自定义委托会导致编辑器定义一个完整的类，该类继承 MulticastDelegate<ul><li>包含 4 个方法：构造器、invoke 方法、begininvoke 方法、endinvoke 方法</li><li>MulticastDelegate<ul><li>_target (Object)：当委托包装静态方法时该字段为 null，实例方法为回调方法要操作的实例对象</li><li>_methodPtr (IntPtr)：clr 用来标识要回调的方法</li><li>_invocationList (Object)：通常为 null，构造委托链时引用一个委托数组</li></ul></li></ul></li><li>所有委托都有一个接受两个参数的构造器：一个是对象引用，另一个是引用了回调方法的整数</li><li>方法地址 IntPtr 值：从 MethodDef 或 MemberRef 元数据 token 获得</li><li>健壮性：一个系统对于参数变化的不敏感性</li><li>可靠性：一个系统的正确性，固定一个参数可以产生稳定、可预测的输出</li><li>委托 target 能取到？</li><li>除非内置 Action、Func 满足不了需求，如：需要利用委托传引用、可变参数，否则不要自定义委托</li><li>不引用成员变量、局部变量的匿名方法被编译为静态匿名函数并在第一次调用时缓存委托，性能更好，因为还不需要额外 this 参数</li></ul><h1 id="第十八章-定制特性"><a class="anchor" href="#第十八章-定制特性">#</a> 第十八章 定制特性</h1><ul><li>定制特性其实是一个类型的实例<ul><li>将特性应用于目标元素时，语法类似于调用类的某个实例构造器</li></ul></li><li>特性类型本质上还是类，而类是可以应用特性的（attributeusage）<ul><li>不将 allowmultiple 明确设置为 true，特性就只能向选定目标元素应用一次</li><li>inherited：指出特性在应用于基类时，是否同时应用于派生类和重写的方法</li><li>若未设置 attributeusage，则编译器和 clr 会假定该特性能应用于所有目标元素，每个目标元素最多一次，且可继承</li></ul></li><li>可想象为：它是类的实例，被序列化成驻留在元数据中的字节流，运行时可对元数据中字节进行反序列化，从而构造出类的实例</li><li>如果只想判断目标是否应用特性，使用 isdefined 更高效：它不会构造特性对象，不会调用构造器，也不会设置字段和属性<ul><li>getcustomattribute：会构造特性对象，每次调用都会构造指定特性类型的新实例</li><li>不管调用哪个，内部都必须扫描托管模块元数据，执行字符串比较来定位指定的定制特性类，可考虑缓存结果</li></ul></li><li>两个特性实例的相互匹配：可在自己的定制特性类中重写 equals 来移除反射的使用，以提高性能（默认的 equals 会在类型一致时，再反射字段比较）</li><li>customattributedata：在查找特性的同时禁止执行特性类中的代码</li><li>conditionalattribute：条件特性类<ul><li>编译器如果发现向目标应用了该特性，仅具有指定预定义时才会在元数据中生成特性信息</li><li>应用于方法时，若无预定义，则调用方法处会代码会直接去掉</li></ul></li></ul><h1 id="第十九章-可空值类型"><a class="anchor" href="#第十九章-可空值类型">#</a> 第十九章 可空值类型</h1><ul><li>操作可空值类型的速度慢于非可空值类型</li><li>&amp;：按位与 (相同为 1，不同为 0)</li><li>|：按位或 (有 1 则 1，无 1 则 0)</li><li>对于自己的值类型重载的操作符，编译器能自动调用其可空实例的</li><li>??：如果左边为空，则返回右边操作数的值</li><li>可空值类型装箱<ul><li>当 clr 对可空值类型实例进行装箱时，若其为空，则不装箱任何东西</li><li>若不为空，则取出其中的值进行装箱</li></ul></li><li>通过可空值类型调用 gettype，会返回内部实际值类型</li></ul><h1 id="第二十一章-托管堆和垃圾回收"><a class="anchor" href="#第二十一章-托管堆和垃圾回收">#</a> 第二十一章 托管堆和垃圾回收</h1><ul><li>托管堆：clr 维护 NextObjPtr 指针</li><li>类型对象指针、同步块索引<ul><li>32 位：各自 32 位</li><li>64 位：各自 64 位，因此每个对象额外 16 字节开销</li></ul></li><li>NextObjPtr：在此放入新对象，初始化对象后，指针加上对象占用字节数得到新值</li><li>GC<ul><li>暂停所有线程，进入标记阶段</li><li>遍历堆中所有对象，将同步块索引字段中的一位设为 0</li><li>检查所有活动根，查看其引用对象</li><li>任何根若引用了堆上对象，则标记该对象：同步块索引中的位设为 1，被标记后，继续检查该对象中的根，若其中对象被标记则不重新检测</li><li>标记完成后，进入压缩阶段，压缩存活对象使其占用连续空间（大对象堆默认不压缩）<ul><li>提升将来访问性能</li><li>解决堆内存空间碎片化问题</li></ul></li><li>修改指针指向新地址 (所以使用指针需要 fixed)</li></ul></li><li>分为三代：0、1、2 代，每代容量会自动计算，运行时也会进行调节，根据应用程序要求的内存负载自动优化</li><li>GC 触发条件<ul><li>手动调用 GC（不推荐）</li><li>系统报告内存过低</li><li>CLR 卸载 AppDomain</li><li>CLR 正在关闭</li></ul></li><li>大对象：超过 85000 字节，处于第二代，默认不压缩（可能会导致内存碎片）</li><li>分为 工作站 服务器 两种 GC 模式</li><li>子模式<ul><li>并发（默认）：内存足够的情况下，可能不压缩内存，消耗内存通常比非并发更多</li><li>非并发</li></ul></li><li>手动调用回收（不推荐），会导致代的预算发生调整，最好让程序根据应用程序行为调整各代预算。</li><li>Finalize：终结器，实现其的对象成为垃圾后，在垃圾回收完毕后才调用<ul><li>可终结对象在垃圾回收时必须存活，导致被提升到下一代，临时复活后会活得比正常时间长，所以一定程度会增加内存消耗</li><li>执行时间、顺序控制不了（不要访问另外实现了终结器的对象）</li><li>clr 用一个专用的、高优先级线程执行终结器方法避免死锁（因此若有终结器方法阻塞、等待信号量会导致线程无法再调用其它终结器 -&gt; 内存泄露）</li></ul></li><li>终结器内部原理<ul><li>创建对象实例时，若发现对象定义了终结器方法，则加入终结器列表</li><li>垃圾回收时，扫描到回收对象处于终结器列表，则移除列表并添加至 f-reachable 队列</li><li>一个特殊的高优先级线程专门调用 F-reachable (可达的) 队列中的终结器方法（因此不要对执行代码的线程做出任何假设）</li><li>reachable (可达的) 使其指向对象保持可达（复活）—— 标记时，将同时递归标记对象引用的对象，所有引用对象也将保持复活</li><li>标记完成后，复活对象也会被提升到老的一代（并不理想）</li><li>最后，特殊的终结器线程清空 freachable 队列，执行每个终结器方法</li><li>下一次对老一代进行垃圾回收时，才能发现终结器对象成为真正的垃圾</li><li>所以，回收一个终结器对象需要不止一次垃圾回收，甚至也不止两次</li></ul></li><li>创建封装了本机资源的托管类型时，应该先从 SafeHandle 派生出一个类</li><li>C# 内置的托管资源操作类，如果不调用 dispose，就得等到它被垃圾回收通过终结器释放资源了</li><li>StreamWriter：会将数据缓存在自己的内存缓冲区，缓冲区满时才会将对象数据写入 Stream<ul><li>该类没有实现终结器，不显式调用 dispose 会导致数据丢失</li></ul></li><li>如果一个类要包装可能很大的本机资源，可使用对应方法提示垃圾回收器实际情况以便处理：<ul><li>GC.AddMemoryPressure</li><li>GC.RemoveMemoryPressure</li></ul></li><li>包装数量有限的本机资源：HandleCollector，计数太大就强制回收</li><li>clr 为每个 appdomain 都提供了一个 GC 句柄表<ul><li>对托管堆对象一个引用</li><li>指出如何控制或监视对象的标记</li></ul></li><li>GCHandle（结构体）用于 添加或删除 GC 句柄表记录项<ul><li>weak：可检测垃圾回收器在什么时候判定该对象在应用程序代码中不可达</li><li>weaktrackresurrection：同上，不过对象终结器 (若有的话) 已执行，内存已回收</li><li>normal：即使应用程序没有根引用该对象，该对象也必须留在内存</li><li>Pinned：即使应用程序没有根引用该对象，该对象也必须留在内存，且发生垃圾回收时，该对象内存不能压缩（需要将内存地址交给本机代码时，这个功能比较好用）</li><li>注 1：使用 clr 的 P/Invoke 机制调用方法时，clr 会自动帮忙固定实参，并在本机方法返回时解除固定。</li><li>注 2：只有将托管对象指针传递给本机代码，且本机代码方法返回后仍需使用该对象时，才需要显式使用 GCHandle 类型</li></ul></li><li>fixed<ul><li>比分配一个固定 GC 句柄高效很多</li><li>编译器在局部变量上生成一个特殊 已固定 标志，垃圾回收期间检测根内容，若根不为空则知道在压缩阶段不要移动变量引用对象</li></ul></li><li>WeakReference<ul><li>其实是包装了一个 GCHandle 实例的面向对象包装器</li><li>实例必须在堆上分配，比 GCHandle 实例更重</li></ul></li><li>ConditionalWeakTable<ul><li>内部存储了对作为 key 传递对象的弱引用（一个 WeakReference 对象），保证不会因为表的存在而使对象 被迫 存活</li><li>保证只要 key 所标识的对象在内存，值就肯定在内存中</li><li>可以实现类似 xaml 依赖属性 机制</li></ul></li></ul><h1 id="第二十二章-clr-寄宿和-appdomain"><a class="anchor" href="#第二十二章-clr-寄宿和-appdomain">#</a> 第二十二章 CLR 寄宿和 AppDomain</h1><ul><li>AppDomain<ul><li>clr 初始化时会创建第一个默认 appdomain，只有进程结束才会被销毁</li><li>相互之间不能直接访问<ul><li>相互有清晰的分隔和边界，容易单独卸载而不影响其它 appdomain</li><li>想要相互访问对象，必须 按引用封送 (marshal-by-reference)，或 按值封送 (marshal-by-value)</li></ul></li><li>可以被卸载：不支持卸载程序集，但是能卸载包含程序集的 appdomain</li><li>可以单独保护：可以设置运行权限</li><li>可以单独配置：appdomain 创建后会关联一组配置设置（涉及搜索路径、版本绑定重定向、卷影复制及加载器优化）</li></ul></li><li>windows 每个应用程序都在自己的进程地址 (虚拟地址) 空间运行，即进程隔离<ul><li>创建进程开销很大，如需要大量内存虚拟化进程地址空间</li><li>appdomain 同样提供了清晰隔离（保护、配置和终止每一个应用所需的隔离），使得可以提供一个进程运行多个托管程序</li></ul></li><li>Loader 堆<ul><li>每个 appdomain 都有自己的 loader 堆，每个 loader 堆都记录了自 appdomain 创建以来已访问过的哪些类型</li><li>loader 堆中每个类型都有一个方法表</li><li>方法表中的每个记录项都指向 jit 编译的本机代码 (前提是方法执行过)</li></ul></li><li>进程<ul><li>appdomain 1<ul><li>loader 堆</li><li>程序集</li></ul></li><li>appdomain 2<ul><li>loader 堆</li><li>程序集</li></ul></li><li>appdomain 中立 的程序集<ul><li>loader 堆</li><li>程序集：MSCorLib.dll</li></ul></li></ul></li><li>jit 编译的代码不共享，每个 appdomain 都有一份</li><li>多个 appdomain 使用的类型在每个 appdomain 都有一组静态字段</li><li>appdomain 中立的程序集：以 中立 方式加载的程序集会共享，不过以 中立 方式加载的程序集，永远不能卸载，回收其资源的唯一方法是终止进程</li><li>跨越 appdomain 边界访问对象（跨域？）<ul><li>同步执行的：一个 appdomain 方法执行完毕，才能执行另一个的方法，不能多个 appdomain 方法并发执行</li><li>按引用封送（继承 marshalbyrefobject）<ul><li>生成代理类型，并创建代理类型实例</li><li>调用方法时，切换至另一个 appdomain 执行</li><li>实例字段通过反射设置或获取</li><li>使用 租约管理器 保持原始对象存活</li><li>性能较差</li><li>应该避免静态成员（总是在调用 appdomain 的上下文访问）</li></ul></li><li>按值封送（继承普通 object）<ul><li>标记 Serializable 特性</li><li>clr 将对象的实例字段序列化成一个字节数组</li><li>从源 appdomain 复制到目标 appdomain</li><li>反序列化字节数组，这会强制 clr 将定义了 被反序列化类型 的程序集加载到目标 appdomain (若未加载)</li><li>创建对象实例，并利用字节数组中的值初始化对象字段</li><li>调用方法时，由于是真实对象，因此不会发生 appdomain 线程切换（卸载源 appdomain 也不再影响该对象）</li></ul></li></ul></li><li>卸载 appdomain：步骤</li><li>监视 appdomain<ul><li>appdomain 静态 MonitoringEnabled：设置为 true 后便不能关闭</li><li>开启后，可查询（只保证在上一次垃圾回收时是准确的）：</li><li>MonitoringSurvivedProcessMemorySize：当前 clr 所有 appdomain 使用的字节数</li><li>MonitoringTotalAllocatedMemorySize：特定 appdomain 已分配字节数</li><li>MonitoringSurvivedMemorySize：特定 appdomain 当前正在使用的字节数</li><li>MonitoringTotalProcessorTime：特定 appdomain 的 cpu 占用率</li></ul></li><li>appdomain firstchance 异常通知<ul><li>每个 appdomain 都可关联一组回调方法，clr 开始查找 appdomain 中的 catch 块时被调用</li><li>可利用此做日志记录操作</li></ul></li><li>代码运行时会访问其它类型，引用另一个程序集中类型时，clr 会定位所需程序集，并将其加载到同一个 appdomain 中</li><li>关闭进程：Environment.Exit</li></ul><h1 id="第二十三章-程序集加载和反射"><a class="anchor" href="#第二十三章-程序集加载和反射">#</a> 第二十三章 程序集加载和反射</h1><ul><li>clr 不提供卸载单独程序集的能力</li><li>程序集加载<ul><li>引用另一个程序集中类型时，clr 会定位所需程序集，并将其加载到同一个 appdomain 中</li><li>clr 内部也是调用 assembly 静态 load 方法</li><li>appdomain 也提供了 load 方法<ul><li>不过是实例方法</li><li>clr 通过发出调用的 appdomain 设置定位和加载（可能找不到）</li><li>存在问题，应该避免</li></ul></li><li>loadfrom<ul><li>首先调用 assemblyname 的 静态 getassemblyname 方法打开指定文件</li><li>找到 assemblyref 元数据表的记录项，提取程序集标识信息</li><li>以 assemblyname 形式返回（并关闭文件）</li><li>随后 loadfrom 方法内部调用 assembly 静态 load 方法，将 assemblyname 传入</li><li>clr 应用版本绑定重定向策略，并在各个位置查找匹配程序集</li><li>若找到匹配程序集则加载，并返回代表程序集的 assembly 对象</li><li>若没有找到，则 loadfrom 会加载传递路径中的程序集</li><li>若已加载具有相同标识程序集，则会直接返回代表程序集的 assembly 对象</li><li>注 1：loadfrom 允许传入 url</li><li>注 2：由于一台机器可能存在相同标识的多个程序集，且 loadfrom 会在内部调用 load，因此 clr 可能加载的不是指定文件</li></ul></li><li>loadfile<ul><li>从任意路径加载程序集，而且可以将相同标识程序集多次加载到同一 appdomain</li><li>clr 不会自动解析任何依赖性问题</li><li>代码必须向 appdomain 的 assemblyresolve 事件登记，并让事件回调显式加载依赖程序集</li></ul></li></ul></li><li>若代码只想反射分析程序集元数据<ul><li>使用 assembly reflectiononlyfrom 或 reflectiononlyload（少见）</li><li>使用上述方法加载程序集时，clr 禁止程序集中任何代码运行</li><li>依赖：reflectiononlyassemblyresolve 事件</li></ul></li><li>在 appdomain 的 assemblyresolve 事件登记后，可以手动处理依赖程序集加载</li><li>反射<ul><li>严重依赖字符串</li><li>编译时无法保证类型安全性</li><li>速度较慢<ul><li>字符串名称标识类型及成员</li><li>使用 reflection 命名空间中类型扫描程序集元数据时，反射机制会不停地执行字符串搜索</li><li>通常字符串搜索不区分大小写，因此进一步影响速度</li><li>反射调用成员（方法）时，首先必须将实参打包成数组，然后在内部将实参解包到线程栈上</li><li>在调用方法前，还必须检查实参是否有正确的数据类型</li></ul></li></ul></li><li>因此，晚期绑定不推荐用反射调用，可以：<ul><li>让类型从已知基类型派生，运行时构造派生类型实例，调用虚方法</li><li>让类型实现已知接口，在运行时构造实例，再调用接口方法 (推荐)</li><li>这样访问对象成员可以获得更好的性能，并确保编译时的安全性</li></ul></li><li>在一个 appdomain 中，每个类型只会有一个 type 对象</li><li>反射方法字符串为这些名称定义了 巴克斯 - 诺尔范式（Backus-Naurform，BMF） 语法</li><li>typeof（早期绑定） 获取类型比 gettype（晚期绑定） 更快</li><li>Type 对象是轻量级引用，更多信息必须通过 gettypeinfo (不过性能更低) 获取 typeinfo（其也可以转型为 type）</li><li>反射构造类型实例<ul><li>Activator.CreateInstance<ul><li>运行在不调用值类型构造器的情况下创建值类型的实例</li></ul></li><li>Activator.CreateInstanceFrom</li><li>AppDomain.CreateInstance</li><li>AppDomain.CreateInstanceAndUnwrap</li><li>AppDomain.CreateInstanceFrom</li><li>AppDomain.CreateInstanceFromAndUnwrap</li><li>Reflection.ConstructorInfo：Type 对象引用可获取构造方法信息，调用后构造类型实例并调用构造器</li><li>创建数组类型：Array.CreateInstance</li><li>创建委托：MethodInfo.CreateDelegate</li><li>构造泛型类型实例首先要获取开放类型的引用，然后调用 MakeGenericType 传递生成封闭类型参数</li></ul></li><li>反射类型成员：MemberInfo (抽象基类)<ul><li>TypeInfo</li><li>FieldInfo</li><li>MethodBase<ul><li>ConstructorInfo</li><li>MethodInfo</li></ul></li><li>PropertyInfo</li><li>EventInfo</li></ul></li><li>反射时传引用<ul><li>类型 &amp;（巴克斯 - 诺尔范式）</li><li>type.makebyreftype</li></ul></li><li>若为了提高性能，缓存 Type 和 MemberInfo 派生对象会消耗更多内存<ul><li>clr 内部用更精简的方式表示这种信息，clr 不需要这些大对象就，能运行，之所以创建这些对象是为了方便开发人员</li><li>精简方式：<ul><li>可以使用运行时句柄代替对象以减小内存</li><li>RuntimeTypeHandle</li><li>RuntimeFieleHandle</li><li>RuntimeMethodHandle</li><li>上述都是值类型，只包含一个 IntPtr 字段，引用 appdomain 的 loader 堆中一个类型、字段或方法</li></ul></li><li>使用方法：<ul><li>type.gettypehandle（gettypefromhandle 转回去）</li><li>fieldinfo.fieldhandle（转换同上）</li><li>methodinfo.methodhandle（转换同上）</li><li>获得 handle 后原对象可被释放（猜测？存疑）</li></ul></li></ul></li></ul><h1 id="第二十四章-运行时序列化"><a class="anchor" href="#第二十四章-运行时序列化">#</a> 第二十四章 运行时序列化</h1><ul><li>类型默认是不可序列化的，必须应用定制特性：Serializable<ul><li>特性可以应用于 引用类型、值类型、枚举和委托类型</li><li>枚举和委托默认总是可序列化（所以不必显式调用）</li><li>该特性不会被派生类继承</li><li>注：自动属性序列化会有问题，因为其字段值由编译器自动生成，名称每次编译可能不同，因此在允许序列化的类型中不要用</li></ul></li><li>序列化会读取对象所有实例字段，包括私有<ul><li>NonSerializable 特性可以标记指定字段不被序列化</li></ul></li><li>序列化、反序列化可允许自动调用方法<ul><li>OnSerializing 特性：序列化前首先调用</li><li>OnSerialized 特性：序列化完毕调用</li><li>OnDeserializing 特性：反序列化前首先调用</li><li>OnDeserialized 特性：反序列化完毕调用</li><li>定义的方法必须获取一个 StreamingContext 参数</li></ul></li><li>反序列化类型存在新增字段会报错<ul><li>可以为新增字段应用 OptionalField 特性</li></ul></li><li>System.Runtime.Serialization.Formatters.Binary：二进制序列化<ul><li>其实现 System.Runtime.Serialization.IFormatter 接口</li><li>默认输出程序集完整标识：文件名、版本号、语言文化、公钥信息<ul><li>反序列化时，通过 assembly load 确保程序集已加载</li><li>查找匹配类型（找不到则抛出异常）</li><li>找到则创建实例，并通过反射用流数据初始化字段（若不完全匹配则抛出异常，可选 OptionalField 忽略）</li></ul></li></ul></li><li>格式化器如何序列化<ul><li>调用 FormatterServices 提供的静态方法</li><li>GetSerializableMembers：反射获取未标记 NonSerualized 的实例字段</li><li>反射获取值</li><li>写入程序集标识和类型完整名称</li><li>遍历反射获取的数组，写入每个成员名称和值</li></ul></li><li>格式化器如何反序列化<ul><li>从流中读取程序集和完整类型名称</li><li>确保程序集加载</li><li>gettypefromassembly 获取反序列化对象类型</li><li>调用 FormatterServices 提供的方法</li><li>GetUnInitializedObject：构造对象，但不调用构造方法，对象所有字段初始化为 0 或 null</li><li>GetSerializableMembers：反射获取字段信息</li><li>根据流中信息初始化值的数组</li><li>调用 PoulateObjectMembers 方法反射初始化值</li></ul></li><li>为提高更多操作，并避免反射开销<ul><li>可以实现 ISerializable 接口，该接口会由格式化器使用</li><li>若一个类型实现了该接口，格式化器将忽略前面说的定制特性</li><li>实现接口的类型需要定义带两个参数的特殊构造器：name (SerializationInfo info,StreamingContext context)，这个构造器在反序列化时被调用</li></ul></li><li>类型序列化为不同类型以及对象反序列化为不同对象<ul><li>序列化单例（贪婪模式），并保证反序列化后也只有一个：实现的 ISerializable 接口方法 序列化实现 IObjectReference 的类型，该类型的方法直接返回单例对象</li><li>在反序列化时，会调用其静态构造方法构成其单例对象</li><li>反序列化时，若发现类型实现了 IObjectReference 接口，会调用其 GetRealObject 方法</li></ul></li><li>序列化代理<ul><li>必须实现 ISerializationSrurogate 接口</li><li>允许开发人员序列化最初没有设计成要序列化的类型</li><li>运行开发人员提供一种方式将类型一个版本映射到另一个版本</li><li>通过 SurrogateSelector 在 IFormatter (格式化器) 注册</li></ul></li><li>反序列化和序列化时不同类型<ul><li>SerializationBinder</li><li>可以重写 类型<ul><li>BindToType</li><li>BindToName</li></ul></li><li>继承 SerializationBinder 实现自己的类，然后在格式化器注册</li></ul></li><li>Xml 序列化<ul><li>XmlSerializer</li><li>DataContractSerializer</li></ul></li><li>可以通过二进制序列化简单实现对象的 深拷贝</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;本来计划的是 3 月份就看完，结果 4 月 2 号了还剩两章，虽然这跟到后面看得更仔细有关，但是公司上个月突然要求加起班来也有关系，导致每周上班时间只有两天可以提前</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C#" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="C#" scheme="https://wangjiaying.top/tags/C/"/>
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C#类型方法调用测试</title>
    <link href="https://wangjiaying.top/2023/03/28/C-%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%B5%8B%E8%AF%95/"/>
    <id>https://wangjiaying.top/2023/03/28/C-%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%B5%8B%E8%AF%95/</id>
    <published>2023-03-28T12:54:56.000Z</published>
    <updated>2023-06-04T11:42:34.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>在 《CLR vir C#》一书中，有说明  <code>call</code>  与  <code>callvirt</code>  的差别：</p><ul><li>call：可调用静态方法，实例方法和虚方法<ul><li>调用实例方法和虚方法必须指定引用了对象的变量，该指令假定该变量不为 null</li></ul></li><li>callvirt：可调用实例方法和虚方法，不能调用静态方法（需要对变量做 null 检查，因此比 call 慢）<ul><li>并且调用虚实例方法时，还需要检查发出调用对象的实际类型，然后以多态方式调用</li></ul></li></ul><p>同时，对于声明为  <code>sealed</code>  的类型，会有优化，采用  <code>call</code>  调用，例如：始终对结构体采用 call 调用。</p><p>这里我想进行各种调用测试，并从  <code>IL</code>  代码上确认下。</p><h1 id="工具"><a class="anchor" href="#工具">#</a> 工具</h1><ul><li>ILSpy 版本 8.0.0.7246-preview3</li></ul><h1 id="测试类型普通方法"><a class="anchor" href="#测试类型普通方法">#</a> 测试类型 (普通方法)</h1><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ClassNormal</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">InvokeNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">ClassSealed</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">InvokeSealed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">struct</span> <span class="token class-name">StructNormal</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">InvokeStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="调用方式一"><a class="anchor" href="#调用方式一">#</a> 调用方式一</h2><p>直接  <code>new</code>  并立即调用：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">new</span> <span class="token constructor-invocation class-name">ClassNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">InvokeNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">new</span> <span class="token constructor-invocation class-name">ClassSealed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">InvokeSealed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">new</span> <span class="token constructor-invocation class-name">StructNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">InvokeStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>IL 代码：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>IL_0008<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassNormal<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>IL_000d<span class="token punctuation">:</span> call instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassNormal<span class="token punctuation">::</span><span class="token function">InvokeNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>IL_0012<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="4"></td><td><pre>IL_0013<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassSealed<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>IL_0018<span class="token punctuation">:</span> call instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassSealed<span class="token punctuation">::</span><span class="token function">InvokeSealed</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>IL_001d<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="7"></td><td><pre>IL_001e<span class="token punctuation">:</span> ldloca<span class="token punctuation">.</span>s <span class="token number">0</span></pre></td></tr><tr><td data-num="8"></td><td><pre>IL_0020<span class="token punctuation">:</span> <span class="token class-name">dup</span></pre></td></tr><tr><td data-num="9"></td><td><pre>IL_0021<span class="token punctuation">:</span> initobj TestCallMethod<span class="token operator">/</span><span class="token class-name">StructNormal</span></pre></td></tr><tr><td data-num="10"></td><td><pre>IL_0027<span class="token punctuation">:</span> call instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>StructNormal<span class="token punctuation">::</span><span class="token function">InvokeStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>直接  <code>new</code>  并立即调用普通方法，三者并无却别，均编译为  <code>call</code>  指令 —— 因为编译器知道调用对象必然不为空，无需进行额外检查。</p><h2 id="调用方式二"><a class="anchor" href="#调用方式二">#</a> 调用方式二</h2><p>缓存调用：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">ClassNormal</span> normal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ClassNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>normal<span class="token punctuation">.</span><span class="token function">InvokeNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">ClassSealed</span> sl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ClassSealed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>sl<span class="token punctuation">.</span><span class="token function">InvokeSealed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token class-name">StructNormal</span> st <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">StructNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>st<span class="token punctuation">.</span><span class="token function">InvokeStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>IL 代码：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>IL_0008<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassNormal<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>IL_000d<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="3"></td><td><pre>IL_000e<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="4"></td><td><pre>IL_000f<span class="token punctuation">:</span> callvirt instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassNormal<span class="token punctuation">::</span><span class="token function">InvokeNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>IL_0014<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="6"></td><td><pre>IL_0015<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassSealed<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>IL_001a<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="8"></td><td><pre>IL_001b<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="9"></td><td><pre>IL_001c<span class="token punctuation">:</span> callvirt instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassSealed<span class="token punctuation">::</span><span class="token function">InvokeSealed</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>IL_0021<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="11"></td><td><pre>IL_0022<span class="token punctuation">:</span> ldloca<span class="token punctuation">.</span>s <span class="token number">2</span></pre></td></tr><tr><td data-num="12"></td><td><pre>IL_0024<span class="token punctuation">:</span> initobj TestCallMethod<span class="token operator">/</span><span class="token class-name">StructNormal</span></pre></td></tr><tr><td data-num="13"></td><td><pre>IL_002a<span class="token punctuation">:</span> ldloca<span class="token punctuation">.</span>s <span class="token number">2</span></pre></td></tr><tr><td data-num="14"></td><td><pre>IL_002c<span class="token punctuation">:</span> call instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>StructNormal<span class="token punctuation">::</span><span class="token function">InvokeStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>结构体调用依然为  <code>call</code>  指令，类型调用已经换成了  <code>callvirt</code>  指令 —— 调用普通类型需要额外检查了。</p><h1 id="测试类型虚方法"><a class="anchor" href="#测试类型虚方法">#</a> 测试类型 (虚方法)</h1><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ClassVirtual</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ClassVirtualChild</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ClassVirtual</span></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">ClassVirtualChildSealed</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ClassVirtual</span></span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="调用方式一-2"><a class="anchor" href="#调用方式一-2">#</a> 调用方式一</h2><p>直接  <code>new</code>  调用：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">new</span> <span class="token constructor-invocation class-name">ClassVirtualChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">new</span> <span class="token constructor-invocation class-name">ClassVirtualChildSealed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>IL 代码：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>IL_0008<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtualChild<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>IL_000d<span class="token punctuation">:</span> callvirt instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtual<span class="token punctuation">::</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>IL_0012<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="4"></td><td><pre>IL_0013<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtualChildSealed<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>IL_0018<span class="token punctuation">:</span> callvirt instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtual<span class="token punctuation">::</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>... 貌似  <code>sealed</code>  没起到作用，对于类型虚方法调用还是采用的  <code>callvirt</code>  指令调用的基类方法名</p><h2 id="调用方式二-2"><a class="anchor" href="#调用方式二-2">#</a> 调用方式二</h2><p>缓存调用：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">ClassVirtualChild</span> normal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ClassVirtualChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>normal<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">ClassVirtualChildSealed</span> sl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ClassVirtualChildSealed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>sl<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>IL 代码：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>IL_0008<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtualChild<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>IL_000d<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="3"></td><td><pre>IL_000e<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="4"></td><td><pre>IL_000f<span class="token punctuation">:</span> callvirt instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtual<span class="token punctuation">::</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>IL_0014<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="6"></td><td><pre>IL_0015<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtualChildSealed<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>IL_001a<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="8"></td><td><pre>IL_001b<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="9"></td><td><pre>IL_001c<span class="token punctuation">:</span> callvirt instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtual<span class="token punctuation">::</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>与第一种方式一样， <code>sealed</code>  标识之后，也还是始终采用  <code>callvirt</code>  调用基类方法名</p><h1 id="测试类型-静态调用"><a class="anchor" href="#测试类型-静态调用">#</a> 测试类型 - 静态调用</h1><p>根据各种信息表明，静态函数必然是  <code>call</code>  指令调用，不过最后还是测试一下：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ClassVirtualChild</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ClassVirtual</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">InvokeStatic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>ClassVirtualChild<span class="token punctuation">.</span><span class="token function">InvokeStatic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>IL 代码：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>IL_0008<span class="token punctuation">:</span> call <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtualChild<span class="token punctuation">::</span><span class="token function">InvokeStatic</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>确实如此。</p><h1 id="methodimploptionsaggressiveinlining-内联特性测试"><a class="anchor" href="#methodimploptionsaggressiveinlining-内联特性测试">#</a> MethodImplOptions.AggressiveInlining 内联特性测试</h1><p>据说将方法使用  <code>[MethodImpl(MethodImplOptions.AggressiveInlining)]</code>  特性标记， <code>CLR</code>  如可能会将方法内联。</p><p>—— 虽然好像说是  <code>JIT</code>  生效的，不过这里也还是做一下测试，看看讷会不会体现在  <code>IL</code>  中：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ClassVirtual</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">MethodImpl</span><span class="token attribute-arguments"><span class="token punctuation">(</span>MethodImplOptions<span class="token punctuation">.</span>AggressiveInlining<span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">InvokeDirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"InvokeDirect"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ClassVirtualChild</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ClassVirtual</span></span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">MethodImpl</span><span class="token attribute-arguments"><span class="token punctuation">(</span>MethodImplOptions<span class="token punctuation">.</span>AggressiveInlining<span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"ClassVirtualChild"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">MethodImpl</span><span class="token attribute-arguments"><span class="token punctuation">(</span>MethodImplOptions<span class="token punctuation">.</span>AggressiveInlining<span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">InvokeNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"InvokeNormal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">ClassVirtualChildSealed</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ClassVirtual</span></span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">MethodImpl</span><span class="token attribute-arguments"><span class="token punctuation">(</span>MethodImplOptions<span class="token punctuation">.</span>AggressiveInlining<span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">override</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"ClassVirtualChildSealed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token keyword">new</span> <span class="token constructor-invocation class-name">ClassVirtual</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">InvokeDirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token keyword">new</span> <span class="token constructor-invocation class-name">ClassVirtualChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token keyword">new</span> <span class="token constructor-invocation class-name">ClassVirtualChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">InvokeNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">new</span> <span class="token constructor-invocation class-name">ClassVirtualChildSealed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token class-name">ClassVirtualChild</span> normal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ClassVirtualChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>normal<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>normal<span class="token punctuation">.</span><span class="token function">InvokeNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token class-name">ClassVirtualChildSealed</span> sl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ClassVirtualChildSealed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>sl<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>IL 代码 (优化版)：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>IL_0006<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtual<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>IL_000b<span class="token punctuation">:</span> call instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtual<span class="token punctuation">::</span><span class="token function">InvokeDirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>IL_0010<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtualChild<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>IL_0015<span class="token punctuation">:</span> callvirt instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtual<span class="token punctuation">::</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>IL_001a<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtualChild<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>IL_001f<span class="token punctuation">:</span> call instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtualChild<span class="token punctuation">::</span><span class="token function">InvokeNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>IL_0024<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtualChildSealed<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>IL_0029<span class="token punctuation">:</span> callvirt instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtual<span class="token punctuation">::</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>IL_002e<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtualChild<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>IL_0033<span class="token punctuation">:</span> <span class="token class-name">dup</span></pre></td></tr><tr><td data-num="11"></td><td><pre>IL_0034<span class="token punctuation">:</span> callvirt instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtual<span class="token punctuation">::</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>IL_0039<span class="token punctuation">:</span> callvirt instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtualChild<span class="token punctuation">::</span><span class="token function">InvokeNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>IL_003e<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtualChildSealed<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>IL_0043<span class="token punctuation">:</span> callvirt instance <span class="token keyword">void</span> TestCallMethod<span class="token operator">/</span>ClassVirtual<span class="token punctuation">::</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>所以貌似没有体现在  <code>IL</code>  代码中，估计该特性真得  <code>JIT</code>  的时候才可能生效，也就是说还是得看  <code>CLR</code>  的判断了，毕竟本身该特性也并未注明一定会对方法产生内联。</p><blockquote><p>注：另外根据 <span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS51bml0eS5jb20vdGhyZWFkcy9tZXRob2RpbXBsLW1ldGhvZGltcGxvcHRpb25zLWFnZ3Jlc3NpdmVpbmxpbmluZy41Njg4MTMv">methodimpl-methodimploptions-aggressiveinlining</span> 文章的相关信息所说， <code>IL2CPP</code>  和  <code>Mono standalone</code>  支持的，不过编辑器内不会体现出来。</p></blockquote><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><ul><li>结构体为值类型，且不支持继承，因此调用其实例方法时直接采用  <code>call</code>  指令，不必进行额外空判断。</li><li>引用类型调用，普通实例方法在直接  <code>new X.Method()</code>  采用  <code>call</code>  指令，其它方式则  <code>callvirt</code>  方式。</li><li>引用类型虚方法调用，仅  <code>callvirt</code>  方式调用基类方法<ul><li>即：调用派生类重载的虚方法，都是通过  <code>callvirt</code>  调用基类方法</li></ul></li></ul><p>所以经过测试，可以得出调用方式结论：</p><ul><li>静态函数始终为  <code>call</code>  调用</li><li>结构体方法使用为  <code>call</code>  调用</li><li>普通方法仅  <code>new X.Method()</code>  方式采用  <code>call</code>  调用</li><li>虚方法通过  <code>callvirt</code>  基类方法进行调用<ul><li>可能还是在传递实例后，由基类方法那边再进行额外多态判断？(书里确实也是这样说的)</li><li>sealed 就算有优化也是处于  <code>JIT</code>  时，毕竟并未改变  <code>il</code>  编译出来的调用指令 (当然理论上应该有，因为不用判断调用实例类型的子类了)</li></ul></li></ul><p>还有信息表示： <code>call</code>  调用申明类型方法， <code>callvirt</code>  调用变量指向对象的实际类型方法<br />更多可参考文章：<a href="https://zhuanlan.zhihu.com/p/21485914">用 MSIL 写程序：从 “call vs callvirt” 看方法调用<br /></a></p><p>这里只是了解了  <code>C#</code>  编译为  <code>IL</code>  时各方法的调用方式，按照相关信息， <code>JIT</code>  时还会有额外优化，例如说上面提到的  <code>sealed</code> <br /> 我们本身并不能控制什么时候必须用  <code>call</code>  指令，除非自己写  <code>IL</code>  代码，不过了解了各种情况编译结果，至少能更明白这些调用的差异。</p><p>其它：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL3poLWNuL2RvdG5ldC9hcGkvc3lzdGVtLnJlZmxlY3Rpb24uZW1pdC5vcGNvZGVzLmNhbGw/dmlldz1uZXQtNi4w">官方文档 - call</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL3poLWNuL2RvdG5ldC9hcGkvc3lzdGVtLnJlZmxlY3Rpb24uZW1pdC5vcGNvZGVzLmNhbGx2aXJ0P3ZpZXc9bmV0LTYuMA==">官方文档 - callvirt</span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;在 《CLR vir C#》一书中，有说明  &lt;code&gt;call&lt;/code&gt;  与  &lt;code&gt;callvirt&lt;/code&gt;  的差别：&lt;/p&gt;
&lt;ul&gt;
</summary>
      
    
    
    
    <category term="C#" scheme="https://wangjiaying.top/categories/C/"/>
    
    
    <category term="C#" scheme="https://wangjiaying.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C#结构体初始化测试</title>
    <link href="https://wangjiaying.top/2023/03/28/C-%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>https://wangjiaying.top/2023/03/28/C-%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%8B%E8%AF%95/</id>
    <published>2023-03-28T12:52:23.000Z</published>
    <updated>2023-06-04T11:42:34.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型"><a class="anchor" href="#原型">#</a> 原型</h1><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">ssss</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">aaaa</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token function">aaaa</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> a<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        x <span class="token operator">=</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        y <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">bbbb</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">public</span> <span class="token function">bbbb</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> a<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">this</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">bbbb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>对应 IL 代码：</p><h2 id="ssss-类"><a class="anchor" href="#ssss-类">#</a> ssss 类</h2><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name"><span class="token keyword">private</span></span> sequential ansi <span class="token keyword">sealed</span> beforefieldinit ssss</pre></td></tr><tr><td data-num="2"></td><td><pre>extends <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>ValueType</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// Fields</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">private</span> int32 x</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">private</span> int32 y</pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of class ssss</span></pre></td></tr></table></figure><h2 id="aaaa-类"><a class="anchor" href="#aaaa-类">#</a> aaaa 类</h2><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name"><span class="token keyword">private</span></span> sequential ansi <span class="token keyword">sealed</span> beforefieldinit aaaa</pre></td></tr><tr><td data-num="2"></td><td><pre>extends <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>ValueType</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// Fields</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">private</span> int32 x</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">private</span> int32 y</pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// Methods</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">public</span> hidebysig specialname rtspecialname </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token return-type class-name">instance</span> <span class="token keyword">void</span> <span class="token punctuation">.</span>ctor <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token class-name">int32</span> a</pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// Method begins at RVA 0x211c</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token comment">// Code size: 17 (0x11)</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>IL_0000<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="20"></td><td><pre>IL_0001<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="21"></td><td><pre>IL_0002<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="22"></td><td><pre>IL_0003<span class="token punctuation">:</span> stfld <span class="token class-name">int32</span> aaaa<span class="token punctuation">::</span><span class="token class-name">x</span></pre></td></tr><tr><td data-num="23"></td><td><pre>IL_0008<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="24"></td><td><pre>IL_0009<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span>s <span class="token number">100</span></pre></td></tr><tr><td data-num="25"></td><td><pre>IL_000b<span class="token punctuation">:</span> stfld <span class="token class-name">int32</span> aaaa<span class="token punctuation">::</span><span class="token class-name">y</span></pre></td></tr><tr><td data-num="26"></td><td><pre>IL_0010<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method aaaa::.ctor</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of class aaaa</span></pre></td></tr></table></figure><h2 id="bbbb-类"><a class="anchor" href="#bbbb-类">#</a> bbbb 类</h2><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name"><span class="token keyword">private</span></span> sequential ansi <span class="token keyword">sealed</span> beforefieldinit bbbb</pre></td></tr><tr><td data-num="2"></td><td><pre>extends <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>ValueType</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// Fields</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">private</span> int32 x</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">private</span> int32 y</pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// Methods</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">public</span> hidebysig specialname rtspecialname </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token return-type class-name">instance</span> <span class="token keyword">void</span> <span class="token punctuation">.</span>ctor <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token class-name">int32</span> a</pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// Method begins at RVA 0x211c</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token comment">// Code size: 16 (0x10)</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>IL_0000<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="20"></td><td><pre>IL_0001<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="21"></td><td><pre>IL_0002<span class="token punctuation">:</span> initobj <span class="token class-name">bbbb</span></pre></td></tr><tr><td data-num="22"></td><td><pre>IL_0008<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="23"></td><td><pre>IL_0009<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="24"></td><td><pre>IL_000a<span class="token punctuation">:</span> stfld <span class="token class-name">int32</span> bbbb<span class="token punctuation">::</span><span class="token class-name">y</span></pre></td></tr><tr><td data-num="25"></td><td><pre>IL_000f<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method bbbb::.ctor</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of class bbbb</span></pre></td></tr></table></figure><h1 id="调用"><a class="anchor" href="#调用">#</a> 调用</h1><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">ssss</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ssss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">bbbb</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">bbbb</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">aaaa</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">aaaa</span><span class="token punctuation">(</span><span class="token number">321</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>IL_0010<span class="token punctuation">:</span> ldloca<span class="token punctuation">.</span>s <span class="token number">0</span></pre></td></tr><tr><td data-num="2"></td><td><pre>IL_0012<span class="token punctuation">:</span> initobj <span class="token class-name">ssss</span></pre></td></tr><tr><td data-num="3"></td><td><pre>IL_0018<span class="token punctuation">:</span> ldloca<span class="token punctuation">.</span>s <span class="token number">1</span></pre></td></tr><tr><td data-num="4"></td><td><pre>IL_001a<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span>s <span class="token number">123</span></pre></td></tr><tr><td data-num="5"></td><td><pre>IL_001c<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> bbbb<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span>int32<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>IL_0021<span class="token punctuation">:</span> ldloca<span class="token punctuation">.</span>s <span class="token number">2</span></pre></td></tr><tr><td data-num="7"></td><td><pre>IL_0023<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4 <span class="token number">321</span></pre></td></tr><tr><td data-num="8"></td><td><pre>IL_0028<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> aaaa<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span>int32<span class="token punctuation">)</span></pre></td></tr></table></figure><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><ul><li>无自定义带参数构造函数，结构体直接外部调用  <code>initobj</code>  初始化</li><li>带自定义带参数构造函数，结构体自定义构造函数中可调用 new 操作符执行  <code>initobj</code>  初始化</li><li>带自定义带参数构造函数，初始化赋值走正常赋值</li></ul><blockquote><p>initobj：将位于指定地址的值类型的每个字段初始化为空引用或适当的基元类型的 0</p></blockquote><p>注：C# 10.0 才支持无参构造函数，因此之前的语法不支持内联初始化：<br /><img data-src="/blogimages/2023/2023-03-28/m_7f3cc3068f64c1bb758817b59357c6cb_r.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原型&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#原型&quot;&gt;#&lt;/a&gt; 原型&lt;/h1&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;figcaption data-lang=&quot;C#&quot;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td d</summary>
      
    
    
    
    <category term="C#" scheme="https://wangjiaying.top/categories/C/"/>
    
    
    <category term="C#" scheme="https://wangjiaying.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>再探TexturePacker命令行设置</title>
    <link href="https://wangjiaying.top/2023/02/24/%E5%86%8D%E6%8E%A2TexturePacker%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%BE%E7%BD%AE/"/>
    <id>https://wangjiaying.top/2023/02/24/%E5%86%8D%E6%8E%A2TexturePacker%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%BE%E7%BD%AE/</id>
    <published>2023-02-24T07:42:08.000Z</published>
    <updated>2023-06-04T11:42:34.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>在上一篇  <code>关于 AssetBundleManifest 使用</code>  文章我就写了，我们项目最近搞   <code>微信小游戏</code>  版本</p><p>那么这个版本肯定是主要面向  <code>国内</code> ，那么就可以考虑  <code>ASTC</code>  格式了，于是索性全部切为  <code>ASTC</code> ，安卓、IOS 统一</p><p>然后就发现，之前通过  <code>TexturePacker</code>  生成的  <code>UI图集</code>  ，基本上都是选择了  <code>Force Squared(强制方形分辨率)</code>  选项的 —— 应该是为了兼容  <code>IOS</code>  平台的  <code>PVRTC</code>  格式。</p><p>不过现在统一换成  <code>ASTC</code>  就没这样的必要了，免得浪费内存。</p><p>于是就想着批量处理一波</p><p>虽然其实很简单，不过还是记录一下，以后没准什么时候就又用到了。</p><h1 id="经过"><a class="anchor" href="#经过">#</a> 经过</h1><p>一开始本来想直接调用  <code>TexturePacker</code>  提供的命令行指令，直接重打包去掉  <code>强制立方体分辨率</code>  选项的，结果发现不行：</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWFuZHdlYi5jb20vdGV4dHVyZXBhY2tlci9kb2N1bWVudGF0aW9uL3RleHR1cmUtc2V0dGluZ3M=">文档 - Texture-settings</span></p><blockquote><p><strong>Force squared --force-squared</strong><br />Forces the texture to have a squared size.</p></blockquote><p>强制立方体分辨率选项的命令行就上边这么一行，没有额外参数 —— 也就是说：只能强制设置为立方体，若  <code>TPS</code>  本来就勾了，靠命令行就没法设置为  <code>False</code>  了：</p><p><img data-src="/blogimages/2023/2023-02-24/m_e1d1608e0a53db0ab51e4c1d3264f1b1_r.png" alt="" /></p><p>我尝试了在后面跟上各种额外参数，例如：</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>TexturePacker.exe Atlas_ChatView_New1.tps --force-squared <span class="token boolean">false</span></pre></td></tr></table></figure><p>确实也没什么效果。</p><p>然后偶然点开  <code>*.tps</code>  文件，发现这东西其实是  <code>Xml</code>  格式的  <code>纯文本</code> ！</p><p><img data-src="/blogimages/2023/2023-02-24/m_15da8ea6fc2ca3b339839a6d6895f86a_r.png" alt="" /></p><p>那这不就简单了，直接按照修改文本的方式改一波，再根据 tps 设置打一次图集就好了。</p><p>（虽然此时同事建议我找个初级的手改，不过感觉写代码也花不了多少时间，于是还是用代码处理了）</p><h1 id="重设代码"><a class="anchor" href="#重设代码">#</a> 重设代码</h1><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">MenuItem</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">"Tools/=>重设项目所有图集&lt;="</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ReSetting</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>EditorUtility<span class="token punctuation">.</span><span class="token function">DisplayDialog</span><span class="token punctuation">(</span><span class="token string">"提示"</span><span class="token punctuation">,</span> <span class="token string">"该操作将会重设项目所有图集，确定？"</span><span class="token punctuation">,</span> <span class="token string">"确定"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name"><span class="token keyword">string</span></span> resDir <span class="token operator">=</span> Path<span class="token punctuation">.</span><span class="token function">Combine</span><span class="token punctuation">(</span>Application<span class="token punctuation">.</span>dataPath<span class="token punctuation">,</span> <span class="token string">"Resources/Ui"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">ReSetting</span><span class="token punctuation">(</span><span class="token string">"第1个图集目录"</span><span class="token punctuation">,</span> Directory<span class="token punctuation">.</span><span class="token function">GetFiles</span><span class="token punctuation">(</span>resDir<span class="token punctuation">,</span> <span class="token string">"*.tps"</span><span class="token punctuation">,</span> SearchOption<span class="token punctuation">.</span>AllDirectories<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        resDir <span class="token operator">=</span> Path<span class="token punctuation">.</span><span class="token function">Combine</span><span class="token punctuation">(</span>Application<span class="token punctuation">.</span>dataPath<span class="token punctuation">,</span> <span class="token string">"Resources/Ui_New"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">ReSetting</span><span class="token punctuation">(</span><span class="token string">"第2个图集目录"</span><span class="token punctuation">,</span> Directory<span class="token punctuation">.</span><span class="token function">GetFiles</span><span class="token punctuation">(</span>resDir<span class="token punctuation">,</span> <span class="token string">"*.tps"</span><span class="token punctuation">,</span> SearchOption<span class="token punctuation">.</span>AllDirectories<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        resDir <span class="token operator">=</span> Path<span class="token punctuation">.</span><span class="token function">Combine</span><span class="token punctuation">(</span>Application<span class="token punctuation">.</span>dataPath<span class="token punctuation">,</span> <span class="token string">"Resources/UIPrefab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token function">ReSetting</span><span class="token punctuation">(</span><span class="token string">"第3个图集目录"</span><span class="token punctuation">,</span> Directory<span class="token punctuation">.</span><span class="token function">GetFiles</span><span class="token punctuation">(</span>resDir<span class="token punctuation">,</span> <span class="token string">"*.tps"</span><span class="token punctuation">,</span> SearchOption<span class="token punctuation">.</span>AllDirectories<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    EditorUtility<span class="token punctuation">.</span><span class="token function">ClearProgressBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ReSetting</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> tipsName<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> atlasTpsList<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token class-name"><span class="token keyword">string</span></span> path<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> lines<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token class-name"><span class="token keyword">string</span></span> line<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> atlasTpsList<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        EditorUtility<span class="token punctuation">.</span><span class="token function">DisplayProgressBar</span><span class="token punctuation">(</span><span class="token string">"处理："</span> <span class="token operator">+</span> tipsName<span class="token punctuation">,</span> <span class="token keyword">string</span><span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"当前处理进度：&#123;0&#125;/&#123;1&#125;"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> atlasTpsList<span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>atlasTpsList<span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        path <span class="token operator">=</span> atlasTpsList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        lines <span class="token operator">=</span> File<span class="token punctuation">.</span><span class="token function">ReadAllLines</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> lineindex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> lineindex <span class="token operator">&lt;</span> lines<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> lineindex<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            line <span class="token operator">=</span> lines<span class="token punctuation">[</span>lineindex<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">EndsWith</span><span class="token punctuation">(</span><span class="token string">"&lt;key>maxTextureSize&lt;/key>"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                <span class="token function">ReSetSize</span><span class="token punctuation">(</span>lines<span class="token punctuation">,</span> <span class="token keyword">ref</span> lineindex<span class="token punctuation">,</span> <span class="token string">"2048"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">EndsWith</span><span class="token punctuation">(</span><span class="token string">"&lt;key>fixedTextureSize&lt;/key>"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>                <span class="token function">ReSetSize</span><span class="token punctuation">(</span>lines<span class="token punctuation">,</span> <span class="token keyword">ref</span> lineindex<span class="token punctuation">,</span> <span class="token string">"-1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">EndsWith</span><span class="token punctuation">(</span><span class="token string">"&lt;key>forceSquared&lt;/key>"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                lines<span class="token punctuation">[</span><span class="token operator">++</span>lineindex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"            &lt;false/>"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>        File<span class="token punctuation">.</span><span class="token function">WriteAllLines</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> lines<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="44"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="45"></td><td><pre></pre></td></tr><tr><td data-num="46"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">ReSetSize</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> lines<span class="token punctuation">,</span> <span class="token keyword">ref</span> <span class="token class-name"><span class="token keyword">int</span></span> index<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> size<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="47"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>    index<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>    lines<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"        &lt;QSize>"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>    lines<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"            &lt;key>width&lt;/key>"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>    lines<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">string</span><span class="token punctuation">.</span><span class="token function">Concat</span><span class="token punctuation">(</span><span class="token string">"            &lt;int>"</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token string">"&lt;/int>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>    lines<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"            &lt;key>height&lt;/key>"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>    lines<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">string</span><span class="token punctuation">.</span><span class="token function">Concat</span><span class="token punctuation">(</span><span class="token string">"            &lt;int>"</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token string">"&lt;/int>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>    lines<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"        &lt;/QSize>"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="55"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>就是这样，TexturePacker 提供的命令行参数感觉比较散，更适合纯命令行调用，比如一开始就写打图集的脚本，规定好各项参数。</p><p>要是加上  <code>TPS</code>   设置的话，有些参数就没法去修改了。</p><p>不过还好  <code>TPS</code>  文本本身是纯文本，要是二进制，那要是不深入研究官方的存储格式，可能就真只能手改了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;在上一篇  &lt;code&gt;关于 AssetBundleManifest 使用&lt;/code&gt;  文章我就写了，我们项目最近搞   &lt;code&gt;微信小游戏&lt;/code&gt; </summary>
      
    
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/categories/Unity3D/"/>
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/tags/Unity3D/"/>
    
    <category term="工具" scheme="https://wangjiaying.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>关于AssetBundleManifest使用疑问</title>
    <link href="https://wangjiaying.top/2023/02/17/%E5%85%B3%E4%BA%8EAssetBundleManifest%E4%BD%BF%E7%94%A8/"/>
    <id>https://wangjiaying.top/2023/02/17/%E5%85%B3%E4%BA%8EAssetBundleManifest%E4%BD%BF%E7%94%A8/</id>
    <published>2023-02-17T08:06:22.000Z</published>
    <updated>2023-06-04T11:42:34.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>最近项目在做  <code>微信小游戏</code>  版本，因此所有的  <code>AssetBundle</code>  都得加上  <code>AppendHashToAssetBundleName</code> ，据说主要是用于解决缓存问题。</p><p>例如<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vd2VjaGF0LW1pbmlnYW1lL21pbmlnYW1lLXVuaXR5LXdlYmdsLXRyYW5zZm9ybS9ibG9iL21haW4vRGVzaWduL1VzaW5nQXNzZXRCdW5kbGUubWQ=">文档</span>：</p><blockquote><ul><li>【重要】BuildAssetBundleOptions.AppendHashToAssetBundleName：bundle 带上 hash。在小游戏底层对 bundle 做缓存及缓存淘汰时，hash 是重要依据。</li></ul></blockquote><p>—— 这也导致了我们打包的一个问题，所有的  <code>AssetBundle</code>  打完之后，实际的名字都被改变了 (而且可以预期的是每次资源发生变化都会变)：</p><p><img data-src="/uploads/e0538/images/m_f13018ba3404b4ee16174dae9e636ade_r.png" alt="" /></p><p>如果依照正常的名字去  <code>AssetBundle.LoadFromFile(&quot;XXXX&quot;)</code>  那肯定就是不行的了。</p><p>而且我们项目走的是自己的一套依赖管理，维护了一张自己的依赖表：</p><ul><li>首先计算出依赖关系，生成依赖表</li><li>然后再根据计算的依赖表设置  <code>AssetBundleName</code></li><li>最后调用  <code>BuildPipeline.BuildAssetBundles</code>  打包。</li></ul><p>也即是  <code>先有依赖表，再有 AssetBundleName 资源</code>  这种模式。</p><p>而非直接从 Unity 的  <code>manifest</code>  生成，所以存在当最终  <code>AssetBundleName</code>  文件名发生改变后，与自己依赖表中的对应名字对不上的情况。</p><p>比如像上面那样资源打包参数要是加上  <code>AppendHashToAssetBundleName</code>  ，最终生成的  <code>AssetBundle</code>  文件名就会存在这样的问题 —— 因此就需要在资源打包完成后，读取  <code>AssetBundleManifest</code>  将自己先前的名称替换为最终带  <code>Hash</code>  的名字。</p><h1 id="工具"><a class="anchor" href="#工具">#</a> 工具</h1><p>Unity2021.2.5f1</p><h1 id="经过"><a class="anchor" href="#经过">#</a> 经过</h1><h2 id="更改依赖表"><a class="anchor" href="#更改依赖表">#</a> 更改依赖表</h2><p>最初以为是个很简单的处理，毕竟也两步而已：</p><ol><li>读取生成后  <code>.AssetBundleManifest</code></li><li>替换掉之前依赖表的常规名字</li><li>保存依赖表，并单打依赖表  <code>AssetBundle</code>  包</li></ol><p>结果实际操作的时候，在第一步就为难了：有编辑器工具可以直接读取  <code>AssetBundleManifest</code>  文件吗？</p><p>找不到啊...</p><p>使用  <code>AssetDatabase.LoadMainAssetAtPath</code>  加载返回的竟然是  <code>UnityEngine.DefaultAsset</code>  类型的对象：</p><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>AssetDatabase.LoadMainAssetAtPath<span class="token punctuation">(</span><span class="token string">"Assets/StreamingAssets/StreamingResources/StreamingResources.manifest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token string">"StreamingResources (UnityEngine.DefaultAsset)"</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    base: <span class="token string">"StreamingResources (UnityEngine.DefaultAsset)"</span></pre></td></tr></table></figure><p>自己研究了下，编辑器提供的  <code>Editor</code>  接口基本没有好用的，查了下几乎都说得先加载  <code>AssetBundle</code>  本身，然后再通过  <code>LoadAsset&lt;AssetBundleManifest&gt;</code>  使用：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">AssetBundle</span> assetBundle <span class="token operator">=</span> AssetBundle<span class="token punctuation">.</span><span class="token function">LoadFromFile</span><span class="token punctuation">(</span>Path<span class="token punctuation">.</span><span class="token function">Combine</span><span class="token punctuation">(</span>Application<span class="token punctuation">.</span>streamingAssetsPath<span class="token punctuation">,</span> <span class="token string">"StreamingResources/StreamingResources"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">AssetBundleManifest</span> manifest <span class="token operator">=</span> assetBundle<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">LoadAsset</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>AssetBundleManifest<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token string">"AssetBundleManifest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>而打包完资源，唯一没被附加  <code>Hash</code>  值导致改名的，唯有与目标目录同名的  <code>主清单文件</code> <br />这就没办法了，直接加载  <code>AssetBundleManifest</code>  的想法最终放弃，采用加载主清单文件，生成一个字典，然后对比自己的依赖表给改过去。<br /><font color=red>注：主清单 AssetBundleManifest 信息在调用打包时也会直接返回</font></p><p>主要代码如下：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> <span class="token function">BeginReadPackmanifestNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">AssetBundle</span> bundle <span class="token operator">=</span> AssetBundle<span class="token punctuation">.</span><span class="token function">LoadFromFile</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">.</span><span class="token function">Concat</span><span class="token punctuation">(</span>Application<span class="token punctuation">.</span>dataPath<span class="token punctuation">,</span> <span class="token string">"/../"</span><span class="token punctuation">,</span> EditorPackDef<span class="token punctuation">.</span>AssetBundleCacheDir<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">,</span> EditorPackDef<span class="token punctuation">.</span>AssetBundleCacheDir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bundle <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        EditorUtility<span class="token punctuation">.</span><span class="token function">DisplayDialog</span><span class="token punctuation">(</span><span class="token string">"错误"</span><span class="token punctuation">,</span> <span class="token string">"未找到依赖总表！"</span><span class="token punctuation">,</span> <span class="token string">"错误！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    _packHashNamesDic <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Dictionary<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">string</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">14000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token class-name">AssetBundleManifest</span> manifest <span class="token operator">=</span> bundle<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">LoadAsset</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>AssetBundleManifest<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token string">"AssetBundleManifest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> allAssets <span class="token operator">=</span> manifest<span class="token punctuation">.</span><span class="token function">GetAllAssetBundles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">//string name;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token class-name"><span class="token keyword">int</span></span> num<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token class-name"><span class="token keyword">bool</span></span> haveTail<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">const</span> <span class="token class-name"><span class="token keyword">string</span></span> tail <span class="token operator">=</span> <span class="token string">".assetbundle"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> item <span class="token keyword">in</span> allAssets<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        haveTail <span class="token operator">=</span> item<span class="token punctuation">.</span><span class="token function">EndsWith</span><span class="token punctuation">(</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        num <span class="token operator">=</span> item<span class="token punctuation">.</span>Length <span class="token operator">-</span> <span class="token punctuation">(</span>haveTail <span class="token punctuation">?</span> <span class="token number">45</span> <span class="token punctuation">:</span> <span class="token number">33</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        _packHashNamesDic<span class="token punctuation">[</span><span class="token keyword">string</span><span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>num <span class="token operator">+</span> <span class="token punctuation">(</span>haveTail <span class="token punctuation">?</span> tail<span class="token punctuation">.</span>Length <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>item<span class="token punctuation">,</span> num<span class="token punctuation">,</span> haveTail<span class="token punctuation">,</span> tail<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>str<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">=></span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            v<span class="token punctuation">.</span>item<span class="token punctuation">.</span><span class="token function">AsSpan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">CopyTo</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>haveTail<span class="token punctuation">)</span> v<span class="token punctuation">.</span>tail<span class="token punctuation">.</span><span class="token function">AsSpan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">CopyTo</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">Slice</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>也可以有其它方式：比如直接解析文本，但是那种感觉更不大好。</p><h2 id="二次打包报-warning"><a class="anchor" href="#二次打包报-warning">#</a> 二次打包报 Warning</h2><p>提示如下：</p><p><code>Assets in StreamingAssets cannot be included in AssetBundles: &quot;XXXXXX&quot;</code></p><p>不清楚是不是我们升级了 Unity 版本的问题？</p><p>毕竟是我直接将其从 Unity2018 升级到 Unity2021.2.5 的..... 公司其它项目说没碰到过，而之前 Unity2018 也没碰到过，已经没法确认是不是版本升级导致的了。</p><p>经过反复测试，发现只要  <code>StreamingAssets</code>  存在  <code>.assetbundle</code>  文件，就会直接报上述 Warning（虽然最终文件看着没什么问题，该重打的看着还是被重新更新了）</p><p>后面同事建议将所有  <code>AssetBundle</code>  打包至 Unity 工程目录外，然后再复制进  <code>StreamingAssets</code></p><h1 id="问题"><a class="anchor" href="#问题">#</a> 问题</h1><p>所以，除了先加载 AssetBundle，然后通过  <code>assetBundle.LoadAsset&lt;AssetBundleManifest&gt;</code>  以及直接纯文本读取方式外，Unity 还有其它方式加载  <code>AssetBundleManifest</code>  吗？</p><hr /><ul><li>参考文档：<ul><li><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS51bml0eS5jb20vdGhyZWFkcy9ob3ctdG8tZ2V0LWFzc2V0YnVuZGxlbWFuaWZlc3QuNDk1NDk0Lw==">How to get AssetBundleManifest</span></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;最近项目在做  &lt;code&gt;微信小游戏&lt;/code&gt;  版本，因此所有的  &lt;code&gt;AssetBundle&lt;/code&gt;  都得加上  &lt;code&gt;Append</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/categories/Unity3D/"/>
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/tags/Unity3D/"/>
    
    <category term="AssetBundle" scheme="https://wangjiaying.top/tags/AssetBundle/"/>
    
  </entry>
  
  <entry>
    <title>从IL代码分析C#匿名函数的原理</title>
    <link href="https://wangjiaying.top/2023/02/08/%E4%BB%8EIL%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90C-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://wangjiaying.top/2023/02/08/%E4%BB%8EIL%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90C-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2023-02-08T09:37:23.000Z</published>
    <updated>2023-06-04T11:42:34.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>匿名函数平时用得太常见了，平时都知道说用多了不好。</p><p>为什么不好？原因呢？</p><p>特别是涉及到造成  <code>闭包</code>  的匿名函数，其原理是什么？闭包  <code>抓住</code>  的的局部变量怎么处理的？</p><p>众所周知  <code>匿名函数</code>  其实是  <code>C#</code>  提供的一种  <code>语法糖</code> ，最终还是会由编译器生成具体的函数。</p><p>不过之前一直没有深入去研究，这次带着这个疑问，我决定利用反编译的  <code>IL</code>  代码详细研究下，对比各种匿名函数写法，看看最后究竟生成了什么。</p><h1 id="分类"><a class="anchor" href="#分类">#</a> 分类</h1><p>C# 匿名函数中，个人觉得从使用方式上主要可以分为以下几类：</p><ul><li>基本匿名函数：指没有抓住任何局部变量或成员变量，单纯执行自己的逻辑</li><li>调用成员变量的匿名函数：引用了类中的成员变量</li><li>带闭包的匿名函数：引用了调用方法的局部变量<ul><li>仅一个匿名函数所使用</li><li>多个匿名函数共同使用同一个局部变量</li><li>多个匿名函数使用不同的局部变量</li><li>缓存 for 循环 index 的闭包</li></ul></li></ul><p>我也就大概就以这几类为例，观察其编译为  <code>IL</code>  代码后变成了什么样子</p><h1 id="测试"><a class="anchor" href="#测试">#</a> 测试</h1><p>首先，为了对比，定义的一个最基本的测试类如下：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>然后查看什么都没有的情况下，这个空类有什么东西：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name"><span class="token keyword">public</span></span> auto ansi beforefieldinit MyClass</pre></td></tr><tr><td data-num="2"></td><td><pre>extends <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// Methods</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">public</span> hidebysig specialname rtspecialname</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token return-type class-name">instance</span> <span class="token keyword">void</span> <span class="token punctuation">.</span>ctor <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// Method begins at RVA 0x2050</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// Code size: 9 (0x9)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>IL_0000<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="14"></td><td><pre>IL_0001<span class="token punctuation">:</span> call instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>IL_0006<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="16"></td><td><pre>IL_0007<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="17"></td><td><pre>IL_0008<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method MyClass::.ctor</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of class MyClass</span></pre></td></tr></table></figure><h2 id="普通成员方法回调"><a class="anchor" href="#普通成员方法回调">#</a> 普通成员方法回调</h2><p>为了对比，先测试一下普通的回调：指自己在类中手动定义成员函数作为回调传入。</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">DoAction</span><span class="token punctuation">(</span>Action<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token class-name">Action</span> callback<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Action</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"DO"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>生成  <code>IL</code>  代码如下：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name"><span class="token keyword">public</span></span> auto ansi beforefieldinit MyClass</pre></td></tr><tr><td data-num="2"></td><td><pre>extends <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// Methods</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">public</span> hidebysig specialname rtspecialname </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token return-type class-name">instance</span> <span class="token keyword">void</span> <span class="token punctuation">.</span>ctor <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// Method begins at RVA 0x2050</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// Code size: 28 (0x1c)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>IL_0000<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="14"></td><td><pre>IL_0001<span class="token punctuation">:</span> call instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>IL_0006<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="16"></td><td><pre>IL_0007<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="17"></td><td><pre>IL_0008<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="18"></td><td><pre>IL_0009<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="19"></td><td><pre>IL_000a<span class="token punctuation">:</span> ldftn instance <span class="token class-name"><span class="token keyword">void</span></span> MyClass<span class="token punctuation">::</span><span class="token function">Action</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>IL_0010<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token punctuation">.</span>ctor<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">,</span> native <span class="token keyword">int</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="21"></td><td><pre>IL_0015<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> MyClass<span class="token punctuation">::</span><span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>IL_001a<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="23"></td><td><pre>IL_001b<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method MyClass::.ctor</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">private</span> hidebysig </pre></td></tr><tr><td data-num="27"></td><td><pre>instance <span class="token return-type class-name"><span class="token keyword">void</span></span> DoAction <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span><span class="token class-name">System<span class="token punctuation">.</span>Action</span> callback</pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token comment">// Method begins at RVA 0x206d</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token comment">// Code size: 9 (0x9)</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre>IL_0000<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="37"></td><td><pre>IL_0001<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="38"></td><td><pre>IL_0002<span class="token punctuation">:</span> callvirt instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre>IL_0007<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="40"></td><td><pre>IL_0008<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method MyClass::DoAction</span></pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">private</span> hidebysig </pre></td></tr><tr><td data-num="44"></td><td><pre>instance <span class="token return-type class-name"><span class="token keyword">void</span></span> Action <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="45"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="46"></td><td><pre><span class="token comment">// Method begins at RVA 0x2077</span></pre></td></tr><tr><td data-num="47"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="48"></td><td><pre><span class="token comment">// Code size: 13 (0xd)</span></pre></td></tr><tr><td data-num="49"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="50"></td><td><pre></pre></td></tr><tr><td data-num="51"></td><td><pre>IL_0000<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="52"></td><td><pre>IL_0001<span class="token punctuation">:</span> ldstr <span class="token string">"DO"</span></pre></td></tr><tr><td data-num="53"></td><td><pre>IL_0006<span class="token punctuation">:</span> call <span class="token keyword">void</span> <span class="token punctuation">[</span>UnityEngine<span class="token punctuation">.</span>CoreModule<span class="token punctuation">]</span>UnityEngine<span class="token punctuation">.</span>Debug<span class="token punctuation">::</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="54"></td><td><pre>IL_000b<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="55"></td><td><pre>IL_000c<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="56"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method MyClass::Action</span></pre></td></tr><tr><td data-num="57"></td><td><pre></pre></td></tr><tr><td data-num="58"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of class MyClass</span></pre></td></tr></table></figure><p>可以看出，生成的  <code>IL</code>  代码中也是单纯的由  <code>构造函数</code>  + <code>DoAction</code> + <code>Action</code>  三个成员函数过程，没有什么特别的问题。</p><h2 id="基本匿名函数"><a class="anchor" href="#基本匿名函数">#</a> 基本匿名函数</h2><p>接着，就轮到普通匿名函数了。</p><p>将上面传参修改为匿名函数方式：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Log: DoAction"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>编译后  <code>IL</code>  代码如下：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name"><span class="token keyword">public</span></span> auto ansi beforefieldinit MyClass</pre></td></tr><tr><td data-num="2"></td><td><pre>extends <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// Nested Types</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name">nested</span> <span class="token keyword">private</span> auto ansi <span class="token keyword">sealed</span> serializable beforefieldinit '<span class="token operator">&lt;</span><span class="token operator">></span>c'</pre></td></tr><tr><td data-num="6"></td><td><pre>extends <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">.</span>custom instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>CompilerServices<span class="token punctuation">.</span>CompilerGeneratedAttribute<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token number">01</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// Fields</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">public</span> <span class="token keyword">static</span> initonly <span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c<span class="token char">' '</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9</span>'</pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action '<span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9__0_0</span>'</pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// Methods</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">private</span> hidebysig specialname rtspecialname <span class="token keyword">static</span> </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">void</span> <span class="token punctuation">.</span>cctor <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment">// Method begins at RVA 0x2139</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment">// Code size: 11 (0xb)</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>IL_0000<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c'<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>IL_0005<span class="token punctuation">:</span> stsfld <span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c' MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9</span>'</pre></td></tr><tr><td data-num="26"></td><td><pre>IL_000a<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method '&lt;>c'::.cctor</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">public</span> hidebysig specialname rtspecialname </pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token return-type class-name">instance</span> <span class="token keyword">void</span> <span class="token punctuation">.</span>ctor <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token comment">// Method begins at RVA 0x2145</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token comment">// Code size: 8 (0x8)</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="36"></td><td><pre></pre></td></tr><tr><td data-num="37"></td><td><pre>IL_0000<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="38"></td><td><pre>IL_0001<span class="token punctuation">:</span> call instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre>IL_0006<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="40"></td><td><pre>IL_0007<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method '&lt;>c'::.ctor</span></pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token punctuation">.</span>method assembly hidebysig </pre></td></tr><tr><td data-num="44"></td><td><pre>instance <span class="token keyword">void</span> '<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__0_0' <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="45"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="46"></td><td><pre><span class="token comment">// Method begins at RVA 0x214e</span></pre></td></tr><tr><td data-num="47"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="48"></td><td><pre><span class="token comment">// Code size: 12 (0xc)</span></pre></td></tr><tr><td data-num="49"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="50"></td><td><pre></pre></td></tr><tr><td data-num="51"></td><td><pre>IL_0000<span class="token punctuation">:</span> ldstr <span class="token string">"Log: DoAction"</span></pre></td></tr><tr><td data-num="52"></td><td><pre>IL_0005<span class="token punctuation">:</span> call <span class="token keyword">void</span> <span class="token punctuation">[</span>UnityEngine<span class="token punctuation">.</span>CoreModule<span class="token punctuation">]</span>UnityEngine<span class="token punctuation">.</span>Debug<span class="token punctuation">::</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="53"></td><td><pre>IL_000a<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="54"></td><td><pre>IL_000b<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="55"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method '&lt;>c'::'&lt;.ctor>b__0_0'</span></pre></td></tr><tr><td data-num="56"></td><td><pre></pre></td></tr><tr><td data-num="57"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of class &lt;>c</span></pre></td></tr><tr><td data-num="58"></td><td><pre></pre></td></tr><tr><td data-num="59"></td><td><pre></pre></td></tr><tr><td data-num="60"></td><td><pre><span class="token comment">// Methods</span></pre></td></tr><tr><td data-num="61"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">public</span> hidebysig specialname rtspecialname </pre></td></tr><tr><td data-num="62"></td><td><pre><span class="token return-type class-name">instance</span> <span class="token keyword">void</span> <span class="token punctuation">.</span>ctor <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="63"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="64"></td><td><pre><span class="token comment">// Method begins at RVA 0x2050</span></pre></td></tr><tr><td data-num="65"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="66"></td><td><pre><span class="token comment">// Code size: 47 (0x2f)</span></pre></td></tr><tr><td data-num="67"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="68"></td><td><pre></pre></td></tr><tr><td data-num="69"></td><td><pre>IL_0000<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="70"></td><td><pre>IL_0001<span class="token punctuation">:</span> call instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="71"></td><td><pre>IL_0006<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="72"></td><td><pre>IL_0007<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="73"></td><td><pre>IL_0008<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="74"></td><td><pre>IL_0009<span class="token punctuation">:</span> ldsfld <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9__0_0</span>'</pre></td></tr><tr><td data-num="75"></td><td><pre>IL_000e<span class="token punctuation">:</span> <span class="token class-name">dup</span></pre></td></tr><tr><td data-num="76"></td><td><pre>IL_000f<span class="token punctuation">:</span> brtrue<span class="token punctuation">.</span>s <span class="token class-name">IL_0028</span></pre></td></tr><tr><td data-num="77"></td><td><pre></pre></td></tr><tr><td data-num="78"></td><td><pre>IL_0011<span class="token punctuation">:</span> <span class="token class-name">pop</span></pre></td></tr><tr><td data-num="79"></td><td><pre>IL_0012<span class="token punctuation">:</span> ldsfld <span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c' MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9</span>'</pre></td></tr><tr><td data-num="80"></td><td><pre>IL_0017<span class="token punctuation">:</span> ldftn instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__0_0'<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="81"></td><td><pre>IL_001d<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token punctuation">.</span>ctor<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">,</span> native <span class="token keyword">int</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="82"></td><td><pre>IL_0022<span class="token punctuation">:</span> <span class="token class-name">dup</span></pre></td></tr><tr><td data-num="83"></td><td><pre>IL_0023<span class="token punctuation">:</span> stsfld <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9__0_0</span>'</pre></td></tr><tr><td data-num="84"></td><td><pre></pre></td></tr><tr><td data-num="85"></td><td><pre>IL_0028<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> MyClass<span class="token punctuation">::</span><span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="86"></td><td><pre>IL_002d<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="87"></td><td><pre>IL_002e<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="88"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method MyClass::.ctor</span></pre></td></tr><tr><td data-num="89"></td><td><pre></pre></td></tr><tr><td data-num="90"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">private</span> hidebysig </pre></td></tr><tr><td data-num="91"></td><td><pre>instance <span class="token return-type class-name"><span class="token keyword">void</span></span> DoAction <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="92"></td><td><pre><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span><span class="token class-name">System<span class="token punctuation">.</span>Action</span> callback</pre></td></tr><tr><td data-num="93"></td><td><pre><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed</pre></td></tr><tr><td data-num="94"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="95"></td><td><pre><span class="token comment">// Method begins at RVA 0x2080</span></pre></td></tr><tr><td data-num="96"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="97"></td><td><pre><span class="token comment">// Code size: 9 (0x9)</span></pre></td></tr><tr><td data-num="98"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="99"></td><td><pre></pre></td></tr><tr><td data-num="100"></td><td><pre>IL_0000<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="101"></td><td><pre>IL_0001<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="102"></td><td><pre>IL_0002<span class="token punctuation">:</span> callvirt instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="103"></td><td><pre>IL_0007<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="104"></td><td><pre>IL_0008<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="105"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method MyClass::DoAction</span></pre></td></tr><tr><td data-num="106"></td><td><pre></pre></td></tr><tr><td data-num="107"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of class MyClass</span></pre></td></tr></table></figure><h3 id="分析"><a class="anchor" href="#分析">#</a> 分析</h3><p>这时候，在原有的类中已经多了一个名为  <code>&lt;&gt;c</code>  的 Nested Types 的新类。</p><p>一步一步来看。</p><p>首先是包括的两个公共的静态字段：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Fields</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 这个该是自己类的实例</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">public</span> <span class="token keyword">static</span> initonly <span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c<span class="token char">' '</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9</span>'</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 绑定的委托实例</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action '<span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9__0_0</span>'</pre></td></tr></table></figure><p>在构造方法中有对这个名为  <code>&lt;&gt;c</code>  的内嵌类做初始化：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>IL_0000<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c'<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>IL_0005<span class="token punctuation">:</span> stsfld <span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c' MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9</span>'</pre></td></tr></table></figure><p>也就是说，一定程度上可以认为这是一个单例（虽然似乎并不标准？）。</p><p>而原本我们的匿名函数则被编译为新类中名为  <code>b__0_0</code>  的方法：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span>method assembly hidebysig</pre></td></tr><tr><td data-num="2"></td><td><pre>instance <span class="token keyword">void</span> '<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__0_0' <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// Method begins at RVA 0x214e</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// Code size: 12 (0xc)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>IL_0000<span class="token punctuation">:</span> ldstr <span class="token string">"Log: DoAction"</span></pre></td></tr><tr><td data-num="10"></td><td><pre>IL_0005<span class="token punctuation">:</span> call <span class="token keyword">void</span> <span class="token punctuation">[</span>UnityEngine<span class="token punctuation">.</span>CoreModule<span class="token punctuation">]</span> UnityEngine<span class="token punctuation">.</span>Debug<span class="token punctuation">::</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    IL_000a<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    IL_000b<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method '&lt;>c'::'&lt;.ctor>b__0_0'</span></pre></td></tr></table></figure><p>根据代码逻辑来看，字段  <code>&lt;&gt;9__0_0(委托)</code>  用于存放  <code>b__0_0(原本匿名方法)</code>  方法的绑定，其类型就是我们常用的内置  <code>Action</code>  委托。</p><p>若下次调用时这一项判断有值，就会直接调用  <code>&lt;&gt;9__0_0(委托)</code>  ，否则创建委托并将  <code>b__0_0(原本匿名方法)</code>  与  <code>&lt;&gt;9__0_0(委托)</code>  进行初始化绑定。</p><p>如下代码所示：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>IL_0008<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="2"></td><td><pre>IL_0009<span class="token punctuation">:</span> ldsfld <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9__0_0</span>'</pre></td></tr><tr><td data-num="3"></td><td><pre>IL_000e<span class="token punctuation">:</span> <span class="token class-name">dup</span></pre></td></tr><tr><td data-num="4"></td><td><pre>IL_000f<span class="token punctuation">:</span> brtrue<span class="token punctuation">.</span>s <span class="token class-name">IL_0028</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>IL_0011<span class="token punctuation">:</span> <span class="token class-name">pop</span></pre></td></tr><tr><td data-num="7"></td><td><pre>IL_0012<span class="token punctuation">:</span> ldsfld <span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c' MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9</span>'</pre></td></tr><tr><td data-num="8"></td><td><pre>IL_0017<span class="token punctuation">:</span> ldftn instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__0_0'<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>IL_001d<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token punctuation">.</span>ctor<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">,</span> native <span class="token keyword">int</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="10"></td><td><pre>IL_0022<span class="token punctuation">:</span> <span class="token class-name">dup</span></pre></td></tr><tr><td data-num="11"></td><td><pre>IL_0023<span class="token punctuation">:</span> stsfld <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9__0_0</span>'</pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>IL_0028<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> MyClass<span class="token punctuation">::</span><span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">)</span></pre></td></tr></table></figure><p>使用静态字段配合类似单例的模式，应该是为了优化性能，这样如果实例化了多个  <code>MyClass</code>  的话，就只会存在有一份委托实例。</p><p>但是这样的话，为什么不直接编译为成员函数？</p><p>之前个人其实一直猜测：普通的匿名函数可能是直接编译为本类的成员函数的。</p><p>而在这里的事实  <code>推翻了</code>  猜测。</p><h3 id="其它"><a class="anchor" href="#其它">#</a> 其它</h3><p>使用单独方法调用的匿名函数，也是一样的情况，委托会在调用之处进行判断及绑定<br />如下单独成员函数中编译成的  <code>IL</code>  代码与上面一致：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DoTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Log: DoAction"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>多个这种类型的匿名函数也是一样，只是对应增加了  <code>Action</code>  类型的委托字段，比如再加一个同类匿名函数：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Fields</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">public</span> <span class="token keyword">static</span> initonly <span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c<span class="token char">' '</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9</span>'</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action '<span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9__0_0</span>'</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action '<span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9__1_0</span>'</pre></td></tr></table></figure><h2 id="调用成员变量的匿名函数"><a class="anchor" href="#调用成员变量的匿名函数">#</a> 调用成员变量的匿名函数</h2><p>测试的 C# 代码如下：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">int</span></span> _myValue<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Log Value:"</span> <span class="token operator">+</span> _myValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token class-name">Action</span> callback<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编译后 IL 代码：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name"><span class="token keyword">public</span></span> auto ansi beforefieldinit MyClass</pre></td></tr><tr><td data-num="2"></td><td><pre>extends <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// Fields</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">private</span> int32 _myValue</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// Methods</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">public</span> hidebysig specialname rtspecialname </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token return-type class-name">instance</span> <span class="token keyword">void</span> <span class="token punctuation">.</span>ctor <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// Method begins at RVA 0x2050</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// Code size: 28 (0x1c)</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>IL_0000<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="17"></td><td><pre>IL_0001<span class="token punctuation">:</span> call instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>IL_0006<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="19"></td><td><pre>IL_0007<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="20"></td><td><pre>IL_0008<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="21"></td><td><pre>IL_0009<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="22"></td><td><pre>IL_000a<span class="token punctuation">:</span> ldftn instance <span class="token class-name"><span class="token keyword">void</span></span> MyClass<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__1_0'<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>IL_0010<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token punctuation">.</span>ctor<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">,</span> native <span class="token keyword">int</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="24"></td><td><pre>IL_0015<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> MyClass<span class="token punctuation">::</span><span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>IL_001a<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="26"></td><td><pre>IL_001b<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method MyClass::.ctor</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">private</span> hidebysig </pre></td></tr><tr><td data-num="30"></td><td><pre>instance <span class="token return-type class-name"><span class="token keyword">void</span></span> DoAction <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span><span class="token class-name">System<span class="token punctuation">.</span>Action</span> callback</pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token comment">// Method begins at RVA 0x206d</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token comment">// Code size: 9 (0x9)</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre>IL_0000<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="40"></td><td><pre>IL_0001<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="41"></td><td><pre>IL_0002<span class="token punctuation">:</span> callvirt instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="42"></td><td><pre>IL_0007<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="43"></td><td><pre>IL_0008<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="44"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method MyClass::DoAction</span></pre></td></tr><tr><td data-num="45"></td><td><pre></pre></td></tr><tr><td data-num="46"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">private</span> hidebysig </pre></td></tr><tr><td data-num="47"></td><td><pre>instance <span class="token keyword">void</span> '<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__1_0' <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="48"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="49"></td><td><pre><span class="token punctuation">.</span>custom instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>CompilerServices<span class="token punctuation">.</span>CompilerGeneratedAttribute<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="50"></td><td><pre><span class="token number">01</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span></pre></td></tr><tr><td data-num="51"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="52"></td><td><pre><span class="token comment">// Method begins at RVA 0x2077</span></pre></td></tr><tr><td data-num="53"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="54"></td><td><pre><span class="token comment">// Code size: 28 (0x1c)</span></pre></td></tr><tr><td data-num="55"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="56"></td><td><pre></pre></td></tr><tr><td data-num="57"></td><td><pre>IL_0000<span class="token punctuation">:</span> ldstr <span class="token string">"Log Value:"</span></pre></td></tr><tr><td data-num="58"></td><td><pre>IL_0005<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="59"></td><td><pre>IL_0006<span class="token punctuation">:</span> ldflda <span class="token class-name">int32</span> MyClass<span class="token punctuation">::</span><span class="token class-name">_myValue</span></pre></td></tr><tr><td data-num="60"></td><td><pre>IL_000b<span class="token punctuation">:</span> call instance <span class="token keyword">string</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Int32<span class="token punctuation">::</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="61"></td><td><pre>IL_0010<span class="token punctuation">:</span> call <span class="token keyword">string</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>String<span class="token punctuation">::</span>Concat<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">string</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="62"></td><td><pre>IL_0015<span class="token punctuation">:</span> call <span class="token keyword">void</span> <span class="token punctuation">[</span>UnityEngine<span class="token punctuation">.</span>CoreModule<span class="token punctuation">]</span>UnityEngine<span class="token punctuation">.</span>Debug<span class="token punctuation">::</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="63"></td><td><pre>IL_001a<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="64"></td><td><pre>IL_001b<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="65"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method MyClass::'&lt;.ctor>b__1_0'</span></pre></td></tr><tr><td data-num="66"></td><td><pre></pre></td></tr><tr><td data-num="67"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of class MyClass</span></pre></td></tr></table></figure><p>！！！！！！</p><p>看来我关于  <code>普通的匿名函数可能是直接编译为本类的成员函数</code>  的猜测也不全是错误的，原来得对本类的  <code>成员变量</code>  发生了访问，才会直接编译为  <code>成员函数</code> 。</p><p>从上面代码可以看出，之前普通匿名函数会额外生成的内嵌类已经不在了，只多了一个名为  <code>b__1_0</code>  的成员函数。</p><h2 id="闭包仅一个匿名函数所使用"><a class="anchor" href="#闭包仅一个匿名函数所使用">#</a> (闭包) 仅一个匿名函数所使用</h2><p>测试代码：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name"><span class="token keyword">int</span></span> val <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Log Val:"</span> <span class="token operator">+</span> val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token class-name">Action</span> callback<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>编译后的  <code>IL</code>  代码：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name"><span class="token keyword">public</span></span> auto ansi beforefieldinit MyClass</pre></td></tr><tr><td data-num="2"></td><td><pre>extends <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// Nested Types</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name">nested</span> <span class="token keyword">private</span> auto ansi <span class="token keyword">sealed</span> beforefieldinit '<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'</pre></td></tr><tr><td data-num="6"></td><td><pre>extends <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">.</span>custom instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>CompilerServices<span class="token punctuation">.</span>CompilerGeneratedAttribute<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token number">01</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// Fields</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">public</span> int32 val</pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// Methods</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">public</span> hidebysig specialname rtspecialname </pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token return-type class-name">instance</span> <span class="token keyword">void</span> <span class="token punctuation">.</span>ctor <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">// Method begins at RVA 0x213d</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">// Code size: 8 (0x8)</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>IL_0000<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="24"></td><td><pre>IL_0001<span class="token punctuation">:</span> call instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>IL_0006<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="26"></td><td><pre>IL_0007<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method '&lt;>c__DisplayClass0_0'::.ctor</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">.</span>method assembly hidebysig </pre></td></tr><tr><td data-num="30"></td><td><pre>instance <span class="token keyword">void</span> '<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__0' <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token comment">// Method begins at RVA 0x2146</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token comment">// Code size: 28 (0x1c)</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="36"></td><td><pre></pre></td></tr><tr><td data-num="37"></td><td><pre>IL_0000<span class="token punctuation">:</span> ldstr <span class="token string">"Log Val:"</span></pre></td></tr><tr><td data-num="38"></td><td><pre>IL_0005<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="39"></td><td><pre>IL_0006<span class="token punctuation">:</span> ldflda int32 MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span><span class="token class-name">val</span></pre></td></tr><tr><td data-num="40"></td><td><pre>IL_000b<span class="token punctuation">:</span> call instance <span class="token keyword">string</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Int32<span class="token punctuation">::</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="41"></td><td><pre>IL_0010<span class="token punctuation">:</span> call <span class="token keyword">string</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>String<span class="token punctuation">::</span>Concat<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">string</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="42"></td><td><pre>IL_0015<span class="token punctuation">:</span> call <span class="token keyword">void</span> <span class="token punctuation">[</span>UnityEngine<span class="token punctuation">.</span>CoreModule<span class="token punctuation">]</span>UnityEngine<span class="token punctuation">.</span>Debug<span class="token punctuation">::</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="43"></td><td><pre>IL_001a<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="44"></td><td><pre>IL_001b<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="45"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method '&lt;>c__DisplayClass0_0'::'&lt;.ctor>b__0'</span></pre></td></tr><tr><td data-num="46"></td><td><pre></pre></td></tr><tr><td data-num="47"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of class &lt;>c__DisplayClass0_0</span></pre></td></tr><tr><td data-num="48"></td><td><pre></pre></td></tr><tr><td data-num="49"></td><td><pre></pre></td></tr><tr><td data-num="50"></td><td><pre><span class="token comment">// Methods</span></pre></td></tr><tr><td data-num="51"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">public</span> hidebysig specialname rtspecialname </pre></td></tr><tr><td data-num="52"></td><td><pre><span class="token return-type class-name">instance</span> <span class="token keyword">void</span> <span class="token punctuation">.</span>ctor <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="53"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="54"></td><td><pre><span class="token comment">// Method begins at RVA 0x2050</span></pre></td></tr><tr><td data-num="55"></td><td><pre><span class="token comment">// Header size: 12</span></pre></td></tr><tr><td data-num="56"></td><td><pre><span class="token comment">// Code size: 42 (0x2a)</span></pre></td></tr><tr><td data-num="57"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">3</span></pre></td></tr><tr><td data-num="58"></td><td><pre><span class="token punctuation">.</span><span class="token return-type class-name">locals</span> init <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="59"></td><td><pre><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0<span class="token char">' '</span>CS$<span class="token operator">&lt;</span><span class="token operator">></span>8__locals0'</pre></td></tr><tr><td data-num="60"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="61"></td><td><pre></pre></td></tr><tr><td data-num="62"></td><td><pre>IL_0000<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="63"></td><td><pre>IL_0001<span class="token punctuation">:</span> call instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="64"></td><td><pre>IL_0006<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="65"></td><td><pre>IL_0007<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="66"></td><td><pre>IL_000c<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="67"></td><td><pre>IL_000d<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="68"></td><td><pre>IL_000e<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="69"></td><td><pre>IL_000f<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span>s <span class="token number">100</span></pre></td></tr><tr><td data-num="70"></td><td><pre>IL_0011<span class="token punctuation">:</span> stfld int32 MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span><span class="token class-name">val</span></pre></td></tr><tr><td data-num="71"></td><td><pre>IL_0016<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="72"></td><td><pre>IL_0017<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="73"></td><td><pre>IL_0018<span class="token punctuation">:</span> ldftn instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__0'<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="74"></td><td><pre>IL_001e<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token punctuation">.</span>ctor<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">,</span> native <span class="token keyword">int</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="75"></td><td><pre>IL_0023<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> MyClass<span class="token punctuation">::</span><span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="76"></td><td><pre>IL_0028<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="77"></td><td><pre>IL_0029<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="78"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method MyClass::.ctor</span></pre></td></tr><tr><td data-num="79"></td><td><pre></pre></td></tr><tr><td data-num="80"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">private</span> hidebysig </pre></td></tr><tr><td data-num="81"></td><td><pre>instance <span class="token return-type class-name"><span class="token keyword">void</span></span> DoAction <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="82"></td><td><pre><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span><span class="token class-name">System<span class="token punctuation">.</span>Action</span> callback</pre></td></tr><tr><td data-num="83"></td><td><pre><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="84"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="85"></td><td><pre><span class="token comment">// Method begins at RVA 0x2086</span></pre></td></tr><tr><td data-num="86"></td><td><pre><span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="87"></td><td><pre><span class="token comment">// Code size: 9 (0x9)</span></pre></td></tr><tr><td data-num="88"></td><td><pre><span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="89"></td><td><pre></pre></td></tr><tr><td data-num="90"></td><td><pre>IL_0000<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="91"></td><td><pre>IL_0001<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="92"></td><td><pre>IL_0002<span class="token punctuation">:</span> callvirt instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token function">Invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="93"></td><td><pre>IL_0007<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="94"></td><td><pre>IL_0008<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="95"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method MyClass::DoAction</span></pre></td></tr><tr><td data-num="96"></td><td><pre></pre></td></tr><tr><td data-num="97"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of class MyClass</span></pre></td></tr></table></figure><p>可以发现，与  <code>普通匿名函数</code>  一样，这里生成了一个名为  <code>&lt;&gt;c__DisplayClass0_0</code>  新的内嵌类，且我们的匿名方法被编译为内嵌类的成员函数。局部变量则作为新类的  <code>成员变量</code> 。</p><p>但与之不同的是：该类字段并非静态的。</p><p>再仔细看看调用的地方：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>IL_0007<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>IL_000c<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="3"></td><td><pre>IL_000d<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="4"></td><td><pre>IL_000e<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="5"></td><td><pre>IL_000f<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span>s <span class="token number">100</span></pre></td></tr><tr><td data-num="6"></td><td><pre>IL_0011<span class="token punctuation">:</span> stfld int32 MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span><span class="token class-name">val</span></pre></td></tr><tr><td data-num="7"></td><td><pre>IL_0016<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="8"></td><td><pre>IL_0017<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="9"></td><td><pre>IL_0018<span class="token punctuation">:</span> ldftn instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__0'<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>IL_001e<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token punctuation">.</span>ctor<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">,</span> native <span class="token keyword">int</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="11"></td><td><pre>IL_0023<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> MyClass<span class="token punctuation">::</span><span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">)</span></pre></td></tr></table></figure><p>可以明显看出不同：这里直接暴力创建了新类，然后将  <code>局部变量</code>  赋值后调用 —— 不存在缓存，也没什么特殊的优化！</p><p>相当于存在闭包的匿名函数：每次走到匿名函数创建的地方，都会创建新的类型。</p><h2 id="闭包多个匿名函数共同使用同一个局部变量"><a class="anchor" href="#闭包多个匿名函数共同使用同一个局部变量">#</a> (闭包) 多个匿名函数共同使用同一个局部变量</h2><p>与前一项类似，只多增加几个调用：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name"><span class="token keyword">int</span></span> val <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Log Val:"</span> <span class="token operator">+</span> val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Log2 Val:"</span> <span class="token operator">+</span> val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Log3 Val:"</span> <span class="token operator">+</span> val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>具体的  <code>IL</code>  代码就不贴了，生成的  <code>IL</code>  是差不多的，三个匿名函数被编译为同一个类的成员函数，共享  <code>val</code>  变量。</p><p>看一下调用时：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>IL_0007<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>IL_000c<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="3"></td><td><pre>IL_000d<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="4"></td><td><pre>IL_000e<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="5"></td><td><pre>IL_000f<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span>s <span class="token number">100</span></pre></td></tr><tr><td data-num="6"></td><td><pre>IL_0011<span class="token punctuation">:</span> stfld int32 MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span><span class="token class-name">val</span></pre></td></tr><tr><td data-num="7"></td><td><pre>IL_0016<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="8"></td><td><pre>IL_0017<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="9"></td><td><pre>IL_0018<span class="token punctuation">:</span> ldftn instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__0'<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>IL_001e<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token punctuation">.</span>ctor<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">,</span> native <span class="token keyword">int</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="11"></td><td><pre>IL_0023<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> MyClass<span class="token punctuation">::</span><span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>IL_0028<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="13"></td><td><pre>IL_0029<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="14"></td><td><pre>IL_002a<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="15"></td><td><pre>IL_002b<span class="token punctuation">:</span> ldftn instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__1'<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>IL_0031<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token punctuation">.</span>ctor<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">,</span> native <span class="token keyword">int</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="17"></td><td><pre>IL_0036<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> MyClass<span class="token punctuation">::</span><span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>IL_003b<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="19"></td><td><pre>IL_003c<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="20"></td><td><pre>IL_003d<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="21"></td><td><pre>IL_003e<span class="token punctuation">:</span> ldftn instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__2'<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>IL_0044<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token punctuation">.</span>ctor<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">,</span> native <span class="token keyword">int</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="23"></td><td><pre>IL_0049<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> MyClass<span class="token punctuation">::</span><span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">)</span></pre></td></tr></table></figure><h2 id="闭包多个匿名函数使用不同的局部变量"><a class="anchor" href="#闭包多个匿名函数使用不同的局部变量">#</a> (闭包) 多个匿名函数使用不同的局部变量</h2><p>处理方式与前者一致。</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name"><span class="token keyword">int</span></span> val <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name"><span class="token keyword">int</span></span> val2 <span class="token operator">=</span> <span class="token number">12345</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Log Val:"</span> <span class="token operator">+</span> val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Log2 Val:"</span> <span class="token operator">+</span> val2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>调用时：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>IL_0007<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>IL_000c<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="3"></td><td><pre>IL_000d<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="4"></td><td><pre>IL_000e<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="5"></td><td><pre>IL_000f<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span>s <span class="token number">100</span></pre></td></tr><tr><td data-num="6"></td><td><pre>IL_0011<span class="token punctuation">:</span> stfld int32 MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span><span class="token class-name">val</span></pre></td></tr><tr><td data-num="7"></td><td><pre>IL_0016<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="8"></td><td><pre>IL_0017<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4 <span class="token number">12345</span></pre></td></tr><tr><td data-num="9"></td><td><pre>IL_001c<span class="token punctuation">:</span> stfld int32 MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span><span class="token class-name">val2</span></pre></td></tr><tr><td data-num="10"></td><td><pre>IL_0021<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="11"></td><td><pre>IL_0022<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="12"></td><td><pre>IL_0023<span class="token punctuation">:</span> ldftn instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__0'<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>IL_0029<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token punctuation">.</span>ctor<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">,</span> native <span class="token keyword">int</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="14"></td><td><pre>IL_002e<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> MyClass<span class="token punctuation">::</span><span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>IL_0033<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="16"></td><td><pre>IL_0034<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="17"></td><td><pre>IL_0035<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="18"></td><td><pre>IL_0036<span class="token punctuation">:</span> ldftn instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__1'<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>IL_003c<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token punctuation">.</span>ctor<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">,</span> native <span class="token keyword">int</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="20"></td><td><pre>IL_0041<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> MyClass<span class="token punctuation">::</span><span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">)</span></pre></td></tr></table></figure><h2 id="闭包同时引用局部变量和成员变量"><a class="anchor" href="#闭包同时引用局部变量和成员变量">#</a> (闭包) 同时引用局部变量和成员变量</h2><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name"><span class="token keyword">int</span></span> val <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name"><span class="token keyword">int</span></span> localVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Log"</span> <span class="token operator">+</span> val <span class="token operator">+</span> localVal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>与闭包一样都是新的实例，区别在于会多定义一个  <code>本类字段</code>  将本类传入以便引用成员变量：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Nested Types</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name">nested</span> <span class="token keyword">private</span> auto ansi <span class="token keyword">sealed</span> beforefieldinit '<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass1_0'</pre></td></tr><tr><td data-num="3"></td><td><pre>    extends <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">.</span>custom instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>CompilerServices<span class="token punctuation">.</span>CompilerGeneratedAttribute<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token number">01</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// Fields</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 局部变量字段</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">.</span>field <span class="token keyword">public</span> int32 localVal</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// 引用类的字段，用于获取成员变量</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">.</span>field <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span> '<span class="token operator">&lt;</span><span class="token operator">></span>4__this'</pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">// Methods</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">.</span>method <span class="token keyword">public</span> hidebysig specialname rtspecialname </pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token return-type class-name">instance</span> <span class="token keyword">void</span> <span class="token punctuation">.</span>ctor <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">//=========== 省略 =================================</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token comment">// end of method '&lt;>c__DisplayClass1_0'::.ctor</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">.</span>method assembly hidebysig</pre></td></tr><tr><td data-num="22"></td><td><pre>        instance <span class="token keyword">void</span> '<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__0' <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed</pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token comment">// Method begins at RVA 0x215a</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token comment">// Code size: 44 (0x2c)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>        IL_0000<span class="token punctuation">:</span> ldstr <span class="token string">"Log"</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        IL_0005<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        IL_0006<span class="token punctuation">:</span> ldfld <span class="token keyword">class</span> <span class="token class-name">MyClass</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass1_0'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token operator">></span>4__this'</pre></td></tr><tr><td data-num="32"></td><td><pre>        IL_000b<span class="token punctuation">:</span> ldflda <span class="token class-name">int32</span> MyClass<span class="token punctuation">::</span><span class="token class-name">val</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        IL_0010<span class="token punctuation">:</span> call instance <span class="token keyword">string</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Int32<span class="token punctuation">::</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        IL_0015<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        IL_0016<span class="token punctuation">:</span> ldflda int32 MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass1_0'<span class="token punctuation">::</span><span class="token class-name">localVal</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        IL_001b<span class="token punctuation">:</span> call instance <span class="token keyword">string</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Int32<span class="token punctuation">::</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        IL_0020<span class="token punctuation">:</span> call <span class="token keyword">string</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>String<span class="token punctuation">::</span>Concat<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">string</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="38"></td><td><pre>        IL_0025<span class="token punctuation">:</span> call <span class="token keyword">void</span> <span class="token punctuation">[</span>UnityEngine<span class="token punctuation">.</span>CoreModule<span class="token punctuation">]</span>UnityEngine<span class="token punctuation">.</span>Debug<span class="token punctuation">::</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        IL_002a<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        IL_002b<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token comment">// end of method '&lt;>c__DisplayClass1_0'::'&lt;.ctor>b__0'</span></pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of class &lt;>c__DisplayClass1_0</span></pre></td></tr><tr><td data-num="44"></td><td><pre></pre></td></tr><tr><td data-num="45"></td><td><pre></pre></td></tr><tr><td data-num="46"></td><td><pre><span class="token comment">// Fields</span></pre></td></tr><tr><td data-num="47"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">private</span> int32 val</pre></td></tr><tr><td data-num="48"></td><td><pre></pre></td></tr><tr><td data-num="49"></td><td><pre><span class="token comment">// Methods</span></pre></td></tr><tr><td data-num="50"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">public</span> hidebysig specialname rtspecialname </pre></td></tr><tr><td data-num="51"></td><td><pre>    <span class="token return-type class-name">instance</span> <span class="token keyword">void</span> <span class="token punctuation">.</span>ctor <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="52"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>    <span class="token comment">// Method begins at RVA 0x2050</span></pre></td></tr><tr><td data-num="54"></td><td><pre>    <span class="token comment">// Header size: 12</span></pre></td></tr><tr><td data-num="55"></td><td><pre>    <span class="token comment">// Code size: 56 (0x38)</span></pre></td></tr><tr><td data-num="56"></td><td><pre>    <span class="token punctuation">.</span>maxstack <span class="token number">3</span></pre></td></tr><tr><td data-num="57"></td><td><pre>    <span class="token punctuation">.</span><span class="token return-type class-name">locals</span> init <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="58"></td><td><pre>        <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass1_0<span class="token char">' '</span>CS$<span class="token operator">&lt;</span><span class="token operator">></span>8__locals0'</pre></td></tr><tr><td data-num="59"></td><td><pre>    <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="60"></td><td><pre></pre></td></tr><tr><td data-num="61"></td><td><pre>    IL_0000<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="62"></td><td><pre>    IL_0001<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span>s <span class="token number">100</span></pre></td></tr><tr><td data-num="63"></td><td><pre>    IL_0003<span class="token punctuation">:</span> stfld <span class="token class-name">int32</span> MyClass<span class="token punctuation">::</span><span class="token class-name">val</span></pre></td></tr><tr><td data-num="64"></td><td><pre>    IL_0008<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="65"></td><td><pre>    IL_0009<span class="token punctuation">:</span> call instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="66"></td><td><pre>    IL_000e<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="67"></td><td><pre>    IL_000f<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass1_0'<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="68"></td><td><pre>    IL_0014<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="69"></td><td><pre>    IL_0015<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="70"></td><td><pre>    IL_0016<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="71"></td><td><pre><span class="token comment">// 将自身引用赋值进去</span></pre></td></tr><tr><td data-num="72"></td><td><pre>    IL_0017<span class="token punctuation">:</span> stfld <span class="token keyword">class</span> <span class="token class-name">MyClass</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass1_0'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token operator">></span>4__this'</pre></td></tr><tr><td data-num="73"></td><td><pre>    IL_001c<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="74"></td><td><pre>    IL_001d<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="75"></td><td><pre>    IL_001e<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="76"></td><td><pre><span class="token comment">// 赋值使用到的局部变量</span></pre></td></tr><tr><td data-num="77"></td><td><pre>    IL_001f<span class="token punctuation">:</span> stfld int32 MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass1_0'<span class="token punctuation">::</span><span class="token class-name">localVal</span></pre></td></tr><tr><td data-num="78"></td><td><pre>    IL_0024<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="79"></td><td><pre>    IL_0025<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="80"></td><td><pre>    IL_0026<span class="token punctuation">:</span> ldftn instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass1_0'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__0'<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="81"></td><td><pre>    IL_002c<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token punctuation">.</span>ctor<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">,</span> native <span class="token keyword">int</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="82"></td><td><pre>    IL_0031<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> MyClass<span class="token punctuation">::</span><span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="83"></td><td><pre>    IL_0036<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="84"></td><td><pre>    IL_0037<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="85"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method MyClass::.ctor</span></pre></td></tr></table></figure><h2 id="闭包for循环缓存"><a class="anchor" href="#闭包for循环缓存">#</a> (闭包) for 循环缓存</h2><p><code>C#</code>  代码：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name"><span class="token keyword">int</span></span> index <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Log index:"</span> <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>看了下与闭包匿名函数一样，被编译为新的内嵌类，不同之处在于使用的地方。</p><p>关键 <code>IL</code>  代码：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>IL_0008<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="2"></td><td><pre>IL_0009<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="3"></td><td><pre>IL_000a<span class="token punctuation">:</span> br<span class="token punctuation">.</span>s IL_0032</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// loop start (head: IL_0032)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>IL_000c<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>IL_0011<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="7"></td><td><pre>IL_0012<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="8"></td><td><pre>IL_0013<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="9"></td><td><pre>IL_0014<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="10"></td><td><pre>IL_0015<span class="token punctuation">:</span> stfld int32 MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span><span class="token class-name">index</span></pre></td></tr><tr><td data-num="11"></td><td><pre>IL_001a<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="12"></td><td><pre>IL_001b<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="13"></td><td><pre>IL_001c<span class="token punctuation">:</span> ldftn instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__0'<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>IL_0022<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span> System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token punctuation">.</span>ctor<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">,</span> native <span class="token keyword">int</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="15"></td><td><pre>IL_0027<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> MyClass<span class="token punctuation">::</span><span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span> System<span class="token punctuation">.</span>Action<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>IL_002c<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="17"></td><td><pre>IL_002d<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="18"></td><td><pre>IL_002e<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="19"></td><td><pre>IL_002f<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="20"></td><td><pre>IL_0030<span class="token punctuation">:</span> <span class="token keyword">add</span></pre></td></tr><tr><td data-num="21"></td><td><pre>IL_0031<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>IL_0032<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="24"></td><td><pre>IL_0033<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span>s <span class="token number">10</span></pre></td></tr><tr><td data-num="25"></td><td><pre>IL_0035<span class="token punctuation">:</span> <span class="token class-name">clt</span></pre></td></tr><tr><td data-num="26"></td><td><pre>IL_0037<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">2</span></pre></td></tr><tr><td data-num="27"></td><td><pre>IL_0038<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">2</span></pre></td></tr><tr><td data-num="28"></td><td><pre>IL_0039<span class="token punctuation">:</span> brtrue<span class="token punctuation">.</span>s IL_000c</pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token comment">// end loop</span></pre></td></tr></table></figure><p>在  <code>每一次</code>  循环中都创建了一个内嵌类  <code>&lt;&gt;c__DisplayClass0_0</code>  的实例！非常恐怖。</p><p>于是想 <code>对比测试</code> 下，我们通常说 for 循环 index 重复 ( <code>即始终取到最后一个index</code> ) 的情景：</p><p>原  <code>C#</code>  代码如下：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">//int index = i;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Log index:"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>IL</code>  代码：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>IL_0008<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span> '<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>IL_000d<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="3"></td><td><pre>IL_000e<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="4"></td><td><pre>IL_000f<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="5"></td><td><pre>IL_0010<span class="token punctuation">:</span> stfld int32 MyClass <span class="token operator">/</span> '<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span><span class="token class-name">i</span></pre></td></tr><tr><td data-num="6"></td><td><pre>IL_0015<span class="token punctuation">:</span> br<span class="token punctuation">.</span>s IL_003c</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// loop start (head: IL_003c)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>IL_0017<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="9"></td><td><pre>IL_0018<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="10"></td><td><pre>IL_0019<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="11"></td><td><pre>IL_001a<span class="token punctuation">:</span> ldftn instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span> '<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__0'<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>IL_0020<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action<span class="token punctuation">::</span><span class="token punctuation">.</span>ctor<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">,</span> native <span class="token keyword">int</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="13"></td><td><pre>IL_0025<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> MyClass<span class="token punctuation">::</span><span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span> System<span class="token punctuation">.</span>Action<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>IL_002a<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="15"></td><td><pre>IL_002b<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="16"></td><td><pre>IL_002c<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="17"></td><td><pre>IL_002d<span class="token punctuation">:</span> ldfld int32 MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span><span class="token class-name">i</span></pre></td></tr><tr><td data-num="18"></td><td><pre>IL_0032<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="19"></td><td><pre>IL_0033<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="20"></td><td><pre>IL_0034<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="21"></td><td><pre>IL_0035<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="22"></td><td><pre>IL_0036<span class="token punctuation">:</span> <span class="token keyword">add</span></pre></td></tr><tr><td data-num="23"></td><td><pre>IL_0037<span class="token punctuation">:</span> stfld int32 MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span><span class="token class-name">i</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>IL_003c<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="26"></td><td><pre>IL_003d<span class="token punctuation">:</span> ldfld int32 MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c__DisplayClass0_0'<span class="token punctuation">::</span><span class="token class-name">i</span></pre></td></tr><tr><td data-num="27"></td><td><pre>IL_0042<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span>s <span class="token number">10</span></pre></td></tr><tr><td data-num="28"></td><td><pre>IL_0044<span class="token punctuation">:</span> <span class="token class-name">clt</span></pre></td></tr><tr><td data-num="29"></td><td><pre>IL_0046<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">2</span></pre></td></tr><tr><td data-num="30"></td><td><pre>IL_0047<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">2</span></pre></td></tr><tr><td data-num="31"></td><td><pre>IL_0048<span class="token punctuation">:</span> brtrue<span class="token punctuation">.</span>s IL_0017</pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token comment">// end loop</span></pre></td></tr></table></figure><p>这种模式就是在循环外创建的实例了，也就是整个 for 循环只会有一个委托内嵌类实例，因此字段值会被覆盖。</p><h1 id="闭包优化-传参"><a class="anchor" href="#闭包优化-传参">#</a> 闭包优化 -- 传参</h1><p>(2023.2.9 补充)</p><p>对于闭包的情况，有没有优化方式呢？</p><p>答案是有的，虽然有一定局限 —— 比如通过局部变量的  <code>传参</code>  的方式使用：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name"><span class="token keyword">int</span></span> val <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">DoAction</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pr<span class="token punctuation">)</span> <span class="token operator">=></span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Log Val:"</span> <span class="token operator">+</span> pr<span class="token punctuation">)</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">DoAction</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token class-name">Action<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span> callback<span class="token punctuation">,</span> <span class="token class-name">T</span> parm<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">callback</span><span class="token punctuation">(</span>parm<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这种方式编译后，生成的  <code>IL</code>  代码与普通匿名函数一样，生成的是一个静态对象，不会造成使用时反复创建新的内嵌类的实例：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//======= 内嵌类字段是静态的，匿名方法被编译为对应带参数成员函数 =========</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">.</span>method assembly hidebysig</pre></td></tr><tr><td data-num="3"></td><td><pre>    instance <span class="token keyword">void</span> '<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__0_0' <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">int32</span> pr</pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// Method begins at RVA 0x2156</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// Code size: 24 (0x18)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    IL_0000<span class="token punctuation">:</span> ldstr <span class="token string">"Log Val:"</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    IL_0005<span class="token punctuation">:</span> ldarga<span class="token punctuation">.</span>s <span class="token class-name">pr</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    IL_0007<span class="token punctuation">:</span> call instance <span class="token keyword">string</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Int32<span class="token punctuation">::</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    IL_000c<span class="token punctuation">:</span> call <span class="token keyword">string</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>String<span class="token punctuation">::</span>Concat<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">string</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="16"></td><td><pre>    IL_0011<span class="token punctuation">:</span> call <span class="token keyword">void</span> <span class="token punctuation">[</span>UnityEngine<span class="token punctuation">.</span>CoreModule<span class="token punctuation">]</span>UnityEngine<span class="token punctuation">.</span>Debug<span class="token punctuation">::</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    IL_0016<span class="token punctuation">:</span> <span class="token class-name">nop</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    IL_0017<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method '&lt;>c'::'&lt;.ctor>b__0_0'</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment">//=== 创建和执行处，判断了是否有实例化绑定过委托 ====</span></pre></td></tr><tr><td data-num="22"></td><td><pre>IL_0008<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span>s <span class="token number">100</span></pre></td></tr><tr><td data-num="23"></td><td><pre>IL_000a<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="24"></td><td><pre>IL_000b<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="25"></td><td><pre>IL_000c<span class="token punctuation">:</span> ldsfld <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action`<span class="token number">1</span><span class="token operator">&lt;</span>int32<span class="token operator">></span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9__0_0</span>'</pre></td></tr><tr><td data-num="26"></td><td><pre>IL_0011<span class="token punctuation">:</span> <span class="token class-name">dup</span></pre></td></tr><tr><td data-num="27"></td><td><pre>IL_0012<span class="token punctuation">:</span> brtrue<span class="token punctuation">.</span>s <span class="token class-name">IL_002b</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>IL_0014<span class="token punctuation">:</span> <span class="token class-name">pop</span></pre></td></tr><tr><td data-num="30"></td><td><pre>IL_0015<span class="token punctuation">:</span> ldsfld <span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c' MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9</span>'</pre></td></tr><tr><td data-num="31"></td><td><pre>IL_001a<span class="token punctuation">:</span> ldftn instance <span class="token keyword">void</span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token punctuation">.</span>ctor<span class="token operator">></span>b__0_0'<span class="token punctuation">(</span>int32<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="32"></td><td><pre>IL_0020<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action`<span class="token number">1</span><span class="token operator">&lt;</span>int32<span class="token operator">></span><span class="token punctuation">::</span><span class="token punctuation">.</span>ctor<span class="token class-name"><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">,</span> native <span class="token keyword">int</span><span class="token punctuation">)</span></span></pre></td></tr><tr><td data-num="33"></td><td><pre>IL_0025<span class="token punctuation">:</span> <span class="token class-name">dup</span></pre></td></tr><tr><td data-num="34"></td><td><pre>IL_0026<span class="token punctuation">:</span> stsfld <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action`<span class="token number">1</span><span class="token operator">&lt;</span>int32<span class="token operator">></span> MyClass<span class="token operator">/</span>'<span class="token operator">&lt;</span><span class="token operator">></span>c'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token operator">></span><span class="token number">9__0_0</span>'</pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre>IL_002b<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="37"></td><td><pre>IL_002c<span class="token punctuation">:</span> call instance <span class="token class-name"><span class="token keyword">void</span></span> MyClass<span class="token punctuation">::</span><span class="token generic-method"><span class="token function">DoAction</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>int32<span class="token punctuation">></span></span></span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Action`<span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">!</span><span class="token number">0</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">!</span><span class="token operator">!</span><span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr></table></figure><blockquote><p>注：局部变量缓存的匿名委托，一样是会编译为内嵌类。</p></blockquote><blockquote><p>例如如下代码编译后与上述  <code>IL</code>  代码基本一致：</p></blockquote><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Action<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span></span> callback <span class="token operator">=</span> <span class="token punctuation">(</span>pr<span class="token punctuation">)</span> <span class="token operator">=></span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Log Val:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>callback<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>当然，这种优化方式也有局限性：那就是调用时就必须传参， <code>没法存储</code>  局部变量  <code>以待后续</code>  的使用，要么就是绑定者自己直接就存储参数。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><ul><li>普通匿名函数 (没有对外部产生任何变量引用)：被编译为一个内嵌类，匿名函数本身成为新类的一个成员函数，并使用静态字段绑定委托。保证调用时只会初始化一次。</li><li>调用过成员变量的匿名函数：会被直接编译为成员函数</li><li>带闭包匿名函数：编译为普通内嵌类，其中生成对应局部变量类型的字段，生成时会创建该类实例，然后将局部变量为其赋值。<ul><li>相当于每次走到匿名函数创建的地方，都会创建新的类型，评价是性能堪忧</li><li>多个匿名函数共同使用同一个局部变量，被编译在同一个类中</li><li>多个匿名函数使用不同的局部变量：被编译在同一个类中</li><li>for 循环缓存：<ul><li>若使用循环外的局部变量，则只有一个实例</li><li>若是循环内部的局部变量，循环多少次，就会创建多少个实例 <code>(!)</code></li></ul></li></ul></li></ul><p>按照如上的情况来看:</p><ul><li><code>普通的匿名函数</code>  应该没什么大问题，委托会被作为静态实例缓存，只会第一次运行到代码块时初始化一次（可能需要考虑由于静态字段原因，一旦创建就不会释放，不过觉得这点空间消耗应该不用过于担心）</li><li><code>仅调用成员变量的匿名函数</code>  它跟自己在类中定义一个成员函数没有区别（当然由于委托本身也是一个类，他与自己的成员函数一样，作为委托传递本身也有实例化消耗）</li><li><code>带闭包的匿名函数</code> 性能就比较糟糕了：每次运行到的时候都会创建新类型的实例，普通  <code>for循环</code>  与  <code>普通闭包匿名函数</code>  一样。同时加上委托本身实例化消耗。<ul><li><code>同时引用局部变量和成员变量</code>  的匿名函数，与闭包一样都是新的实例，区别在于会多定义一个  <code>本类字段</code>  将本类传入以便引用成员变量</li><li>若实在需要局部变量作为参数，可以考虑是否可以使用传参的方式做优化 (例如 Task.TaskFactory.StartNew 就提供了传参的重载)</li></ul></li></ul><p><code>注意</code> 特别最为需要避免的就是 for 循环中使用循环中定义的局部变量：例如缓存 index，每一个循环都会造成一次实例化。—— 当然，闭包确实也是一个很方便的特性... 必要时可以极大减少代码量，不要滥用就好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;匿名函数平时用得太常见了，平时都知道说用多了不好。&lt;/p&gt;
&lt;p&gt;为什么不好？原因呢？&lt;/p&gt;
&lt;p&gt;特别是涉及到造成  &lt;code&gt;闭包&lt;/code&gt;  的匿名函</summary>
      
    
    
    
    <category term="C#" scheme="https://wangjiaying.top/categories/C/"/>
    
    
    <category term="性能优化" scheme="https://wangjiaying.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="C#" scheme="https://wangjiaying.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>BatchTextureModifier工具使用说明</title>
    <link href="https://wangjiaying.top/2023/02/05/BatchTextureModifier%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>https://wangjiaying.top/2023/02/05/BatchTextureModifier%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</id>
    <published>2023-02-05T06:38:57.000Z</published>
    <updated>2023-04-28T11:08:43.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>这是上个月开始弄的一个小工具，春节期间收尾的。</p><blockquote><p>实在不知道取什么名字好，暂且就先用着这个  <code>BatchTextureModifier</code>  名字吧 🙀。</p></blockquote><p>这几天又完善了一下，这两天在家里亲自以自己网站  <code>二次元随机图库</code>  处理为目的，进行试用了一番：</p><blockquote><p>也就是说，本站的所有随机图片，都是由该工具统一处理完成：所有随机图片都是  <code>1280x800</code> ，大小则为  <code>100KB</code>  以下的  <code>Webp</code>  格式。</p></blockquote><p>并且在过程中再次改动了一波，虽然功能应该不算复杂，而且对各个选项基本也都加了  <code>Tooltips</code> ，不过考虑到部分选项情况，感觉最好也可以写一写汇总的使用说明。</p><h1 id="功能"><a class="anchor" href="#功能">#</a> 功能</h1><p>主要是实现一个批量图片处理功能，例如批量进行格式转换的同时，对图片做一些裁剪、缩放等操作。</p><p>使用 WPF .NetCore6.0 开发</p><p>目前支持：</p><ol><li>批量处理图片 (也可以单图处理)</li><li>预览修改效果、及修改后文件大小</li><li>覆盖修改、自动备份 (前提是直接覆盖修改的话)</li><li>多种模式缩放图片</li><li>按照指定参数，批量转换图片格式为  <code>*.png</code>   <code>*.jpg</code>   <code>*.webp</code>   <code>*.tga</code>   <code>*.bmp</code>   <code>*.gif</code><ul><li>支持自动读取的后缀为： <code>*.png</code>   <code>*.jpg</code>   <code>*.jpeg</code>   <code>*.webp</code>   <code>*.tga</code>   <code>*.bmp</code>   <code>*.gif</code></li><li>(如果发现批量处理时没有读取到，可以检查是否图片后缀不对劲)</li></ul></li><li>POT 缩放 (用过 Unity 的应该知道什么意思，不过这个跟 Unity 强行拉伸方式不同，而是比例缩放)</li><li>多线程处理，同时开启处理量取决于 CPU 核心数目</li><li>处理转为  <code>jpg</code>   <code>Webp</code>  格式时可选限制最终生成的文件大小，超出指定大小会尝试降低质量进行迭代（会极大增加额外消耗）</li></ol><h1 id="界面"><a class="anchor" href="#界面">#</a> 界面</h1><p>最基本的界面如下：</p><p><img data-src="/blogimages/2023/2023-02-05/Snipaste_2023-02-05_15-00-11.jpg" alt="" /></p><p>从上往下主要分为三个模块：</p><ol><li>普通设置</li><li>参数设置</li><li>结果预览</li></ol><h2 id="普通设置"><a class="anchor" href="#普通设置">#</a> 普通设置</h2><p>又分为  <code>批量处理</code> 、 <code>单图处理</code> 、 <code>其它工具</code></p><h3 id="批量处理"><a class="anchor" href="#批量处理">#</a> 批量处理</h3><p>最基本的页面，也是主要功能。</p><ul><li>原始目录：即需要处理的图片目录</li><li>输出目录：处理完毕后，保存地址</li></ul><p>若输出目录与原始目录填写一致，会自动判断为  <code>覆盖模式</code> ，并进行处理时的备份，若不需要则可以将  <code>参数设置-&gt;文件设置-&gt;备份文件</code>  勾选取消。</p><p>点击  <code>处理</code>  按钮，自动跳转至  <code>日志页签</code> ，并开启线程进行批量处理。</p><h3 id="单图处理"><a class="anchor" href="#单图处理">#</a> 单图处理</h3><p>这里可以选择某一张图片作为预览，并且单独保存：</p><p><img data-src="/blogimages/2023/2023-02-05/Snipaste_2023-02-05_15-27-21.jpg" alt="" /></p><p>注：只要有预览图片，就可以保存。</p><h3 id="其它工具"><a class="anchor" href="#其它工具">#</a> 其它工具</h3><p>昨天刚加了个  <code>生成文件列表</code>  的小功能，目前就这一个。</p><p><img data-src="/blogimages/2023/2023-02-05/Snipaste_2023-02-05_15-25-58.jpg" alt="" /></p><p>其功能是可以将指定目录下，所有文件生成一个文件列表，可选添加统一前缀。</p><p>目录路径可以直接粘贴上去，也可以点击  <code>选择</code>  用浏览去选。</p><h2 id="参数设置"><a class="anchor" href="#参数设置">#</a> 参数设置</h2><p>分为  <code>输出格式</code>   <code>缩放模式</code>   <code>文件设置</code>  三类</p><h3 id="输出格式"><a class="anchor" href="#输出格式">#</a> 输出格式</h3><p>可以选择在保存时将输入的原图转换为  <code>*.png</code>   <code>*.jpg</code>   <code>*.webp</code>   <code>*.tga</code>   <code>*.bmp</code>   <code>*.gif</code>  几种格式。</p><p>每种格式都尽量提供了会对图片造成影响的选项以供配置。</p><p>其中  <code>JPG</code>  和  <code>webp</code>  有损格式 支持  <code>质量设置</code>  ，因此这两者提供了  <code>文件大小限制</code> ，即：超过指定大小会尝试降低质量进行迭代，不过会极大增加额外消耗。</p><p>另外  <code>保持透明</code>  选项默认不勾选，不勾选的情况下：指的是转化时若像素不可见则填充为透明度 (透明图片)，勾选的情况下则不做处理。</p><h3 id="缩放模式"><a class="anchor" href="#缩放模式">#</a> 缩放模式</h3><p>不缩放：不会改变原本分辨率，如果你连格式也选择保持不变，那么就没什么用<br />比例缩放 II：将原图缩放至指定分辨率时尽量保持比例不变，多余处则填充<br />直接裁剪：直接裁剪至目标分辨率<br />基于宽度：以宽度为基准进行缩放，高度不足则填充，高度超过之处则裁剪<br />基于高度：以高度为基准进行缩放，宽度不足则填充，宽度超过之处则裁剪<br />比例缩放：如果图片小于设定分辨率，则比例放大，不足之处则填充；如果图片大于设定分辨率，则比例缩小<br />比例裁剪：以高度或宽度最大者为基准进行缩放，尽量保持比例不变，多余处直接裁剪<br />直接缩放 (向下)：(与设定分辨率不会保持一致) 基于最小边长达到给定分辨率直接缩小，不会改变原本图片比例，也不会放大<br />直接缩放 (向上)：(与设定分辨率不会保持一致) 基于原本图片比例，缩放至新分辨率的比例，缩放后分辨率一般比设定分辨率更小<br />拉伸缩放：原图直接填充至新的分辨率，不足直接拉伸，会导致图片变形<br /> POT 缩放：高宽缩放至最接近 2N 次方的分辨率，尽量保持比例不变，不足处则填充<br /> POT 方形缩放：高宽缩放至最接近 2N 次方的方形分辨率，尽量保持比例不变，不足处则填充</p><p>缩放算法默认是  <code>Bicubic</code> ，我在处理本站 随机图片时，采用的  <code>Spline</code>  算法，该算法模糊图片减少细节，并能减少最终图片大小 (相比其它算法)，比较适用于生成的图片用在  <code>缩小使用</code>  的情况。</p><blockquote><p>注：填充的究竟是透明度还是黑色，取决于图片原本是否是有透明通道的图片。</p></blockquote><p><code>停靠模式</code> ：这个选项可以控制图片 <code>裁剪</code> 或 <code>缩放</code> 时，原图在新的比例下停靠标准</p><blockquote><p>例如，如果有一张竖行分辨率的图片，主要内容在靠近上部分位置，想要仅获取这部分内容，就可以选择先裁剪上半部分，然后再居中缩放为指定分辨率。</p></blockquote><h3 id="文件设置"><a class="anchor" href="#文件设置">#</a> 文件设置</h3><p>直接覆盖：可选是否直接覆盖源文件，如果勾上的话，会直接删除源文件并以转化后图片进行替代，谨慎使用！<br />保留结构：覆盖源文件且备份时使用，备份时会依照源文件的子目录进行备份，否则会全部备份在一个目录中。</p><h2 id="结果预览"><a class="anchor" href="#结果预览">#</a> 结果预览</h2><p>在结果页面，又分为两个页签，默认处于  <code>预览页签</code> ，点击  <code>输出</code>  可切换至  <code>日志页签</code> 。</p><h3 id="预览页签"><a class="anchor" href="#预览页签">#</a> 预览页签</h3><p>左侧为原图，右侧为经过修改后的预览图。</p><p>图片上方展示了该图片的分辨率、文件大小：修改后的预览图是保存磁盘后的文件大小。</p><p>因为界面比较小，如果觉得看不清楚，提供了两种选项：</p><ol><li>可以点击国轩右侧预览图的右上角， <code>仅显示结果</code> ，该选项会使 UI 只显示一张修改后的预览图</li><li>若觉得还是不够，则可以点击右侧预览图的右下角， <code>放大</code>  按钮：这个按钮会打开一个新的对比页面，该页面运行全屏、放大展示</li></ol><p><img data-src="/blogimages/2023/2023-02-05/Snipaste_2023-02-05_15-46-46.jpg" alt="" /></p><h2 id="日志页签"><a class="anchor" href="#日志页签">#</a> 日志页签</h2><p><img data-src="/blogimages/2023/2023-02-05/Snipaste_2023-02-05_15-09-34.jpg" alt="" /></p><p>运行或操作过程中的日志会记录在此，在点击批处理后会自动跳转至该页面。</p><p>处理完毕后注意一下最后  <code>批处理执行完毕！共处理 X 个文件，消耗时间：Y</code>  其中的处理文件数量是否跟目录实际文件数量一致即可：一般来说，只要图片后缀是上述支持的格式，应该就没什么大问题。</p><h1 id="最后"><a class="anchor" href="#最后">#</a> 最后</h1><p>因为不知道用什么 ICON 好，所以也没加 ICON。</p><p>Git 地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NXSElTTUUvQmF0Y2hUZXh0dXJlTW9kaWZpZXI=">https://github.com/CWHISME/BatchTextureModifier</span></p><p>走过路过点个赞吧，如果有任何  <code>Bug</code>  或者  <code>问题</code>  什么的，也欢迎提出 😸。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;这是上个月开始弄的一个小工具，春节期间收尾的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实在不知道取什么名字好，暂且就先用着这个  &lt;code&gt;BatchTextu</summary>
      
    
    
    
    <category term="工具" scheme="https://wangjiaying.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://wangjiaying.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="WPF" scheme="https://wangjiaying.top/tags/WPF/"/>
    
  </entry>
  
  <entry>
    <title>C#协程的底层原理</title>
    <link href="https://wangjiaying.top/2023/02/01/CS-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <id>https://wangjiaying.top/2023/02/01/CS-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</id>
    <published>2023-02-01T09:27:37.000Z</published>
    <updated>2023-06-04T11:42:34.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>这两天又研究了下协程，之前虽然用过，也稍微想过，但是并没有深入研究，这次就想把流程仔细走一遍。</p><h1 id="原理"><a class="anchor" href="#原理">#</a> 原理</h1><p>其实也是一个思维方式问题，协程的原理其实很简单：利用迭代器</p><h2 id="迭代器"><a class="anchor" href="#迭代器">#</a> 迭代器</h2><p>我们都知道，实现了  <code>IEnumerable</code>  接口、或者说拥有  <code>IEnumerator GetEnumerator()</code>  的类可以被  <code>foreach</code>  所迭代。</p><p>其重点就在于  <code>IEnumerator</code>  这个接口。</p><p><code>数组</code> 、 <code>List</code> 、 <code>字典</code>  等数据结构，迭代时都是通过返回自己创建的一个实现了  <code>IEnumerator</code>  的  <code>Warp</code>  类进行。</p><p>为什么一个方法，标记返回  <code>IEnumerator</code>  直接就能被迭代？</p><p>例如：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestEnumerator</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DoTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> item <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name">IEnumerator</span> <span class="token function">GetEnumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"迭代"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>上述代码是不会报错的，如果执行也会正常调用：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre>迭代</pre></td></tr><tr><td data-num="2"></td><td><pre>UnityEngine<span class="token punctuation">.</span>Debug<span class="token punctuation">:</span><span class="token function">Log</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token operator">&lt;</span>GetEnumerator<span class="token operator">></span>c__Iterator0<span class="token punctuation">:</span><span class="token function">MoveNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>at Assets<span class="token operator">/</span>TestEnumerator<span class="token punctuation">.</span>cs<span class="token punctuation">:</span><span class="token number">37</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>TestEnumerator<span class="token punctuation">:</span><span class="token function">DoTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>at Assets<span class="token operator">/</span>TestEnumerator<span class="token punctuation">.</span>cs<span class="token punctuation">:</span><span class="token number">29</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>Test<span class="token punctuation">:</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>at Assets<span class="token operator">/</span>Test<span class="token punctuation">.</span>cs<span class="token punctuation">:</span><span class="token number">15</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h2 id="从il代码分析"><a class="anchor" href="#从il代码分析">#</a> 从 IL 代码分析</h2><p>想过为什么会这样吗？毕竟这只是一个方法而已，为何就能被迭代了？</p><p>实际上， <code>IEnumerator</code> + <code>yield</code>  该是属于  <code>C#</code>  的法糖，因为底层编译器会为此生成一个新的类，这个新类直接实现了  <code>IEnumerator</code>  接口，而原本的方法则会在被调用时，创建这个新类并返回。</p><p>如果想要证实这个猜测，这就要从编译后的代码说起了，通过  <code>dnSpy</code>  反编译，选择  <code>IL</code>  语言 (C# 模式会还原我们的代码，所以看不出来)，就可以查看到具体信息，一部分代码如下：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Token: 0x0200019E RID: 414</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name"><span class="token keyword">public</span></span> auto ansi beforefieldinit TestEnumerator</pre></td></tr><tr><td data-num="3"></td><td><pre>extends <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// Nested Types</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// Token: 0x02000215 RID: 533</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name">nested</span> <span class="token keyword">private</span> auto ansi <span class="token keyword">sealed</span> beforefieldinit '<span class="token operator">&lt;</span>GetEnumerator<span class="token operator">></span>c__Iterator0'</pre></td></tr><tr><td data-num="8"></td><td><pre>extends <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Object</pre></td></tr><tr><td data-num="9"></td><td><pre>implements <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>IEnumerator<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>           <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">mscorlib</span></span><span class="token punctuation">]</span>System<span class="token punctuation">.</span>IDisposable<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>           <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">.</span>IEnumerator`<span class="token number">1</span><span class="token operator">&lt;</span><span class="token keyword">object</span><span class="token operator">></span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">.</span>custom instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>CompilerServices<span class="token punctuation">.</span>CompilerGeneratedAttribute<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token number">01</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token comment">// Fields</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment">// Token: 0x04000C77 RID: 3191</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">.</span>field assembly <span class="token keyword">object</span> $current</pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment">// Token: 0x04000C78 RID: 3192</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">.</span>field assembly <span class="token keyword">bool</span> $disposing</pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment">// Token: 0x04000C79 RID: 3193</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">.</span>field assembly int32 $PC</pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment">//============ 略 ================</span></pre></td></tr></table></figure><p>我们只有一个  <code>TestEnumerator</code>  类，但是  <code>IL</code>  代码中却在  <code>TestEnumerator</code>  中又额外包含了一个  <code>&lt;GetEnumerator&gt;c__Iterator0</code>  新类。</p><p>再看原本的  <code>GetEnumerator()</code>  方法：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Token: 0x06000E23 RID: 3619 RVA: 0x00059D54 File Offset: 0x00058154</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">public</span> hidebysig</pre></td></tr><tr><td data-num="3"></td><td><pre>    instance <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span><span class="token return-type class-name">System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>IEnumerator</span> GetEnumerator <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">.</span>custom instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Diagnostics<span class="token punctuation">.</span>DebuggerHiddenAttribute<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token number">01</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// Header Size: 12 bytes</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// Code Size: 15 (0xF) bytes</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// LocalVarSig Token: 0x11000353 RID: 851</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">.</span>maxstack <span class="token number">1</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">.</span><span class="token return-type class-name">locals</span> init <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">class</span> <span class="token class-name">TestEnumerator</span><span class="token operator">/</span>'<span class="token operator">&lt;</span>GetEnumerator<span class="token operator">></span>c__Iterator0'<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>IEnumerator</pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token comment">/* 0x00058160 736E110006   */</span> IL_0000<span class="token punctuation">:</span> newobj    instance <span class="token keyword">void</span> TestEnumerator<span class="token operator">/</span>'<span class="token operator">&lt;</span>GetEnumerator<span class="token operator">></span>c__Iterator0'<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">/* 0x00058165 0A           */</span> IL_0005<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">/* 0x00058166 06           */</span> IL_0006<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">/* 0x00058167 0B           */</span> IL_0007<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token comment">/* 0x00058168 3800000000   */</span> IL_0008<span class="token punctuation">:</span> br        IL_000D</pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token comment">/* 0x0005816D 07           */</span> IL_000D<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token comment">/* 0x0005816E 2A           */</span> IL_000E<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method TestEnumerator::GetEnumerator</span></pre></td></tr></table></figure><p>该方法创建并返回了  <code>&lt;GetEnumerator&gt;c__Iterator0</code>  类的实例。</p><h3 id="movenext-原理"><a class="anchor" href="#movenext-原理">#</a> MoveNext 原理</h3><p>那么，协程中又是如何实现分块执行  <code>yield</code>  分割的代码呢？</p><p>在我之前的想像中，是觉得有一个  <code>容器</code>  去  <code>盛放</code>  这些代码块，通过  <code>yield</code>  将原本函数代码分割成一个个更小的代码块，然后维护一个下标，通过  <code>MoveNext</code>  递增下标来执行实现。</p><p>看了  <code>IL</code>  代码后，虽然跟实际表现有差异，不过想得感觉倒是没大错：确实是被编译成了更细小的代码块，同时以一个下标维护着代码块执行进度。</p><p>首先是三个字段：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Fields</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// Token: 0x04000C77 RID: 3191</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">.</span>field assembly <span class="token keyword">object</span> $current</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// Token: 0x04000C78 RID: 3192</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">.</span>field assembly <span class="token keyword">bool</span> $disposing</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// Token: 0x04000C79 RID: 3193</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">.</span>field assembly int32 $PC</pre></td></tr></table></figure><p>因为之前的代码太简单，不好看出结构，这里我多加了一点代码：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token return-type class-name">IEnumerator</span> <span class="token function">GetEnumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"迭代1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"迭代2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"迭代3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>GetEnumerator()</code>  被编译为新类的  <code>MoveNext()</code>  方法块，结构如下：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Token: 0x0600116F RID: 4463 RVA: 0x00059D78 File Offset: 0x00058178</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">public</span> final hidebysig newslot <span class="token keyword">virtual</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>    instance <span class="token return-type class-name"><span class="token keyword">bool</span></span> MoveNext <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// Header Size: 12 bytes</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// Code Size: 133 (0x85) bytes</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// LocalVarSig Token: 0x1100007D RID: 125</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">.</span>maxstack <span class="token number">2</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">.</span><span class="token return-type class-name">locals</span> init <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> uint32</pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">/* 0x00058184 02           */</span> IL_0000<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">/* 0x00058185 7B790C0004   */</span> IL_0001<span class="token punctuation">:</span> ldfld     int32 TestEnumerator<span class="token operator">/</span>'<span class="token operator">&lt;</span>GetEnumerator<span class="token operator">></span>c__Iterator0'<span class="token punctuation">::</span>$PC</pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">/* 0x0005818A 0A           */</span> IL_0006<span class="token punctuation">:</span> stloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">/* 0x0005818B 02           */</span> IL_0007<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token comment">/* 0x0005818C 15           */</span> IL_0008<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span>m1</pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">/* 0x0005818D 7D790C0004   */</span> IL_0009<span class="token punctuation">:</span> stfld     int32 TestEnumerator<span class="token operator">/</span>'<span class="token operator">&lt;</span>GetEnumerator<span class="token operator">></span>c__Iterator0'<span class="token punctuation">::</span>$PC</pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">/* 0x00058192 06           */</span> IL_000E<span class="token punctuation">:</span> ldloc<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">/* 0x00058193 4503000000050000002B00000050000000 */</span> IL_000F<span class="token punctuation">:</span> <span class="token keyword">switch</span>    <span class="token punctuation">(</span>IL_0025<span class="token punctuation">,</span> IL_004B<span class="token punctuation">,</span> IL_0070<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">/* 0x000581A4 385C000000   */</span> IL_0020<span class="token punctuation">:</span> br        IL_0081</pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token comment">/* 0x000581A9 00           */</span> IL_0025<span class="token punctuation">:</span> nop</pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token comment">/* 0x000581AA 7230AE0070   */</span> IL_0026<span class="token punctuation">:</span> ldstr     <span class="token string">"迭代1"</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token comment">/* 0x000581AF 28F700000A   */</span> IL_002B<span class="token punctuation">:</span> call      <span class="token keyword">void</span> <span class="token punctuation">[</span>UnityEngine<span class="token punctuation">.</span>CoreModule<span class="token punctuation">]</span>UnityEngine<span class="token punctuation">.</span>Debug<span class="token punctuation">::</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token comment">/* 0x000581B4 02           */</span> IL_0030<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token comment">/* 0x000581B5 14           */</span> IL_0031<span class="token punctuation">:</span> ldnull</pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token comment">/* 0x000581B6 7D770C0004   */</span> IL_0032<span class="token punctuation">:</span> stfld     <span class="token keyword">object</span> TestEnumerator<span class="token operator">/</span>'<span class="token operator">&lt;</span>GetEnumerator<span class="token operator">></span>c__Iterator0'<span class="token punctuation">::</span>$current</pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token comment">/* 0x000581BB 02           */</span> IL_0037<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token comment">/* 0x000581BC 7B780C0004   */</span> IL_0038<span class="token punctuation">:</span> ldfld     <span class="token keyword">bool</span> TestEnumerator<span class="token operator">/</span>'<span class="token operator">&lt;</span>GetEnumerator<span class="token operator">></span>c__Iterator0'<span class="token punctuation">::</span>$disposing</pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token comment">/* 0x000581C1 2D07         */</span> IL_003D<span class="token punctuation">:</span> brtrue<span class="token punctuation">.</span>s  IL_0046</pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token comment">/* 0x000581C3 02           */</span> IL_003F<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token comment">/* 0x000581C4 17           */</span> IL_0040<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token comment">/* 0x000581C5 7D790C0004   */</span> IL_0041<span class="token punctuation">:</span> stfld     int32 TestEnumerator<span class="token operator">/</span>'<span class="token operator">&lt;</span>GetEnumerator<span class="token operator">></span>c__Iterator0'<span class="token punctuation">::</span>$PC</pre></td></tr><tr><td data-num="37"></td><td><pre></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token comment">/* 0x000581CA 3838000000   */</span> IL_0046<span class="token punctuation">:</span> br        IL_0083</pre></td></tr><tr><td data-num="39"></td><td><pre></pre></td></tr><tr><td data-num="40"></td><td><pre>    <span class="token comment">/* 0x000581CF 7238AE0070   */</span> IL_004B<span class="token punctuation">:</span> ldstr     <span class="token string">"迭代2"</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token comment">/* 0x000581D4 28F700000A   */</span> IL_0050<span class="token punctuation">:</span> call      <span class="token keyword">void</span> <span class="token punctuation">[</span>UnityEngine<span class="token punctuation">.</span>CoreModule<span class="token punctuation">]</span>UnityEngine<span class="token punctuation">.</span>Debug<span class="token punctuation">::</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="42"></td><td><pre>    <span class="token comment">/* 0x000581D9 02           */</span> IL_0055<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token comment">/* 0x000581DA 14           */</span> IL_0056<span class="token punctuation">:</span> ldnull</pre></td></tr><tr><td data-num="44"></td><td><pre>    <span class="token comment">/* 0x000581DB 7D770C0004   */</span> IL_0057<span class="token punctuation">:</span> stfld     <span class="token keyword">object</span> TestEnumerator<span class="token operator">/</span>'<span class="token operator">&lt;</span>GetEnumerator<span class="token operator">></span>c__Iterator0'<span class="token punctuation">::</span>$current</pre></td></tr><tr><td data-num="45"></td><td><pre>    <span class="token comment">/* 0x000581E0 02           */</span> IL_005C<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="46"></td><td><pre>    <span class="token comment">/* 0x000581E1 7B780C0004   */</span> IL_005D<span class="token punctuation">:</span> ldfld     <span class="token keyword">bool</span> TestEnumerator<span class="token operator">/</span>'<span class="token operator">&lt;</span>GetEnumerator<span class="token operator">></span>c__Iterator0'<span class="token punctuation">::</span>$disposing</pre></td></tr><tr><td data-num="47"></td><td><pre>    <span class="token comment">/* 0x000581E6 2D07         */</span> IL_0062<span class="token punctuation">:</span> brtrue<span class="token punctuation">.</span>s  IL_006B</pre></td></tr><tr><td data-num="48"></td><td><pre></pre></td></tr><tr><td data-num="49"></td><td><pre>    <span class="token comment">/* 0x000581E8 02           */</span> IL_0064<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="50"></td><td><pre>    <span class="token comment">/* 0x000581E9 18           */</span> IL_0065<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">2</span></pre></td></tr><tr><td data-num="51"></td><td><pre>    <span class="token comment">/* 0x000581EA 7D790C0004   */</span> IL_0066<span class="token punctuation">:</span> stfld     int32 TestEnumerator<span class="token operator">/</span>'<span class="token operator">&lt;</span>GetEnumerator<span class="token operator">></span>c__Iterator0'<span class="token punctuation">::</span>$PC</pre></td></tr><tr><td data-num="52"></td><td><pre></pre></td></tr><tr><td data-num="53"></td><td><pre>    <span class="token comment">/* 0x000581EF 3813000000   */</span> IL_006B<span class="token punctuation">:</span> br        IL_0083</pre></td></tr><tr><td data-num="54"></td><td><pre></pre></td></tr><tr><td data-num="55"></td><td><pre>    <span class="token comment">/* 0x000581F4 7240AE0070   */</span> IL_0070<span class="token punctuation">:</span> ldstr     <span class="token string">"迭代3"</span></pre></td></tr><tr><td data-num="56"></td><td><pre>    <span class="token comment">/* 0x000581F9 28F700000A   */</span> IL_0075<span class="token punctuation">:</span> call      <span class="token keyword">void</span> <span class="token punctuation">[</span>UnityEngine<span class="token punctuation">.</span>CoreModule<span class="token punctuation">]</span>UnityEngine<span class="token punctuation">.</span>Debug<span class="token punctuation">::</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="57"></td><td><pre>    <span class="token comment">/* 0x000581FE 02           */</span> IL_007A<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="58"></td><td><pre>    <span class="token comment">/* 0x000581FF 15           */</span> IL_007B<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span>m1</pre></td></tr><tr><td data-num="59"></td><td><pre>    <span class="token comment">/* 0x00058200 7D790C0004   */</span> IL_007C<span class="token punctuation">:</span> stfld     int32 TestEnumerator<span class="token operator">/</span>'<span class="token operator">&lt;</span>GetEnumerator<span class="token operator">></span>c__Iterator0'<span class="token punctuation">::</span>$PC</pre></td></tr><tr><td data-num="60"></td><td><pre></pre></td></tr><tr><td data-num="61"></td><td><pre>    <span class="token comment">/* 0x00058205 16           */</span> IL_0081<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="62"></td><td><pre>    <span class="token comment">/* 0x00058206 2A           */</span> IL_0082<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="63"></td><td><pre></pre></td></tr><tr><td data-num="64"></td><td><pre>    <span class="token comment">/* 0x00058207 17           */</span> IL_0083<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="65"></td><td><pre>    <span class="token comment">/* 0x00058208 2A           */</span> IL_0084<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="66"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method '&lt;GetEnumerator>c__Iterator0'::MoveNext</span></pre></td></tr></table></figure><p>其中  <code>$PC</code>  字段就代表了当前细分代码块进度，然后在  <code>MoveNext()</code>  方法调用时，通过一个  <code>IL_000F: switch    (IL_0025, IL_004B, IL_0070)</code> —— 也就是  <code>Switch case</code>  判断执行当前应该执行哪个细分代码块了。</p><p>执行完细分代码块后，将  <code>yield</code>  返回值赋值给  <code>$current</code> :</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/* 0x000581B4 02           */</span> IL_0030<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">/* 0x000581B5 14           */</span> IL_0031<span class="token punctuation">:</span> ldnull</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">/* 0x000581B6 7D770C0004   */</span> IL_0032<span class="token punctuation">:</span> stfld     <span class="token keyword">object</span> TestEnumerator<span class="token operator">/</span>'<span class="token operator">&lt;</span>GetEnumerator<span class="token operator">></span>c__Iterator0'<span class="token punctuation">::</span>$current</pre></td></tr></table></figure><p>并将  <code>$PC</code>  替换为对应的 index：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/* 0x000581C3 02           */</span> IL_003F<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">/* 0x000581C4 17           */</span> IL_0040<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">/* 0x000581C5 7D790C0004   */</span> IL_0041<span class="token punctuation">:</span> stfld     int32 TestEnumerator<span class="token operator">/</span>'<span class="token operator">&lt;</span>GetEnumerator<span class="token operator">></span>c__Iterator0'<span class="token punctuation">::</span>$PC</pre></td></tr></table></figure><p>执行完毕后，最后通过指令跳转返回  <code>0</code>  或  <code>1</code>  作为  <code>bool</code>  变量，用于调用者判断是否已结束：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/* 0x00058205 16           */</span> IL_0081<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">/* 0x00058206 2A           */</span> IL_0082<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">/* 0x00058207 17           */</span> IL_0083<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">1</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">/* 0x00058208 2A           */</span> IL_0084<span class="token punctuation">:</span> ret</pre></td></tr></table></figure><p>原来指令集中  <code>bool</code>  确实是作为  <code>int</code>  处理的？难怪之前在研究  <code>Bool字节对齐</code>  字节对齐的时候，通过  <code>Marshal.SizeOf</code>  取出来是  <code>4</code>  个字节。</p><h1 id="实现自己的协程"><a class="anchor" href="#实现自己的协程">#</a> 实现自己的协程</h1><p>有了上述基本原理理解之后，实现一个自己的  <code>协程</code>  也就是非常简单的事了。</p><p>这里以一个简单的多线程为例：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestEnumerator</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">SynchronizationContext</span> Current<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token function">TestEnumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        Current <span class="token operator">=</span> SynchronizationContext<span class="token punctuation">.</span>Current<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DoTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token class-name">IEnumerator</span> em <span class="token operator">=</span> <span class="token function">TestMyEnumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        ThreadPool<span class="token punctuation">.</span><span class="token function">QueueUserWorkItem</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=></span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token class-name"><span class="token keyword">int</span></span> wait <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>em<span class="token punctuation">.</span><span class="token function">MoveNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                wait <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>em<span class="token punctuation">.</span>Current <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                    Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>wait <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token function">TryParse</span><span class="token punctuation">(</span>em<span class="token punctuation">.</span>Current<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">out</span> wait<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                    Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>wait <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                <span class="token keyword">else</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                    <span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"发现未知迭代对象："</span> <span class="token operator">+</span> em<span class="token punctuation">.</span>Current<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name">IEnumerator</span> <span class="token function">TestMyEnumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        <span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"迭代1，Time："</span> <span class="token operator">+</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"迭代2，Time："</span> <span class="token operator">+</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>        <span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"迭代3，Time："</span> <span class="token operator">+</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">WaitForEndOfFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="45"></td><td><pre></pre></td></tr><tr><td data-num="46"></td><td><pre>    <span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Log</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> str<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="47"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>        Current<span class="token punctuation">.</span><span class="token function">Post</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=></span> Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="50"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="/blogimages/2023/2023-02-01/m_89e0a77f491e315a3a6392e896cf92fa_r.png" alt="" /></p><p>如上图所示，我们自己实现的  <code>协程</code>  ，只处理了  <code>yield return null</code>  及  <code>yield return 数字</code>  的情况，若为  <code>null</code>  等待一秒，若为  <code>数字</code>  则等待指定数字秒数。</p><p>根据打印时间判断，逻辑是正确生效了的。</p><p>同时如果还有其它等待逻辑，则增加判断即可，如  <code>Unity</code>  提供的各种协程等待方法： <code>WaitForEndOfFrame</code> 、 <code>WaitForSeconds</code> 、 <code>WaitForFixedUpdate</code>  等等，我怀疑就是这样处理的，不过由于  <code>Unity</code>   <code>StartCoroutine</code>  协程最终实际生效是调用的  <code>extern</code>  函数，C# 反编译跟不进去了：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">MethodImpl</span><span class="token attribute-arguments"><span class="token punctuation">(</span>MethodImplOptions<span class="token punctuation">.</span>InternalCall<span class="token punctuation">)</span></span></span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">extern</span> <span class="token return-type class-name">Coroutine</span> <span class="token function">StartCoroutineManaged2</span><span class="token punctuation">(</span><span class="token class-name">IEnumerator</span> enumerator<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>因此真实逻辑就不得而知了，只能猜测大约是使用类似方式，毕竟迭代器逻辑就这样。</p><h1 id="unity协程执行时机"><a class="anchor" href="#unity协程执行时机">#</a> Unity 协程执行时机</h1><p>在 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTkuNC9NYW51YWwvRXhlY3V0aW9uT3JkZXIuaHRtbA==">官方文档 ExecutionOrder</span> 有对应的流程图，其正常等待位于  <code>Update</code>  之后， <code>LateUpdate</code>  之前。</p><p>例外的有比如： <code>WaitForFixedUpdate</code>  位于 Update 之前， <code>WaitForEndOfFrame</code>  位于一帧最后。</p><h1 id="补充"><a class="anchor" href="#补充">#</a> 补充</h1><p>(2023.2.24)</p><h2 id="调用了类成员函数的协程"><a class="anchor" href="#调用了类成员函数的协程">#</a> 调用了类成员函数的协程</h2><p>例如：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestEnumerator</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">int</span></span> _counter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token return-type class-name">IEnumerator</span> <span class="token function">GetEnumerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"迭代"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        _counter<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>为协程编译的新类字段中会对本类产生引用：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Fields</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">private</span> int32 '<span class="token operator">&lt;</span><span class="token operator">></span>1__state'</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">private</span> <span class="token keyword">object</span> '<span class="token operator">&lt;</span><span class="token operator">></span>2__current'</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestEnumerator</span> '<span class="token operator">&lt;</span><span class="token operator">></span>4__this'</pre></td></tr></table></figure><p>初始化的地方是原本主类的  <code>GetEnumerator</code>  方法（实例化迭代类时将自身实例传进去）：</p><figure class="highlight cs"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Fields</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">.</span>field <span class="token keyword">private</span> int32 _counter</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// Methods</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">.</span>method <span class="token keyword">public</span> hidebysig </pre></td></tr><tr><td data-num="6"></td><td><pre>    instance <span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span><span class="token return-type class-name">System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>IEnumerator</span> GetEnumerator <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token return-type class-name">cil</span> managed </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">.</span>custom instance <span class="token keyword">void</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Runtime<span class="token punctuation">.</span>CompilerServices<span class="token punctuation">.</span>IteratorStateMachineAttribute<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">[</span>mscorlib<span class="token punctuation">]</span>System<span class="token punctuation">.</span>Type<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token number">01</span> <span class="token number">00</span> <span class="token number">22</span> <span class="token number">54</span> <span class="token number">65</span> <span class="token number">73</span> <span class="token number">74</span> <span class="token number">45</span> 6e <span class="token number">75</span> <span class="token number">6d</span> <span class="token number">65</span> <span class="token number">72</span> <span class="token number">61</span> <span class="token number">74</span> <span class="token number">6f</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token number">72</span> 2b 3c <span class="token number">47</span> <span class="token number">65</span> <span class="token number">74</span> <span class="token number">45</span> 6e <span class="token number">75</span> <span class="token number">6d</span> <span class="token number">65</span> <span class="token number">72</span> <span class="token number">61</span> <span class="token number">74</span> <span class="token number">6f</span> <span class="token number">72</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        3e <span class="token number">64</span> <span class="token number">5f</span> <span class="token number">5f</span> <span class="token number">31</span> <span class="token number">00</span> <span class="token number">00</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// Method begins at RVA 0x2151</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">// Header size: 1</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// Code size: 14 (0xe)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">.</span>maxstack <span class="token number">8</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    IL_0000<span class="token punctuation">:</span> ldc<span class="token punctuation">.</span>i4<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    IL_0001<span class="token punctuation">:</span> newobj instance <span class="token keyword">void</span> TestEnumerator<span class="token operator">/</span>'<span class="token operator">&lt;</span>GetEnumerator<span class="token operator">></span>d__1'<span class="token punctuation">::</span><span class="token punctuation">.</span><span class="token function">ctor</span><span class="token punctuation">(</span>int32<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    IL_0006<span class="token punctuation">:</span> <span class="token class-name">dup</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    IL_0007<span class="token punctuation">:</span> ldarg<span class="token punctuation">.</span><span class="token number">0</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    IL_0008<span class="token punctuation">:</span> stfld <span class="token keyword">class</span> <span class="token class-name">TestEnumerator</span> TestEnumerator<span class="token operator">/</span>'<span class="token operator">&lt;</span>GetEnumerator<span class="token operator">></span>d__1'<span class="token punctuation">::</span>'<span class="token operator">&lt;</span><span class="token operator">></span>4__this'</pre></td></tr><tr><td data-num="23"></td><td><pre>    IL_000d<span class="token punctuation">:</span> ret</pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">// end of method TestEnumerator::GetEnumerator</span></pre></td></tr></table></figure><p>注：后续反编译发现就算协程没有调用主类字段，初始化内嵌类时依然会将主类实例出传递进去 (为什么上面的记录似乎没有？)。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><ul><li>反编译  <code>IL</code>  代码显示为自动创建一个实现了  <code>IEnumerator</code>  的新类，调用存在  <code>yield</code>  的原方法自动  <code>newObj</code>  这个新类<ul><li>协程的局部变量会被编译为新类的成员变量</li></ul></li><li>根据  <code>yield</code>  原方法逻辑会被编译成一段一段更细粒度的的代码块，并挪到  <code>MoveNext</code>  方法中</li><li>维护一个下标，每次调用返回的  <code>IEnumerator</code>   <code>MoveNext()</code>  就往下挪一位</li><li>等待逻辑后再调用下一个小方法块，可以由调用者判断  <code>Current</code>  值进行操作。因此如果是主线程调用，其中有死循环就会卡死主线程</li><li>协程本质上依然只是主线程上的一个调用，消耗的是主线程的时间，同时每个协程方法会被编译成一个新类，因此也不能滥用，顶多某些时候可以更方便地分帧处理</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;这两天又研究了下协程，之前虽然用过，也稍微想过，但是并没有深入研究，这次就想把流程仔细走一遍。&lt;/p&gt;
&lt;h1 id=&quot;原理&quot;&gt;&lt;a class=&quot;anchor&quot; </summary>
      
    
    
    
    <category term="C#" scheme="https://wangjiaying.top/categories/C/"/>
    
    
    <category term="C#" scheme="https://wangjiaying.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2022年总结</title>
    <link href="https://wangjiaying.top/2023/01/30/2022%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://wangjiaying.top/2023/01/30/2022%E5%B9%B4%E6%80%BB%E7%BB%93/</id>
    <published>2023-01-30T03:48:27.000Z</published>
    <updated>2023-04-16T08:02:40.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>今年春节本来也没回家，就打算把总结写一下的。然后不知怎么拖延症又上来了，加上春节放假前几天不知怎么，嘴里也开了个口子，吃东西都疼，心情也难以好起来。</p><p>整个春节除了有两天时间出去买菜之外（另外春节蔬菜也涨价了，几乎比平时贵了几倍，白菜除外），基本上是一直待在成都屋里的。</p><ul><li>早上起床坐一会，感觉就该吃午饭了</li><li>再睡一觉，又到了晚饭</li></ul><p>—— 简直过得比以前看小说的时候都快，时间从来没这么快的！</p><p>以前有听过一个理论：</p><blockquote><p>熟悉的记忆会被大脑合并，导致产生『时间过得快』的错觉，这次春节确实有这种感觉。</p></blockquote><p>仔细想想，春节本来还打算利用这些时间加深学习的，结果似乎也没干多少事：</p><ol><li>收尾批量图片处理工具</li><li>又玩了《三国志幻想大陆》—— 不得不说，这游戏的回归福利太好了，送得像破解版似的，当然回归时间过了就没了</li><li>1 月 26~27 号补番看了《致不灭的你 2》、《世界顶尖的暗杀者 - 转生为异世界贵族》、《野良神》</li></ol><p>也就是说，春节花了几天把 <a href="/2023/01/21/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%89%B9%E9%87%8F%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/" title="开发一个批量图片处理工具">开发一个批量图片处理工具</a> 姑且收尾之后，就一直拖着了。</p><hr /><p>今天是 1 月 30 日，眼看着一月份就要过去了，还是整理一下，把总结写了罢。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>又是一年，2022 年就这样过去了，来到了 2023 年。</p><p>去年做了什么呢？</p><h2 id="生活上"><a class="anchor" href="#生活上">#</a> 生活上</h2><p>游戏上玩了：</p><ol><li>《幻塔》台服</li><li>《三国志幻想大陆》(年底刚回坑玩了下)</li></ol><p>小说：</p><ol><li>信息全知者 (没看完，太长了)</li><li>银河系殖民手册</li><li>天道方程式</li><li>我的成神日志</li></ol><p>小说就看了这么几本？</p><p>感觉当然不止，只是从头看完的，还觉得可以的大概就这几本了。</p><p>最后的成神日志写了一个靠 “学习” 把一切都研究透彻的故事，虽然必然夸大其词 —— 毕竟是小说，不过总感觉让人也对追求知识有所期待了。</p><p>后面暂时就不打算看小说了 (其实自动去年评审后基本就没看了)。<br />小说虽然容易让大脑满足幻想，但也有可能覆盖显示记忆的缺点，大概就是那种以感性换理性的感觉，『过犹不及』，如果想继续前进，就不大容幻想，还是要回到理性上来，以后什么时候想歇歇了再说吧。</p><hr /><p>还有就是，跟妹妹介绍的对象  <code>晚安晚安早安</code>  地发了一年之后，前段时间也终于没有再聊了 —— 网聊确实很难，开始那段时间确实心情挺激动的样子，想象着对方的样子。<br />不过久了之后就感觉越来越难以为继了，特别是我们性格都是那种... 难以主动表达自己的人 —— 一年了，甚至我们除了一开始之外，都没有语音过、更别说什么视频了。连对方的样子说实话，都没有任何印象。</p><p>国庆时候回去看了一下，不过只见了一面对方就回老家去了，作为脸盲患者，很快就又失了印象。</p><p>加上作为恐婚者，难以想象怎么样与另外似乎『陌生人』人共同生活。那段时间工作也不顺利，买的基金也巨亏，慢慢就淡了。</p><p>虽然家里人劝起来有时候感觉危机... 一般听得最多的就是，现在年轻，但是老了怎么办？但确实恐惧、害怕、担心，总让人想起以前，小学、初中、高中...<br /> 一个人就不用担心了。</p><h2 id="工作上"><a class="anchor" href="#工作上">#</a> 工作上</h2><p>自从开始接手现在 汉室复兴 项目以来，也有一年多了 —— 还记得前年刚接手的时候，给组员开周会都紧张得背上冒汗，到逐渐能比较完整传达意思，明明感觉比以前光做功能时进步更大。</p><p>而且在此期间除了大功能开发之外，基本上都亲力亲为地去搞，同时在这期间以优化项目总体上进行研究新技术，试图应用于项目本身。</p><p>比如意图升级项目，然后采用 Huatuo (HybridClr) 方式进行代码热更 —— 想象以后要是跟策划运营说：『需求你们随便提，版更都不用出整包，直接可以功能热更』就感觉有点激动呢！</p><p>过去的一年大概是工作积极性最高的。</p><p>当然，虽然是项目主程了，也不能为所欲为... 被更上级阻止了，被批评忽视了项目安全和稳定性 —— 虽然我觉得自己已经够稳了，测试都是在无关紧要分支上做的。当时费功夫升级后，又花时间『<a href="/2022/08/31/%E5%85%B3%E4%BA%8E%E4%BB%8EUnity2021%E9%99%8D%E7%BA%A7%E4%B8%BAUnity2018%E7%9A%84%E9%97%AE%E9%A2%98/" title="降级">降级</a>』，现在那个分支版本可以说是都已经被『放弃』了。</p><p>于是只能说，以后会把自我学习放在首位，项目以稳定性为准，维护好项目。</p><h2 id="学习上"><a class="anchor" href="#学习上">#</a> 学习上</h2><h3 id="底层基础知识的深入"><a class="anchor" href="#底层基础知识的深入">#</a> 底层基础知识的深入</h3><p>之前老是去搞宏观上的技术研究，能不能用上不说 —— 却因为项目开发过程中用不到就忽略忽视了对基础知识的深入了解和研究以及复习，并且没有作系统的总结，导致知识分散，都是点，无法形成面，不能统合所学知识，甚至清晰明确地表达出来。—— 这样也导致碰到问题，全凭经验解决，问如何解决的？就难以适时找出合适的回答。</p><p>特别是底层知识点，不能因为平时用不上，就只做理论上了解，理论了解再多，想错了那就全错了，必须得实践 —— 自己创建测试工程，一一尝试，才能明白究竟哪里理解得不对，哪里有偏差，及时反应过来并正确理解。当足够深入，平时想不到的做法或许就有启发？</p><h3 id="还有项目功能设计总结"><a class="anchor" href="#还有项目功能设计总结">#</a> 还有项目功能设计总结</h3><p>知道跟说出来是两回事，除了本身了解，还得想象如何才能明确表达，问急了直接说不知道是不行的 —— 而且思维还停留在问什么答什么。</p><p>例如之前评审时问的登录功能，解析登录数据的排序如何？控制顺序字段数组里加字段都不是一次两次了，结果直接按照普通接口解析规则回答，回答顺序控制由后台决定..... 虽然后面的是按照项目回答的，但是第一步就错了就给人一种是不是乱说的感觉？所以说做功能不止做完就完了，还得记住为什么才行，说不出来的经验谁当真呢。</p><h3 id="另外纯理论知识也需要更多的补充同时结合实践理解"><a class="anchor" href="#另外纯理论知识也需要更多的补充同时结合实践理解">#</a> 另外，纯理论知识也需要更多的补充，同时结合实践理解</h3><p>平时还是在开发应用层面花的时间多了（而且还没法把这些 “应用” 清晰明确地逻辑讲出来）。</p><ul><li>例如战斗系统<br />从《九州缥缈录》——18 年还是 19 年开始就一直在搞战斗系统，当被问到 如何设计一个高性能战斗系统？ 的时候，竟然不知道从何说起 —— 这虽然跟当时实在是脑袋太昏有点关系，但更多也是因为平时只在单纯做，实现策划功能，却没有认真去思考框架设计有关系。</li></ul><p>给一个需求单，然后给几天慢慢想肯定能能给出一个完整的解决方案，要求当时立即说出来.... 那实在是难反应过来 —— 总感觉自己的脑袋比较笨，即时反应能力很弱。平时也该更多地思考。</p><h3 id="其次对算法技能也不够敏感需要加强算法锻炼"><a class="anchor" href="#其次对算法技能也不够敏感需要加强算法锻炼">#</a> 其次对算法技能也不够敏感，需要加强算法锻炼</h3><h3 id="最后关于写文章"><a class="anchor" href="#最后关于写文章">#</a> 最后，关于写文章</h3><p>之前的自我学习的时候也确存在缺点，比较浮于表面，而且写文章也太啰嗦了，长篇大论后自己都不想看，所以后面我开始有意识在文章末尾加上『总结』：至少把重点最后标注出来</p><p>当然感觉写文章本身的时候该是也需要优化一下，写明白主要点就够了，提及重点 —— 毕竟写技术文章主要就是给自己看，太过于长篇大论，浪费时间不说，后续自己都不喜欢看也没意义。</p><p>嗯... 文章排版也需要学习下，就算用 Markdown，也总感觉跟其他人的有很大差距，不够美观，组织还难看。</p><p>过去一年，虽然写了十几二十几篇文章，时间久了知识点连自己都记不清了。所以，要记、思考、总结并理解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;今年春节本来也没回家，就打算把总结写一下的。然后不知怎么拖延症又上来了，加上春节放假前几天不知怎么，嘴里也开了个口子，吃东西都疼，心情也难以好起来。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="总结" scheme="https://wangjiaying.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="总结" scheme="https://wangjiaying.top/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
