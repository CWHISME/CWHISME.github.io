<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CWHISME</title>
  
  <subtitle>人不能没有梦想，也要有足够的敬畏</subtitle>
  <link href="https://wangjiaying.top/atom.xml" rel="self"/>
  
  <link href="https://wangjiaying.top/"/>
  <updated>2023-10-22T08:23:16.985Z</updated>
  <id>https://wangjiaying.top/</id>
  
  <author>
    <name>WangJiaYing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《C++ Primer(第五版)》-笔记(2)</title>
    <link href="https://wangjiaying.top/2023/10/22/CPP-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%AC%94%E8%AE%B0-2/"/>
    <id>https://wangjiaying.top/2023/10/22/CPP-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%AC%94%E8%AE%B0-2/</id>
    <published>2023-10-22T07:57:06.000Z</published>
    <updated>2023-10-22T08:23:16.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本篇笔记从原书第二部分开始，到第三部分第十四章重载运算与类型转换结束，不过对于 第八章 (IO 库)、第九章 (顺序容器)、第十一章 (关联容器) 基本略过。<br />因为这几章个人也只是粗略翻过，考虑到就算 UE5 里边，容器算法这些估计也都是全套 UE 系列自定义的模板，所以对于标准库提供的感觉目前大概了解下、有个印象就行了。<br />同理，第十章泛型算法也是如此，不过还是记录了部分思想。</p><hr /><p>本来之前还计划国庆节把这本书看完，结果因为国庆身体中招了，加上研究了下其它 (UE5 C++ 及其动画、AI 等)，国庆后又忙于工作交接，导致现在其实也还剩了三分之一，因此觉得还是分一下阶段比较好... 可能还是得分成三份了。</p><h1 id="第九章-顺序容器"><a class="anchor" href="#第九章-顺序容器">#</a> 第九章 顺序容器</h1><ul><li><code>vector</code> ：可变大小数组，具有 size 和 capacity，当添加元素导致 size 超出 capacity 则翻倍扩容。</li><li><code>deque</code> ：双端队列，支持快速随机访问，在 头 (尾) 插入 (删除) 元素很快。</li><li><code>list</code> ：双向链表</li><li><code>forward_lis</code> t：单链表</li><li><code>array</code> ：固定大小数组，与内置数组相比更安全、更容易使用</li><li><code>string</code> ：与 vector 类似，保存字符容器</li></ul><p>容器适配器</p><ul><li><code>stack</code> ：栈，默认基于 deque 实现。</li><li><code>queue</code> ：队列，默认基于 deque 实现。</li><li><code>priority_queue</code> ：优先级队列，默认基于 vector 实现。</li></ul><h1 id="第十章-泛型算法"><a class="anchor" href="#第十章-泛型算法">#</a> 第十章 泛型算法</h1><p>标准库并未给每个容器都定义成员函数来实现各种操作，而是定义了一组 泛型算法。</p><ul><li>这组算法实现了一些经典算法的公共接口 (如排序、搜索)</li><li>一般情况这些算法不直接操作容器，而是遍历由两个迭代器指定的元素范围</li><li>迭代器令算法不依赖于容器：泛型算法本身不执行容器的操作，而是运行于迭代器之上，执行迭代器操作</li></ul><h2 id="lamda-表达式"><a class="anchor" href="#lamda-表达式">#</a> lamda 表达式</h2><p>对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它为可调用的。</p><ul><li>函数和函数指针</li><li>重载了函数调用运算符的类</li><li>lambda 表达式</li></ul><p>一个 lambda 表达式表示一个可调用的代码单元，可理解为一个未命名的内联函数。</p><ul><li><code>[捕获列表](参数列表)-&gt;返回类型&#123;函数体&#125;</code></li><li>参数列表和返回类型可被忽略： <code>auto f=[]&#123;return 42;&#125;</code></li><li>注：捕获列表只用于局部非 static 变量，lambda 可直接使用局部 static 变量和它所在函数之外声明的名字。</li></ul><p>lambda 捕获和返回</p><ul><li>当定义一个 lambda 时，编译器生成一个与 lambda 对应的新的 (未命名的) 类类型。</li><li>默认情况下，从 lambda 生成的类都包含一个对应该 lambda 所捕获的变量的数据成员 (类似任何普通类的数据成员)，lambda 数据成员也在 lambda 对象创建时被初始化。</li></ul><p>值捕获</p><ul><li><code>auto f=[v1]&#123;return v1;&#125;</code></li><li>与传值参数类似，采用值拷贝的前提是变量可以拷贝，与参数不同，被捕获的变量在 lambda 创建时被拷贝 (进 lambda 数据成员)。</li></ul><p>引用捕获</p><ul><li><code>auto f=[&amp;v1]&#123;return v1;&#125;</code></li><li>以引用捕获方式与其它任何类型的引用的行为类似，当在 lambda 内使用时，实际操作的是引用所绑定对象。</li><li>引用捕获与返回引用有相同问题和限制：必须确保执行时被引用对象依然存在。</li></ul><p>隐式捕获</p><ul><li>让编译器根据 lambda 体中的代码来推断需要使用哪些变量</li><li>捕获列表：&amp;(引用捕获) 或 =(值捕获)</li><li>可混合使用： <code>[&amp;,c]xxxx、[=,&amp;c]xxxx</code> ，捕获列表中第一个元素 (&amp; 或 =) 指定了默认捕获方式为引用或值。</li></ul><p>可变 lambda</p><ul><li>默认情况下，值捕获的被拷贝的变量，lambda 不会改变其值</li><li>若想改变需要加上 mutable 关键字</li><li><code>[v1]()mutable &#123;return ++v1;&#125;</code></li></ul><h2 id="标准库-bind-函数"><a class="anchor" href="#标准库-bind-函数">#</a> 标准库 bind 函数</h2><p><code>auto newCallable=bind(callable,arg_list);</code></p><ul><li>arg_list：参数列表， 形如『 <code>_n</code> 』，n 表示参数占位符</li><li>可看作一个通用函数适配器</li><li>接受一个可调用对象，生成一个新的可调用对象来 适配 原对象的参数列表</li><li>可用 bind 修正参数的值、调整顺序等</li></ul><p>绑定引用参数</p><ul><li>引用：ref (val)，ref 返回一个对象，包含给定的引用</li><li>常量引用：cref (val)，cref 生成一个保存 const 引用的类</li><li>例：bind (print,ref (os),_1,' ')</li></ul><h2 id="再探迭代器"><a class="anchor" href="#再探迭代器">#</a> 再探迭代器</h2><p>额外迭代器：</p><ul><li>插入迭代器：绑定于容器，用于插入元素</li><li>流迭代器：绑定到输入或输出流，用于遍历关联 IO 流</li><li>反向迭代器：向后而不是向前移动，除 forward_list 均有</li><li>移动迭代器：移动元素</li></ul><h1 id="第十一章-关联容器"><a class="anchor" href="#第十一章-关联容器">#</a> 第十一章 关联容器</h1><p>按关键字有序保存元素</p><ul><li><code>map</code> ：关联数组，保存关键字 - 值对<ul><li>如果关键字还未在 map 中，下标运算会添加一个新元素</li></ul></li><li><code>set</code> ：关键字即值</li><li><code>multimap</code> ：关键字可重复出现的 map</li><li><code>multiset</code> ：关键字可重复出现的 set</li></ul><p>无序集合</p><ul><li><code>unorderd_map</code> ：哈希函数组织的 map</li><li><code>unorderd_set</code> ：哈希函数组织的 set</li><li><code>unorderd_multimap</code></li><li><code>unorderd_multiset</code></li></ul><h2 id="pair-类型"><a class="anchor" href="#pair-类型">#</a> pair 类型</h2><p>一个 pair 保存两个数据成员</p><ul><li><code>make_pair</code></li></ul><h1 id="第十二章-动态内存"><a class="anchor" href="#第十二章-动态内存">#</a> 第十二章 动态内存</h1><p>动态分配的对象生存期与它们在哪里创建无关，只有显示释放才会销毁。<br />在 C++ 中，动态内存管理运算符 new 和 delete 完成。</p><ul><li>在自由空间分配的内存是无名的，new 运算符返回指向该对象的指针</li><li><code>int *pi1=new int; //默认初始化，*pi1 的值未定义</code></li><li><code>int *pi2=new int() //值初始化为 0，*pi2 为 0</code></li><li>注：对于定义了自己构造函数的类类型来说，不管采用哪种方式都会通过默认构造函数来初始化。默认初始化和值初始化仅影响内置类型成员。</li><li>const 对象使用 new 分配是合法的 (也可以 delete)</li><li>内存耗尽时，new 表达式就会失败</li><li>由内置指针 (而非智能指针) 管理的动态内存在被显式释放前一直都会存在。</li></ul><p>空悬指针：指向一块曾经保存数据对象但现在已经无效的内存的指针。</p><h2 id="智能指针"><a class="anchor" href="#智能指针">#</a> 智能指针</h2><p>智能指针也是模板。<br />默认初始化的智能指针中保存着一个空指针，如果在一个条件判断语句中使用智能指针，效果就是检测其是否为空。</p><ul><li>解引用一个智能指针返回它指向的对象</li></ul><p>即使发生异常，(由于局部对象会被销毁) 智能指针也会释放其对象。</p><h3 id="类型"><a class="anchor" href="#类型">#</a> 类型</h3><p><code>shared_ptr</code></p><ul><li>允许多个指针指向同一个对象。</li><li>通过引用计数器记录，当我们拷贝 shared_ptr 时计数递增，被拷贝对象离开作用域被销毁递减</li><li>计数器归零则自动释放所管理对象 (通过析构函数)</li></ul><p><code>unique_ptr</code></p><ul><li>『独占』所指向的对象</li></ul><p><code>weak_ptr</code></p><ul><li>一种弱引用，指向 shared_ptr 所管理的对象</li></ul><h3 id="make_shared-函数"><a class="anchor" href="#make_shared-函数">#</a> make_shared 函数</h3><p>此函数在动态内存分配一个对象并初始化，返回指向对象的 shared_ptr</p><ul><li>可传递匹配对应对象构造函数的参数</li><li>若不传递任何参数，对象会被进行值初始化</li></ul><h3 id="shared_ptr-和-new-结合使用"><a class="anchor" href="#shared_ptr-和-new-结合使用">#</a> shared_ptr 和 new 结合使用</h3><p>这两者允许结合使用，使用 new 返回的指针初始化智能指针 (但必须使用直接初始化方式)：</p><ul><li><code>shared_ptr&lt;int&gt; p(new int(1024))</code></li><li>另外 shared_ptr 提供了 get 函数返回普通指针</li><li>reset：<ul><li>释放绑定的普通指针</li><li>或重新绑定智能指针维护的普通指针</li><li>(会更新引用计数)</li></ul></li></ul><p>注 1：默认情况下初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用 delete 释放关联对象。可使用 shared_ptr<T> p (q,d) (d 为可调用对象) 接管释放对象操作。<br />注 2：但是不要混合使用智能指针和普通指针</p><h3 id="自定义-shared_ptr-释放操作"><a class="anchor" href="#自定义-shared_ptr-释放操作">#</a> 自定义 shared_ptr 释放操作</h3><p>可以传递一个可选的指向删除器函数的参数</p><h3 id="智能指针使用注意"><a class="anchor" href="#智能指针使用注意">#</a> 智能指针使用注意</h3><ul><li>不使用相同的内置指针初始化 (或 reset) 多个智能指针</li><li>不 delete get () 返回的内置指针</li><li>不使用 get () 返回的内置指针初始化或 reset 另外一个智能指针</li><li>使用 get () 返回的内置指针时，注意智能指针自动释放后，该内置指针指向内存也会无效</li><li>如果智能指针不是管理的 new 操作符分配的动态内存，注意需要传递一个删除器以使其正确释放对象</li></ul><h3 id="unique_ptr"><a class="anchor" href="#unique_ptr">#</a> unique_ptr</h3><p>某个时刻只有一个 unique_ptr 指向一个给定对象<br />因此 unique_ptr 不支持普通的拷贝或赋值操作，只能采用直接初始化方式：</p><ul><li><code>unique_ptr&lt;int&gt; p(new int(1024))</code></li><li>注：拷贝限制的例外之处在于即将销毁时，例如允许从函数返回一个 unique_ptr</li></ul><p>需要注意的是 release 操作：</p><ul><li>该操作会切断 unique_ptr 与其管理的对象间的联系，返回对象内置指针 (不会释放对象内存)</li><li>返回的内置指针需要我们自己维护 (释放)，或转移至另外一个智能指针管理</li><li>(会导致释放对象的操作与 shared_ptr 一样，是 reset)</li></ul><h3 id="weak_ptr"><a class="anchor" href="#weak_ptr">#</a> weak_ptr</h3><p>一种不控制所指向对象生存期的智能指针，其指向一个 shared_ptr，即使有 weak_ptr 指向，当其它指向 shared_ptr 销毁时对象就会被 shared_ptr 销毁。<br />主要操作</p><ul><li>expired ()：若 shared_ptr 数量为 0 (对象可能已释放)，返回 true，否则 false</li><li>lock ()：若 expired () 为 true，返回空，否则返回 shared_ptr</li><li>use_count ()：shared_ptr 共享数量</li></ul><p>使用： <code>if(shared_ptr&lt;int&gt; p=wp.lock())&#123;&#125;</code></p><h2 id="动态数组"><a class="anchor" href="#动态数组">#</a> 动态数组</h2><ul><li>new T []，返回一个数组元素类型的指针</li><li>delete [] array，释放</li><li>或使用智能指针管理：<ul><li><code>unique_ptr&lt;int[]&gt; array(new int[10])</code></li><li><code>array.release()</code></li><li>对于 unique_ptr 指向的数组不能使用点或箭头成员运算符，但可以使用下标访问元素</li><li>注：shared_ptr 不直接支持动态数组，如果想使用 shared_ptr 管理动态数组，需要提供自定义的删除器且访问也更麻烦 (通过获取内置指针)</li></ul></li><li>注：动态数组并不是数组类型，也不能使用 begin 或 end 获取迭代器</li></ul><p>建议：大多数应用应该使用标准库容器而不是动态分配的数组。标准库容器更简单、安全，性能也更好。</p><h2 id="allocator-类"><a class="anchor" href="#allocator-类">#</a> allocator 类</h2><p>new 将内存分配和对象构造组合在了一起，灵活性更有局限。<br />allocator 类将内存分配和对象构造分离开来，其分配的内存是原始的、未构造的。<br />操作</p><ul><li><code>allocator&lt;T&gt; a</code> ：定义一个可以为类型 T 分配内存的 allocator 对象</li><li><code>allocate(n)</code> ：分配可以存储 n 个对象的原始内存</li><li><code>deallocate(p,n)</code> ：释放，调用之前必须对每个对象先调用过 destroy</li><li><code>construct(p,args)</code> ：实际构造对象</li><li><code>destroy(p)</code> ：对 p 指针指向对象执行析构函数</li></ul><p>注：为使用 allocate 返回的内存，必须用 construct 构造对象。<br />另外还提供了可以拷贝和填充未初始化内存算法：</p><ul><li><code>uninitialized_copy</code></li><li><code>uninitialized_copy_n</code></li><li><code>uninitialized_fill</code></li><li><code>uninitialized_fill_n</code></li></ul><h1 id="第十三章-拷贝控制"><a class="anchor" href="#第十三章-拷贝控制">#</a> 第十三章 拷贝控制</h1><p>当定义一个类时，我们显式指定在此类型的对象拷贝、移动、赋值和销毁时做什么：</p><ul><li>拷贝构造函数：当用同类型的另一个对象初始化本对象时做什么</li><li>拷贝赋值运算符：将一个对象赋予同类型另一个对象时做什么</li><li>移动构造函数：当用同类型的另一个对象初始化本对象时做什么</li><li>移动赋值运算符：将一个对象赋予同类型另一个对象时做什么</li><li>析构函数：销毁时做什么</li><li>注：这些操作若我们未显式定义，则编译器会自动生成</li></ul><h2 id="拷贝构造函数"><a class="anchor" href="#拷贝构造函数">#</a> 拷贝构造函数</h2><p>一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值</p><ul><li>Foo (); // 默认构造函数</li><li>Foo (const Foo&amp;); // 拷贝构造函数</li></ul><p>拷贝初始化</p><ul><li>拷贝初始化通常使用拷贝构造函数完成，不过一个类有移动构造函数时，有时会使用移动构造函数完成</li><li>string s (&quot;1&quot;) // 直接初始化</li><li>string s2=s; // 拷贝初始化</li><li>其它发生情况：<ul><li>将一个对象作为实参传递给一个非引用类型的形参</li><li>从一个返回类型为非引用类型的函数返回一个对象</li><li>花括号列表初始化一个数组中的元素或一个聚合类中的成员</li></ul></li></ul><h2 id="拷贝赋值运算符"><a class="anchor" href="#拷贝赋值运算符">#</a> 拷贝赋值运算符</h2><p>重载赋值运算符</p><ul><li>重载运算符本质上是函数，其名字由 operator 关键字后接表示要定义的运算符的符号组成</li><li>因此赋值运算符是一个名为 operator= 的函数，类似于任何其它函数</li><li>运算符函数也有一个返回类型和一个参数列表</li></ul><p>拷贝赋值运算符表现：</p><ul><li><code>Foo&amp; operator=(const Foo&amp;);</code></li></ul><p>注：注意即使一个对象赋值给自身，也需要正确工作。因此处理拷贝控制时需要临时变量做缓存，即销毁左侧运算对象资源之前拷贝右侧运算对象。</p><h2 id="析构函数"><a class="anchor" href="#析构函数">#</a> 析构函数</h2><p>资源释放<br />注 1：析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的。析构函数体作为成员销毁步骤之外的另一部分而进行。<br />注 2：根据三 / 五法则，如果一个类需要定义析构函数，几乎可以肯定它也需要自定义拷贝构造函数和拷贝赋值运算符。</p><h2 id="阻止拷贝"><a class="anchor" href="#阻止拷贝">#</a> 阻止拷贝</h2><p>可以通过将拷贝构造函数和拷贝赋值运算符定义为 删除的函数 来阻止拷贝。</p><ul><li><code>NoCopy()=default; //使用合成的默认构造函数</code></li><li><code>NoCopy(const NoCopy&amp;)=delete; //阻止拷贝</code></li><li><code>NoCopy &amp;operator=(const NoCopy&amp;) =delete; //阻止赋值</code></li></ul><p>注 1：不同于 =default，我们可以对任何函数指定 =delete<br /> 注 2：本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。</p><h2 id="拷贝控制和资源管理"><a class="anchor" href="#拷贝控制和资源管理">#</a> 拷贝控制和资源管理</h2><p>众所周知，若一个类对象被拷贝，若成员是指针，而我们定义了释放该指针的析构函数，每个发生释放的拷贝对象都会释放指针资源，导致错误问题。<br />因此需要同时重载拷贝构造函数。</p><h3 id="行为像值的类"><a class="anchor" href="#行为像值的类">#</a> 行为像值的类</h3><p>重载的拷贝构造函数或拷贝赋值运算符中，将指针对象重新分配一次，每个拷贝对象中指针都指向内容相同但实际不同的对象。<br />这样每次析构函数释放时都是释放自己指向的指针。</p><h3 id="行为像指针的类"><a class="anchor" href="#行为像指针的类">#</a> 行为像指针的类</h3><p>需要定义拷贝构造函数和拷贝赋值运算符，以拷贝成员本身而不是它指向的对象。<br />而析构函数释放关联对象内存的方式，必须是最后一个指向关联对象的该对象销毁才可以释放。</p><ul><li>因此最好的方法是使用 shared_ptr 管理类中资源</li><li>或自定义引用计算进行管理<ul><li>构造函数还需要创建一个引用计算，记录有多少对象与正在创建对象共享状态</li><li>拷贝构造函数不分配新的计数器，而是拷贝数据成员并递增共享的计数器</li><li>析构函数递减计数器，若计数器达到 0，则释放状态</li><li>拷贝赋值运算符递增右侧运算对象计数器，递减左侧运算对象计数器，同时判断左侧计数器是否为 0 以决定是否释放其资源</li><li>注：引用计数不能直接作为对象数据成员，可以使用动态内存分配指针</li></ul></li></ul><h2 id="交换操作"><a class="anchor" href="#交换操作">#</a> 交换操作</h2><p>swap 标准库函数，有时需要定义自己的 swap 覆盖标准库的函数，避免额外分配。<br />可以在赋值运算符中使用使用 swap，使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。</p><h3 id="移动构造函数与-stdmove"><a class="anchor" href="#移动构造函数与-stdmove">#</a> 移动构造函数与 std:move</h3><h2 id="对象移动"><a class="anchor" href="#对象移动">#</a> 对象移动</h2><p>IO 类和 unique_ptr 可以移动但不能拷贝</p><h3 id="右值引用"><a class="anchor" href="#右值引用">#</a> 右值引用</h3><p>左值持久，右值短暂<br /> &amp;&amp;：只能绑定到临时对象，如对象将要销毁、对象没有其它用具</p><ul><li>使用右值引用可以自由地接管所引用对象的资源</li><li>变量是左值：因此不能将右值引用直接绑定到一个变量上，即使这个变量是右值引用也不行</li></ul><p>但是允许使用 move 函数显式将一个左值转换为对应右值引用类型</p><ul><li><code>int &amp;&amp;rr3=std::move(rr1);</code></li><li>调用 move 意味着承诺：除了对 rr1 赋值或销毁它外，我们将不再使用它</li><li>注：使用 move 应使用 std:move</li></ul><h2 id="移动构造函数和移动赋值运算符"><a class="anchor" href="#移动构造函数和移动赋值运算符">#</a> 移动构造函数和移动赋值运算符</h2><p>这两个成员类似对应拷贝操作，但它们从给定对象『窃取』资源而不是拷贝资源。</p><ul><li>移动构造函数不分配任何新的内存</li><li>类名 (类名 &amp;&amp;s) noexcept:{}</li></ul><p>noexcept</p><ul><li>承诺一个函数不抛出异常</li><li>移动构造函数通常不应抛出异常，因此可以以此标识，通知标准库减少一些额外操作</li></ul><p>移动赋值运算符执行与析构函数和移动构造函数相同工作。</p><ul><li>移动赋值运算符必须销毁左侧运算对象的旧状态</li></ul><p>注 1：在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值做任何假设。<br />注 2：编译器根本不会为某些类合成移动操作。特别是一个类已定义自己的 拷贝构造函数、拷贝赋值运算符或析构函数，就不会合成移动构造函数和移动赋值运算符。—— 只有当一个类没有定义任何自己版本的拷贝控制成员，且所有数据成员都能移动构造或移动赋值时，编译器才会为其合成移动操作。<br />注 3：如果一个类没有移动构造函数或移动赋值运算符，则类会使用对应的拷贝操作来代替移动操作。</p><h2 id="右值引用的成员函数"><a class="anchor" href="#右值引用的成员函数">#</a> 右值引用的成员函数</h2><p>成员函数也可以同时提供拷贝和移动版本。</p><h2 id="引用限定符"><a class="anchor" href="#引用限定符">#</a> 引用限定符</h2><p>通过 &amp; 或 &amp;&amp; 分别指出 this 可以指向一个左值或一个右值</p><ul><li><code>Foo &amp;operator=(const Foo&amp;) &amp;; //只能向可修改的左值赋值</code></li><li><code>Foo sorted() &amp;&amp;; //可用于可改变的右值</code></li></ul><h1 id="第十四章-重载运算与类型转换"><a class="anchor" href="#第十四章-重载运算与类型转换">#</a> 第十四章 重载运算与类型转换</h1><p><img data-src="/blogimages/2023/2023-10-22/-1327189457.jpeg" alt="" /></p><p>赋值运算符</p><ul><li>例如使类型可以像 vector 一样接受花括号初始化</li><li><code>xxx &amp;operator=(std::initializer_list&lt;std::string&gt;);</code></li></ul><p>下标运算符</p><ul><li><code>operator[]</code></li></ul><p>递增和递减运算符</p><ul><li>区分前置和后置</li><li>前置返回对象引用，后置返回对象的原值</li></ul><p>成员访问运算符</p><ul><li><code>*</code></li><li><code>-&gt;</code></li><li>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</li></ul><p>函数调用运算符</p><ul><li><code>operator()</code></li><li>可以像使用函数一样使用该类对象</li><li>如果类定义了调用运算符，则该类对象称作 函数对象</li></ul><p>lambda</p><ul><li>lambda 生成的匿名类型中含有一个重载函数调用运算符</li><li><code>stable_sort(words.begin(),words.end(),类名());</code></li><li>捕获变量的 lambda 则生成构造函数带有对应参数</li></ul><h2 id="可调用对象与-function"><a class="anchor" href="#可调用对象与-function">#</a> 可调用对象与 function</h2><p>C++ 语言中有几种可调用对象：</p><ul><li>函数</li><li>函数指针</li><li>lambda 表达式</li><li>bind 创建的对象</li><li>重载了函数调用运算符的类</li></ul><p>可调用对象也有类型，但两个不同类型的可调用对象可能共享同一种 调用形式。</p><ul><li>调用形式：指明了调用返回的类型及传递给调用的实参类型</li></ul><h3 id="标准库-function-类型"><a class="anchor" href="#标准库-function-类型">#</a> 标准库 function 类型</h3><ul><li>function 是一个模板，定义时可用于指定该 function 类型能够表示的对象的调用形式。</li><li>只要可调用对象满足指定的调用形式，就可以存储于同一个 function 类型中。</li><li>例如：<ul><li><code>function&lt;int(int,int)&gt;</code></li><li>表示接受两个 int，返回一个 int 的可调用对象</li><li>如此声明后，可用于表示任意一种类似可调用类型：函数指针、函数对象类的对象 (函数对象)、lambda</li></ul></li></ul><h3 id="重载函数与-function"><a class="anchor" href="#重载函数与-function">#</a> 重载函数与 function</h3><ul><li>如果函数存在重载，那么直接通过函数名称存储会导致二义性</li><li>可通过 存储函数指针而非函数名字，或 lambda 表达式来消除二义性<ul><li>定义函数指针： <code>int (*fp)(int,int)=add</code></li><li>定义 lambda： <code>[](int a,int b)&#123;return add(a,b);&#125;</code></li></ul></li></ul><h2 id="重载-类型转换与运算符"><a class="anchor" href="#重载-类型转换与运算符">#</a> 重载、类型转换与运算符</h2><h3 id="类型转换运算符"><a class="anchor" href="#类型转换运算符">#</a> 类型转换运算符</h3><p>类型转换运算符是类的一种特殊的成员函数，负责将一个类类型转换成其它类型。</p><ul><li><code>operator type() const</code></li><li>一个类型转换函数必须是类的成员函数，它不能声明返回类型，形参列表也必须为空 (类型转换运算符是隐式执行的)。类型转换函数通常应该是 const (不应修改待转换对象的内容)</li></ul><h3 id="显式的类型转换运算符"><a class="anchor" href="#显式的类型转换运算符">#</a> 显式的类型转换运算符</h3><ul><li>为防止隐式转换可能产生的异常情况</li><li><code>explicit operator type() const</code></li><li>显式的类型转换也可能会被隐式执行：<ul><li>if、while 及 do 语句条件部分</li><li>for 语句头的条件表达式</li><li>逻辑非运算符 (!)、逻辑或运算符 (||)、逻辑与运算符 (&amp;&amp;) 的运算对象</li><li>条件运算符 (? 😃 的条件表达式</li></ul></li><li>注：向 bool 的类型转换通常用在条件部分，因此 operator bool 一般定义成 explicit 的</li></ul><h3 id="避免二义性转换"><a class="anchor" href="#避免二义性转换">#</a> 避免二义性转换</h3><ul><li>例如定义了多个类型转换规则，可以通过其它类型转换联系到一起。</li><li>重载构造函数 (默认隐式转换) 也可能导致</li><li>对同一个类既提供转换目标是算数类型的类型转换，也提供了重载的运算符，重载运算符与内置运算符将会有二义性问题</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;本篇笔记从原书第二部分开始，到第三部分第十四章重载运算与类型转换结束，不过对于 第八章 (IO 库)、第九章 (顺序容器)、第十一章 (关联容器) 基本略过。&lt;br</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CPP" scheme="https://wangjiaying.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>虚幻5动画适配方式-笔记</title>
    <link href="https://wangjiaying.top/2023/10/06/%E8%99%9A%E5%B9%BB5%E5%8A%A8%E7%94%BB%E9%80%82%E9%85%8D-%E7%AC%94%E8%AE%B0/"/>
    <id>https://wangjiaying.top/2023/10/06/%E8%99%9A%E5%B9%BB5%E5%8A%A8%E7%94%BB%E9%80%82%E9%85%8D-%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-06T13:08:22.000Z</published>
    <updated>2023-10-07T01:42:41.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>国庆将虚幻 5 C++ 基础又研究了一通，今天是最后一天了。<br />本来是想找找 Lyra C++ 相关东西看看有没有比较好的教程的，结果搜到一个虚幻官方很早以前就发的一个 Lyra 动画系统的直播介绍视频，看了下介绍似乎还不错。<br />特别是提到适用于不同情况下的动画 Retarging 操作，感觉正缺点这方面的知识。<br />于是今天就花了一天跟着看了一遍，操作了一遍，在此记录一下。</p><h1 id="情况一"><a class="anchor" href="#情况一">#</a> 情况一</h1><ul><li>同样的骨架资源</li><li>同样的参考姿势 (基础骨骼和层级)</li><li>同样的比例参数：例如角色高矮相同</li></ul><p>不需要重定向，可直接应用动画播放</p><h1 id="情况二"><a class="anchor" href="#情况二">#</a> 情况二</h1><ul><li>同样的骨架资源</li><li>同样的参考姿势 (基础骨骼和层级)</li><li><font color=red>不同的比例参数：例如角色高矮不同、肩宽、腿长 等有差异</font></li></ul><p>需要一些简单的重定向，确保动画播放不至于拉伸、挤压：</p><p><img data-src="/blogimages/2023/2023-10-06/1.png" alt="" /></p><h1 id="情况三"><a class="anchor" href="#情况三">#</a> 情况三</h1><ul><li><font color=red>不同的骨架资源</font></li><li>同样的参考姿势 (基础骨骼和层级)</li><li><font color=red>(可能) 额外的骨骼</font></li></ul><p>这应该是最常见的情况，操作方式主要有两种：</p><ul><li>从网格体复制姿势 (Copy Pose From Mesh)</li><li>使用兼容骨骼 (UE5 新功能)</li></ul><h2 id="copy-pose-from-mesh"><a class="anchor" href="#copy-pose-from-mesh">#</a> Copy Pose From Mesh</h2><ul><li>模块化角色的基础，适合具有额外骨骼角色，导入资源时，它们被导入自身独有的骨骼资源中</li><li>该选项位于动画蓝图 (ABP) 中，属于一个节点</li></ul><h3 id="原理"><a class="anchor" href="#原理">#</a> 原理</h3><ul><li>其中源骨骼运行正常基础动画：走路、奔跑、跳跃 等</li><li>额外骨骼 (马尾辫、背包、装饰品 等) 则由分离后作为子级驱动</li></ul><h2 id="兼容骨架"><a class="anchor" href="#兼容骨架">#</a> 兼容骨架</h2><ul><li>原理与 Copy Pose From Mesh 类似，都是首先得有相同的骨架，但可能具有额外的骨骼</li><li>即：虽然骨架资源不同，但它们拥有同样的基础骨骼和层级</li></ul><p>从 Window-&gt;AssetDetail 打开：<br /><img data-src="/blogimages/2023/2023-10-06/2.png" alt="" /><br />在没设置兼容骨架之前，下方 AssetBrwser 是空的，设置之后重新打开，就会发现会显示出兼容骨骼的动画。<br />注：兼容骨架是个数组，因此可以放置多个骨架，以适配多个骨架的动画资源</p><h1 id="情况四"><a class="anchor" href="#情况四">#</a> 情况四</h1><p>最复杂的情况是：</p><ul><li><font color=red>不同的骨架资源</font></li><li><font color=red>不同的骨骼层级</font></li><li><font color=red>不同的参考姿势</font></li><li><font color=red>有额外的骨骼 / 缺失的骨骼</font></li></ul><p>为了尽可能复用动画资源<br />操作方式：</p><ul><li>IK 重定向 (IK Retarging)，也是属于 UE5 新功能</li></ul><h2 id="retarget-pose-from-mesh"><a class="anchor" href="#retarget-pose-from-mesh">#</a> Retarget Pose From Mesh</h2><ul><li>该选项位于动画蓝图 (ABP) 中，属于一个节点</li><li>设计的与 Copy Pose From Mesh 使用方式类似，而原理也类似，都是从源骨骼复制数据</li><li>不同之处在于，这个选项不会对源骨骼作任何假设，因此需要我们告诉引擎如何将源骨骼与目标骨骼进行相互关联，该节点通过关联信息使用 IK Retarging 进行重定向</li></ul><p>始终涉及三个资源：</p><ul><li>源</li><li>目标</li><li>关联两者的 IK Retarging 资源</li></ul><p>注：绑定完成后，除运行时动态进行计算，还可以离线生成新的动画以进行进一步优化</p><h3 id="创建-ik-rig"><a class="anchor" href="#创建-ik-rig">#</a> 创建 IK Rig</h3><ol><li>创建 Animation-&gt;Retarging-&gt;IK Rig 资源</li><li>将需要修改的目标对象骨骼设置上去</li><li>选择需要重映射的『骨骼链』后创建重定向链</li></ol><p><img data-src="/blogimages/2023/2023-10-06/3.png" alt="" /><br />点击后会弹出几个弹窗，分别按照骨骼命名即可 (前臂、后腿之类的)<br /> 随后还需要依次设置：Spine、Neck、Head 等需要重定向的骨骼链<br />注意：创建的时候需要把对应的子骨骼也选中上！<br />效果如下：<br /><img data-src="/blogimages/2023/2023-10-06/4.png" alt="" /><br />选择对应骨骼会高亮显示。</p><ol start="4"><li>选择 手、脚 创建 IK Goal 以便后续进行微调 (通常一个 FullBodyIK 就够了)</li><li>保持选中 IK Solver 状态，选中对应根骨骼，将其设置为 SetRootBoneFromSolver</li></ol><p><img data-src="/blogimages/2023/2023-10-06/5.png" alt="" /><br />此时就已经可以使用 IK Goal 进行调整了：<br /><img data-src="/blogimages/2023/2023-10-06/6.png" alt="" /></p><ol start="6"><li>设置重定向动画的根 (Set Retarget Root)，右键对应的根骨骼选择设置即可，随后可在 IK Retargeting 界面看到：</li></ol><p><img data-src="/blogimages/2023/2023-10-06/7.png" alt="" /></p><h3 id="创建-ik-retargeter"><a class="anchor" href="#创建-ik-retargeter">#</a> 创建 IK Retargeter</h3><p>创建 IK Retargeter</p><ul><li>然后 Source 指定为 UE5 的 Mannequin</li><li>Target 指定为刚才我们创建的 IK_Dog</li></ul><p>此时在 ChainMapping 窗口可以看见，引擎已经自动应用了重映射 (字符串模糊匹配算法，所以结果不一定准确)：<br /><img data-src="/blogimages/2023/2023-10-06/8.png" alt="" /><br />随后，编译默认的 T-Pose，确保两者尽量一致<br />选择一个动画后，即可预览效果：<br /><img data-src="/blogimages/2023/2023-10-06/9.png" alt="" /><br />注：虚线连接的圆圈是 IK 位置，设置 BlendToSource 可使其混合，设置到源动画同样的位置 (高度)，还有静态偏移设置，用于调整步幅、匹配握抢姿势什么的。</p><h3 id="应用"><a class="anchor" href="#应用">#</a> 应用</h3><p>确认无误，就可以创建一个新的动画蓝图，添加 Retarget Pose From Mesh 节点，IK RetargeterAsset 选择刚才创建的 IK Retargeter 即可：<br /><img data-src="/blogimages/2023/2023-10-06/10.png" alt="" /></p><p>实际效果：</p><p><img data-src="/blogimages/2023/2023-10-06/GIF2023-10-6-17-05-01.gif" alt="" /></p><h1 id="blueprintthreadsafeupdateanimation"><a class="anchor" href="#blueprintthreadsafeupdateanimation">#</a> BlueprintThreadSafeUpdateAnimation</h1><ul><li>多线程执行</li></ul><h1 id="动态适配"><a class="anchor" href="#动态适配">#</a> 动态适配</h1><p>动画节点：</p><ul><li>OrientationWraping：方向适配<ul><li>调整脊椎、双脚，使角色动画匹配移动方向 (不旋转)，避免滑步等，主要用于移动过程，Idle 时没什么用</li><li>可以只在需要的状态中启用，且可以通过 Alpha 控制权重</li><li>控制台命令：a.AnimNode.OrientationWraping.Enable</li></ul></li><li>StrideWraping：步幅匹配<ul><li>使角色移动动画与其移动速度匹配 (有多种方式，例如调整播放速率，步幅撇配也是一种)</li><li>控制台命令：a.AnimNode.StrideWraping.Enable</li></ul></li><li>DistanceMatchToTarget：距离匹配<ul><li>如果角色移动了 100 个单位，希望动画也移动 100 个单位</li><li>例如角色坠落：距离地面 100 个单位，可以在动画中找到距离地面 100 个单位的关键帧并从此播放</li><li>以角色实际移动距离为准，不管动画的时间跨度多少，通过调整动画播放速率使其一定匹配对应移动距离 (可能使改变动画播放速度比较大，可对最高播放速率做限制)</li></ul></li><li>AdvanceTimeByDistanceMatching：距离匹配推动时间</li><li>SetPlayrateSpeed：设置播放速率匹配速度</li><li>MotionWraping：运动扭曲</li></ul><p>情境动画系统</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>各种尝试了下，总的来说，还是情况四提供的 IK Retarging 最靠谱，前三种情况都更适合有专门的动画师，以及能做到按照标准的素体骨骼制作动画才行。<br />而且要是新的动画要求或骨骼层级发生了改变，那么也没法兼容：<s>个人尝试使用兼容骨架功能将商城一个 UE4 的人形资源适配到 UE5 的官方骨架上，直接就变形了</s>。<br />补正：简单动画重定向选项可以与兼容骨架配合使用，一定程度避免变形。<br />(可能这也是为什么虚幻会增加 IK Retarging 功能的原因之一，试用一下就知道，跟其它方式相比灵活性太强了！)</p><h1 id="参考文档"><a class="anchor" href="#参考文档">#</a> 参考文档</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXlHNHkxODd5Ng==">[英文直播] 分析 Lyra 中的动画 (官方字幕)_哔哩哔哩_bilibili</span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;国庆将虚幻 5 C++ 基础又研究了一通，今天是最后一天了。&lt;br /&gt;
本来是想找找 Lyra C++ 相关东西看看有没有比较好的教程的，结果搜到一个虚幻官方很早</summary>
      
    
    
    
    <category term="虚幻引擎" scheme="https://wangjiaying.top/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="虚幻引擎" scheme="https://wangjiaying.top/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer(第五版)》-笔记(1)</title>
    <link href="https://wangjiaying.top/2023/10/02/CPP_Primer_%E7%AC%AC%E4%BA%94%E7%89%88_%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://wangjiaying.top/2023/10/02/CPP_Primer_%E7%AC%AC%E4%BA%94%E7%89%88_%E7%AC%94%E8%AE%B0-1/</id>
    <published>2023-10-02T09:14:12.000Z</published>
    <updated>2023-10-06T04:28:37.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本篇笔记主要包含原书第一部分，第一章～第七章，从变量定义到类结束。</p><p>这次仔细从头开始看，包括最基础的语法都给重新过了一遍，虽然可能看得稍微有点快，而且做不到看完就熟稔了，不过至少重点记录了笔记，后续翻看一下，总能回忆不少印象。</p><p>说实话的话，补完这几章，再去看 UE 的 C++ 代码的时候，看起来就感觉更轻松些了 —— 毕竟理论知识确实是基础，自然比全然不知道的情况下去总结经验来得强。</p><p>这本书还是有点厚，不知道这次国庆节抽出的时间看不看得完。</p><hr /><ul><li>像编译器一样来思考和理解 C++</li><li>本书主要为 C++11 标准</li></ul><h1 id="第一章-开始"><a class="anchor" href="#第一章-开始">#</a> 第一章 开始</h1><p>错误的注释比完全没有注释更糟糕。<br />点运算符只能用于类类型对象。</p><h1 id="第二章-变量和基本类型"><a class="anchor" href="#第二章-变量和基本类型">#</a> 第二章 变量和基本类型</h1><p>为赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据类型，类型决定数据所占比特数及如何解释这些比特内容。<br />整型和浮点型具有字面值</p><ul><li>整型字面值的具体数据类型由它的值和符号决定 (int、long、long long 尺寸最小的一个)</li><li>严格来说，十进制字面值不会是负数，『-42』这种字面值的负号不在字面值之内，作用是对字面值取负值</li><li>浮点型的字面值是一个 double</li><li>类型 short 没有对应的字面值</li></ul><p>字符串字面值</p><ul><li>是由常量字符构成的数组，字符串结尾会被编译器添加一个空字符 (\0)，因此字符串字面值实际长度比内容多一个。</li></ul><p>指针字面值</p><ul><li>nullptr</li></ul><p>指定字面值类型</p><ul><li>通过添加值的前缀或后缀，可指定字面值的默认类型</li><li>如 3.14F 表示 float</li></ul><h2 id="变量"><a class="anchor" href="#变量">#</a> 变量</h2><p>通常情况下，对象指一块能够存储数据并具有某种类型的内存空间。</p><h3 id="初始值值初始化"><a class="anchor" href="#初始值值初始化">#</a> 初始值 (值初始化)</h3><p>当对象在创建时获得了一个特定的值<br />注：(虽然都是等号) 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义则是把对象当前值擦除，而以一个新值替代</p><h3 id="列表初始化"><a class="anchor" href="#列表初始化">#</a> 列表初始化</h3><ul><li>可使用花括号初始值，称为列表初始化</li><li>注：对结构的数据成员进行初始化时，必须使用列表初始化进行</li></ul><h3 id="默认初始化"><a class="anchor" href="#默认初始化">#</a> 默认初始化</h3><ul><li>若定义变量时没有指定初值，则变量被默认初始化</li><li>此时变量被赋予 &quot;默认值&quot;</li><li>内置类型定义于函数体内时，将不被初始化，未初始化内置类型变量值属于未定义，访问将引发错误。(定义于函数体外则被默认初始化为 0)</li></ul><p>注：每个类各自决定其初始化对象的方式，是否允许不经初始化就定义对象也由类自己决定。多数类都支持无需显式初始化而定义对象。</p><h3 id="变量声明和定义"><a class="anchor" href="#变量声明和定义">#</a> 变量声明和定义</h3><p>为支持分离式编译，C++ 将声明 (declaration) 和定义 (definition) 区分开类。</p><ul><li>声明规定了变量类型和名字</li><li>定义除声明功能外，还申请存储空间，或为变量赋一个初始值</li></ul><p>例如</p><ul><li>仅声明：extern int i;</li><li>声明并定义：int j;</li><li>注：包含显式初始化的声明即成为定义，如 extern int x=12 表示的是定义 (extern 声明相当于无效)</li></ul><p>注 1：变量可以被多次声明，但只能被定义一次<br />注 2：C++ 是一种静态类型语言，编译器会在编译阶段检查类型，因此要求我们在使用某个变量之前必须声明其类型</p><h3 id="作用域"><a class="anchor" href="#作用域">#</a> 作用域</h3><p>当第一次使用变量时再定义它<br />全局作用域</p><ul><li>:: 变量名</li><li>如果函数有可能用到某全局变量，则不宜再定义一个同名局部变量 (此处记录表示可以有这种操作)</li></ul><h2 id="复合类型"><a class="anchor" href="#复合类型">#</a> 复合类型</h2><h3 id="引用"><a class="anchor" href="#引用">#</a> 引用</h3><p>引用为对象起了另外一个名字，引用类型引用另外一种类型。</p><ul><li>通过声明符 &amp; 定义引用类型</li><li>定义引用时，程序把引用和它的初始值绑定在一起</li><li>对引用的所有操作都是在与之绑定的对象上进行</li><li>引用必须被初始化，并且无法再重新绑定给另外对象</li><li>(引用本身不是一个对象，因此不能定义引用的引用)</li></ul><h3 id="指针"><a class="anchor" href="#指针">#</a> 指针</h3><p>指针是指向另外一种类型的复合类型，与引用类似，指针也实现了对其它对象的间接访问。</p><ul><li>指针本身是一个对象，允许对指针赋值和拷贝</li><li>指针允许无需在定义时赋初值</li><li>(与其它内置类型一样，块作用域定义的指针若未初始化则具有不确定值)</li></ul><p>解引用符 (*) 可用于访问指针指向的对象 (仅适用于确实指向了某个对象的有效指针)<br /> 空指针</p><ul><li>赋值 nullptr (推荐)</li><li>赋值 0</li><li>赋值 NULL (cstdlib 预处理变量，值实际为 0)</li></ul><p>void* 指针</p><ul><li>特殊的指针类型，可用于存放任意对象的地址</li><li>不能直接操作 void* 指针所指的对象 (因为不确定类型)</li><li>即 void* 仅代表内存空间，无法访问内存空间中所存储的对象</li></ul><p>注：面对一条比较复杂的指针或引用声明时，从右往左阅读有助于弄清楚它的真实含义。</p><h3 id="const-限定符"><a class="anchor" href="#const-限定符">#</a> const 限定符</h3><p>const 对象一旦创建后其值就不能改变因此 const 对象必须初始化。<br />默认状态下，const 对象仅在文件内有效</p><ul><li>编译器将在编译过程中把用到该变量的地方都替换成对应的值</li><li>添加 extern 关键字可以改变默认行为，使其全局 (多个文件之间共享) 生效</li></ul><h4 id="const-的引用"><a class="anchor" href="#const-的引用">#</a> const 的引用</h4><ul><li>可以把引用绑定到 const 对象上，称为对常量的引用，对常量的引用不能修改它所绑定的对象</li><li>const int &amp;r1=xxx</li><li>注：常量引用仅对引用可参与的操作做出限定，对于引用本身是否是一个常量未做限定</li></ul><h4 id="指针和-const"><a class="anchor" href="#指针和-const">#</a> 指针和 const</h4><ul><li>指针添加 const 称为 指向常量的指针</li><li>const double *ptr=&amp;xxx</li><li>指向常量的指针不能指向非常量地址，也不能修改指向对象的值 (也可以指向非常量对象，相当于多了不能修改的限制)</li></ul><h4 id="const-指针"><a class="anchor" href="#const-指针">#</a> const 指针</h4><ul><li>常量指针必须初始化，而且一旦初始化完成，其值 (指向的地址) 就不能再改变</li><li>把 * 放在 const 之前说明指针是一个常量，不变的是指针本身的值而非指向地址的值</li><li>int *const ptr=&amp;xxx</li></ul><h3 id="constexpr-和常量表达式"><a class="anchor" href="#constexpr-和常量表达式">#</a> constexpr 和常量表达式</h3><p>常量表达式</p><ul><li>指值不会改变并且在编译过程就能得到计算结果的表达式</li></ul><h4 id="constexpr-变量"><a class="anchor" href="#constexpr-变量">#</a> constexpr 变量</h4><ul><li>在一个复杂系统中很难分辨一个初始值到底是不是常量表达式</li><li>因此 C++11 规定，允许将变量声明为 constexpr 类型以便又编译器来验证变量的值是否是一个常量表达式</li></ul><h4 id="constexpr-函数"><a class="anchor" href="#constexpr-函数">#</a> constexpr 函数</h4><ul><li>这种函数应该足够简单以使得编译时就可以计算其结果</li><li>这样就能用 constexpr 函数去初始化 constexpr 变量了</li></ul><hr /><p>注：常量表达式的值需要在编译时就得到计算，因此对声明 constexpr 的类型必须有所限制 —— 称为字面值类型<br />指针和 constexpr</p><ul><li>constexpr 仅对指针有效，与指针所指对象无关</li><li>即：constexpr 定义的一定是 常量指针 (指针本身不可变)</li></ul><h2 id="处理类型"><a class="anchor" href="#处理类型">#</a> 处理类型</h2><h3 id="类型别名"><a class="anchor" href="#类型别名">#</a> 类型别名</h3><ul><li>typedef a b</li><li>using b=a</li></ul><h3 id="auto-类型说明符"><a class="anchor" href="#auto-类型说明符">#</a> auto 类型说明符</h3><ul><li>auto 让编译器通过初始值推算变量的类型 (因此定义必须有初始值)</li></ul><h3 id="decltype-类型指示符"><a class="anchor" href="#decltype-类型指示符">#</a> decltype 类型指示符</h3><ul><li>选择并返回操作数的数据类型</li><li>编译器分析表达式并得到它的类型，却不实际计算表达式的值</li><li>如果 decltype 使用的表达式不是一个变量，则 decltype 返回表达式结果对应的类型</li><li>decltype (func ()) sum=x; //sum 的类型即 func 函数返回类型</li></ul><p>注 1：decltype 与 auto 的区别是 decltype 的结果类型与表达式形式密切相关。<br />注 2：decltype ((variable))(注意是双括号) 的结果永远是引用，而 decltype (variable) 结果只有当 variable 本身就是一个引用时才是引用。</p><h2 id="自定义数据结构"><a class="anchor" href="#自定义数据结构">#</a> 自定义数据结构</h2><p>可使用 struct 定义自己的数据类型<br />确保头文件多次包含仍能安全工作的常用技术是雨处理器。<br />头文件保护符</p><ul><li>#define</li><li>#ifdef</li><li>#ifndef</li><li>#endif</li></ul><h1 id="第三章-字符串-向量和数组"><a class="anchor" href="#第三章-字符串-向量和数组">#</a> 第三章 字符串、向量和数组</h1><h2 id="命名空间的-using-声明"><a class="anchor" href="#命名空间的-using-声明">#</a> 命名空间的 using 声明</h2><p>使用 using namespace::name 后，可直接访问 name</p><ul><li>using std::cin;</li><li>cin&gt;&gt;x; // 正确</li></ul><p>注 1：每个 using 声明引入命名空间中的 一个 成员<br />注 2：头文件不应包含 using 声明 (可以做，但可能导致名字冲突)</p><h3 id="直接初始化和拷贝初始化"><a class="anchor" href="#直接初始化和拷贝初始化">#</a> 直接初始化和拷贝初始化</h3><ul><li>拷贝初始化：使用等号初始化 (只能初始化一个变量)</li><li>直接初始化：不使用等号 (可初始化具有多个初始值的对象)</li></ul><h2 id="string"><a class="anchor" href="#string">#</a> string</h2><p>初始化方式</p><ul><li>string s1</li><li>string s2(s1)</li><li>string s3=s1</li><li>string s3=&quot;value&quot;</li><li>string s4(n,'c')</li></ul><p>注 1：字符串字面值与 string 是不同类型 (因为历史及与 C 兼容等原因)<br /> 注 2：cctype 头文件中提供了一系列判断字符操作，例如判断是否是字母、数字、大写字母 等。<br />处理每个字符</p><ul><li>使用基于范围的 for 语句</li><li>如果想改变，则定义循环变量为引用类型</li><li>也可以通过索引访问，不过需要特别注意不要越界</li></ul><h2 id="vector"><a class="anchor" href="#vector">#</a> vector</h2><ul><li>允许使用列表初始化</li><li>允许提供一个元素数量，默认初始化 指定数量的元素</li><li>允许索引访问元素，但不能用下标形式添加元素</li></ul><p>操作</p><ul><li>push_back：添加到末尾</li></ul><h2 id="迭代器"><a class="anchor" href="#迭代器">#</a> 迭代器</h2><p>begin ()：指向第一个元素<br /> end ()：指向尾元素的下一个位置 (尾后迭代器)<br /> 注 1：容器为空时，均为尾后迭代器<br />注 2：C++11 引入了常量迭代器 - cbegin ()、cend ()<br /> 其它</p><ul><li>*iter：返回迭代器 iter 所指元素的引用</li><li>iter-&gt;mem：解引用 iter 并获取名为 mem 的成员 (等价 (*iter).mem)</li><li>++iter：令 iter 指示容器中的下一个元素</li><li>--iter：令迭代器指示容器中的上一个元素</li><li>注：迭代器运算也支持增减具体数字，使其移动若干个位置</li><li>iter1==iter2：判断两个迭代器是否相等 (指示同一元素或是同一个容器的尾后迭代器)</li><li>iter1&lt;iter2：判断前者是否比后者指示位置小</li><li>iter1-iter2：获得两个迭代器的距离 (右侧迭代器向前移动多少位置可以追上左侧迭代器，可能为负)</li></ul><p>箭头运算符 (-&gt;)：把解引用和成员访问两个操作结合在一起。</p><ul><li>成员访问即。操作</li></ul><h2 id="数组"><a class="anchor" href="#数组">#</a> 数组</h2><ul><li>数组的维度必须是一个常量表达式<ul><li>注：据说是因为数组作为 C++ 的内置数据类型，其空间分配在栈内存中，这部分空间的大小在编译时就要确定 (有的编译器支持了，但都不建议，因为容易爆栈)</li><li>动态大小可以使用 new 运算符分配到堆上</li></ul></li><li>默认情况下数组元素被默认初始化</li><li>注：与内置类型一样，函数内部定义了某种内置类型数组，默认初始化会令数组含有未定义的值</li></ul><p>注：与 vector 一样，数组元素应为对象，因此不存在引用的数组。</p><h3 id="显式初始化数组元素"><a class="anchor" href="#显式初始化数组元素">#</a> 显式初始化数组元素</h3><ul><li>可对数组元素进行列表初始化 (此时允许忽略数组维度，若未指定维度则编译器自动推测)</li></ul><p>字符数组特殊性</p><ul><li>字符数组可以用字符串字面值初始化，此时会额外多一个空字符 (\0)</li></ul><p>注：不允许对数组进行拷贝给其它数组和赋值给其它数组</p><ul><li>但是运行使用数组初始化 vector 对象，指明拷贝的首元素地址和尾后地址即可</li><li>vector<int> ivec(begin(array),end(array))</li></ul><p>注：(重要！) 在大多数表达式中，使用数组类型对象其实是使用一个指向该数组首元素的指针</p><ul><li>例如当使用数组作为一个 auto 变量初始值时，推断得到的类型是指针而非数组</li><li>指向数组元素的指针拥有更多功能，迭代器支持的运算数组的指针均支持</li><li>尾后指针：指向数组尾元素之后那个不存在的元素的地址，利用尾后指针可以像尾后迭代器一样判断</li></ul><p>标准库函数 begin、end：</p><ul><li>使用指针运算容易出错</li><li>C++11 提供了两个函数，分别返回数组首元素指针和尾后指针</li><li>begin(array)、end(array)</li></ul><p>关系运算符</p><ul><li>若两个指针指向同一个数组的元素，则还可以使用关系运算符进行比较</li></ul><h3 id="多维数组"><a class="anchor" href="#多维数组">#</a> 多维数组</h3><p>严格来说，C++ 语言中没有多维数组，通常所说的多维数组是数组的数组。<br />循环遍历多维数组时，需将外层类型定义为引用才能正确遍历下层数组</p><ul><li>如 for (auto &amp;row:array){</li><li>for(auto col:row)</li><li>} 才是合法的</li></ul><p>指针</p><ul><li>由多维数组名转换得来的指针是指向第一个内层数组的指针</li></ul><h1 id="第四章-表达式"><a class="anchor" href="#第四章-表达式">#</a> 第四章 表达式</h1><p>左值和右值</p><ul><li>左值：指求值结果为对象或函数的表达式，一个表示对象的非常量左值可以作为赋值运算符左侧运算对象。</li><li>右值：指一种表达式，其结果是值而非值所在的位置</li></ul><p>表达式语句</p><ul><li>C++ 中最低级别的计算，每个表达式都有对应的求值结果</li></ul><p>不为 0 的数值转 bool 都是 true<br />C++11 新标准规定商一律向 0 取整 (直接舍弃小数部分)<br /> 进行比较时，除非比较对象是布尔类型，否则不要使用布尔字面值 true 或 false 作为运算对象。</p><h2 id="赋值运算符"><a class="anchor" href="#赋值运算符">#</a> 赋值运算符</h2><h3 id="复合赋值运算符"><a class="anchor" href="#复合赋值运算符">#</a> 复合赋值运算符</h3><ul><li>使用复合赋值运算符只求值一次，使用普通运算符则求值两次 (一次运算，一次赋值)</li></ul><h3 id="递增和递减运算符"><a class="anchor" href="#递增和递减运算符">#</a> 递增和递减运算符</h3><ul><li>前置版本将对象本身作为左值返回 (值加 1 后直接返回改变了的运算对象)</li><li>后置版本则将对象原始值的副本作为右值返回</li><li>注：允许在一条语句中混用解引用和递增运算符</li></ul><h3 id="成员访问运算符"><a class="anchor" href="#成员访问运算符">#</a> 成员访问运算符</h3><ul><li>点运算符和箭头运算符均可用于访问成员</li><li>ptr-&gt;mem 等价于 (*ptr).mem</li></ul><h3 id="sizeof-运算符"><a class="anchor" href="#sizeof-运算符">#</a> sizeof 运算符</h3><ul><li>返回一条表达式或一个类型名字所占用的字节数</li><li>注：表达式类型返回的是其结果类型大小，并不实际计算其运算对象的值</li></ul><p>运算结果</p><ul><li>引用类型：得到被引用对象所占空间的大小</li><li>指针：得到指针本身所占空间大小</li><li>解引用指针：得到指针指向的对象所占空间的大小 (指针可以不需要有效)</li><li>数组：得到整个数组所占空间的大小，等同于对数组中所有元素各执行一次 sizeof 运算并求和 (注：sizeof 不会将数组转为指针来处理)<ul><li>因此可以以此除以单个元素大小得到数组中元素个数</li></ul></li><li>对 string 或 vector：返回该类型固定部分大小，不会计算对象中的元素占用了多少空间</li></ul><p>注：sizeof 返回的是一个常量表达式</p><h2 id="类型转换"><a class="anchor" href="#类型转换">#</a> 类型转换</h2><h3 id="隐式转换"><a class="anchor" href="#隐式转换">#</a> 隐式转换</h3><ul><li>低于整型类型可能会提升为整型</li><li>计算中，两个不同类型数值计算，宽度较小类型会提升为更大精度类型</li><li>在条件中，非布尔值转换成布尔类型</li><li>数组转换成指针：数组自动转换成指向数组首元素的指针<ul><li>当数组被用作 decltype、取地址符、sizeof、typeid 等运算符的运算对象时转换不会发生</li></ul></li></ul><p>指针的转换</p><ul><li>常量整数值 0 或字面值 nullptr 能转换成任意指针类型</li><li>指向任意非常量的指针能转换成 void*</li><li>指向任意对象的指针能转换成 const void*</li></ul><h3 id="显式转换"><a class="anchor" href="#显式转换">#</a> 显式转换</h3><p>注：避免强制类型转换</p><h4 id="旧式强制类型转换"><a class="anchor" href="#旧式强制类型转换">#</a> 旧式强制类型转换</h4><ul><li>type (expr)</li><li>(type)expr</li><li>注：旧式强制类型转换分别具有与 const_cast、static_cast 或 reinterpret_cast 相似的行为。</li></ul><h4 id="static_cast"><a class="anchor" href="#static_cast">#</a> static_cast</h4><ul><li>任何具有明确定义的类型转换，只要不包含底层 const 就可以使用<ul><li>T t=static_cast<T>(val)</li><li>还可以使用这个将存放于 void* 的指针转换回来</li></ul></li></ul><h4 id="const_cast"><a class="anchor" href="#const_cast">#</a> const_cast</h4><ul><li>可以将常量对象转换为非常量对象：即去掉 const 性质</li><li>转换后编译器就不会阻止我们对该对象进行写操作</li><li>注：如果对象本身不是常量，获得写操作是合法的。但若本身是一个常量，写操作可能产生未定义行为</li></ul><h4 id="reinterpret_cast"><a class="anchor" href="#reinterpret_cast">#</a> reinterpret_cast</h4><ul><li>通常为运算对象的位模式提供较低层次上的重新解释</li></ul><h1 id="第五章-语句"><a class="anchor" href="#第五章-语句">#</a> 第五章 语句</h1><p>空语句：『;』<br />空块：『{}』<br />异常处理</p><ul><li>throw 表达式</li><li>try 语句块</li><li>一套异常类 (异常类型具有 what 成员函数，返回 C 风格字符串，无初始值异常类型返回内容由编译器决定)</li></ul><h1 id="第六章-函数"><a class="anchor" href="#第六章-函数">#</a> 第六章 函数</h1><ul><li>形参和实参</li><li>函数返回类型不能是数组或函数类型，不过可以是指向数组或函数的指针</li></ul><p>局部静态对象</p><ul><li>标记为 static 的局部变量</li><li>在程序的执行路径第一次经过对象定义语句时初始化，直到程序终止才销毁</li><li>生命周期不受函数本身控制</li><li>注：若未有显式初始值，则执行值初始化</li></ul><p>参数传递</p><ul><li>引用传递 (传引用调用)：形参是引用类型时<ul><li>也可以利用这个返回额外信息</li></ul></li><li>值传递：实参的值被拷贝给形参时 (两个对象独立)<ul><li>注：指针形参与其它非引用类型一样，也属于拷贝的指针的值</li></ul></li></ul><p>注：若函数无需改变引用形参的值，最好将其声明为常量引用。</p><ul><li>常量引用可接受范围更大 (包括常量和非常量对象)，而且可以起到标记函数不会修改传入对象的功能</li></ul><p>数组作为参数</p><ul><li>一般需要传递长度相关信息</li><li>或使用数组引用形参<ul><li>func(int (&amp;array)[10])</li></ul></li></ul><p>main 的命令行选项</p><ul><li>main 函数可选具有形参的实现，使用户可从命令行传递参数</li></ul><h2 id="可变形参的函数"><a class="anchor" href="#可变形参的函数">#</a> 可变形参的函数</h2><p>当无法预知应该向函数传递几个实参时</p><ul><li>如果所有实参类型相同：initializer_list (标准库类型)，用于表示某种特定类型的值的数组</li><li>实参类型不同：可变参数模板</li><li>注：还有一种特殊形参类型 (省略符)</li></ul><p>initializer_list</p><ul><li>initializer_list<T> lst</li><li>lst.size()</li><li>lst.begin ()：首元素指针</li><li>lst.end ()：尾后指针</li><li>注：其中的元素永远是常量值</li></ul><p>省略符形参 (...)</p><ul><li>为了便于 C++ 程序访问某些特殊 C 代码设计</li><li>只能出现在形参列表的最后一个位置</li><li>通常，省略符形参不应用于其它目的</li></ul><h2 id="不要返回局部对象的引用或指针"><a class="anchor" href="#不要返回局部对象的引用或指针">#</a> 不要返回局部对象的引用或指针</h2><p>函数完成后，它所占用的存储空间也会随之释放。</p><ul><li>函数终止意味着局部变量的引用将指向无效内存区域</li></ul><h2 id="返回值"><a class="anchor" href="#返回值">#</a> 返回值</h2><ul><li>调用一个返回引用的函数得到左值</li><li>其它返回类型得到右值</li></ul><p>列表初始化返回值</p><ul><li>C++11 标准规定：函数可以返回花括号包围的值的列表</li></ul><p>返回数组指针</p><ul><li>尾置返回类型：尾置返回类型跟在形参列表后并以一个 -&gt; 符号开头</li><li>auto func (int i)-&gt;int (*)[10] //func 接受一个 int 类型实参，返回一个指向含有 10 个整数的指针</li><li>注：若知道返回指针指向的数组，可使用 decltype 表示返回类型</li></ul><h2 id="函数重载"><a class="anchor" href="#函数重载">#</a> 函数重载</h2><ul><li>如果形参是某种类型的指针或引用，可通过区分指向的是常量对象或非常量对象实现函数重载</li><li>其它 const 形参与普通形参的差别则不能构成重载</li></ul><p>const_cast 与重载</p><ul><li>将非常量对象转换为常量实参，以做到调用常量形参的重载函数 (如果同时存在非常量版本，而想调用常量版本时)</li></ul><h2 id="默认参数"><a class="anchor" href="#默认参数">#</a> 默认参数</h2><ul><li>局部变量不能作为默认实参</li><li>此外只要表达式的类型能转换成形参所需类型，该表达式就能作为默认实参：同名局部变量虽然会隐藏外层对象，但不会影响默认实参</li></ul><h2 id="内联函数与-constexpr-函数"><a class="anchor" href="#内联函数与-constexpr-函数">#</a> 内联函数与 constexpr 函数</h2><ul><li>函数前加上 inline (内联说明只是向编译器发出请求，编译器可以选择忽略)</li><li>constexpr 函数返回类型及所有形参类型都得是字面值类型</li></ul><p>注 1：constexpr 函数被隐式指定为内联函数，编译器会在编译过程中展开<br />注 2：constexpr 函数调用时，传递常量表达式则返回常量表达式。传递非常量表达式则返回的也会是非常量表达式。即 constexpr 不一定返回常量表达式。</p><h2 id="调试帮助"><a class="anchor" href="#调试帮助">#</a> 调试帮助</h2><p>assert 预处理宏</p><ul><li>assert(expr)</li><li>对 expr 求值，若表达式为 false，assert 输出信息并终止程序执行。否则什么也不做。</li></ul><p>NDEBUG 预处理变量</p><ul><li>assert 的行为依赖 NDEBUG 的预处理变量的状态</li><li>若定义了 NDEBUG 则 assert 什么也不做 (默认状态下未定义，assert 将执行运行时检查)</li></ul><p><code>__func__</code></p><ul><li>编译器定义的一个局部静态变量，用于存放函数的名字</li></ul><p><code>__FILE__</code></p><ul><li>存放文件名的字符串字面值</li></ul><p><code>__LINE__</code></p><ul><li>存放当前行号的整型字面值</li></ul><p><code>__TIME__</code></p><ul><li>存放文件编译时间的字符串字面值</li></ul><p><code>__DATA__</code></p><ul><li>存放文件编译日期的字符串字面值</li></ul><h3 id="函数指针"><a class="anchor" href="#函数指针">#</a> 函数指针</h3><p>要想声明一个可以指向函数的指针，只需用指针替换函数名即可</p><ul><li>bool (*pf)(xxxxx) // 注：*pf 的括号必不可少，否则就是一个返回值为 bool 指针的函数了</li><li>当我们把函数名作为一个值使用时，该函数自动地转换成指针</li><li>此外可以直接使用指向函数的指针调用该函数，无需提前解引用指针</li></ul><p>函数指针形参</p><ul><li>与数组类似，不能直接定义函数类型的形参</li><li>但是形参可以是指向函数的指针</li><li>void func(bool (*pf)(xxxxx))<ul><li>如果明确知道返回函数是哪一个，可使用类型别名或 decltype 简化</li><li>typedef decltype(myfunc) *callbackName</li></ul></li><li>可以直接把函数作为实参使用</li></ul><h1 id="第七章-类"><a class="anchor" href="#第七章-类">#</a> 第七章 类</h1><p>定义在类内部的函数是隐式的 inline 函数。<br />当我调用成员函数时，实际上是替某个对象调用。成员函数通过一个名为 this 的额外隐式参数来访问调用它的那个堆对象。</p><ul><li>默认情况下，this 是指向类类型非常量版本的常量指针</li><li>常量对象以及常量对象的引用或指针都只能调用常量成员函数</li><li>注：一个 const 成员函数如果以引用方式返回 *this，则返回类型将是常量引用 (不可再做修改)。</li></ul><h2 id="构造函数"><a class="anchor" href="#构造函数">#</a> 构造函数</h2><ul><li>构造函数不能声明为 const</li><li>当我们创建类的一个 const 对象时，直到构造函数完成初始化过程，对象才能真正取得其 常量 属性：因此构造函数在 const 对象构造过程中可以向其写值</li></ul><p>注：当对象被默认初始化或值初始化时自动执行默认构造函数。<br />例如：</p><ul><li>Sales_data obj1 (); // 错误：声明了一个函数而非对象</li><li>Sales_data obj3; // 正确：默认初始化 obj2 对象</li></ul><h3 id="合成的默认构造函数"><a class="anchor" href="#合成的默认构造函数">#</a> 合成的默认构造函数</h3><p>只有当类没有声明任何构造函数时编译器才会自动生成</p><ul><li>如果存在类内初始值，用其初始化成员</li><li>否则，默认初始化该成员</li><li>即：通过相应类内初始值初始化或执行默认初始化</li><li>=default：要求编译器生成构造函数</li></ul><h3 id="构造函数初始值列表"><a class="anchor" href="#构造函数初始值列表">#</a> 构造函数初始值列表</h3><ul><li>(构造函数中参数后冒号与花括号之间) 可用于成员初始化</li><li>fun(const std::string &amp;name):Name(name){}</li><li>例如 const 只能使用这种方式初始值 (而不能在花括号里面赋值)</li><li>注：该列表只说明用于初始化成员的值，而不限定具体执行顺序，具体顺序与其在类中定义的出现顺序一致。(因此最好保持顺序一致，或避免使用某些成员初始化其它成员)</li></ul><p>注 1：当我们提供一个类内初始值时，必须以符号 = 或 花括号表示。<br />注 2：初始化和赋值的区别事关底层效率问题，前者直接初始化数据成员，后者则先初始化再赋值。(因此建议使用构造函数初始值)</p><h3 id="委托构造函数"><a class="anchor" href="#委托构造函数">#</a> 委托构造函数</h3><p>一个委托构造函数使用它所属类的其它构造函数执行它自己的初始化过程。</p><ul><li>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。</li></ul><h3 id="隐式的类类型转换"><a class="anchor" href="#隐式的类类型转换">#</a> 隐式的类类型转换</h3><p>使用 explicit 可抑制构造函数定义的隐式转换</p><ul><li>当以 explicit 声明构造函数时，它将只能以直接初始化的形式使用</li><li>且编译器不会在自动转换过程中使用该构造函数</li></ul><h2 id="class-与-struct"><a class="anchor" href="#class-与-struct">#</a> class 与 struct</h2><p>唯一区别是：两者默认访问权限不一样</p><ul><li>struct：定义在第一个访问修饰符之前的成员是 public</li><li>class：第一个访问修饰符之前的成员是 private</li><li>一般当定义类所有成员都是 public 时采用 struct</li></ul><h2 id="可变数据成员"><a class="anchor" href="#可变数据成员">#</a> 可变数据成员</h2><p>变量声明中加入 mutable 关键字</p><ul><li>永远不会是 const</li><li>即使作为 const 对象成员</li></ul><h2 id="友元"><a class="anchor" href="#友元">#</a> 友元</h2><p>每个类复制控制自己的友元类或友元函数</p><ul><li>还可以某类成员函数成为自己的友元</li></ul><h2 id="类的声明"><a class="anchor" href="#类的声明">#</a> 类的声明</h2><p>前向声明</p><ul><li>class className;</li><li>引入类名并指明这是一个类类型</li><li>在它声明之后定义之前是一个『不完全类型』</li></ul><p>不完全类型</p><ul><li>只能在非常有限的情况下使用：可以定义指向这种类型的指针或引用，也可以声明 (但不能定义) 以不完全类型作为参数或返回类型的函数。</li></ul><h2 id="类作用域"><a class="anchor" href="#类作用域">#</a> 类作用域</h2><p>编译器处理完类中全部声明后才会处理成员函数的定义。</p><h2 id="聚合类"><a class="anchor" href="#聚合类">#</a> 聚合类</h2><p>聚合类使得用户可直接访问其成员，且具有特殊的初始化语法形式。</p><ul><li>所有成员都是 public 的</li><li>没有定义任何构造函数</li><li>没有类内初始值</li><li>没有基类，有没有虚函数</li></ul><p>可以使用花括号初始化聚合类的数据成员，初始值的顺序必须与声明一致。</p><h3 id="字面值常量类"><a class="anchor" href="#字面值常量类">#</a> 字面值常量类</h3><p>数据成员都是字面值类型的聚合类是字面值常量类。</p><ul><li>注：还有一些满足额外条件的非聚合类也可以是字面值常量类</li></ul><h2 id="类的静态成员"><a class="anchor" href="#类的静态成员">#</a> 类的静态成员</h2><p>成员与类本身直接相关，而不是与类的各个对象保持关联。<br />静态成员函数</p><ul><li>静态成员函数不包含 this 指针，静态成员函数不能声明为 const</li></ul><p>静态数据成员</p><ul><li>类似于全局变量，静态数据成员定义在任何函数之外，一旦被定义，将存在于程序整个生命周期</li><li>通常类的静态成员不应在类内部初始化，不过可以为其提供 const 类内初始值</li><li>注：<ul><li>静态数据成员可以是不完全类型</li><li>静态数据成员类型可以就是它所属类型 (普通成员只能声明所属类型的指针或引用)</li><li>可以使用静态成员作为默认实参</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;本篇笔记主要包含原书第一部分，第一章～第七章，从变量定义到类结束。&lt;/p&gt;
&lt;p&gt;这次仔细从头开始看，包括最基础的语法都给重新过了一遍，虽然可能看得稍微有点快，而且</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/C/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CPP" scheme="https://wangjiaying.top/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>《游戏编程模式》-笔记</title>
    <link href="https://wangjiaying.top/2023/09/25/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-%E7%AC%94%E8%AE%B0/"/>
    <id>https://wangjiaying.top/2023/09/25/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-%E7%AC%94%E8%AE%B0/</id>
    <published>2023-09-25T08:31:19.000Z</published>
    <updated>2023-10-06T04:02:54.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>说实话，关于正经游戏模式的书还是有点少，这本算是少数中的其中之一。</p><p>整本书看下来，发现书里并没有按照类似常规 “23 种设计模式” 这种概念来讲述，有不少其实都不存在于常规设计模式当中：<br />比如双缓冲、空间分区、脏标记等... 确实跟书名更符一点，讲的是 “游戏编程模式”，而不是单纯的设计模式。</p><p>不过，要说是是游戏程序设计方面的书籍，本书肯定是算的。总之值得一看。</p><h1 id="介绍"><a class="anchor" href="#介绍">#</a> 介绍</h1><p>设计模式相关的书籍，主要是为了做到如何更好组织程序</p><ul><li>编写超出大脑思考范围的程序，需要更好的设计与组织。</li><li>宝藏埋在代码深处，而许多人正在它们之上路过。</li></ul><p>作者将其描述的模式分为：序列型、行为型、解藕型、优化型</p><h1 id="架构-性能和游戏"><a class="anchor" href="#架构-性能和游戏">#</a> 架构、性能和游戏</h1><p>解藕</p><ul><li>解藕符合最少知识原则：如果两块代码耦合，意味着必须同时搞清楚两者，而如果解藕，只需要了解其一</li></ul><p>维护设计</p><ul><li>一个良好的设计必须在实现新需求时优雅地融入，否则就会死于一个又一个『小补丁』</li><li>在项目生命周期维护一个良好的架构需要很大努力</li></ul><p>许多模式会让代码更加灵活，但是依赖于一些运行时成本的机制 (如接口、消息、虚函数等)。</p><h2 id="寻求平衡"><a class="anchor" href="#寻求平衡">#</a> 寻求平衡</h2><ul><li>良好架构：在项目生命周期内更容易理解代码</li><li>快速的运行时性能</li><li>快速完成所需功能</li></ul><p>它们一部分是冲突的，需要权衡</p><h2 id="要点"><a class="anchor" href="#要点">#</a> 要点</h2><ul><li>抽象和解藕能够使程序开发变得更快和简单，但不必浪费时间来做，除非确信存在问题的代码需要这种灵活性</li><li>在开发周期中要对性能进行思考和设计，但要推迟会降低灵活性、底层的、详尽的优化</li><li>尽快探索游戏设计空间，但不要走得太快留下烂摊子</li><li>如果将要删除代码，那么不需要浪费时间将其整理得很整洁</li><li>乐在其中</li></ul><h1 id="再探设计模式"><a class="anchor" href="#再探设计模式">#</a> 再探设计模式</h1><h2 id="命令模式"><a class="anchor" href="#命令模式">#</a> 命令模式</h2><p>『命令就是一个对象化 (实例化) 的方法调用』</p><ul><li>将某个概念转化为一块数据、一个对象 (或者可以认为是传入函数的变量等)</li><li>支持 undo、redo 的命令模式与备忘录模式有点类似，但区别在于备忘录模式是记录所有数据，而命令模式仅需记录该条命令改变的数据</li></ul><p>示例：关卡编辑、角色 (包括 AI) 控制</p><h2 id="享元模式"><a class="anchor" href="#享元模式">#</a> 享元模式</h2><p>一般用于太多对象并考虑对其进行轻量化时<br />享元模式通过将对象数据切分成两种类型解决共同数据问题</p><ol><li>不属于单一实例对象并且能够被所有对象共享的数据 (内部状态)</li><li>单一对象实例特有数据 (外部状态)</li></ol><p>示例：地图绘制，地块类型等数据</p><h3 id="森林之树"><a class="anchor" href="#森林之树">#</a> 森林之树</h3><p>『迷雾升起，一片雄伟、古老而茂密的森林在眼前展现。数不尽的远古铁杉铺面而来，宛如一座绿色的大教堂。漫天树叶像是褪色的巨大玻璃穹顶，将阳光滤碎成细密的水雾，透过高大树干的间隙，你能感到这庞大的森林往远方渐逝。』</p><h2 id="观察者模式"><a class="anchor" href="#观察者模式">#</a> 观察者模式</h2><p>MVC 一般必然都会用到。<br />C# event 亦是。<br />分为『容器』方式和链表方式<br />链式观察者</p><ul><li>避免动态容器扩容导致的内存分配</li><li>链表节点池 (指向观察者及下一个链表)，可以使得多个链表节点指向同一个观察者，使得一个观察者可以同时观察多个被观察对象。</li></ul><p>注：观察者模式非常适合于一些不相干的模块之间的通信问题，但并不适合于单个紧凑的模块内部的通信。<br />目的：解藕<br />示例：成就系统、数据绑定</p><h2 id="原型模式"><a class="anchor" href="#原型模式">#</a> 原型模式</h2><p>如 prefab<br /> 原型数据建模</p><ul><li>如 BOSS 或某些特殊物品，通常是游戏中某一对象的重定义版本</li><li>即可定义：原型 + 额外数据</li></ul><h2 id="单例模式"><a class="anchor" href="#单例模式">#</a> 单例模式</h2><p>谨慎使用，避免使用、避免滥用。<br />单例会尽可能将初始化延后 (懒汉)，所以到那时它们所需信息一般都可获得。</p><ul><li>只要不是循环依赖，一个单例甚至可以在其初始化时引用另一个单例。</li><li>可以继承单例，例如使用简单的编译跳转，实现不同平台绑定到具体类型</li></ul><p>不推荐单例的原因：单例模式就是一个全局状态，只是被封装到类中了而已</p><ol><li>全局变量有害，令代码晦涩难懂</li><li>全局变量促进耦合，控制对实例的访问才能控制耦合</li><li>并发不友好</li></ol><p>注：不访问或不修改全局状态的函数称为『纯函数』，纯函数易于理解、利于编译器优化，并能使用诸如记忆缓存、重用调用结果等技巧。<br />为实例提供便捷访问方式</p><ul><li>传递参数</li><li>在基类获取</li><li>通过其它全局对象访问</li><li>通过 服务定位器访问 (定义一个类专门用来给对象做全局访问)</li></ul><h2 id="状态模式"><a class="anchor" href="#状态模式">#</a> 状态模式</h2><h3 id="有限状态机"><a class="anchor" href="#有限状态机">#</a> 有限状态机</h3><ul><li>借鉴了计算机科学里的自动机理论中的一种数据结构 (图灵机) 思想。</li><li>FSMs 可以看作最简单的图灵机</li></ul><p>表达的是：</p><ul><li>拥有一组状态，且可以在这组状态之间进行切换</li><li>状态机同一时刻只能处于一种状态</li><li>状态机会接收一组输入或事件</li><li>每一个状态有一组转换，每一个转换都关联着一个输入并指向另一个状态</li></ul><p>整个状态机可以分为：状态、输入和转换<br />注：部分状态机实例 (没有内部状态) 可通过享元模式复用</p><h3 id="并发状态机"><a class="anchor" href="#并发状态机">#</a> 并发状态机</h3><p>角色在持枪过程中可以跑、跳和躲避，并能在过程中开火，若执着于传统的有限状态机，那么之前的状态可能都需要加倍：对于已存在状态，需要定另一个 (附加额外操作的) 状态。</p><ul><li>并发状态机即另外定义一个状态机，与基础状态机同时运行</li><li>适用于两个状态没什么关系的时候 (也许还需要加点额外判断)，但至少比单层有限状态机更能完成任务</li></ul><h3 id="层次状态机"><a class="anchor" href="#层次状态机">#</a> 层次状态机</h3><p>比如有一个『on ground』状态用于处理跳跃状态和躲避状态，站立、走路、跑步状态则可以从这个『on ground』状态继承而来。</p><ul><li>一个状态有一个父状态，当一个事件进来时，如果子状态不处理则沿继承链传给父状态处理。</li><li>或使用状态栈实现状态链</li></ul><h3 id="下推自动机"><a class="anchor" href="#下推自动机">#</a> 下推自动机</h3><p>解决有限状态机没有历史记录问题。</p><ul><li>下推自动机有一个状态栈</li><li>在一个有限状态机里，当有一个状态切进来时，则替换之前状态</li><li>下推状态机除此之外还提供额外选择：<ul><li>可以把新状态放入栈中 (当前状态即存在栈顶)</li><li>可以弹出栈顶状态 (上一个状态变成新的栈顶状态)</li></ul></li></ul><h1 id="序列型模式"><a class="anchor" href="#序列型模式">#</a> 序列型模式</h1><h2 id="双缓冲"><a class="anchor" href="#双缓冲">#</a> 双缓冲</h2><p>当今多数游戏中，每个像素占 32 位：红、绿、蓝 各占 8 位，剩余 8 位保留做其它各种用途。<br />显示器从左至右，从上至下绘制显示器像素，会从帧缓冲区获知这些像素该是何种颜色。</p><ul><li>各种高级图形算法，本质上都是为了向这个帧缓冲数组写东西</li></ul><p>撕裂</p><ul><li>显示器访问速度 (屏幕刷新率) 比显卡写入速度 (帧率) 更快</li><li>GPU 的帧率超过显示器后、或在帧率较低的时候都可能会出现撕裂的情况：其本质是帧率和屏幕刷新率的不一致导致</li></ul><p>适用双缓冲情景：</p><ul><li>需要维护一些被逐步改变着的状态量</li><li>同个状态可能会在其被修改的同时被访问到</li><li>希望避免访问状态的代码能看到具体的工作过程</li><li>希望能够读取状态但不希望等待写入操作完成</li></ul><p>注意</p><ul><li>双缓冲需要在写入完成后进行一次交换操作，操作必须是原子性的</li><li>双缓冲意味着增加了内存使用</li></ul><p>双缓冲模式所解决的核心问题是对状态同时进行修改和访问的冲突 (并非只针对图形)</p><ul><li>状态被另一个线程或中断代码直接访问</li><li>进行状态修改的代码访问到了其正在修改的那个状态</li></ul><p>例如：战斗中事件状态？<br />做法</p><ul><li>交换缓冲区指针或引用 (需要注意外部不能缓冲这个引用，因为引用指向地址可能错误)</li><li>在两个缓冲区之间进行数据拷贝</li></ul><h2 id="游戏循环"><a class="anchor" href="#游戏循环">#</a> 游戏循环</h2><p>实现用户输入和处理器速度在游戏行进时间上的解藕。<br />一个游戏循环在游戏过程中持续运转，每循环一次，非阻塞地处理用户的输入、更新游戏状态并渲染游戏。它跟踪流逝的时间并控制游戏的速率。<br />关键部分：</p><ul><li>非阻塞用户输入</li><li>帧时间适配<ul><li>非同步的固定时间步长 (尽可能快执行更新循环)</li><li>同步的固定时长 (让循环以固定时间步长运行：增加延时或追赶帧时间)</li><li>变时步长 (使游戏变得不确定)</li><li>定时更新迭代，变时渲染 (最复杂且最具适配性)</li></ul></li></ul><h2 id="更新方法"><a class="anchor" href="#更新方法">#</a> 更新方法</h2><p>通过对所有对象实例同时进行帧更新来模拟一系列相互独立的游戏对象。<br />注 1：所有对象都在每帧进行模拟，但并非真正同步。且对象更新顺序亦有很大影响，因为 A 更新时，看到的 B 的状态是前一帧的。(除非借助双缓冲模式)<br /> 注 2：在更新期间修改对象列表必须谨慎</p><ul><li>更新期间删除列表对象可能导致某项被跳过</li><li>添加新对象则会导致新对象提前一帧更新</li></ul><p>update 依存：</p><ul><li>实体类中</li><li>组件类中</li><li>代理类中</li></ul><p>处理非激活对象</p><ul><li>过多无需被更新的对象会导致 CPU 浪费额外时间来遍历，并破坏缓存。若非激活对象较多，可考虑单独一个列表维护</li></ul><h1 id="行为型模式"><a class="anchor" href="#行为型模式">#</a> 行为型模式</h1><h2 id="字节码"><a class="anchor" href="#字节码">#</a> 字节码</h2><h3 id="解释器模式"><a class="anchor" href="#解释器模式">#</a> 解释器模式</h3><p>缺点</p><ul><li>从磁盘加载它需要进行实例化并串联成堆的小对象</li><li>这些对象与它们之间的指针占用大量内存</li><li>遍历子表达式、虚函数调用均对缓存不友好</li></ul><h3 id="虚拟机器码"><a class="anchor" href="#虚拟机器码">#</a> 虚拟机器码</h3><p>由虚拟机 (VM) 执行</p><ul><li>高密度</li><li>线性</li><li>底层</li><li>迅速</li></ul><p>字节码模式</p><ul><li>指令集定义了一套可以执行的底层操作，一系列指令被编码为字节序列，虚拟机逐条执行指令栈上的这些指令</li><li>通过组合指令，即可完成很多高级行为</li></ul><h3 id="堆栈机"><a class="anchor" href="#堆栈机">#</a> 堆栈机</h3><p>指令<br />字面值指令 + 数据<br />指令分类</p><ul><li>外部基本操作：虚拟机之外，引擎内部，做一些玩家能看到的事情，决定字节码能够表达的真正行为</li><li>内部基本操作：操作虚拟机内部的值 —— 字面值、算数运算符、操作栈的指令等</li><li>控制流：让指令有选择执行或循环重复执行，即跳转</li><li>抽象化：复用，方法调用</li></ul><h3 id="语法转换工具"><a class="anchor" href="#语法转换工具">#</a> 语法转换工具</h3><p>一个图形界面以让用户定义行为，随后转换为字节码<br />注 1：用户其实可以绕过编译器，手动编写一些恶意字节码<br />注 2：ANTLR 或 Bison 解析器生成器</p><h3 id="设计决策"><a class="anchor" href="#设计决策">#</a> 设计决策</h3><p>基于栈虚拟机</p><ul><li>指令较小</li><li>代码生成简单</li><li>指令数更多</li></ul><p>基于寄存器虚拟机</p><ul><li>指令更大：需要记录参数在栈中偏移量</li><li>指令更少：每个指令能做更多的事</li></ul><h2 id="子类沙盒"><a class="anchor" href="#子类沙盒">#</a> 子类沙盒</h2><p>使用基类提供的操作集合来定义子类中的行为。</p><ul><li>基类定义保护的方法供给子类调用</li><li>基类可能会与许多不同游戏系统耦合，而子类不会</li></ul><p>注：它去掉了继承类的耦合，但这是通过把耦合聚集到基类自身来实现的。（基类可能会变得更大且越难以维护）<br />适用情景：</p><ul><li>有一个带有大量子类的基类</li><li>基类能够提供所有子类可能需要执行的操作集合</li><li>在子类之间有重叠代码，使它们之间更简便共享代码</li><li>希望使这些继承类与其它代码之间耦合最小化</li></ul><h2 id="类型对象"><a class="anchor" href="#类型对象">#</a> 类型对象</h2><p>通过创建一个类来支持新类型的灵活创建，其每个实例都代表一个不同的对象类型。<br />继承树实现 (is-a 关系)</p><ul><li>游戏中每只怪物实例都将属于某一种派生的怪物种族，种族越多继承树就越庞大</li></ul><p>包含 (has-a 种类) 实现</p><ul><li>每个怪物包含种族数据 (初始生命值、攻击等)</li></ul><p>『定义一个类型对象类和一个持有类型对象类，每个类型对象表示一个不同的逻辑类型。每个持有类型对象类的实例引用一个描述其类型的类型对象。』<br />使用情景：</p><ul><li>需要定义一系列不同『种类』的东西，又不想硬编码进类型系统</li><li>不知道将来会有什么类型</li><li>需要在不重新编译或修改代码的情况下，修改或添加新的类型</li></ul><p>注：在 C++ 内部，虚方法通过 虚函数表 (vtable) 实现，一个虚函数表是包含了函数指针集合的简单结构体，每个函数指针指向类里一个虚方法。每个类在内存驻存一张虚函数表。每个实例都有一个指向其类虚函数表的指针。当调用虚函数时，代码首先从对象虚函数表中查找，通过存储在表里的函数指针进行函数调用。<br />缺点</p><ul><li>通过类型对象去定义类型相关的数据非常容易，但是定义类型相关的行为却很难</li><li>解决方式：<ul><li>简单方式：是创建一个固定的预定义行为集合，让类型对象中数据从中任选其一</li><li>复杂方式：支持在数据中定义行为 (解释器模式或字节码模式)</li></ul></li></ul><p>通过继承共享数据</p><ul><li>没错，数据之间也可以通过继承共享</li><li>分为动态继承 (基类可能会动态变更) 或静态 (基类属性不变) 直接复制给子类</li></ul><p>类型对象应该封装还是暴露</p><ul><li>如果封装<ul><li>类型对象模式的复杂性对代码库其它部分不可见，成为持有类型对象才关心的实现细节</li><li>持有类型对象可以选择性重写类型对象的行为</li><li>需要给类型对象暴露的所有内容提供转发函数</li></ul></li><li>如果公开类型对象<ul><li>外部代码在没有持有类型对象类实例的情况下就能访问类型对象</li><li>类型对象现在是对象公共 API 的一部分</li></ul></li></ul><h1 id="解藕型模式"><a class="anchor" href="#解藕型模式">#</a> 解藕型模式</h1><p>我们几乎没有可能不去更改程序的功能或特性，而解藕能够让变化变得简单点。<br />某块代码中的变化通常不会影响到另一块代码</p><ul><li>组件将游戏中不同域相互解藕成单一实体</li><li>事件队列能够静态而且及时地将两个通信中的对象解藕开来</li><li>服务器定位器允许代码访问功能却不需要被绑定到提供服务的代码上</li></ul><h2 id="组件模式"><a class="anchor" href="#组件模式">#</a> 组件模式</h2><p>『允许一个单一的实体跨越多个不同域而不会导致耦合』</p><ul><li>软件设计的趋势是尽可能使用组合而不是继承</li><li>为实现两个类之间的代码共享，应该让它们拥有同一个类的实例而不是继承同一个类</li></ul><p>单一实体横跨了多个域，为保持域之间的相互隔离，每个域的代码都独立地放在自己的组件类中。实体本身则简化为这些组件的容器。<br />使用情景：</p><ul><li>有一个涉及多个域的类，但也能够用在别的地方</li><li>一个类越来越庞大、难以开发</li><li>希望定义许多共享不同能力的对象，但采用继承方式却无法精确重用代码</li></ul><p>注 1：组件模式相较直接在类中实现，引入了更多复杂性：每个概念上的对象成为一系列必须被同时实例化、初始化，并正确关联的集群。不同组件间通信也变得更具挑战性。<br />注 2：组件指针属于二级引用，在循环代码中可能导致更低性能</p><h3 id="组件之间传递信息"><a class="anchor" href="#组件之间传递信息">#</a> 组件之间传递信息</h3><ol><li>通过修改容器对象的状态 (状态共享)<ul><li>使组件间可以保持解藕</li><li>要求组件间任何需要共享的数据都由容器对象进行共享</li><li>使得信息传递变得隐秘，同时对组件执行的顺序产生依赖</li></ul></li><li>直接相互引用 (组件之间会有耦合)</li><li>通过传递信息的方式 (最复杂)</li></ol><h2 id="事件队列"><a class="anchor" href="#事件队列">#</a> 事件队列</h2><p>『对消息或事件的发送与受理进行时间上的解藕』<br />事件队列是一个按照先进先出顺序存储一系列通知或请求的队列。请求可由处理直接处理或转交给对其感兴趣模块，使消息的处理变得动态且非实时。</p><ul><li>在很多方面，可以看作是观察者模式的异步版本</li></ul><p>使用情景：</p><ul><li>相比观察者模式的直接 『派发 - 处理』模式，队列提供给拉取请求的代码块一些控制权：接收者可以延迟处理，聚合请求或完全废弃它们</li><li>使得队列在发送端需要实时反馈时显得不适用</li><li>如播放音效：解藕播放与受理，并避免两个同类音效同时叠加播放</li></ul><p>注 1：队列事件视图比同步系统中的事件具有更重量级的数据结构：后者只需通知然后接收者可以通过检查系统环境获知，而队列则需要在事件发生时记录以便稍后处理消息时使用。<br />注 2：当消息系统是同步时，注意可能导致消息循环的情景，如避免在处理事件端代码中发送事件。</p><h3 id="环形缓冲区"><a class="anchor" href="#环形缓冲区">#</a> 环形缓冲区</h3><h3 id="设计决策-2"><a class="anchor" href="#设计决策-2">#</a> 设计决策</h3><p>入队的是什么</p><ul><li>事件：就有点类似异步观察者模式</li><li>消息：一个『消息』或『请求』描述一种期望发生在『将来』的行为，或者可以认为是一种异步 API 服务</li></ul><p>读取者</p><ul><li>单播队列：当一个队列是一个类 API 本身的一部分时</li><li>广播队列：类似事件系统</li><li>工作队列：可以有多个处理者，不过队列中一项只能投递给一个处理者</li></ul><p>写入者</p><ul><li>一个写入者：类似同步观察者模式<ul><li>隐式知道事件来源</li><li>通常允许多个读取者</li></ul></li><li>多个写入者：类似『全局』或『中央』事件总线工作原理</li></ul><p>同步消息提醒模式下，调用执行只有在所有接收者都处理完消息后才会返回到发送者。</p><h2 id="服务定位器"><a class="anchor" href="#服务定位器">#</a> 服务定位器</h2><p>『为某服务提供一个全局访问入口来避免使用者与该服务具体实现类之间产生耦合』</p><ul><li>一个服务类为一系列操作定义了一个抽象接口</li><li>一个具体的服务提供器实现这个接口</li><li>一个单独的服务定位器通过查找一个合适的提供器来提供这个服务的访问，同时屏蔽了提供器的具体类型和定位这个服务的过程</li><li>注：由于使用接口抽象，因此可以方便地使用装饰器模式额外为服务提供器附加额外功能</li></ul><p>注：注意处理服务不能被定位器使用时的处理</p><h1 id="优化型模式"><a class="anchor" href="#优化型模式">#</a> 优化型模式</h1><h2 id="数据局部性"><a class="anchor" href="#数据局部性">#</a> 数据局部性</h2><p>『通过合理组织数据利用 CPU 的缓存机制来加快内存访问速度』<br />我们能更快地处理数据，但不能更快地获取数据</p><ul><li>CPU 进行运算时需要从主存取出数据并置入寄存器</li><li>RAM 的存取速度远远跟不上 CPU 的速度，甚至从未接近</li></ul><p>数据获取 (缓存)</p><ul><li>利用数据的时空局部性，获取数据时同时缓存数据及相关数据。</li></ul><p>数据即性能</p><ul><li>缓存失效与面向数据局部性的代码，性能相差可能几十倍，由于缓存机制，组织数据的方式会直接影响性能 (包括代码也是在内存中，需要载入 CPU 执行)</li><li>缓存行：优化的目标在于尽量将数据结构组织，使其在内存中两两相邻</li></ul><p>使用情景</p><ul><li>找到出现性能热点的地方</li><li>不需要在不常执行之处：结果会更加复杂笨拙</li></ul><p>使用须知</p><ul><li>抽象化意味着要通过指针或引用访问对象，导致在内存中来回跳转，引发缓存未命中的现象</li><li>越是在数据局部性上下功夫，就越要牺牲继承、接口及这些手段带来的好处</li></ul><p>CPU 流水线</p><ul><li>免分支预测，导致 CPU 预测失准和流水线停顿<ul><li>现代 CPU 单条指令需要多个时钟周期来完成，为了让 CPU 保持忙碌，因此引入流水线以便多条指令并行执行</li></ul></li><li>流水线模式：CPU 猜测哪些指令接下来会被执行，顺序结构很简单，控制流结构很麻烦，需要分支猜测：分析前面代码走向，预测下一次代码执行流（因此出现控制流代码会降低面向数据设计的性能，因此关键代码最好避开控制流）</li></ul><p>冷 / 热代码分解</p><ul><li>每帧需要检查和修改的变量 (如位置)</li><li>非每帧需要用到的处理意外情况的变量 (如怪物掉落数据)</li></ul><h3 id="设计决策-3"><a class="anchor" href="#设计决策-3">#</a> 设计决策</h3><ul><li>避开继承<ul><li>或者至少在进行缓存优化之处避开</li></ul></li><li>为不同的对象类型使用相互独立的数组</li></ul><p>游戏实体的定义 (主要指配合组件模式)</p><ul><li>假如游戏实体通过类中的指针索引其组件<ul><li>可以将组件存于相邻数组中，游戏实体并不关心组件存储，这样组织可以对迭代过程进行优化</li><li>对于给定实体，很容易通过其指针获取对应组件</li><li>在内存中移动组件较困难：启用禁用组件，对其移动 (排序) 时，可能一不小心就破坏了指针关联，必须确保对实体相应指针进行更新</li></ul></li><li>假如游戏实体通过一系列 ID 进行索引更新<ul><li>更加复杂 (相比指针)</li><li>速度更慢：不大可能比遍历原始指针更快，通过 ID 获取组件可能也涉及到哈希查找问题</li><li>需要访问组件管理器：存储组件数组的管理类来提供 ID 获取组件的对应接口</li></ul></li><li>假如游戏实体本身就只是个 ID<ul><li>若将游戏实体所有行为和状态都从主类移动到组件中，游戏实体唯一要做的就是将自己与其组件绑定</li><li>实体类变得很小，只是个数值包装</li><li>实体类本身为空</li><li>无需管理其生命周期 (现在实体只是某些内置类型的值)</li><li>检索一个实体的所有组件会很慢：与前一个方案问题类似，为某个实体寻找对应组件需要进行 ID 映射带来开销 (或者将实体 ID 对应为其组件所在数组索引，但这样所有组件必须保持平行，导致不能排序)</li></ul></li></ul><h2 id="脏标记模式"><a class="anchor" href="#脏标记模式">#</a> 脏标记模式</h2><p>『将工作推迟到必要时进行以避免不必要的工作』<br />一组原始数据随时间变化，一组衍生数据经过一些代价昂贵的操作由这些数据确定。一个脏标记跟踪这个衍生数据是否和原始数据同步，它在原始数据改变时被设置。如果它被设置，那么当需要衍生数据时，它们就会被重新计算并清除标记，否则仅使用缓存数据。<br />使用情景</p><ul><li>这个模式解决一个相当特定的问题</li><li>仅当性能问题严重到值得增加代码复杂度时才使用</li></ul><p>其它要求</p><ul><li>原始数据修改次数比衍生数据的使用次数多</li><li>递增更新数据十分困难<ul><li>例如在容器里放东西，更新容器总量，每当增加或减少时重新统计 —— 这样还不如使用动态总重量：增加或减少物品时直接在总量上进行操作（例如属性系统）</li></ul></li></ul><p>注意</p><ul><li>延时太长会有代价<ul><li>这个模式将某些耗时工作推迟到真正需要时才执行</li><li>而真正需要时，往往刻不容缓</li></ul></li><li>必须保证每次状态改动时都设置脏标记</li><li>必须在内存中保存上次的衍生数据</li></ul><h2 id="对象池"><a class="anchor" href="#对象池">#</a> 对象池</h2><p>内存碎片化</p><ul><li>如同乱停的车和规矩停放的车，可停数量差异一样。</li><li>即使碎片化情况很少，它也依然在削减着堆内存并使其成为一个千疮百孔而不可用的泡沫块。</li></ul><p>使用情景</p><ul><li>需要频繁创建和销毁对象</li><li>对象的大小一致</li><li>在堆上进行对象内存分配较慢或会产生内存碎片时</li><li>每个对象封装着获取代价昂贵且可重用的资源</li></ul><p>注意</p><ul><li>每个对象的内存大小是固定的 (应当是一个类型)</li><li>重用对象不会被自动清理 (若没有适当重设，可能保留上一次的数据)</li><li>未使用的对象将占用内存 (并会阻碍垃圾回收释放它指向的对象)</li></ul><p>空闲表</p><ul><li>O (1) 的时间复杂度</li><li>一个头指针，依次指向形成链表</li><li>使用时取出当前头指针，并重置当前头指针为其指向的下一个空闲对象</li><li>回收时将回收对象指向当前头指针，然后重置当前头指针为回收对象</li></ul><h2 id="空间分区"><a class="anchor" href="#空间分区">#</a> 空间分区</h2><p>『将对象存储在根据位置组织的数据结构中来高效地定位它们。』<br />基本要求是有一组对象，每个对象都具备某种位置信息。</p><ul><li>普通 (方格) 空间分区</li><li>四叉树 (二维)</li><li>八叉树 (三维)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;说实话，关于正经游戏模式的书还是有点少，这本算是少数中的其中之一。&lt;/p&gt;
&lt;p&gt;整本书看下来，发现书里并没有按照类似常规 “23 种设计模式” 这种概念来讲述，有</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>虚幻5基础学习笔记-详细(C++)</title>
    <link href="https://wangjiaying.top/2023/09/18/%E8%99%9A%E5%B9%BB5%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-C/"/>
    <id>https://wangjiaying.top/2023/09/18/%E8%99%9A%E5%B9%BB5%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-C/</id>
    <published>2023-09-18T04:20:22.000Z</published>
    <updated>2023-10-06T04:24:14.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>前几天 Unity 公布了新的 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnVuaXR5LmNvbS9jbi9uZXdzL3BsYW4tcHJpY2luZy1hbmQtcGFja2FnaW5nLXVwZGF0ZXM=">收费政策</span>，然后整个开发者社区都沸腾了，处处都是 <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzYyMTc1MTM4MQ==">讨论的声音</span>，不管最后实际生效政策如何 (2023.9.18 官方似乎更新了公告，说会对『运行费』政策进行修改)，这种杀鸡取卵的行为必然都会造成以后开发选择的考虑点。</p><p>之前本来还打算专一 Unity 的，比如前些日子都还一直在研究 HDRP，算是基本把 HDRP 物理光照、各种调参熟悉得七七八八了，结果就听到这么个消息... 简直是...<br /> 如果真的实施，人家独立开发只怕都会把这个作为一个很大比例权重考虑进去了，毕竟哪个游戏开发者没有想做个好玩 (爆款) 的大作的梦想呢？</p><p>之前一直都关注 UE，比如 UE 商城每月一次的各种免费资源都嫖了好久：</p><p><img data-src="/blogimages/2023/2023-09-18/Snipaste_2023-09-18_14-48-05.jpg" alt="" /></p><p>要是没有使用之地也太可惜了。</p><p>加上想到到学 UE 顺便还能深入下 C++ 和真正的游戏引擎代码 (Unity 作为一个黑盒引擎，有时候用起来确实感觉不是自己的)</p><blockquote><p>之前本来还打算 C# 一条道走到黑的，现在考虑了良久，觉得至少 C/C++ 也要深入一下才行，UE 也可以算是个入口了<br />而且 UE 内置工具链比 Unity 完善很多，Unity 扩展几乎全靠插件... 怎么感觉 UE 才适合个人玩？毕竟很多东西给提供了，不用个人造轮子。<br />几年前使用 UE4 的时候，感觉很难搞下去还有一个重要原因是：UE 的 C++ 操作起来实在太慢了！最近重新试了下，现在代码跳转提示的速度算是可以接受了。</p></blockquote><p>这两天对 UE 的基础知识进行了一轮学习，先记录一部分笔记，后续再做补充。</p><h1 id="术语"><a class="anchor" href="#术语">#</a> 术语</h1><h2 id="gameplay"><a class="anchor" href="#gameplay">#</a> Gameplay</h2><ul><li>玩法：游戏的规则和状态</li><li>提供能力的是引擎，提供内容的是 Gameplay</li><li>Unreal Gameplay 框架：游戏规则、角色、控制、相机、用户界面和 HUD<ul><li>GameMode：不同的游戏规则</li><li>GameState：存储当前的游戏状态</li><li>PlayerState：存储玩家状态信息</li><li>Character：角色</li><li>Camera：相机</li><li>Controller：控制器</li><li>3C：Character、Control 和 Camera</li></ul></li></ul><p>GameFeatures：UE5 推出的一个支持动态改变游戏玩法的框架</p><ul><li>类似动态插件</li><li>一种模块化的逻辑组织方式，GameFeatures 允许在 “游戏功能” 这个颗粒度上进行解耦</li></ul><p>UGameInstance：游戏单例，全局唯一</p><ul><li>引擎的初始化加载</li><li>还可以包含 UGameInstanceSubsystem</li></ul><p>GEngine：全局变量</p><ul><li>也可以包含 UEngineSubsystem</li></ul><p>坐标轴</p><ul><li>X、Y、Z</li><li>Row、Pitch、Yaw</li></ul><p>服务器</p><ul><li>异构服务器：客户端和服务器的执行逻辑完全不一样，服务器和客户端分别各自实现</li><li>同构服务器：服务器和客户端用同一套框架和代码，通过在启动时指定自己作为服务器还是客户端即可</li></ul><h2 id="关系"><a class="anchor" href="#关系">#</a> 关系</h2><ul><li>Actor 组成世界</li><li>Actor 由 Component 组成</li></ul><h3 id="component"><a class="anchor" href="#component">#</a> Component</h3><ul><li>功能的载体，表达的是『功能』的概念，一定程度的嵌套组装能力 (SceneComponent)</li><li>正确理解『功能』和『游戏业务逻辑』的区分是理解 Component 的关键要点</li></ul><blockquote><p>是实现一个个『与特定游戏无关』的功能。理想情况下，已经实现完成的 Components 是可以直接在游戏之间迁移使用<br /> ——<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yMzMyMTY2Ng==">《InsideUE4》GamePlay 架构（四）Pawn</span></p></blockquote><h3 id="actor"><a class="anchor" href="#actor">#</a> Actor</h3><ul><li>世界中的基础对象</li><li>Actor 可以组装其它 Actor 或 Component</li><li>概念上也可以类比 Unity 中的 Prefab</li></ul><h3 id="pawn"><a class="anchor" href="#pawn">#</a> Pawn</h3><ul><li>可以响应响应外部输入、移动能力的 Actor (如可以被玩家或 AI 控制)</li><li>封装了一些列对 UPawnMovementComponent 组件操作 (因此也有封装碰撞)</li></ul><p>分类</p><ul><li>DefaultPawn：默认带 UFloatingPawnMovement (移动)、USphereComponent (碰撞)、UStaticMeshComponent (显示) 三件套</li><li>SpectatorPawn (观众)：相当于不带重力的 DefaultPawn</li><li>Character：人形角色使用 (Pawn 的加强特化版本)</li></ul><h1 id="结构"><a class="anchor" href="#结构">#</a> 结构</h1><p>保管库：下载资源地址，每个引擎对应一个，可自定义路径</p><ul><li>不需要的引擎可删除</li></ul><p>编译 (材质) 公共缓存：AppData/Local/UnrealEngine</p><ul><li>派生数据缓存 (DDC)</li><li>不用引擎版本可删除</li><li>还可以放服务器</li></ul><h2 id="视口"><a class="anchor" href="#视口">#</a> 视口</h2><ul><li>快速隐藏各个 Editor 提示图标：选 GameView (快捷键 G)</li><li>ShowFPS：显示帧率</li><li>全屏：F11</li><li>移动捕捉：视口右上，网格图标设置</li><li>相机自动跟随移动目标：按住 Shift + 移动</li><li>End 键：将对象投射到地面</li><li>物体对齐当前视口：右键对象，选择 SnapObjectToView</li><li>复制：Alt + 拖动</li><li>以视口控制移动：Ctrl+Shift+P (或右键 actor 选择控制)</li><li>运行模式退出鼠标：Shitf+F1</li></ul><h2 id="工具"><a class="anchor" href="#工具">#</a> 工具</h2><p>BSP：做原型的，可以避免普通 cube 材质拉伸等，还支持打洞、组合等。</p><h1 id="代码"><a class="anchor" href="#代码">#</a> 代码</h1><p>UHT：反射与垃圾回收系统</p><ul><li><code>#include &quot;xxx.generated.h&quot;</code>  需要包含在最后，其它头文件在此之前</li></ul><p>类型</p><ul><li>整型使用 int32 (UE 提供的跨平台类型)</li></ul><h2 id="类型关系"><a class="anchor" href="#类型关系">#</a> 类型关系</h2><p>继承关系</p><ul><li>UObject-&gt;<ul><li>UActorComponent</li><li>AActor<ul><li>APawn-&gt;ACharacter</li><li>AController-&gt;APlayerController</li><li>AInfo-&gt;APlayerState</li></ul></li></ul></li></ul><p>命名关系</p><ul><li>派生自 Actor 带有 A 前缀，如 AController</li><li>派生自 Object 带有 U 前缀，如 UComponent</li><li>Enums 的前缀是 E，如 EFortificationType</li><li>Interface 的前缀是 I，如 IAbilitySystemInterface</li><li>Template 的前缀是 T，如 TArray</li><li>派生自 SWidget 的类 (Slate UI) 带有前缀 S，如 SButton</li><li>其它类 (结构) 的前缀为字母 F，如 FVector</li></ul><h3 id="详情"><a class="anchor" href="#详情">#</a> 详情</h3><h4 id="uobject"><a class="anchor" href="#uobject">#</a> UObject</h4><ul><li>存放数据、不能放置到场景</li></ul><h4 id="uactorcomponent"><a class="anchor" href="#uactorcomponent">#</a> UActorComponent</h4><ul><li>可以挂载至场景 Actor 上，必须依附于 Actor 存在</li></ul><h4 id="aactor"><a class="anchor" href="#aactor">#</a> AActor</h4><ul><li>能放置在场景，可以有视觉表现</li><li>除了继承自 UObject 的序列化、反射、内存管理等能力之外，额外实现的是组件的组合能力，Tick 能力，网络复制能力和对生命周期的管控</li></ul><h4 id="apawn"><a class="anchor" href="#apawn">#</a> APawn</h4><ul><li>可以被控制器持有</li></ul><h4 id="acharacter"><a class="anchor" href="#acharacter">#</a> ACharacter</h4><ul><li>有角色移动组件 (CharacterMovementComponent)</li><li>具有角色封装好的一系列功能</li></ul><h4 id="acontroller"><a class="anchor" href="#acontroller">#</a> AController</h4><ul><li>可以控制 APawn 的控制器</li></ul><h4 id="aplayercontroller"><a class="anchor" href="#aplayercontroller">#</a> APlayerController</h4><ul><li>角色控制器存在于整个游戏关卡中，而 Pawn 可以被破坏、重生</li><li>可以控制不同的 Pawn，也可以在它们之间切换，或完全不控制任何 Pawn</li><li>具有输入，不过一般用于处理与 Pawn 无关的事件 (如 UI)</li></ul><h3 id="注意"><a class="anchor" href="#注意">#</a> 注意</h3><ul><li>如果想要一个 C++ 类可以被蓝图继承，需要填写<ul><li>UCLASS(Blueprintable)</li><li>注：继承应用了该宏的派生类可以不用加</li></ul></li><li>不建议 vs 生成代码，而是引擎中编译按钮进行重新生成，或按 Alt+Ctrl+F11 调用引擎 LiveCoding 编译 (编译信息可以在 Window-&gt;MessageLog 查看)</li><li>若关闭了 LiveCoding 可使用 Ctrl+Alt+Shift+P 热编译代码修改</li></ul><h2 id="接口"><a class="anchor" href="#接口">#</a> 接口</h2><h3 id="常规"><a class="anchor" href="#常规">#</a> 常规</h3><ul><li><p>GetWorld()：&quot;Engine/World.h&quot;</p><ul><li>UActorComponent、AActor 均有该接口</li></ul></li><li><p>GetActorTransform：transform</p></li><li><p>SetActorLocation：设置对象坐标，同 Unity position</p></li><li><p>AddActorLocalOffset：本地坐标增量移动 (注：sweep 只对根组件生效)</p></li><li><p>AddForce：启用物理模拟后施加力，可传入第三个参数指定忽略质量</p></li><li><p>SetupAttachment：设置父级组件</p></li><li><p>ContructorHelper：静态帮助类，可用于加载资源</p></li><li><p>&quot;Kismet/GameplayStatics.h&quot;</p><ul><li>各种帮助函数，如 GetAllActorsOfClass (GetWorld (),XXX::StaticClasd)</li></ul></li><li><p>碰撞</p><ul><li>设置为触发器：UBoxComponent-&gt;SetCollisionEnabled (ECollisionEnabled::QueryOnly)</li><li>设置响应通道：-&gt;SetCollisionResponseToChannel ()</li><li>绑定响应事件：-&gt;OnComponentBeginOverlap.AddDynamic ()</li><li>注：或直接使用 TriggerBox 等</li></ul></li></ul><h3 id="对象创建"><a class="anchor" href="#对象创建">#</a> 对象创建</h3><h4 id="uworldspawnactor"><a class="anchor" href="#uworldspawnactor">#</a> UWorld::SpawnActor</h4><ul><li>在世界中创建 Actor</li></ul><h4 id="uworldspawnactordeferred"><a class="anchor" href="#uworldspawnactordeferred">#</a> UWorld::SpawnActorDeferred</h4><ul><li>在世界中创建 Actor</li><li>配套 xxx-&gt;FinishSpawn () 调用后才会调用 BeginPlay 等进行初始化的函数，即延迟调用 (在此之前可设置一些其它初始化参数)</li></ul><h4 id="createdefaultsubobject"><a class="anchor" href="#createdefaultsubobject">#</a> CreateDefaultSubobject</h4><ul><li>为 Actor 创建组件 ( <code>只能在构造函数使用</code> )</li><li>T：类型</li><li>TEXT：一个标识，当前类中不能重复</li></ul><h4 id="newobject"><a class="anchor" href="#newobject">#</a> NewObject</h4><ul><li>仅在运行时构建 UObject 使用 ( <code>构造函数不要用</code> )</li><li>主要指 UObject 的派生类 (非 Actor、非 ActorComponent)</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNS4wL3poLUNOL29iamVjdHMtaW4tdW5yZWFsLWVuZ2luZS8=">objects-in-unreal-engine</span></li></ul><h4 id="aactoraddcomponentbyclass"><a class="anchor" href="#aactoraddcomponentbyclass">#</a> AActor::AddComponentByClass</h4><ul><li>动态为 Actor 创建一个组件</li><li>AActor 所实现，内部其实也是调用 NewObject 创建 (所以构造函数应当也不要用)</li></ul><h4 id="纯-c-类的创建"><a class="anchor" href="#纯-c-类的创建">#</a> 纯 C++ 类的创建</h4><ul><li>纯 C++ 类 (指非继承自 UObject 的类，如 UE 中一般以 F 开头的)</li><li>可以通过 new 来创建对象，并使用 TSharedPtr 和 TSharedRef 来管理对象</li><li><code>TSharedPtr&lt;MyClass&gt; MyClassPtr = MakeShareable(new MyClass())</code></li></ul><h3 id="资源加载"><a class="anchor" href="#资源加载">#</a> 资源加载</h3><h4 id="uobjectstaticloadobject"><a class="anchor" href="#uobjectstaticloadobject">#</a> UObject::StaticLoadObject</h4><ul><li>加载资源文件 (静态对象、非蓝图资源)</li><li>应该算是资源加载 API 中最底层的了？</li></ul><h4 id="uobjectstaticloadclass"><a class="anchor" href="#uobjectstaticloadclass">#</a> UObject::StaticLoadClass</h4><ul><li>可用于加载蓝图类资源</li><li>内部调用 LoadObject</li></ul><h4 id="loadobjectt"><a class="anchor" href="#loadobjectt">#</a> LoadObject&lt; <code>T</code> &gt;</h4><ul><li>封装  <code>StaticLoadObject</code> ，可以当做其泛型版本</li><li>可用来加载非蓝图资源，比如动画、贴图、音效等</li><li>内部会先执行 FindObject (查找已加载对象)</li></ul><h4 id="loadclasst"><a class="anchor" href="#loadclasst">#</a> LoadClass&lt; <code>T</code> &gt;</h4><ul><li>封装  <code>StaticLoadClass</code> ，用来加载 UClass，可以当做其泛型版本</li><li>可以用来加载蓝图并获取蓝图类</li></ul><h4 id="constructorhelpers"><a class="anchor" href="#constructorhelpers">#</a> ConstructorHelpers</h4><ul><li>FClassFinder：可以用来加载蓝图类资源</li><li>FObjectFinder：对 LoadObject () 的封装，加载非蓝图普通资源</li><li><code>只能在构造函数使用</code></li><li>查找某个对象的对象和类</li></ul><h4 id="fsoftobjectpath"><a class="anchor" href="#fsoftobjectpath">#</a> FSoftObjectPath</h4><ul><li>包含资源路径字符串的结构体</li><li>根据给定的资源路径找到对应的资源</li><li>ResolveObject 内部封装  <code>FindObject&lt;UObject&gt;(nullptr, PathString)</code>  调用</li><li>TryLoad 内部封装  <code>StaticLoadObject</code>  或  <code>LoadObject</code>  调用</li><li>可配合 StreamableManager 进行资源异步加载</li><li>TSoftObjectPtr ：看起来可以管理 FSoftObjectPath</li></ul><h4 id="fsoftclasspath"><a class="anchor" href="#fsoftclasspath">#</a> FSoftClassPath</h4><ul><li>继承自 FSoftObjectPath，可用于加载蓝图资源</li><li>提供 TryLoadClass 实际调用 LoadClass</li></ul><h4 id="fsoftobjectptr"><a class="anchor" href="#fsoftobjectptr">#</a> FSoftObjectPtr</h4><ul><li>封装对 FSoftObjectPath 操作</li><li>(也提供了 LoadSynchronous 同步加载方法，实际是调用 FSoftObjectPath.TryLoad)</li></ul><h4 id="tsoftclassptr"><a class="anchor" href="#tsoftclassptr">#</a> TSoftClassPtr</h4><ul><li>与 TSoftObjectPtr 类似</li></ul><h4 id="fstreamablemanager"><a class="anchor" href="#fstreamablemanager">#</a> FStreamableManager</h4><ul><li>可用于资源异步加载</li><li>异步加载：<ul><li>RequestAsyncLoad，返回 FStreamableHandle</li></ul></li><li>同步加载：<ul><li>RequestSyncLoad (多个或单个加载，返回 FStreamableHandle)</li><li>LoadSynchronous (单个加载，实际调用 RequestSyncLoad，直接返回 UObject)</li></ul></li><li>看起来主要是与 FSoftObjectPath 配合使用</li><li>官方建议定义在类似单例之类对象中使用</li><li>注：FStreamableHandle 是同步或者异步加载的句柄，只要句柄处于激活状态，资源就会一直存在于内存</li></ul><h4 id="objectlibrary"><a class="anchor" href="#objectlibrary">#</a> ObjectLibrary</h4><ul><li>资源加载库：设定一个路径，然后让它自动扫描</li><li>可用于在指定路径中加载所有资源数据，之后选择性加载实际资源</li><li>其中存储的 FAssetData 提供 GetSoftObjectPath () 接口返回 FSoftClassPath</li></ul><h4 id="调用关系"><a class="anchor" href="#调用关系">#</a> 调用关系</h4><ul><li><code>LoadObject</code> -&gt;UObject::StaticLoadObject</li><li><code>UObject::StaticLoadClass</code> -&gt;LoadObject-&gt;UObject::StaticLoadObject</li><li><code>LoadClass</code> -&gt;UObject::StaticLoadClass-&gt;LoadObject-&gt;UObject::StaticLoadObject</li><li><code>ConstructorHelpers::FObjectFinder</code> -&gt;LoadObject-&gt;UObject::StaticLoadObject</li><li><code>ConstructorHelpers::FClassFinder</code> -&gt;UObject::StaticLoadClass-&gt;LoadObject-&gt;UObject::StaticLoadObject</li><li><code>FSoftObjectPath</code> -&gt;ResolveObject-&gt;UObject::FindObject</li><li><code>FSoftObjectPath</code> -&gt;TryLoad-&gt;UObject::StaticLoadObject</li><li><code>FSoftClassPath</code> -&gt;TryLoadClass-&gt;LoadClass-&gt;UObject::StaticLoadClass-&gt;LoadObject-&gt;UObject::StaticLoadObject</li></ul><h4 id="注意-2"><a class="anchor" href="#注意-2">#</a> 注意</h4><p>资源加载中，同类 API 一般有  <code>LoadObject</code>  和  <code>LoadClass</code>  两种版本的，其中  <code>LoadObject</code>  最基础， <code>LoadClass</code>  属于在  <code>LoadObject</code>  之上的封装 (继承) 扩展。<br />相当于 LoadObject 可用于加载所有资源，而 LoadClass 可用于更方便地加载蓝图类资源 (不知道理解得对不对)。</p><p>FObjectFinder、FClassFinder、LoadClass、StaticLoadClass 等最终都会调用到 LoadObject</p><h3 id="模板"><a class="anchor" href="#模板">#</a> 模板</h3><p>TSubclassOf&lt; <code>T</code> &gt;：定义类类型属性时，使引擎面板过滤类型，只能选择 T 类本身或继承自它的类。</p><ul><li>注：直接定义类类型指针，将能选择场景中类型对象</li></ul><p>TArray：动态容器<br /> Cast&lt; <code>T</code> &gt;：类型转换</p><h3 id="字符串"><a class="anchor" href="#字符串">#</a> 字符串</h3><ul><li>FString::FromInt</li><li>FString::SanitizeFloat</li><li>FString::Printf</li></ul><h3 id="调试"><a class="anchor" href="#调试">#</a> 调试</h3><p>GEngine-&gt;AddOnScreenDebugMessage：屏幕调试显示 (-1 的 key 可以始终显示，否则会去重)</p><ul><li>蓝图中为 PrintString</li></ul><h3 id="材质"><a class="anchor" href="#材质">#</a> 材质</h3><p>Actor：BaseMesh</p><ul><li>BaseMesh-&gt;CreateAndSetMaterialInstanceDynamic</li><li>UMaterialInstanceDynamic-&gt;SetVectorParameterValue()</li></ul><h3 id="颜色"><a class="anchor" href="#颜色">#</a> 颜色</h3><p>FLineColor</p><ul><li>有预定义静态颜色</li><li>随机颜色：FLineColor::MakeRandomColor ()</li></ul><h3 id="定时器"><a class="anchor" href="#定时器">#</a> 定时器</h3><p>TimeManager.h</p><ul><li>GetWorldTimerManager().SetTimer(FTimeHandler,this,callback,timeRate,isLoop)</li><li>GetWorldTimerManager().ClearTimer(FTimeHandler)</li></ul><h3 id="组件"><a class="anchor" href="#组件">#</a> 组件</h3><ul><li>USceneComponent：空组件</li><li>UStaticMeshComponent：mesh 组件</li><li>USpringArmComponent：悬臂组件 (相机平滑跟随)</li><li>UCameraComponent：相机</li><li>UParticleSystem：粒子</li><li>UDecalComponent：贴花</li></ul><h2 id="宏定义"><a class="anchor" href="#宏定义">#</a> 宏定义</h2><ul><li>UPROPERTY<ul><li>BlueprintReadWrite</li><li>BlueprintReadOnly</li><li>VisibleAnywhere：可在任何地方可见</li><li>EditAnywhere：可在任何地方编辑 (常用，但指针类型避免使用)</li><li>Category=&quot;分类&quot;</li><li>EditInstanceOnly：只允许在实例上编辑</li><li>VisibleInstanceOnly：只允许在实例上查看</li><li>EditDefaultsOnly：只允许在原型中编辑</li><li>VisibleDefaultsOnly：只允许在原型中编辑</li><li>meta=(ClampMin=-5.0f,ClampMax=5.0f,UIMin=-5.0f,UIMax=5.0f)：数值限制等</li><li>meta=(AllowedClassses=&quot;Textures&quot;)：限制变量类型</li><li>注：标记该属性的对象会被引擎自动计数回收</li></ul></li><li>UFUNCTION<ul><li>BlueprintCallable</li><li>BlueprintImplementableEvent：标记方法为蓝图实现的事件，代码仅定义</li></ul></li><li>UE_LOG<ul><li>LogTemp,Log/Warning/Error,TEXT(&quot;Hello World!&quot;)</li></ul></li><li>FORCEINLINE：强制内联</li><li>DEFINE_LOG_CATEGORY_STATIC：自定义日志级别</li><li>UENUM：定义枚举<ul><li>BlueprintType (蓝图可用)</li></ul></li><li>USTRUCT：定义结构<ul><li>BlueprintType (蓝图可用)</li><li>主体需添加：GENERATED_USTRUCT_BODY</li></ul></li><li>DECLARE_DELEGATE：定义委托<ul><li>代码中通过 AddUObject 绑定</li></ul></li><li>DECLARE_MULTICAST_DELEGATE：定义多播委托</li><li>DECLARE_DYNAMIC_DELEGATE：定义委托 (蓝图可用)<ul><li>绑定的委托方法需要定义 UFUNCTION 宏</li><li>代码中通过 AddDynamic 绑定</li></ul></li><li>DECLARE_DYNAMIC_MULTICAST_DELEGATE：定义多播委托 (蓝图可用)</li></ul><h2 id="问题"><a class="anchor" href="#问题">#</a> 问题</h2><ul><li>不允许指针指向不完整类型<ul><li>官方文档搜索类型，可查看需要引入的头文件</li></ul></li><li>类前添加 class 可规避一些编辑器不识别的麻烦</li><li>默认创建类时，若添加了自己的目录，引用头文件也会添加，需要删除 (否则会找不到)</li></ul><h1 id="蓝图"><a class="anchor" href="#蓝图">#</a> 蓝图</h1><p>蓝图对象根组件：(如果没有任何组件时会自动创建) 相当于一个空物体对象，承载 Transform 等属性，可被替换</p><ul><li>根层级有多个组件且未指定根组件时，会随机选取一个作为根组件</li><li>指定方式很简单：(代码) 构造函数初始化时为 RootComponent 赋值即可</li></ul><p>操作</p><ul><li>Alt + 点击连接线：断开节点</li><li>右键蓝图 -&gt; 资产操作 -&gt; 重新加载</li></ul><p>其它</p><ul><li>关卡蓝图：每个关卡一张</li></ul><p>节点</p><ul><li>Construct Object from class：实例化一个继承自 UObject 的类</li><li>Break XXX：访问一个类型对象中的字段 (或直接右键节点 split)</li></ul><h1 id="物体"><a class="anchor" href="#物体">#</a> 物体</h1><p>碰撞</p><ul><li>默认导入对象生成的是复杂碰撞，简单碰撞需要手动生成 (Detail 面板也需要设置，引擎似乎也可以全局设置)</li><li>凸包碰撞：生成的凸包碰撞也是属于简单碰撞，外形与模型类似，可调整参数</li></ul><h1 id="控制台"><a class="anchor" href="#控制台">#</a> 控制台</h1><p>～键打开</p><ul><li>最大帧率：t.MaxFPS</li></ul><h1 id="参考文档"><a class="anchor" href="#参考文档">#</a> 参考文档</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MDgyOTY5NTU=">写给 Unity 开发者的 Unreal Engine 开发指南 （扫盲）</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTA1MjM0ODU=">Unreal Engine 的启动流程</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTI4MzcwNDU=">Unreal Engine 的 Gameplay 框架和重点</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NjcyMzY2NzU=">https://zhuanlan.zhihu.com/p/467236675</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUNlNHkxZTdQRQ==">【UE4/5】虚幻 4/5 入门 c++ 基础训练</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWFZNHkxeTdRNw==">成功上岸，将自己进大厂前花 3w 买的 C++ 游戏开发 &amp; 虚幻引擎 UE 全套教程，完整版 300 集，拿出来分享给大家！学会即可上岗就业</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yMzMyMTY2Nj9yZWZlcj1pbnNpZGV1ZTQ=">《InsideUE4》GamePlay 架构（四）Pawn</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yMzQ4MDA3MQ==">《InsideUE4》GamePlay 架构（五）Controller</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNC4yNy96aC1DTi9Qcm9ncmFtbWluZ0FuZFNjcmlwdGluZy9TdWJzeXN0ZW1zLw==">Subsystems</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b2ZlaXhpb25nc2l4L2FydGljbGUvZGV0YWlscy84MTA2MTc2NA==">Unreal Engine 4 C++ 创建对象的几种方法</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNS4wL3poLUNOL29iamVjdHMtaW4tdW5yZWFsLWVuZ2luZS8=">objects-in-unreal-engine</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85OTMyNzM3Mw==">【UE4 基础】对象创建与资源获取</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2luOTk4L3AvMTU1MDU5MTIuaHRtbA==">使用 ConstructorHelpers 来加载</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EzNTk4Nzc0NTQvYXJ0aWNsZS9kZXRhaWxzLzgwNTIzMzU0">[UE4] C++ 实现动态加载的问题</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMTc0NzkwMjI=">UE4_C++_资源加载与优化</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVucmVhbGVuZ2luZS5jb20vNC4yNi96aC1DTi9Qcm9ncmFtbWluZ0FuZFNjcmlwdGluZy9Qcm9ncmFtbWluZ1dpdGhDUFAvQXNzZXRzL0FzeW5jTG9hZGluZy8=">AsyncLoading</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC84MDg0NjI3Nw==">AssetManager 系列之 TAssetPtr 与 FStreamableManager</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2luOTk4L3AvMTU1NTQwNDguaHRtbA==">关于资产引用的各种 Path 和 Ptr 介绍</span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;前几天 Unity 公布了新的 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9ibG9nLnVuaXR5LmNvbS9jbi9</summary>
      
    
    
    
    <category term="虚幻引擎" scheme="https://wangjiaying.top/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    <category term="C++" scheme="https://wangjiaying.top/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/C/"/>
    
    
    <category term="虚幻引擎" scheme="https://wangjiaying.top/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>《.NET内存管理宝典》-笔记(6)[完]</title>
    <link href="https://wangjiaying.top/2023/08/21/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-6-%E5%AE%8C/"/>
    <id>https://wangjiaying.top/2023/08/21/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-6-%E5%AE%8C/</id>
    <published>2023-08-21T01:33:55.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本文包含原书第七章至第十五章，也就是本书最后一部分。<br />主要为对象资源释放、线程局部存储、托管指针、ref 类型、非托管类型、非托管约束、 <code>Span&lt;T&gt;</code> 、 <code>Memory&lt;T&gt;</code> 、Unsafe 类、面向数据设计 等高级主题。</p><p>这是本书的最后一份笔记，没想到整体看完这本书花了 2 月有余... 说来惭愧，这两个月花了太多时间在其它东西上去了：玩游戏，比如最近的蔚蓝档案、或者在家看 HDRP 相关的教程。<br />虽然除了玩游戏也不能说全无相关，但确实是这次没有专心看书了，导致时间线被严重拉长 —— 特别是本来每天就只有下班时间两个小时的情况下。</p><p>后面得再紧张一点了。</p><h1 id="第十二章-对象生存期"><a class="anchor" href="#第十二章-对象生存期">#</a> 第十二章 对象生存期</h1><h2 id="终结"><a class="anchor" href="#终结">#</a> 终结</h2><p>.NET 有两种终结方式：非确定性终结与确定性终结，也可以称为 隐式清除 和 显式清除</p><ul><li>析构函数</li><li>IDisposable</li></ul><p>终结机制和垃圾回收机制在概念上并没有直接关系。<br />终结器对象特点：</p><ul><li>执行时间非确定</li><li>执行顺序、及其持有的对象图只有在运行完终结器之后才能被回收</li><li>执行线程不确定</li><li>不保证终结器代码一定会执行一次 (如出错会阻塞执行线程)</li><li>在终结器引发异常会很危险 (无法执行终结器被视为最严重故障)</li><li>可终结对象对 GC 有额外开销</li></ul><p>因此，推荐显式 IDisposable 释放而非使用终结器<br />注：值类型可以有终结器，但只会在装箱实例上运行。其在 .NET Core 则直接无效。<br />调用时间点</p><ul><li>当 GC 结束时</li><li>当运行时卸载 AppDomain 和运行时终止时</li></ul><h3 id="关键终结器"><a class="anchor" href="#关键终结器">#</a> 关键终结器</h3><p>CriticalFinalizerObject<br /> 关键终结器是一种常规终结器，但其带有额外的保证，保证其代码一定会执行。</p><ul><li>是一个不包含实现的抽象类，只是类型系统和运行时之间的一个协议</li><li>运行时将采取一些预防措施确保在任何情况下都执行关键终结器 (如运行时会提前 jit 代码，避免后续因 out-of-memory 而无法 jit 编译和执行)</li></ul><p>(SafeHandle 继承 CriticalFinalizerObject)</p><h3 id="终结器内部实现"><a class="anchor" href="#终结器内部实现">#</a> 终结器内部实现</h3><p>GC 使用一个 finalization queue (终结器队列) 记录所有可终结对象</p><ul><li>在执行 GC 期间，GC 会在标记阶段结束后检查终结器队列，查看是否有可终结对象已死亡</li><li>若有，则将其移动到 fReachable queue (可达对象队列)，然后通知专门的终结器线程执行</li><li>终结器线程执行发生在 GC 将托管线程从挂起恢复到正常状态之后</li><li>由于引用这些对象的根已经从终结器队列移除，下一次 GC 时会最终对其执行回收：即可终结对象至少能存活到下一次 GC</li></ul><p>注 1：由于终结器线程不一定能在下一次 GC 前执行完毕，fReachable queue 在标记阶段也会被视为一个根，并导致终结器对象被提升到老一代，面临『中年危机』<br />注 2：.NET 提供一个方法 GC.WaitForPendingFunalizers ，可阻塞线程直到可达对象队列执行完毕<br />另外还有两个与终结器相关的重要 API：</p><ul><li>GC.ReRegisterForFinalize(object)</li><li>GC.SuppressFinalize (object)：设置对象标头中的一个 bit，终结器线程工作期间，不会调用此 bit 被设置过的对象的 Finalize 方法</li></ul><p>为什么需要专门的 queue 和终结器线程？</p><ul><li>终结器代码是用户的，以异步方式执行终结器代码更安全</li></ul><h3 id="终结器开销"><a class="anchor" href="#终结器开销">#</a> 终结器开销</h3><ul><li>默认情况下，分配对象时强制使用慢速分支</li><li>默认情况下，至少会让对象被提升一次，增加对象生存期</li><li>如果可终结对象分配速度快于被终结速度，导致危险后果</li></ul><h3 id="复活"><a class="anchor" href="#复活">#</a> 复活</h3><p>终结器代码可以将自身赋值给某个根，导致此对象重新变为可达，这种情况称为复活。</p><ul><li>注：复活后除非重新注册终结器队列，否则死亡时不会再执行终结器代码</li></ul><p>使用复活机制的场景之一是对象池的隐式回收，但隐式池化管理并没有特别的好处。</p><h3 id="终结器注意点"><a class="anchor" href="#终结器注意点">#</a> 终结器注意点</h3><ul><li>总是检查是否存在期待资源：如从构造函数抛出异常，会导致终结器在对象状态未完全初始化的情况下执行</li><li>避免在终结器分配资源：如果出现 OutOfMemory 会是严重错误</li><li>避免任何线程上下文依赖</li><li>不要在终结器抛出异常</li><li>避免从终结器调用 virtual 成员</li></ul><p>首选显式清理。</p><h2 id="idisposable"><a class="anchor" href="#idisposable">#</a> IDisposable</h2><p>通常可以将隐式释放的终结器与要求显式释放的 IDisposable 接口结合，若显示调用了 Dispose 方法则使用 GC.SuppressFinalize 抑制终结器的调用，否则以终结器兜底。<br />注：抑制终结器如上所示，操作很简单，没有性能影响</p><h2 id="安全句柄"><a class="anchor" href="#安全句柄">#</a> 安全句柄</h2><p>用于安全处理非托管资源的类型，构建于关键终结器 (CriticalFinalizerObject) 之上。</p><ul><li>即结合了显式和隐式释放</li></ul><p>CLR 在 P/Invoke 期间会以特殊方式处理：不会 (像 HandleRef 那样) 被垃圾回收，而是基于安全原因使用引用计数逻辑</p><ul><li>每个 P/Invoke 都包含 JIT 编译的用于递增引用计数逻辑，并在调用结束后递减计数器</li></ul><p>相比其它替代者，SafeHandle 好处有：</p><ul><li>拥有关键终结器，比常规终结器更可靠</li><li>仅对非托管资源 (句柄) 进行了最小化的简单封装</li><li>使用 SafeHandle 的对象无需使用终结器</li><li>更好的生存期管理：GC 在 P/Invoke 调用期间自动保持其存活状态，无需手动 GC.KeepAlive</li><li>有多个对应不同资源的 SafeHandle 子类型，比直接使用 IntPtr 拥有更好的强类型支持</li><li>对句柄重用攻击防范使得安全性提高</li></ul><p>注：P/Invoke marshaling 机制可以在底层将 SafeHandle 派生类视为 IntPtr (直接将 IntPtr 句柄赋值给 SafeHandle 派生类)</p><h3 id="预定义安全句柄"><a class="anchor" href="#预定义安全句柄">#</a> 预定义安全句柄</h3><ul><li>SafeFileHandle</li><li>SafeMemoryMappedFileHandle、SafeMemoryMappedViewHandle：内存映射文件句柄相关的安全句柄</li><li>SafeNCryptKeyHandle、SafeNCrypProviderHandle、SafeNCrypSecretHandle</li><li>SafePipeHandle：命名管道句柄的安全句柄</li><li>SafeProcessHandle：用于进程的安全句柄</li><li>SafeRegistryHandle：用于注册表键的安全句柄</li><li>SafeWaitHandle：安全等待句柄 (用于同步场景)</li></ul><p>注：若底层非托管代码某些部分确实需要直接使用 IntPtr，可以通过 DangerousGetHandle 获取原始句柄。</p><h2 id="弱引用"><a class="anchor" href="#弱引用">#</a> 弱引用</h2><p>存储一个对象的引用，但其自身不被视为一个根 (它对目标对象的引用不会使得后者保持可达状态)</p><ul><li>短弱句柄 (short weak handle)：当 GC 决定回收对象，在终结器运行之前被清零。即使终结器复活了对象，引用它的弱句柄依然保持清零状态。</li><li>长弱句柄 (long weak handle)：当对象由于终结被提升时，它们的目标仍然保持有效。如果终结器复活了对象，长弱句柄将保持有效状态。</li></ul><p>主要应用场景：</p><ul><li>各种类型的观察和侦听器</li><li>缓存</li></ul><p>.NET 提供：GCHandle 及封装其的 WeakReference 和 WeakReference<T>（请使用 TryGetTarget）<br />注：WPF 中存在 WeakEventManager 实现了弱事件的模式</p><h1 id="第十三章-其它主题"><a class="anchor" href="#第十三章-其它主题">#</a> 第十三章 其它主题</h1><h2 id="依赖句柄"><a class="anchor" href="#依赖句柄">#</a> 依赖句柄</h2><p>依赖句柄允许我们将两个对象的生存期耦合起来</p><ul><li>像其它 GC 句柄一样指向一个目标</li><li>行为像一个弱句柄：即不能使目标一直保持存活</li></ul><p>行为如下：</p><ul><li>句柄本身不会影响两个对象的生存期</li><li>只要主对象存活，次要对象也存活</li></ul><p>使用它的唯一方法是使用包装类 ConditionalWeakTable，其被组织为 Dictionary，其 key 存储主要对象，value 存储次要对象。</p><ul><li>注：此类的 key 是弱引用</li></ul><p>依赖句柄的底层弱引用行为像长弱引用：即使主要对象终结仍然会保持维护主要对象和次要对象之间的关系，使其可以正确处理复活场景。</p><h2 id="线程局部存储"><a class="anchor" href="#线程局部存储">#</a> 线程局部存储</h2><p>线程局部存储 (TLS)</p><ul><li>其行为像一个全局变量，但数据是为每个线程单独存储的。</li></ul><p>当前再 .NET 中有三种使用线程局部存储方法：</p><ul><li>线程静态字段：添加  <code>ThreadStatic</code>  属性标记后，就可以作为静态字段使用</li><li>包装线程静态字段的帮助类： <code>ThreadLocal&lt;T&gt;</code>  类型</li><li>线程数据插槽：在  <code>Thread.SetData</code>  和  <code>Thread.GetData</code>  方法的帮助下使用</li></ul><p>注：线程静态字段性能比线程数据插槽性能更好，且线程静态字段是强类型，而线程数据插槽始终对 object 进行操作。</p><h3 id="线程静态字段"><a class="anchor" href="#线程静态字段">#</a> 线程静态字段</h3><p>使用 ThreadStatic 标记常规静态字段即可，值和引用类型都可以用作线程静态字段。<br />注：若线程静态字段具有初始化程序，将只会在执行静态构造函数的线程上调用一次，会导致后续其它线程字段将保持其默认值。</p><ul><li>为克服类似问题，后续 .NET 提供了  <code>ThreadLocal&lt;T&gt;</code>  类以提供更好、更确定性的初始化行为。</li><li>当然，也因此  <code>ThreadLocal&lt;T&gt;</code>  会比直接使用 ThreadStatic 方式性能差一些</li></ul><h3 id="线程数据插槽"><a class="anchor" href="#线程数据插槽">#</a> 线程数据插槽</h3><p>使用非常简单，不过不建议使用，性能和 object 这种非强类型操作都很不妥当。</p><h3 id="线程局部存储内部"><a class="anchor" href="#线程局部存储内部">#</a> 线程局部存储内部</h3><p>有一个特殊的内存区域专用于每个线程自己的目的，在 Windows 中称为线程局部存储 (Thread Local Storage,TLS)，在 Linux 中称为线程专用数据 (thread-specific data)</p><ul><li>但是这样的区域相当小，例如 Windows 保证每个进程仅有 64 个此类插槽可用，且最大数量不超过 1088 个，其无法保存数据本身</li></ul><p>CLR 使用了 C++ 中使用线程局部存储方法，定义了一个 ThreadLocalInfo struct 类型的全局线程静态变量，其保留三个 CLR 内部数据地址：</p><ul><li>表示当前正在运行的托管线程的非托管 Thread 类的实例</li><li>正在执行当前线程的 AppDomain 实例</li><li>ClrTlsInfo 结构的实例</li></ul><p>当我们在 .NET 使用线程局部存储技术时，只存储了 ThreadLocalInfo 结构指针在 TLS 中，其它所有内容都驻留在 CLR 私有堆和 GC 堆中，即与常规静态变量实现方式类似：实例通常由堆分配，只是它们的引用存储在专用的常规对象数组中。</p><p><img data-src="/blogimages/2023/2023-08-21/2140760369.jpeg" alt="2140760369.jpeg" /></p><p>由于在编译时已经知道了类型的数量，因此专用的 Object [] 数组和静态 blob 都具有恒定的、预先计算的大小。<br />总的来说 TLS 仅用作对应数据结构的线程相关性的功能实现细节，它本身并没有加快任何速度 (甚至会有额外开销)</p><h3 id="使用场景"><a class="anchor" href="#使用场景">#</a> 使用场景</h3><ul><li>需要存储和管理线程敏感数据</li><li>可以利用单线程相关性：<ul><li>日志记录或诊断</li><li>缓存 (如 StreamBuilderCache)</li></ul></li></ul><p>注：使用线程静态变量显然不适合异步编程，因为异步方法的延续不能保证会在同一个线程执行。</p><ul><li>因此作为 ThreadLocal 的补充，AsyncLocal<T> 可用于在所有异步方法执行期间保留数据。</li></ul><h2 id="托管指针"><a class="anchor" href="#托管指针">#</a> 托管指针</h2><p>简称 byref。<br />对象的引用实际上是一个类型安全指针 (地址)，该指针始终指向对象 MethidTable 引用字段 (通常说指向对象的开头)，有了对象引用，就有了整个对象地址。</p><ul><li>例如 GC 可通过常量偏移量快速访问标头</li><li>通过 MethodTable 中存储的信息，字段地址也很容易计算</li></ul><p>相比引用而言，托管指针可以定义为一种更通用的指针类型，它可以指向其它位置，而不是对象的开头。</p><ul><li>局部变量</li><li>参数</li><li>复合类型的字段</li><li>数组元素</li></ul><p>托管指针任然还是类型，有一个指向 System.Int32 对象的托管指针类型，强类型使它们比纯粹的非托管指针更安全。</p><ul><li>但托管指针只允许用于局部变量和参数签名</li><li>由于这些限制，托管指针并没有直接暴露于 C#，以 ref 参数形式存在 (因此通常也称为 byref)</li></ul><h3 id="ref-局部变量"><a class="anchor" href="#ref-局部变量">#</a> ref 局部变量</h3><p>可视为存储托管指针的局部变量</p><h3 id="ref-返回值"><a class="anchor" href="#ref-返回值">#</a> ref 返回值</h3><p>允许我们从方法中返回托管指针</p><ul><li>返回值的生存期必须超过方法执行范围</li><li>例如不能返回方法中局部变量，可以是类的实例或静态字段、或传递给方法的参数</li></ul><h3 id="只读-ref-和-in-参数"><a class="anchor" href="#只读-ref-和-in-参数">#</a> 只读 ref 和 in 参数</h3><p>用于控制 ref 变量存储变化能力</p><ul><li>对于值类型：保证该值不会更改</li><li>对于引用类型：保证该引用不会被更改</li></ul><p>注：如果在只读 ref 结构调用可修改值的方法也可以确保不被修改：因为这是通过防御性复制方法来实现。因为编译器分析调用方法是否确实会修改状态。<br />创建防御性副本是一个明显开销，可以通过将此类结构设为只读 (如果适用) 来避免防御性复制。</p><ul><li>编译器可以安全略过直接在传递值类型参数上创建防御性复制和调用方法的操作。</li></ul><h3 id="ref-类型的内部"><a class="anchor" href="#ref-类型的内部">#</a> ref 类型的内部</h3><ul><li>指向堆栈分配对象的托管指针</li><li>指向堆分配对象的托管指针<ul><li>指向内部字段 (内部指针) 如何保证其主对象没有其它引用时存活：有一个 brick 表和 plug 树，判断并使内部指针成为根 (但是有开销)</li></ul></li></ul><p>他们均需要对 GC 进行报告，以使 GC 能够检测到目标可达性</p><p><img data-src="/blogimages/2023/2023-08-21/52284544.jpeg" alt="52284544.jpeg" /></p><h3 id="c-中的托管指针-ref-变量"><a class="anchor" href="#c-中的托管指针-ref-变量">#</a> C# 中的托管指针 - ref 变量</h3><p>ref (参数、局部变量、返回值) 都是围绕托指针的小型包装器，显然不应该被视为指针，而是属于变量。</p><blockquote><p>避免复制数据 - 特别是大型结构 - 以类型安全方式</p></blockquote><h2 id="关于更多结构知识"><a class="anchor" href="#关于更多结构知识">#</a> 关于更多结构知识</h2><p>只读结构</p><ul><li>public readonly struct xxx</li><li>避免防御性副本</li></ul><p>ref 结构</p><ul><li>public ref struct xxx</li><li>编译器对其施加了很多限制，以使其只会被堆栈分配 (不能装箱)<ul><li>不能声明为常规结构或类的字段</li><li>不能声明为静态字段</li><li>不能装箱：不能分配 / 强转为对象、动态或任何接口类型，也不能用作数组元素</li><li>不能用作迭代器、泛型参数</li><li>不能在异步方法用作局部变量：因为会被闭包类装箱</li><li>不能被 lambda 或局部函数捕获 (因为会被闭包装箱)</li></ul></li><li>特性：永远不会被堆分配、永远不会被多个线程访问到 (线程间传递堆栈地址非法)</li></ul><h3 id="固定大小缓冲区"><a class="anchor" href="#固定大小缓冲区">#</a> 固定大小缓冲区</h3><p>将结构的一个字段定义为数组时，该字段只是对堆分配数组的引用 (而不是数组本身)</p><ul><li>固定大小缓冲区即是将整个数组嵌入结构中</li><li>唯一限制：数组必须具有预定义的大小，类型只能是基元类型之一 (bool、byte、char、short、int、long、sbyte、ushort、uint、ulong、float、double)</li><li>使用固定大小缓冲区的结构需要标记为 unsafe</li></ul><p>固定大小缓冲区最长用于 P/Invoke 上下文中。</p><ul><li>也可以考虑将其用于通用代码，作为一种定义更密集数据结构的便捷方法，即使将此类结构作为泛型集合的一部分进行堆分配，生成代码也能提供更好的数据局部性。</li></ul><p><img data-src="/blogimages/2023/2023-08-21/1037927430.jpeg" alt="1037927430.jpeg" /></p><p>注：还可以将它们与 stackalloc 组合使用，以创建包含『其它』数组的元素的堆栈分配数组。</p><h2 id="对象结构布局"><a class="anchor" href="#对象结构布局">#</a> 对象 / 结构布局</h2><p>数据对齐</p><ul><li>每种基元数据类型都有其自己首选的对齐方式 —— 存储其地址的值的倍数。</li><li>通常，这种基元类型对齐方式与其大小相等</li><li>（CPU 访问未对齐数据需要更多指令）</li></ul><p>在包含基元类型的复杂类型在布局这些字段时也需要考虑它们的对齐要求，因此会在字段之间引入填充</p><ul><li>复杂类型实例本身也应对齐，以确保其成为更复杂类型 (如数组) 一部分时其字段仍然对齐</li></ul><p>MSDN 为有关对象的布局定义了三个规则：</p><ul><li>类型的对齐方式是其最大元素的大小或指定的打包大小 (以较小者为准)</li><li>每个字段必须与其自身大小或类型的对齐方式 (以较小者为准) 对齐</li><li>在字段之间添加填充以满足对齐要求</li></ul><p>两种类型类别中字段布局设计决策：</p><ul><li>结构：默认情况具有顺序布局 (因为默认假定其会传递给非托管代码)，这会引入填充并增加生成结构的大小</li><li>类：默认情况下具有自动布局，字段会以最高效的方式重新排序</li></ul><p>.NET 提供的控制字段布局方法：</p><ul><li>LayoutKind.Sequential：顺序布局</li><li>LayoutKind.Auto：自动布局</li><li>LayoutKind.Explicit：显式手动布局</li></ul><p>注 1：当为结构体添加托管的引用类型字段时，排列会自动更改为自动布局 (引用类型通常为第一个字段)。当该结构包含其它自动布局结构时，默认布局行为也会变为自动。<br />注 2：类和非托管结构的自动布局是无法更改的<br />注 3：上述特性提供了具有 Pack 参数的重载，即指定的打包大小，类型对齐也会以此为准</p><h3 id="联合"><a class="anchor" href="#联合">#</a> 联合</h3><p>手动指定布局时，故意让字段相互重叠，则称为可区分联合 (discriminated union)</p><h3 id="字段对齐工具"><a class="anchor" href="#字段对齐工具">#</a> 字段对齐工具</h3><ul><li>ObjectLayoutInspector：用于检查对象内存布局，可打印类型布局信息。</li><li><span class="exturl" data-url="aHR0cDovL1NoYXJwbGFiLmlv">Sharplab.io</span></li><li>WinDbg</li></ul><h2 id="非托管类型unmanaged-type"><a class="anchor" href="#非托管类型unmanaged-type">#</a> 非托管类型 (Unmanaged Type)</h2><ul><li>14 种基元类型 + Decimal (decimal)</li><li>枚举类型</li><li>指针类型（比如 int*， long*）</li><li>只包含 Unmanaged 类型字段的结构体</li></ul><h3 id="非托管约束"><a class="anchor" href="#非托管约束">#</a> 非托管约束</h3><p>非托管类型是一直不是引用类型的类型，并且在任何嵌套级别都不包含引用类型字段。</p><ul><li>即上文提到过的不包含 (嵌套) 引用类型的结构体</li></ul><p>借助非托管泛型约束，可以让编译器为我们检查非托管类型条件，可用于泛型方法和泛型结构类型。<br />使用：where T:unmanaged</p><h3 id="非托管约束的作用"><a class="anchor" href="#非托管约束的作用">#</a> 非托管约束的作用</h3><ul><li>可以使用 T 的指针 (也可以转换为 void*)</li><li>可以使用 sizeof (T)</li><li>可以对 T 使用 stackalloc</li></ul><p>注：由于非托管约束意味着 T 是一个值类型，因此不需要固定即可获取参数的指针 (通过引用传递、或在结构实例方法中使用时，还是必须固定，因为可能是装箱的堆分配)<br /> 另外还可以借此更方便使用非托管内存类型。</p><h2 id="blittable-类型"><a class="anchor" href="#blittable-类型">#</a> blittable 类型</h2><p>blittable 类型被定义为托管和非托管代码在内存中都具有相同的表示形式。<br />非托管类型与 bilittable 类型几乎相同，不过后者比前者更为严格。因为有些值类型只是『有时是 bilttable』：</p><ul><li>deceimal：二进制表示形式不够完善，因此不能采用非托管方面格式</li><li>bool：通常在托管和非托管方面都占用 1 字节，但有时在非托管方面占用会更大</li><li>char：通常占用 2 字节，但有时在非托管方面会更小或更大 (取决于编码)</li><li>DateTime：具有自动布局结构因此不能 blittable</li><li>Guid：内部表示取决于机器端</li></ul><p>因此包含这种特殊值类型字段的结构是有效的非托管类型 (满足非托管泛型约束)，但在 Interop marshal 意义上是不能 bilittable 的<br />总结：</p><ul><li>非托管类型 (以及非托管泛型约束) 主要用于通用编程，通常于 unsafe 上下文使用，对序列化等功能进行底层内存优化</li><li>Blittable 类型在 Interop marshal 处理场景中使用</li></ul><p>更多知识：<br /><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MveEcxVGo0cjh0VS1oMlNNdlRUdFFNUQ==">.NET 的基元类型包括哪些？Unmanaged 和 Blittable 类型又是什么？</span></p><h1 id="第十四章-高级技巧"><a class="anchor" href="#第十四章-高级技巧">#</a> 第十四章 高级技巧</h1><h2 id="spant"><a class="anchor" href="#spant">#</a>  <code>Span&lt;T&gt;</code></h2><p>为值类型 (ref struct)，可以表示各种形式的值的连续集合，可以像使用数组一样使用，并内置切片功能。</p><ul><li>由于其分配在堆栈上，因此完全没有堆分配开销</li><li>编译器也能智能地处理封装到  <code>Span&lt;T&gt;</code>  中的数据的生存期 (如返回局部 stack 数据会报错，返回封装托管数组 (或非托管内存) 的 span 则被允许)</li></ul><p>注：C# 不允许将 stackalloc 的执行结果赋值给一个已经定义的变量 (它只能赋值给正在初始化的变量)<br /> 注：其它比如还可以使用  <code>string.AsSpan().Slice()</code>  代替开销更大的 SubString</p><h3 id="内部实现"><a class="anchor" href="#内部实现">#</a> 内部实现</h3><p>在 .NET Core 2.1 之后运行时提供了一种模拟内部指针 (byref) 的功能，称为快速 span，在这之前则称为慢速 span (兼容版本)。</p><ul><li>注 1：目前 byref (内部指针) 不支持定义为字段 (即使是 byref 类型中也不行)</li><li>注 2：快速和慢速之分，实际相差 25%，通常使用情况下只相差 12%~15%</li></ul><h2 id="memoryt"><a class="anchor" href="#memoryt">#</a>  <code>Memory&lt;T&gt;</code></h2><p><code>Span&lt;T&gt;</code>  存在种种限制，如无法存在于堆中。<br /> <code>Memory&lt;T&gt;</code>  同样表示任意内存中一段连续区间，不过它既不是 byref 式类型，也不包含 byref 式实例字段。可用于封装如下数据：</p><ul><li>arrayT[]</li><li>字符串</li><li>实现  <code>IMemoryOwner&lt;T&gt;</code>  的类型 (对生存期有控制)</li></ul><p>可以将  <code>Memory&lt;T&gt;</code>  想象成一个能自由分配并传入传出的盒子，通常不会直接访问其存储内容，而是：</p><ul><li>从它生成  <code>Span&lt;T&gt;</code>  以供局部高效使用 (因此也称为  <code>Span&lt;T&gt;</code>  工厂)</li><li>对于  <code>Memory&lt;char&gt;</code>  可以 ToString 生成字符串，其它类型 ToArray 生成数组</li><li>与  <code>Span&lt;T&gt;</code>  一样支持数据切片</li><li>注：切片和生成 Span 都是非常高效的操作</li></ul><p>注：不允许  <code>Memory&lt;T&gt;</code>  封装 stack 数据 (如 stackalloc 返回值)</p><h2 id="unsafe类"><a class="anchor" href="#unsafe类">#</a> Unsafe 类</h2><p>相比使用普通的不安全代码 (基于指针和 fixed 语句)</p><ul><li>System.Runtime.CompilerServices.Unsafe 提供了一组泛型 / 底层功能以一种更安全的方式操作指针</li><li>并暴露了一些 CIL 支持但 C# 不直接支持的功能</li></ul><p>注：当然实际上它所做的操作仍然是不安全且危险的<br />其提供了大量方法，按功能分组如下：</p><ul><li>类型转换和重解释：在非托管指针和 ref 类型之间来回转换，或在任意两种 ref 类型之间转换</li><li>指针运算：可以像操作普通指针一样对 ref 类型实例做加法和减法</li><li>信息：获取各种信息，如两个 ref 类型实例的大小或字节差异</li><li>内存访问：从任何位置写入或读取任何内容</li></ul><p>注：使用 Unsafe 的方法并不需要标记为 unsafe<br />MemoryMarshal 辅助类</p><ul><li>AsBytes：将任何基元类型 (结构) 的  <code>Span&lt;T&gt;</code>  转换为  <code>Span&lt;byte&gt;</code></li><li>Cast：在两种不同基元类型 (结构)  <code>Span&lt;T&gt;</code>  之间相互转换</li><li>TryGetArray、TryGetMrmoryManager、TryGetString：尝试将指定  <code>Memory&lt;T&gt;</code>  或  <code>ReadOnlyMemory&lt;T&gt;</code>  转换成一种特定类型</li><li>GetReference：以 ref 返回值 (ref return) 方式返回底层  <code>Span&lt;T&gt;</code>  或  <code>ReadOnlySpan&lt;T&gt;</code>  对象</li></ul><p>对非托管内存的封装 (原生内存分配)：</p><ul><li><span class="exturl" data-url="aHR0cDovL2plbWFsbG9jLk5FVA==">jemalloc.NET</span></li><li>Snowflake</li></ul><p>Unsafe 原理：</p><ul><li>对受 IL 支持但 C# 不支持的底层操作的封装</li></ul><h2 id="面向数据设计"><a class="anchor" href="#面向数据设计">#</a> 面向数据设计</h2><p>即基于最高效的内存访问目的来设计数据，与面向对象设计针锋相对：</p><ul><li>设计数据和功能时尽量实现循序内存访问，同时考虑 cacheline 的限制 (将最常用数据打包在一起) 和分层缓存得影响 (将尽可能多的数据保持在高层缓存中)</li><li>设计类型和数据以及使用它们的算法时，使其易于并行化且无需高开销的同步锁</li></ul><p>面向数据设计还可以进一步细分为两类：</p><ul><li>战术型面向数据设计：专注于『局部』数据结构，如最高效的字段布局或以正确的顺序访问数据 (可以很容易在面向对象应用程序应用)</li><li>战略型面向数据设计：从架构层面专注于应用程序的高层设计</li></ul><h3 id="战术型设计"><a class="anchor" href="#战术型设计">#</a> 战术型设计</h3><ol><li>将类型设计成把尽可能多的关联数据容纳进首个 cacheline（例如托管类型自动内存布局将引用字段放置于对象起始位置）</li><li>将数据设计成可以填充进更高层级的缓存</li><li>将数据设计成易于并行化</li><li>避免非循序，特别是随机式内存访问</li></ol><h3 id="战略型设计"><a class="anchor" href="#战略型设计">#</a> 战略型设计</h3><p>战略型设计需要程序员大幅度转变自己的思维</p><ol><li>从 Array-of-structures 走向 Structures-of-arrays（值类型数组才能提供更好的数据局部性）</li><li>Entity Component System<ul><li>实体 (Entity)：一个具有标识符的简单对象，不包含任何数据货逻辑。定义实体的功能是通过向它添加或移除特定组件。</li><li>组件 (Component)：只包含数据而不包含逻辑的简单对象。组件包含的数据表示了它所代表的功能的当前状态。</li><li>系统 (System)：特定功能与特性的逻辑所在，系统对过滤后的实体列表逐个进行操作。</li><li>注：过滤实体的效率对系统很重要，但只要管理得当，数据组件将被循序访问，获得良好的数据局部性和预取命中率。</li></ul></li></ol><h2 id="未来特性"><a class="anchor" href="#未来特性">#</a> 未来特性</h2><ul><li>可空引用类型</li><li>Piplines：替代 streams，具有更好性能和避免分配，大量使用了 Span 和 Memory。目前 Kestrel 是 Piplines 主要使用者之一。</li></ul><h1 id="第十五章-编程-api"><a class="anchor" href="#第十五章-编程-api">#</a> 第十五章 编程 API</h1><h2 id="gc-api"><a class="anchor" href="#gc-api">#</a> GC API</h2><h3 id="收集数据和统计"><a class="anchor" href="#收集数据和统计">#</a> 收集数据和统计</h3><ol><li>GC.MaxGeneration：告知 GC 当前实现的最大代数</li><li>GC.CollectionCount (Int32)：告知自程序启动以来特定代的 GC 出现次数 (包含性)</li><li>GC.GetGeneration：告知给定对象所属的代</li><li>GC.GetTotalMemory：返回所有代中正在使用的字节数 (不包括碎片)，即托管堆上所有托管对象的总大小 (非常耗性能)</li><li>GC.GetAllocatedBytesForCurrentThread：返回当前线程到目前为止分配过的字节总数 (注：只考虑分配过多少数量，并不考虑垃圾回收后的)</li><li>GC.KeepAlive：延长堆栈根存活性，使传递的参数在调用此方法时至少可以到达行 (从而影响生成的 GC 信息)</li><li>GCSetting.LargeObjectHeapCompactionMode：例如设置为 CompactOnce，可以显式请求发生第一个完全阻塞 GC 时压缩 LOH</li><li>GCSetting.LatencyMode</li><li>GCSetting.IsServerGC</li></ol><h3 id="gc-通知"><a class="anchor" href="#gc-通知">#</a> GC 通知</h3><p>只有阻塞垃圾回收才会引发此类通知：</p><ul><li>GC.RegisterForFullGCNotification：如果满足完全阻塞 GC 条件将引发此通知 (该通知并不能保证将会发生完全 GC，只有条件达到足以进行完全 GC 的阈值才会发生)</li><li>GC.CancelFullGCNotification</li><li>GC.WaitForFullGCApproach：无限期等待 GC 通知</li><li>GC.WaitForFullGCComplete：无限期等待完全 GC 的完成</li></ul><h3 id="控制非托管内存压力"><a class="anchor" href="#控制非托管内存压力">#</a> 控制非托管内存压力</h3><p>通知 GC 某些托管对象正在持有 (或释放) 一些非托管内存：</p><ul><li>GC.AddMemoryPressure(Int64)</li><li>GC.RemoveMemoryPressure(Int64)</li></ul><h3 id="无-gc-区域"><a class="anchor" href="#无-gc-区域">#</a> 无 GC 区域</h3><p>创建运行时尝试禁止 GC 的代码区域：</p><ul><li>GC.TryStartNoGCRegion</li><li>GC.EndNoGCRegion</li></ul><h3 id="终结finalization管理"><a class="anchor" href="#终结finalization管理">#</a> 终结 (Finalization) 管理</h3><ul><li>GC.ReRegiterForFinalize</li><li>GC.SuppressFinalize</li><li>GC.WaitForPendingFinalizers</li></ul><h2 id="clr-hosting"><a class="anchor" href="#clr-hosting">#</a> CLR Hosting</h2><p>略</p><h2 id="clrmd"><a class="anchor" href="#clrmd">#</a> ClrMD</h2><p>一组用于自检托管进程和内存转储的托管 API，提供与 WinDBG 的 SOS 相似功能不过可以用 C# 更方便使用。<br />注：如 Netext 和 SOSEX 这些 WinDbg 扩展就是围绕 ClrMD 的包装器。</p><h2 id="traceevent"><a class="anchor" href="#traceevent">#</a> TraceEvent</h2><p>略</p><h2 id="自定义-gc"><a class="anchor" href="#自定义-gc">#</a> 自定义 GC</h2><p>从 .NET Core 2.1 开始，垃圾回收与执行引擎之间的耦合已经松动很多，并引入本地 GC 的概念，意味着现在 GC 是可插拔的：我们可以通过设置单个环境变量来插入自定义 GC。<br />它允许完全替换 GC 的实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;本文包含原书第七章至第十五章，也就是本书最后一部分。&lt;br /&gt;
主要为对象资源释放、线程局部存储、托管指针、ref 类型、非托管类型、非托管约束、 &lt;code&gt;S</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《.NET内存管理宝典》-笔记(5)</title>
    <link href="https://wangjiaying.top/2023/08/04/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-5/"/>
    <id>https://wangjiaying.top/2023/08/04/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-5/</id>
    <published>2023-08-04T06:31:59.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本文包含原书第七章至第十一章，主要为 .NET 垃圾回收过程的详细描述</p><h1 id="第七章-垃圾回收-简介"><a class="anchor" href="#第七章-垃圾回收-简介">#</a> 第七章 垃圾回收 - 简介</h1><h2 id="高层视图"><a class="anchor" href="#高层视图">#</a> 高层视图</h2><p>.NET GC 的两种模式：</p><ul><li>工作站模式：最大限度减少 GC 引入的延迟，GC 频率更高<ul><li>非并发：GC 时应用程序所有托管线程都挂起</li></ul></li><li>服务器模式：最大限度提高应用程序的吞吐量，GC 频率更低<ul><li>并发：GC 的某些部分在托管现在还在工作时执行</li></ul></li></ul><h2 id="gc-过程示例"><a class="anchor" href="#gc-过程示例">#</a> GC 过程示例</h2><p>垃圾回收是在特定代的上下文中发生，该代称为被判决的代。</p><ul><li>可决定同时回收比当前被判决代更小的代</li></ul><h3 id="第-0-代被判决的垃圾回收"><a class="anchor" href="#第-0-代被判决的垃圾回收">#</a> 第 0 代被判决的垃圾回收：</h3><ul><li>仅检查第 0 代中对象的可达性</li><li>第 0 代变为空 (只有意保留非常小的空间)，最小一代所有对象要么被回收，要么提升到更大的一代</li><li>第 0 代可达对象提升至第 1 代</li><li>第 1 代增长</li><li>第 2 代和 LOH 不变</li></ul><p><img data-src="/blogimages/2023/2023-08-04/139468769.jpeg" alt="139468769.jpeg" /></p><h3 id="第-1-代被判决的垃圾回收"><a class="anchor" href="#第-1-代被判决的垃圾回收">#</a> 第 1 代被判决的垃圾回收：</h3><ul><li>仅检查第 0 代和第 1 代中对象的可达性</li><li>第 0 代变为空</li><li>第 0 代的可达性对象被提升到第 1 代</li><li>第 1 代的可达性对象被提升到第 2 代</li><li>第 1 代可能会增长或缩小</li><li>第 2 代增长</li><li>LOH 不变</li></ul><p>从性能上讲，第 1 代被判决的垃圾回会有更多的对象被分析，不过在这两种情况下，GC 都在单个临时段内运行</p><h3 id="第-2-代被判决完全gc"><a class="anchor" href="#第-2-代被判决完全gc">#</a> 第 2 代被判决 (完全 GC)</h3><p>与前两种情况相比，这种完全 GC 需要分析更多对象，且标记阶段将分析整个托管堆：第 0、1、2 和 LOH ，并可能跨越多个段</p><ul><li>所有代和 LOH 的所有对象的可达性都经检查</li><li>第 0 代变为空</li><li>第 0、1 代的可达对象相应提升到第 1、2 代</li><li>第 2 代可达对象继续留在第 2 代中</li><li>LOH 在没有压缩的情况下被回收，空闲空间被 空闲列表记录以便重用</li></ul><p>最后，第 2 代在段中增长后，可能大到导致第 0、1 代没有足够空间：</p><ul><li>当前临时段被更改为只有第 2 代的段</li><li>创建一个新的临时段，将第 0 代的所有可达性对象都压缩过去 (作为第 1 代对象)<ul><li>如果有一个已存在的且具有较小第 2 代的『只有第 2 代的段』也可作为新的临时段重新使用</li></ul></li><li>LOH 照常使用清除回收处理</li></ul><p>完全垃圾回收与第 0、1 代被判决的临时垃圾回收之间的开销差异可能是几个数量级的，因此尽可能避免完全垃圾回收。</p><h2 id="gc-过程步骤"><a class="anchor" href="#gc-过程步骤">#</a> GC 过程步骤</h2><ol><li>触发垃圾回收</li><li>挂起托管线程</li><li>用户线程启动 GC 代码</li><li>选择要判决的代</li><li>标记</li><li>计划</li><li>清除或压缩</li><li>恢复托管线程</li></ol><h2 id="垃圾回收数据"><a class="anchor" href="#垃圾回收数据">#</a> 垃圾回收数据</h2><h3 id="静态数据"><a class="anchor" href="#静态数据">#</a> 静态数据</h3><p>表示 .NET 运行时初始设置的配置，以后将永远不会更改</p><ul><li>最小大小：最小分配预算</li><li>最大大小：最大分配预算</li><li>碎片限制和碎片比率限制：在决定是否应该压缩时使用</li><li>限制和最大限制：用于计算代分配预算的增长</li><li>时间限制：指定开始回收代要达到的时间</li><li>时间时钟：指定开始回收代要达到的时间，以性能计数</li><li>GC 时钟：指定开始回收代要达到的 GC 数量</li></ul><p><img data-src="/blogimages/2023/2023-08-04/-1582334348.jpeg" alt="-1582334348.jpeg" /></p><p>注：</p><ul><li>SSIZE_T_MAX：(最大地址限制) 字长的一半</li></ul><h3 id="动态数据"><a class="anchor" href="#动态数据">#</a> 动态数据</h3><p>表示托管堆当前状态，会在 GC 期间更新，计算各种决策所需的数据</p><ul><li>分配预算：GC 希望在下一次 GC 之前用于新分配的大小<ul><li>代表 GC 希望用于特定代分配的总大小</li><li>在回收该代的每个 GC 上，分配预算会动态更改，主要基于该代的存活率</li></ul></li><li>新分配：在当前分配预算下，在下一次 GC 之前剩余分配空间的大小<ul><li>对于分配器和 GC 的合作至关重要，跟踪一代中相对于分配预算进行了多少分配，如果为负数，则意味已经超出分配预算，将为该代触发垃圾回收</li></ul></li><li>碎片：该代中空闲对象消耗的总大小</li><li>存活的大小：存活对象占用的总大小</li><li>存活固定的大小：存活固定插头占用的总大小</li><li>存活率：存活字节数除以总字节数的比率</li><li>当前大小：GC 发生后所有对象的总大小 (不包括碎片部分)</li><li>GC 时钟：回收这一代 GC 的数量</li><li>时间时钟：回收这一代的上一次 GC 开始时间</li></ul><p>注：代只是被简单创建为空，跟它们默认大小无关，随着对象被分配和提升，它们大小会根据分配预算而增加。</p><h2 id="回收触发器"><a class="anchor" href="#回收触发器">#</a> 回收触发器</h2><h3 id="分配触发器"><a class="anchor" href="#分配触发器">#</a> 分配触发器</h3><p>如果无法为正在创建的对象找到合适的空间，小对象堆分配器和大对象堆分配器都可能触发垃圾回收。</p><ul><li>小对象分配 (AllocSmall)：在对象分配期间，第 0 代预算已用完 (最常见)，在第 0 代分配预算超出的情况下触发</li><li>大对象分配 (AllocLarge)：在大对象分配期间，LOH 的预算已经用完</li><li>慢速路径上的小对象分配 (OutOfSpaceSOH)</li><li>慢速路径上的大对象分配 (OutOfSpaceLOH)</li></ul><p>如果没有分配，则不会发生这种触发。</p><h3 id="显式触发器"><a class="anchor" href="#显式触发器">#</a> 显式触发器</h3><p>显示调用相关 API：</p><ul><li><code>GC.Collect()</code>  及其重载</li><li><code>GC.AddMemoryPresure</code>  (非托管内存)</li></ul><p>调用 GC.Collect 很少是合理的，显式调用会干扰内部启发式垃圾回收算法，破坏 GC 的自我调整。</p><h3 id="低内存级别系统触发器"><a class="anchor" href="#低内存级别系统触发器">#</a> 低内存级别系统触发器</h3><p>操作系统发现内存不足，.NET 接收到信号后触发</p><h3 id="各种内部触发器"><a class="anchor" href="#各种内部触发器">#</a> 各种内部触发器</h3><ul><li>AppDomain 卸载</li><li>清理表示为死线程的线程对象 (每个线程由一个托管对象表示)</li><li>在启动 NoGC 区域之前 (15 章)</li></ul><h2 id="ee-挂起"><a class="anchor" href="#ee-挂起">#</a> EE 挂起</h2><p>挂起用户代码的所有线程的过程称为『EE 挂起』</p><ul><li>即执行引擎挂起，意为挂起托管线程</li><li>从应用程序角度看，整个世界都是在垃圾回收时暂停的</li></ul><p>安全点是一个可以检查寄存器和堆栈位置的实时引用的代码位置，安全点的实现并非易事，挂起也必须是非常高效的。</p><ul><li>如果一个线程被挂起在安全点之外 (这很可能)，那么当前堆栈帧的返回地址将被操作到一个特殊的存根，这个根将把它『停』在一个安全点上。</li></ul><p>注：非托管线程不会挂起和重启，若创建一个后台本机线程执行，则它将独立于 EE 挂起运行 (当然 P/Invoke 机制肯定会从非托管代码返回托管代码时阻塞)</p><h1 id="第八章-垃圾回收-标记阶段"><a class="anchor" href="#第八章-垃圾回收-标记阶段">#</a> 第八章 垃圾回收 - 标记阶段</h1><p>在非并发 GC 的情况下，一开始所有线程均会挂起，托管堆以此确保自己不会发生任何变化，保持 GC 的独占性，以安全地浏览堆，从中搜寻出所有可达对象。</p><h2 id="对象的遍历与标记"><a class="anchor" href="#对象的遍历与标记">#</a> 对象的遍历与标记</h2><p>对于一个特定的根地址，遍历程序将执行以下步骤：</p><ol><li>将其转换为一个托管对象的确切地址：如果根地址是个内部指针 (表示它并不指向托管对象的开头，而是指向对象内部的某个位置)，则需要进行此转换</li><li>设置固定标记：如果一个对象被固定，则在对象头中设置一个合适的位</li><li>开始遍历对象的引用：由于有存储于 MethodTable 中的类型信息，GC 可以知道哪些偏移位置 (字段) 代表传出的引用<ul><li>GC 以深度优先方式访问所有这些引用并维护到一个集合，称为标记堆栈<ul><li>已访问对象将被跳过</li><li>尚未访问对象将被标记：通过在 MethodTable 指针中设置一个位来完成 (此操作不会破坏 MT 指针，其至少有两个未被使用的最低位)</li><li>添加传出引用到标记堆栈集合中</li></ul></li><li>当标记堆栈中不再有尚未访问的对象时，遍历操作即完成</li><li>注：使用自己实现的标记堆栈而不是递归，是为了避免堆栈溢出</li></ul></li></ol><p>GC 根是 .NET 内存管理中最有用的部分，根包含可达对象的整个图并可能导致：</p><ul><li>占用大量内存</li><li>内存泄露</li></ul><p>标记机制始于各种不同类型的根并随之逐渐构建出包含所有可达对象的完整对象图。<br />注：暂存字符串和静态引用数据采用了和其它对象完全一致的标记机制。</p><h2 id="局部变量根"><a class="anchor" href="#局部变量根">#</a> 局部变量根</h2><ul><li>局部变量存储：可以存储在堆栈或 CPU 寄存器中</li><li>堆栈根：既可能位于堆栈中，也可能位于 CPU 寄存器中</li><li>词法作用域：定义了变量可见代码区域</li><li>存活堆栈根与词法作用域：在 Debug 编译模式下，JIT 编译器将所有局部变量的可达性延长至方法结束 (Release 将进行更多优化)</li><li>带有渐进式根回收的存活堆栈根：Release 模式下 JIT 将使用激进式根回收，不需要通过将局部变量设置为 null 来『通知』GC 对象不再使用，通过激进式根回收，编译器和 JIT 可以完美确定变量的实际使用范围。(编译器会优化掉冗余的 null 赋值语句)<ul><li>由于编译器会尽量最短化局部变量的生存周期，可能会进行方法『其中一部分 (调用了实例本身的语句)』的代码内联化 (不至于影响代码逻辑的情况)，以使对象可以更早被回收</li><li>GC.KeepAlive：不包含任何代码，而是使用 MethodImplOptions.NoInLining 选项为方法添加一个特性，使对象不被内联，传入参数将被视为可达</li></ul></li></ul><h3 id="gc-信息"><a class="anchor" href="#gc-信息">#</a> GC 信息</h3><p>GC 信息实际上是非常紧密的二进制数据，当前唯一可以查看 GC 信息的工具是带有 SOS 扩展的 WinDbg</p><h3 id="固定局部变量"><a class="anchor" href="#固定局部变量">#</a> 固定局部变量</h3><p>固定局部变量是一种特殊类型的局部变量，在 C# 中使用 fixed 关键字可以显式创建</p><ul><li>JIT 编译器会针对固定局部变量生成适当的 GC 信息，有关根本身的信息也被保持为固定状态。</li><li>这种被固定的根只在很短时间内可见 (仅在包含它的方法执行期间)</li></ul><h3 id="堆栈根扫描"><a class="anchor" href="#堆栈根扫描">#</a> 堆栈根扫描</h3><p>当所有线程在安全点挂起时，可以从 GC 信息中解码出存在哪些存活插槽，每个这样的插槽 (无论位于堆栈或寄存器中) 都被视为根并从它们开始执行标记遍历操作。</p><h2 id="终结根"><a class="anchor" href="#终结根">#</a> 终结根</h2><p>终结器对象第一次被回收时，放入终结器队列，会成为终结器根？</p><h2 id="gc-内部根"><a class="anchor" href="#gc-内部根">#</a> GC 内部根</h2><p>例如卡根扫描</p><h2 id="gc-句柄根"><a class="anchor" href="#gc-句柄根">#</a> GC 句柄根</h2><p>句柄有各种不同类型，全都存储在一个全局句柄表映射中。扫描句柄表后，扫描到的一组句柄类型与它们指向的目标都将被视为根。</p><ul><li>强句柄 (GCHandle.Alloc)：类似普通引用</li><li>固定句柄：强句柄的子类别</li></ul><h2 id="处理内存泄露"><a class="anchor" href="#处理内存泄露">#</a> 处理内存泄露</h2><p>持续增长的内存使用率和内存泄露一定不会是因为垃圾回收器无法正常识别对象是否处于可达状态</p><ul><li>而很可能是因为有些对象持续持有对其它对象的引用</li><li>因此关键在于找出哪些根在持续持有应当回收但始终存活的对象</li></ul><h1 id="第九章-垃圾回收-计划阶段"><a class="anchor" href="#第九章-垃圾回收-计划阶段">#</a> 第九章 垃圾回收 - 计划阶段</h1><p>标记阶段之后，所有对象都被标记为可达或不可达，那些可达对象将用一个专用位进行标记，某些被标记对象可能还要用额外一个位标记为固定的。此时，垃圾回收器已经有了启动其工作所需的所有信息。<br />计划阶段计算与压缩过程结果直接对应的所有信息，这些信息『在侧面』准备，并没有实际去移动对象。并让随后的清理和压缩阶段使用。</p><ul><li>如进行『虚假的压缩』得到结果并评估是否值得压缩</li></ul><p>注：源码中方法为 plan_phase (int)，该阶段准备了所有必要数据，后续阶段只是以适当方式使用这些数据。</p><h2 id="小对象堆"><a class="anchor" href="#小对象堆">#</a> 小对象堆</h2><h3 id="插头和间隙"><a class="anchor" href="#插头和间隙">#</a> 插头和间隙</h3><p>通过将对象组织成 slot 和 gap，可以非常高效获得如下一整套信息：</p><ul><li>压缩效率</li><li>如果是清除回收，应在哪里创建空闲列表</li><li>如果是压缩回收，将把可达对象移到哪里</li></ul><p>不过，这些数据存储在哪里？</p><ul><li>.NET 重用了托管对象标头位置</li></ul><p>如果我们适当地建立 slot 和 gap，那么每个 slot 在其之前都会具有其对应的 gap，而 gap 的内容可以安全覆盖：它只包含将不再使用的不可达对象。</p><ul><li>这样的 slot 信息精确占用 24 字节 (32 位 12 字节)</li><li>它包含相应的间隙大小、slot 重定位偏移量及一些附加数据</li></ul><p><img data-src="/blogimages/2023/2023-08-04/-697247850.jpeg" alt="-697247850.jpeg" /></p><p>最后可以构建一个包含所有插头地址的二叉插头树 (组织成二叉搜索树 - BST)</p><h3 id="砖表"><a class="anchor" href="#砖表">#</a> 砖表</h3><p>插头树的根需要存储在某个地方，但为整个托管堆创建一个巨大的插头树不切实际。</p><ul><li>一种更实际的方法是为连续地址范围构建插头树</li><li>这样的范围在 CLR 中称为砖，砖大小为 2048B (32 位) 和 4096B (64 位)</li><li>砖存储在覆盖整个托管堆的砖表中</li></ul><p>通过将砖表条目与与每个插头头的左 / 右偏移量组合，可以高效地表示插头树。</p><h3 id="固定"><a class="anchor" href="#固定">#</a> 固定</h3><p>如果一个对象被固定，则很可能是因为我们想把它的地址传递给非托管代码。<br />有两种固定源：</p><ul><li>固定局部变量：fixed 关键字隐式创建的局部变量对象</li><li>固定句柄：通过固定句柄引用显式固定的对象 (GCHandle.Allocate)</li></ul><p>因为要固定，所以实际上可能有三种对象组：</p><ul><li>插头：表示一组已标记 (可达) 的对象</li><li>固定插头：表示一组被固定 (并因此标记) 的对象</li><li>间隙：表示一组未标记 (不可达) 对象</li></ul><h3 id="代边界"><a class="anchor" href="#代边界">#</a> 代边界</h3><p>在清除或压缩后，代边界将相应地更改。<br />在计划阶段，内部分配器计算插头的新地址，也计算新的代边界。</p><ul><li>所有这些操作都是在实际上没有移动任何对象的情况下完成的。</li></ul><h3 id="降级"><a class="anchor" href="#降级">#</a> 降级</h3><p>固定对象可能会提升和降级。</p><h2 id="大对象堆"><a class="anchor" href="#大对象堆">#</a> 大对象堆</h2><p>事实上，LOH 中的计划阶段几乎不需要，因为它基本只是清除 (除非我们明确要求进行压缩)</p><ul><li>仅在启用压缩时才需要大对象堆的压缩阶段</li><li>LOH 是特殊的，因为它确保只有大对象活在其中，因此有一些简化<ul><li>在每个插头前存储的信息仅包含插头的重定位偏移量</li><li>由于大对象堆内部也没有代，因此也无需重新计算代边界，也没有降级的可能性</li></ul></li></ul><p>与 SOH 相比，LOH 中的固定并没有区别，因此一样会引入可能碎片化的问题。</p><h2 id="压缩决策"><a class="anchor" href="#压缩决策">#</a> 压缩决策</h2><p>在计划阶段执行了复杂的计算后，GC 会决定是否值得压缩。大多数情况下，该决策基于碎片化级别。<br />决定压缩的原因：</p><ul><li>这是抛出 OutOfMemoryException 之前最后一个完全 GC，GC 尽可能尝试回收内存</li><li>显式指定压缩 (GC.Collect 参数)</li><li>用完了临时段中的空间</li><li>代的碎片化程度较高</li><li>系统中物理内存负载较高</li></ul><p>如上所述，决策中，代的碎片化阈值起到作用最重：</p><p><img data-src="/blogimages/2023/2023-08-04/-1519001997.jpeg" alt="-1519001997.jpeg" /></p><h1 id="第十章-清除和压缩"><a class="anchor" href="#第十章-清除和压缩">#</a> 第十章 清除和压缩</h1><p>尽管大部分计算已在之前完成，但从性能开销角度看，清除和压缩仍然是性能消耗最大的一个阶段，因为修改和移动内存中数据是最耗时的操作。<br />最典型的 GC 组合是：</p><ul><li>执行 SOH 的压缩和 LOH 的清除，并在 SOH 压缩之前完成 LOH 的清除</li></ul><h2 id="清除阶段"><a class="anchor" href="#清除阶段">#</a> 清除阶段</h2><p>清除回收很简单：所有不可达对象都被转换成空闲内存空间，即 GC 把所有或某些内存间隙转换成空闲列表项。</p><h3 id="小对象堆-2"><a class="anchor" href="#小对象堆-2">#</a> 小对象堆</h3><ul><li>基于内存中的间隙创建空闲列表项<ul><li>将每个尺寸大于两个最小对象的间隙创建一个空闲列表项并组织进一个空闲列表</li><li>尺寸更小的间隙将被视为未使用空闲空间</li></ul></li><li>恢复已保存的前置和后置插头</li><li>完成其它统计工作以更新终结器队列并提升 (或降级) 适当类型的存活句柄</li><li>相应地重排段，如移除掉一些不再需要的段</li></ul><h3 id="大对象堆-2"><a class="anchor" href="#大对象堆-2">#</a> 大对象堆</h3><p>清除操作将逐个扫描对象，并简单地在被标记对象之间创建空闲列表项，所有不再需要的 LOH 段将被删除 (或启用段重用后进行缓存)</p><h2 id="压缩阶段"><a class="anchor" href="#压缩阶段">#</a> 压缩阶段</h2><p>包含两个主要子步骤：移动 (或复制) 对象并将所有指向被移动对象的引用更新到对象所在的新位置。<br />注：压缩阶段比清除阶段复杂得多，可能导致大量内存操作</p><h3 id="小对象堆-3"><a class="anchor" href="#小对象堆-3">#</a> 小对象堆</h3><ol><li>如果需要，则获取一个新的临时段</li><li>重定位引用<ul><li>堆栈上的引用</li><li>存储在跨代记忆集中的对象内的引用</li><li>SOH 和 LOH 中对象内的引用<ul><li>SOH：重定位操作大量使用砖和插头树，以快速将当前地址转换为新地址</li><li>LOH：逐个扫描存活下来的 LOH 对象</li></ul></li><li>前置和后置插头内的引用<ul><li>某些对象的结尾可能被插头信息覆盖而损坏，其原始内存内容存储在固定插头队列的条目中</li></ul></li><li>终结器队列中对象内的引用</li><li>句柄表中的引用：句柄需要更新其指针</li></ul></li><li>压缩对象<ul><li>复制对象：使用计算出的重定位偏移量逐个 slot 完成复制<ul><li>采用滑动压缩，总是首先复制低位内存空间，只要复制的单位足够小，就不会产生覆盖问题</li></ul></li><li>恢复前置和后置插头信息：从存储于固定插头队列条目内的副本中恢复对象的损坏部分</li></ul></li><li>修复代边界</li><li>若需要，删除或反提交段</li><li>创建空闲列表项</li><li>提升根</li></ol><h3 id="大对象堆-3"><a class="anchor" href="#大对象堆-3">#</a> 大对象堆</h3><p>压缩大对象堆与小对象堆类似，不过实现更简单</p><h1 id="第十一章-gc-风格"><a class="anchor" href="#第十一章-gc-风格">#</a> 第十一章 GC 风格</h1><h2 id="模式概述"><a class="anchor" href="#模式概述">#</a> 模式概述</h2><h3 id="工作站与服务器模式"><a class="anchor" href="#工作站与服务器模式">#</a> 工作站与服务器模式</h3><p>工作站模式</p><ul><li>GC 将会更频繁发生</li><li>作为上一点副作用：内存使用率将更低</li><li>只有一个托管堆</li><li>段更小</li></ul><p>服务器模式</p><ul><li>GC 的发生频率将更低</li><li>作为上一点副作用：内存使用率见更高</li><li>有多个托管堆</li><li>默认段大小更大</li><li>因此，服务器模式将消耗更多内存，但带来更小的 Time in GC 值</li></ul><h3 id="并发模式与非并非模式"><a class="anchor" href="#并发模式与非并非模式">#</a> 并发模式与非并非模式</h3><p>这两种模式在工作站与服务器模式下都支持。<br />非并发模式</p><ul><li>在 GC 期间，所有托管用户线程都将被挂起。执行完毕后恢复。</li></ul><p>并发模式</p><ul><li>并发 GC 在普通用户线程工作时运行，用户线程和回收器在工作期间必须进行额外同步。</li></ul><h2 id="模式配置"><a class="anchor" href="#模式配置">#</a> 模式配置</h2><h3 id="net-framework"><a class="anchor" href="#net-framework">#</a> .NET Framework</h3><ul><li><span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> WEB 应用程序：web.config</li><li>控制台应用程序或 Windows 服务：[应用程序名].exe.config</li></ul><h3 id="net-core"><a class="anchor" href="#net-core">#</a> .NET Core</h3><p>文件配置方式与 .NET Framework 相似<br />并引入了 配置旋钮 概念，可通过多种方式提供值。</p><h2 id="gc-停顿和开销"><a class="anchor" href="#gc-停顿和开销">#</a> GC 停顿和开销</h2><h2 id="模式模式"><a class="anchor" href="#模式模式">#</a> 模式模式</h2><h3 id="非并发工作站模式"><a class="anchor" href="#非并发工作站模式">#</a> 非并发工作站模式</h3><p>即典型的 GC</p><ul><li>整个 GC 期间，所有托管线程都将挂起</li><li>GC 代码在触发回收的用户线程上执行 (从分配器内部)</li><li>GC 总是在『停止世界』阶段执行</li></ul><h3 id="并发工作站模式40版本之前"><a class="anchor" href="#并发工作站模式40版本之前">#</a> 并发工作站模式 (4.0 版本之前)</h3><ul><li>有一个专用于 GC 目的的额外线程 (多数时间挂起等待)</li><li>临时回收总是非并发</li><li>完全 GC 可以两种模式执行<ul><li>并发 GC</li><li>非并发 GC</li></ul></li><li>并发完全 GC 附加特性：<ul><li>用户托管线程可能在其工作期间分配对象，此类分配仅限于临时段大小 (如果用完了将挂起，直到 GC 结束)</li><li>包含两个短的『停止世界』阶段 (开始和中间)</li><li>从 GC 开始到第二个『停止世界』阶段之前分配的对象将被提升</li><li>在第二个『停止世界』阶段之后分配的所有事物都将被提升</li></ul></li></ul><h3 id="后台工作站模式"><a class="anchor" href="#后台工作站模式">#</a> 后台工作站模式</h3><p>.NET Framework4.0 后取代并发工作站模式<br />主要改进在于：即使在并发 GC 期间，如果需要也可以触发临时 GC</p><h4 id="并发标记"><a class="anchor" href="#并发标记">#</a> 并发标记</h4><p>标记一个对象意味着在 MethodTable 中设置一个位，完成后恢复。<br />但并发工作时意味着线程可能正在使用它，因此不能这样干。</p><ul><li>并发标记会将有关标记的信息存储在一个专用的单独的标记数组中，组织结构类似于卡表</li></ul><h3 id="非并发服务器模式"><a class="anchor" href="#非并发服务器模式">#</a> 非并发服务器模式</h3><p>默认情况下，托管堆的数量与 CPU 逻辑内核一样多</p><ul><li>有专用于 GC 的线程，默认与托管堆数量相同</li><li>所有回收都是非并发 GC</li><li>标记是从多个 GC 线程并行完成</li></ul><h3 id="后台服务器模式"><a class="anchor" href="#后台服务器模式">#</a> 后台服务器模式</h3><p>最复杂的 GC，也是最消耗资源的 GC</p><ul><li>每个托管堆都有两个专用于 GC 目的的线程<ul><li>服务器 GC 线程</li><li>后台 GC 线程</li></ul></li><li>临时回收是非并发 GC</li><li>完全 GC 可能以一以下两种模式执行：<ul><li>非并发 GC</li><li>后台 GC</li></ul></li><li>后台完全 GC 还有以下额外特征：<ul><li>用户托管线程能够在其工作期间分配对象，这些分配可以触发临时回收 (前台 GC)</li><li>在后台 GC 期间，前台 GC 可能会多次发生</li><li>包含两个短暂的『停止世界』阶段 (GC 开始和中间)</li></ul></li></ul><h2 id="延迟模式"><a class="anchor" href="#延迟模式">#</a> 延迟模式</h2><ul><li>批处理模式</li><li>交互式模式</li><li>持续低延迟模式</li><li>无 GC 区域模式</li><li>延迟优化目标</li></ul><h2 id="选择-gc-风格"><a class="anchor" href="#选择-gc-风格">#</a> 选择 GC 风格</h2><p><img data-src="/blogimages/2023/2023-08-04/-1641765449.jpeg" alt="-1641765449.jpeg" /></p><p>注：并发 (后台) 版本 GC 的托管堆会更大，频繁的非压缩后台 GC 会导致更严重的碎片化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;本文包含原书第七章至第十一章，主要为 .NET 垃圾回收过程的详细描述&lt;/p&gt;
&lt;h1 id=&quot;第七章-垃圾回收-简介&quot;&gt;&lt;a class=&quot;anchor&quot; hre</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《.NET内存管理宝典》-笔记(4)</title>
    <link href="https://wangjiaying.top/2023/07/19/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-4/"/>
    <id>https://wangjiaying.top/2023/07/19/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-4/</id>
    <published>2023-07-19T03:16:33.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本篇包含原书第五章和第六章，主要讲了 .NET 内存分区和内存分配方式</p><ul><li>小对象通过指针快速分配 (多数情况下)</li><li>大对象通过空闲列表分配 (因此最好避免)</li></ul><p>并提出了一些优化方式：避免分配，包括显式和隐式分配等</p><h1 id="第五章-内存分区"><a class="anchor" href="#第五章-内存分区">#</a> 第五章 内存分区</h1><h2 id="分区策略"><a class="anchor" href="#分区策略">#</a> 分区策略</h2><p>总体上有：</p><ul><li>大小</li><li>生存期</li><li>可变性</li><li>类型</li><li>种类</li></ul><p>简单来说，.NET 根据『大小』和『生存期』作为分区策略。</p><h2 id="按大小分区"><a class="anchor" href="#按大小分区">#</a> 按大小分区</h2><p>.NET 根据大小处理不同对象，分为两类：</p><ul><li>小对象堆 (SOH)：所有小于 85000 字节的对象在此分区创建</li><li>大对象堆 (LOH)：所有大于或等于 85000 字节的对象在此创建</li></ul><p>区别在于，默认情况下小对象堆在 GC 回收后会进行压缩，而大对象堆默认不会。<br />对齐方式</p><ul><li>32 位：SOH 4 字节对齐，LOH 8 字节对齐</li><li>64 位：SOH 和 LOH 均 8 字节对齐</li></ul><p>注 1：Mono 5.4 单个对象大小阈值为 8000 字节<br />注 2：具传言所说，85000 字节是微软内部测试实验而选出，但并未经证实。<br />注 3：计算的是对象引用的浅表大小 (即实际大小)，而非引用对象的大小。对大数组作为字段时，只是对其一个小引用。</p><h3 id="小对象堆"><a class="anchor" href="#小对象堆">#</a> 小对象堆</h3><p>使用频率最高的内存区域，通常其中分配对象会在数量级上超过位于 LOH 的对象数量。<br />因此将其划分为更小的分离部分，即常规意义上说的分代：0、1、2 代</p><h3 id="大对象堆"><a class="anchor" href="#大对象堆">#</a> 大对象堆</h3><p>有时候被称为第三代，或者是被第三个索引引用 (位于 0、1、2 这三代之后)</p><ul><li>不过从回收器角度看，LOH 中的大对象在逻辑上属于第二代，因为它们仅在第二代被回收时才被回收。</li></ul><p>处于其中的常见对象：</p><ul><li>double 数组：等于或大于 1000 个元素时就会在 LOH 中进行分配 (例外)——[注意是 32 位运行环境]<ul><li>原因与内存对齐方式有关，double 占 8 个字节，而 32 位环境下，大对象堆 8 字节对齐，访问消耗更低</li><li>1000 个阈值是为了避免内存碎片</li></ul></li><li>内部 CLR 数据：LargeHeapHandleTable，该结构管理在大对象堆中分配用于内部用途的对象数组。<ul><li>每个域的静态成员，至少包含一个 bucket</li><li>全局字符串文字映射 (StringIntern)-GlobalStringLiteralMap</li></ul></li></ul><p><img data-src="/blogimages/2023/2023-07-19/-523718562.jpeg" alt="-523718562.jpeg" /></p><p>注：大对象堆默认不压缩，注意会产生内存碎片</p><h2 id="按生存期分区"><a class="anchor" href="#按生存期分区">#</a> 按生存期分区</h2><p>如前所述，小对象堆可能存在大量对象，因此在决定再根据生存期分成若干部分，即『分代垃圾回收 (Generational Garbage Collection』<br />做法有两种：</p><ul><li>提升复制，为名为 0、1、2 的代提供三个单独的内存区域，回收年轻代对象时，存活对象被复制到老一代内存区域（会有复制开销）</li><li>按地址边界在逻辑上定义代，即在单个连续内存区域内通过逻辑边界来形成代，避免复制开销（.NET 采用的方式）</li></ul><p><img data-src="/blogimages/2023/2023-07-19/-1903600403.jpeg" alt="-1903600403.jpeg" /></p><h3 id="记忆集remembered-sets"><a class="anchor" href="#记忆集remembered-sets">#</a> 记忆集 (remembered sets)</h3><p>标记阶段使用可达性分析进行。<br />如何做到只回收『年轻』一代的？</p><ul><li>从根开始遍历，忽略此代之外的引用</li></ul><p>同时存在跨代引用问题需要处理：</p><ul><li>从年轻到老：最近创建对象可能引用已存在老对象</li><li>从老到年轻：老对象可能直接设置包含新创建对象的引用</li></ul><p><img data-src="/blogimages/2023/2023-07-19/-1012548466.jpeg" alt="-1012548466.jpeg" /></p><p>记忆集是一组记忆从老一代到年轻一代的引用、用于跨代回收的集。然后在标记阶段对它们进行简单的审查。</p><ul><li>在创建此类引用时记住它，主要发生于字段分配期间</li><li>在 Mutator.write 操作插入这个指令会带来很大开销，不过 JIT 编译器可以从 IL 代码了解信息 (是否将托管对象的引用存储到另一个托管对象的字段中)，并在生成汇编代码时可选是否生成对应代码 (.NET 运行时采用的方式)</li></ul><p>如果年轻代引用老年代，也需要如此实现记忆集，这并不容易。因此 .NET 采用了更简单的决定：回收某一代同时也意味着回收比它更年轻代的对象。</p><ul><li>仅回收第 0 代</li><li>回收第 0 代和第 1 代</li><li>回收所有第 0 代、第 1 代和第 2 代以及大对象堆 (完全垃圾回收)</li></ul><h3 id="卡表card-tables"><a class="anchor" href="#卡表card-tables">#</a> 卡表 (Card Tables)</h3><p>.NET 有三代，因此可能的跨代引用数量可能很大。将一个记忆集作为每个跨代引用的幼稚回收管理会带来过大开销。<br />卡表即是对记忆集的优化：</p><ul><li>将老一代拆分成恒定大小区域 (具有给定字节数的连续内存区域)</li><li>当某个地方将对象 C 分配给对象 E 字段时，计算 E 的卡，并将卡标记为 dirty，此后该卡中所有对象都被视为附加的根</li></ul><p><img data-src="/blogimages/2023/2023-07-19/672960811.jpeg" alt="672960811.jpeg" /></p><p>这显然也会有开销：即使只有一个从老一代对象到年轻一代的引用，也必须访问卡中所有对象并遵循它们的引用。不过，这也是性能和准确性之间的权衡。<br />注意：</p><ul><li>如果一张卡片很小，小到做多只能包含一个对象，那么我们最终会得到一个典型记忆集方法。</li><li>如果一张卡片很大以至于覆盖了整整一代，那么最终会变成遍历整个对象图的方法。</li></ul><p>在 .NET 运行时 (64 位) 中，一张卡对应于 256 个字节，每个这样的卡都由一个位标志表示。</p><ul><li>1 字节能表示 8 倍 256 字节，即 2048 字节的存储区域。</li><li>卡片被分为 32 个元素，称为卡片字，意味着卡片字是 4 字节宽的 DWORD 类型 (ulong)。单个卡片字表示 8192 字节。</li></ul><h3 id="卡包card-bundles"><a class="anchor" href="#卡包card-bundles">#</a> 卡包 (Card Bundles)</h3><p>卡表优化了记忆集的使用，但是扫描依然会带来较大开销，此外卡表可能比较稀疏。<br />因此增加了另一个级别的观察：</p><ul><li>一个卡字将多个卡组合在一起，而一个卡包字将多个卡字组合在一起</li><li>卡包字设计密度更高，可覆盖更大内存区域</li><li>首先扫描卡包以查找 dirty 的大区域，再对其中卡表进行更精确扫描。</li></ul><h2 id="按物理分区"><a class="anchor" href="#按物理分区">#</a> 按物理分区</h2><p>从物理上讲，托管堆由一组堆段组成：一个段要么属于 SOH 要么 属于 LOH</p><ul><li>注：对于 SOH，如果存在多个段，那么只有一个称为『临时段』的包含第 0 代和第 1 代，其它段都是第 2 代的段。</li></ul><p>堆段从低地址到高地址使用</p><ul><li>.NET 运行时尝试为初始段分配 (保留) 单个连续内存块</li><li>为 SOH 和 LOH 创建两个单独的段</li><li>第 0、1、2 代通过提交一些指定数量内存在 SOH 段内创建，LOH 也提交一定数量内存</li></ul><p><img data-src="/blogimages/2023/2023-07-19/270983224.jpeg" alt="270983224.jpeg" /></p><h3 id="段和堆解析"><a class="anchor" href="#段和堆解析">#</a> 段和堆解析</h3><p>段是托管堆的物理表示，每个 SOH 和 LOH 都具有以下结构：</p><ul><li>在开始处存储段信息 (heap_segment  类的一个实例)</li><li>对象从名为 mem 的地址分配</li><li>当前已分配对象结束的地址被命名为 allocated</li></ul><p><img data-src="/blogimages/2023/2023-07-19/335804534.jpeg" alt="335804534.jpeg" /></p><h3 id="段重用"><a class="anchor" href="#段重用">#</a> 段重用</h3><p>连续创建和删除段可能导致碎片问题，特别是 32 位虚拟地址空间有限的情况。<br />因此引入更智能的段处理：虚拟机囤积 (VM Hoarding)</p><ul><li>与其完全释放空段，不如将其存储 (囤积) 以供以后使用</li></ul><p>即：</p><ul><li>整个段内存将保持保留</li><li>该段大部分内存被取消提交 (不消耗物理内存)，只有少量信息 (如段信息) 保持提交状态</li><li>在一个可重用列表记录，当需要新段时，首先检查</li></ul><p>注 1：在 64 位执行引擎中，由于虚拟地址空间大很多，囤积相对就没那么重要了。不过，由于在非常动态场景中，有许多段被创建和销毁时，重用速度更快，因此在 64 位下段重用也是值得的。<br />注 2：默认情况下 .NET 会禁用段囤积功能 (System.GC.RetainVM)</p><h1 id="第六章-内存分配"><a class="anchor" href="#第六章-内存分配">#</a> 第六章 内存分配</h1><p>分配器 (allocator) 概念：负责提供指定大小内存，在此抽象层次上，分配器并不关心内存中需要存储的是哪种类型对象，只需提供正确数量字节空间即可。<br />.NET 托管环境会预先分配连续内存块，比每次创建对象都向操作系统请求更快，且可以简化内存分配机制。<br />对象分配发生于：</p><ul><li>对于 SOH：分配发生于 0 代，位于一个暂留段。</li><li>对于 LOH：分配发生在多个 LOH 段中的一个。</li></ul><blockquote><p>每次分配一个大对象时会考虑整个 LOH，而分配小对象仅考虑暂留段。</p></blockquote><p>有两种实现分配器方法：</p><ul><li>循序分配和自由列表</li><li>.NET 同时使用了两者</li></ul><h2 id="bump-pointer-分配"><a class="anchor" href="#bump-pointer-分配">#</a> Bump Pointer 分配</h2><p>即采用循序分配的一种模式，分配指针指向已分配对象末尾，提前清零区域 (allocation context) 前端，分配内存时，仅需要往提前清零区域移动指定字节即可。</p><ul><li>注：allocation context 是每个线程独占的</li></ul><p><img data-src="/blogimages/2023/2023-07-19/662564621.jpeg" alt="662564621.jpeg" /></p><h2 id="空闲列表分配"><a class="anchor" href="#空闲列表分配">#</a> 空闲列表分配</h2><p>当运行时要求 GC 分配给定大小内存时，其在一个空闲列表中搜索，以找到一块足够大的空闲空隙。</p><ul><li>最佳匹配：找到最匹配所需空间内存</li><li>最先匹配：找到第一块能满足需求的空闲内存</li></ul><h2 id="创建新对象"><a class="anchor" href="#创建新对象">#</a> 创建新对象</h2><p>CIL 代码：newobj</p><ul><li>如果对象超出大尺寸阈值 (在 LOH 中创建)，或者其有终结器则使用通用且稍慢的 JIT_New 函数</li><li>否则使用较快的辅助函数</li></ul><p>例外的是创建数组：newarr，用于创建数组对象的优化版本</p><h3 id="小对象堆分配"><a class="anchor" href="#小对象堆分配">#</a> 小对象堆分配</h3><p>基本通过 bump pointer 分配到到 allocation context 中。</p><ul><li>注：若 allocation context 无法满足所需大小，或对象带终结器，则将回退到调用更通用的 JIT_NEW 函数，此函数包含完成分配的慢速分支代码。</li></ul><p>慢速分支逻辑：</p><ul><li>首先尝试使用暂留段中已有的未使用空间<ul><li>尝试使用空闲列表找到一块合适的内存空隙，用其创建一个新的 allocation context</li><li>尝试调整 commited 内存中的分配限制位</li><li>尝试从 reserved 内存中提交更多内存，并调整位于其内部的分配限制位</li></ul></li><li>若上述操作皆失败，则触发垃圾回 (收回收根据具体情况执行多次)</li><li>若上述依然失败，则触发 OutOfMemoryException</li></ul><h3 id="大对象堆分配"><a class="anchor" href="#大对象堆分配">#</a> 大对象堆分配</h3><p>主要使用空闲列表分配机制，并在段空间末尾使用一种简化的 bump pointer 技术 (不使用 allocation context)<br /> LOH 分配器总是采取与 SOH 慢速分支类似的方法。</p><ul><li>首先尝试使用未使用的现有空间<ul><li>尝试使用空闲列表为对象寻找一个合适的内存空隙</li></ul></li><li>在每个包含 LOH 段中：<ul><li>尝试调整 commited 内存中的分配限制位</li><li>尝试从 reserved 内存中提交更多内存，并调整位于其内部的分配限制位</li></ul></li><li>若上述操作皆失败，则触发垃圾回收 (回收根据具体情况执行多次)</li><li>若上述依然失败，则触发 OutOfMemoryException</li></ul><p>同时，由于 LOH 没有 allocation context 机制，因此分配完成后还需对对象内存清零，而大对象内存清零本来也是一段耗时过程。<br />因此 LOH 分配开销远大于 SOH 分配。</p><h2 id="堆再平衡"><a class="anchor" href="#堆再平衡">#</a> 堆再平衡</h2><p>略</p><h2 id="outofmemoryexception-异常"><a class="anchor" href="#outofmemoryexception-异常">#</a> OutOfMemoryException 异常</h2><p>已经触发垃圾回收器</p><ul><li>此时再触发垃圾回收没什么用，倒是可以考虑显示触发 LOH 压缩后再触发一次 GC</li></ul><p>分配器无法准备所需大小的内存区域</p><ul><li>虚拟内存已耗尽 (32 位)，主要由于内存碎片导致</li><li>物理后备存储 (包括物理内存和交换内存) 已耗尽</li></ul><p>改进：</p><ul><li>少分配一些对象</li><li>使用对象池</li><li>使用 VM Hoarding</li><li>编译为 64 位程序</li></ul><h2 id="堆栈分配"><a class="anchor" href="#堆栈分配">#</a> 堆栈分配</h2><p>堆栈分配只需要移动 stack 指针，不会造成任何 GC 开销。<br />在满足条件的情况下，值类型将在堆栈上分配。<br />除此之外，也可以通过 stackalloc 显示在堆栈分配内存。其返回一个指针，可使用指针或 span&lt;&gt; 操作，其有两个好处：</p><ul><li>销毁以这种方式创建的对象与销毁堆栈上其它对象的速度一样快，无需使用堆分配器，不会进入分配决策树的慢速分支，也完全不需要 GC</li><li>由于 stack frames 不会在内存中移动，因此此类对象的地址也被隐式固定，可以安全将指针传递给非托管代码。</li></ul><p>stackalloc 被转换为 CIL 指令 localloc<br /> 注：stackalloc 仅能用于分配一个 unmanaged_type 元素类型的数组。</p><ul><li>基元类型</li><li>枚举类型</li><li>指针类型</li><li>所有非构造类型且仅包含 unmanaged_type 字段的用户自定义结构</li></ul><p>无法显示释放 stackalloc 分配的内存，方法结束时将隐式释放。</p><h2 id="避免分配"><a class="anchor" href="#避免分配">#</a> 避免分配</h2><h3 id="显式的引用类型分配"><a class="anchor" href="#显式的引用类型分配">#</a> 显式的引用类型分配</h3><p>可以认真评估，在特定情况下，是否真的有必要在堆上创建引用类型对象？</p><ol><li>通用场景 - 考虑使用结构<ul><li>例如数据不存储任何基于堆的数据内部</li></ul></li><li>元组 - 使用 ValueTuple 代替<ul><li>注 1：Tulpe 和匿名类型都是引用类型</li><li>注 2：值元组有种称为解构 (deconstruction) 的特性，允许直接将方法返回元组赋值给元组，还可以使用弃元 (discarding) 显示忽略不感兴趣的元素</li></ul></li><li>小型临时局部数据 - 考虑使用 stackalloc<ul><li>结构数组依然会分配在堆上，可以使用 stackalloc 使其分配于堆栈</li><li>stackalloc 缺点在于可能引发堆栈溢出异常</li><li>如果想使用并希望百分百不会引发堆栈溢出异常，可尝试使用 RuntimeHelpers.TryEnsureSufficientExecutionStack () 或 RuntimeHelpers.EnsureSufficientExecutionStack () 方法</li></ul></li><li>创建数组 - 使用 ArrayPool<ul><li>ArrayPool 提供可重用托管数组池的专用方案 (包含在 SystemBuffers 中)</li><li>其管理指定类型的不同大小的数组集，并将数组分组到不同的 bucket 中</li><li>通过静态属性 ArrayPool<T>.Share 可获得此类型的默认数组池：当需要时调用 Rent，不需要时调用 Return 方法归还（获取的数组长度可能大于指定长度，不低于指定值，从 16 开始按倍数提前确定好）</li><li>注 1：内部使用了相当复杂的缓存技术，并针对多线程有处理，如使用了 TLS (thread local storage)</li><li>注 2：位于 ArrayPool 的数组将永久存活，因此若是短时间临时使用需要谨慎考虑</li></ul></li><li>Streams - 使用 RecyclableMemoryStream<ul><li>注：若程序需要密集使用 MemoryStream，还可以考虑使用 System.IO.Pipelines，比 Stream 更高效，内存分配更少</li></ul></li><li>创建大量对象 - 使用对象池</li><li>返回 Task 对象的异步方法 - 使用 ValueTask</li></ol><h3 id="隐式的分配"><a class="anchor" href="#隐式的分配">#</a> 隐式的分配</h3><ol><li>委托导致的分配<ul><li>创建一个新的委托会导致一次隐式分配</li><li>C# 编译器对 lambda 有一个重要优化：如果表达式未捕获任何数据，编译器会生成额外代码，将委托实例作为静态字段缓存，使其仅在第一次分配一次</li></ul></li><li>装箱<ul><li>在需要使用对象 (引用类型) 的地方使用值类型</li><li>以接口类型使用值类型实例<ul><li>避免方式是最好使用泛型、泛型约束</li></ul></li><li>调用 valueType.GetHashCode () 和 valueType.ToString () 但值类型未重写</li><li>调用 valueType.GetType () 一定会将值类型装箱</li><li>从一个值类型的方法创建委托时一定会将其装箱 (值类型实例需要被引用)</li></ul></li><li>闭包 (closures)</li><li>Yield Return (迭代器)</li><li>参数数组 (params)</li><li>串联多个字符串</li></ol><h3 id="类库中各种隐式分配"><a class="anchor" href="#类库中各种隐式分配">#</a> 类库中各种隐式分配</h3><ol><li>System.Generics 集合</li><li>LINQ - 委托</li><li>LINQ - 创建匿名类型</li><li>LINQ - 枚举</li></ol><p>注：可以使用自动将 LINQ 查询重写成常规过程式代码的类库，可以既享受 LINQ 查询的好处，又避免分配的缺点。</p><ul><li>如 roslyn-linq-rewrite</li><li>LinqOptimizer</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;本篇包含原书第五章和第六章，主要讲了 .NET 内存分区和内存分配方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小对象通过指针快速分配 (多数情况下)&lt;/li&gt;
&lt;li&gt;大对象通</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《.NET内存管理宝典》-笔记(3)</title>
    <link href="https://wangjiaying.top/2023/07/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-3/"/>
    <id>https://wangjiaying.top/2023/07/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-3/</id>
    <published>2023-07-12T07:38:51.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本篇包含原书的第三章和第四章，第三章主要讲了一些测试工具使用，我自己也看得也比较囫囵吞枣 (毕竟个人是搞 Unity3D，这块多数工具基本都是没用的，当然部分理论依然还是可以参考的)。</p><p>其次是第四章的  <code>.NET基础知识</code> ，这一章名字说是基础知识，实际上还是比较深入的，比如各个字段的内存区域、详细描述了为什么值类型 <code>更快</code> 等等。评价是  <code>比较重要</code> 。</p><h1 id="第三章-内存测量"><a class="anchor" href="#第三章-内存测量">#</a> 第三章 内存测量</h1><h2 id="尽早测量"><a class="anchor" href="#尽早测量">#</a> 尽早测量</h2><p>与其过早地专注于优化，不如先测量评估一下我们是否有这方面的需求。</p><h3 id="开销和侵入性"><a class="anchor" href="#开销和侵入性">#</a> 开销和侵入性</h3><p>开销：额外消耗<br />侵入性：游戏应用程序本身功能</p><h3 id="采样与跟踪"><a class="anchor" href="#采样与跟踪">#</a> 采样与跟踪</h3><p>跟踪：诊断数据在特定的、被关注的时间触发时收集 (基于事件)，优势是具有数据精确性。<br />采样：可以接受数据精度丢失，仅间隔一定时间搜集 (基于时间) 采样频率越低，从测量中得到的数据就越不精确。</p><h3 id="调用树"><a class="anchor" href="#调用树">#</a> 调用树</h3><ul><li>独占：仅包含该特定函数的值。</li><li>包含：测量该特定函数的值及其所有子函数的测量值的总和。(在该函数时间、它所调用的所有其它函数的时间，及调用的所有函数等时间总和)</li></ul><p>浏览这个树，我们可以很快找出最慢的函数，或不一定很慢但被多次调用的方法。<br />同样的想法亦可用于可视化内存使用情况，其每个节点代表一种特定类型对象，子级是该对象包含或引用的该对象实例的其它类型。<br /><img data-src="/blogimages/2023/2023-07-12/1390063999.jpeg" alt="1390063999.jpeg" /></p><h3 id="对象图"><a class="anchor" href="#对象图">#</a> 对象图</h3><p>表示内存中对象之间关系的图，称为对象图或引用图。</p><ul><li>最短根路径：取决于所选对象，从特定对象到某个根的引用的最短路径。</li><li>依赖关系子图：取决于所选对象，是包含对象本身以及被其直接或间接引用的所有对象的子图。</li><li>保留子图：取决于所选定对象，指如果删除了给定对象本身则也会被删除的对象的子图。<ul><li>(因为依赖关系图很复杂，因此删除对象并不意味着所有依赖于它的对象都被删除了，对它们的引用可能仍然由其它对象保留着)</li></ul></li></ul><p>指示对象大小</p><ul><li>浅大小：对象本身大小 (其所有字段、包括对其它对象的引用的大小)</li><li>总大小：对象的浅大小与其直接或间接引用的所有对象的浅大小之和</li><li>保留大小：保留子图中所有对象的总和，即保留大小是删除给定对象后可以释放的内存量。对象图中不同引用共享的对象越多，保留大小就越小于总大小。（需要对整个对象图进行复杂分析）</li></ul><h3 id="统计"><a class="anchor" href="#统计">#</a> 统计</h3><ul><li>平均值：直观，计算方便，但是其结果没有指向任何特定样本，且容易掩盖数据分发的真实本质。</li><li>中位数：将样本分为高低两半的值</li><li>百分位数：低于给定百分比的样本的值</li><li>直方图：样本分布的图形表示（最好的测量方法）</li></ul><h3 id="延迟与吞吐量"><a class="anchor" href="#延迟与吞吐量">#</a> 延迟与吞吐量</h3><p>阿姆达尔定律</p><ul><li>潜在的延迟加速受程序的串行 (无法并行化) 部分的限制。</li><li>例如，如果程序的 90% 部分可以并行化，但仍有 10% 的部分必须正常执行，那么最大潜在加速度被限制为最多 10 倍。</li></ul><h3 id="内存转储-跟踪-实时调试"><a class="anchor" href="#内存转储-跟踪-实时调试">#</a> 内存转储、跟踪、实时调试</h3><p>监视：通过跟踪或采样方式生成诊断信息。<br />内存转储：在给定时刻保存进程的内存状态。</p><ul><li>如果没有时间变化背景，有时很难得出具体结论，因此一般进行两个或多个内存转储并相互比较。</li><li>崩溃转储可作为内存转储一种特殊情况</li></ul><p>实时调试：最具侵入性的方法，将调试器直接连接到进程上，然后逐步分析应用程序。</p><h2 id="windows-环境"><a class="anchor" href="#windows-环境">#</a> Windows 环境</h2><h3 id="vmmap"><a class="anchor" href="#vmmap">#</a> VMMap</h3><p>查看进程内存使用情况分析，vmmap 检测 .net 托管堆使用的页以及专用于堆栈或加载的二进制文件专用的页。</p><h3 id="性能计数器"><a class="anchor" href="#性能计数器">#</a> 性能计数器</h3><ul><li>性能计数器值的读取完全由我们使用的工具采样的频率来控制。</li><li>仅当发生特定事件时，才会更新性能计数器数据，之后其值将一直保持不变。</li></ul><h3 id="windows-事件跟踪"><a class="anchor" href="#windows-事件跟踪">#</a> Windows 事件跟踪</h3><p>EWT<br />（诊断功能强大）</p><h3 id="windows-性能工具包"><a class="anchor" href="#windows-性能工具包">#</a> Windows 性能工具包</h3><p>Windows performance toolkit,WPT 是 Windows 环境中的一组诊断工具，具有搜集和分析 EWT 数据能力。</p><ul><li>Windows performance recorder (WPR，Windows 性能记录器)：充当 EWT 的控制器</li><li>Windows performance analyzer (WPA，Windows 性能分析器)：充当 EWT 的使用者</li></ul><h3 id="perfview"><a class="anchor" href="#perfview">#</a> PerfView</h3><h3 id="procdump-debugdiag"><a class="anchor" href="#procdump-debugdiag">#</a> ProcDump、DebugDiag</h3><p>进行内存转储的工具<br />前着为命令行，后者为 GUI 工具</p><h3 id="windbg"><a class="anchor" href="#windbg">#</a> WinDbg</h3><p>最底层的工具，不管是 net 托管程序还是原生 Windows 应用程序或调试内核本身。<br />也可以直接附加到托管程序并调试。<br />默认情况下，windbg 作为原生调试器工作，因此必须使用 windbg 扩展以为其提供 net 相关概念：</p><ul><li>SOS</li><li>SOSEX</li><li>NetExt 和 MEX</li></ul><p>由于一次又一次地输入所有命令非常麻烦，可使用命令树窗口简化。</p><h3 id="benchmarkdotnet"><a class="anchor" href="#benchmarkdotnet">#</a> BenchmarkDotNet</h3><p>代码性能测量</p><h3 id="商业工具"><a class="anchor" href="#商业工具">#</a> 商业工具</h3><p>visual studio<br />Scitech .Net Memory Profiler<br />JetBrain dotMemory<br />RedGate ANTS Memory Profiler<br />Intel VTune Amplifier 和 AMD CodeAnalyst Performance Analyzer</p><ul><li>专门用于基于硬件的底层代码分析，这些工具通常由处理器制造商提供</li><li>可以从硬件中内置的硬件计数器中获取其有关内部行为的信息：缓存和内存利用率、管道停顿等</li><li>只有这样的底层工具才能清楚地指出诸如第二章中显示的伪共享之类的问题。</li></ul><p>Dynatrace 和 AppDynamics</p><ul><li>用于监视应用程序性能的上层工具，可持续收集数据</li></ul><h2 id="linux-环境"><a class="anchor" href="#linux-环境">#</a> Linux 环境</h2><p>略</p><h1 id="第四章-net基础知识"><a class="anchor" href="#第四章-net基础知识">#</a> 第四章 .NET 基础知识</h1><p>.NET 整个概念都基于 common language infrastructure (CLI) 的规范，CLI 描述了代码和运行时 环境的概念，并确保无需重新编译的情况在不同计算机运行。<br />有很多不同 .NET 实现，此处略。</p><h2 id="net-内部原理"><a class="anchor" href="#net-内部原理">#</a> .NET 内部原理</h2><p>代码被编译为 CIL (common intermediate language) 然后由 common language runtime (CLR) 执行。CLR 是托管环境的执行核心。<br />CLR 主要职责：</p><ul><li>JIT 编译器：将 cil 代码转换为机器码。这种执行托管代码方式其实是对原生系统机制的巧妙封装，就像内存管理包含了线程堆栈和堆一样。</li><li>类型系统：负责管理类型控制和兼容性机制。包括 common type system (CTS) 和 (用于反射机制的) 元数据。</li><li>异常处理：负责在用户程序和运行时两个层次上进行异常处理。</li><li>内存管理 (通常指垃圾回收器)：运行时中管理内存的组件。</li><li>执行引擎：负责大部分运行时的职责，包括 jit 编译和异常处理，ecma-335 中被称为虚拟执行系统 (VES)，负责加载和运行为 cli 编写的程序。</li><li>垃圾回收器：负责内存管理、对象分配，回收不再使用的内存区域。</li></ul><p>托管代码：包含足够额外信息的代码，这些信息用于使 CLI 为代码执行提供一组核心服务。</p><ul><li>如给出代码中一个方法地址，CLI 必须能够定位到描述该方法的元数据，还必须能够遍历 stack、处理异常、存储和获取安全信息。</li></ul><p>一些误解：</p><ul><li>.NET 并非一般意义上的虚拟机，.NET 运行时不会创建一个隔离环境，也不会模拟任何特定的架构或计算机。其重用了诸如操作系统内存管理之类的内置系统资源，包括 heap、stack、进程和线程等，然后再在这些内置资源之上构建一些附加功能 (自动内存管理等)</li><li>计算机不会始终运行着一个 .NET 运行时，每个 .NET 程序运行时才被加载和执行</li></ul><p>.maxstack：</p><ul><li>不是 CIL 指令，而是一个元数据描述，其它工具可以使用它验证代码安全性 (防止缓冲区溢出攻击)。其描述了方法执行期间 evaluation stack 中最多可以分配多少字节。</li></ul><p>.NET stack machine 的位置概念：</p><ul><li>方法中局部变量</li><li>方法参数</li><li>另一个值的实例字段</li><li>(类、接口或模块的) 静态字段</li><li>本地内存池</li><li>暂时放在 evaluation stack 上</li></ul><p>JIT 编译器会负责将每个 逻辑位置 映射到特定的计算机架构 (即寄存器操作的机器码)。</p><h2 id="程序集和应用程序域"><a class="anchor" href="#程序集和应用程序域">#</a> 程序集和应用程序域</h2><p>为满足安全性、可靠性或版本化需求，应用程序域提供将应用程序代码不同部分隔离到应用程序域中的功能。</p><ul><li>注：由于为使得 .NET Core 保持精简，应用程序域已移除，不过 CoreCLR 内部依然使用了应用程序域</li><li>（微软建议开放人员使用进程或新式容器实现 .NET Core 程序隔离）</li></ul><p>应用程序域分类：</p><ul><li>共享域：不同应用程序域之间共享代码加载此域。包括 basic class library、system 命名空间中的类型</li><li>系统域：核心运行时组件加载到此域，负责创建和初始化其它应用程序域。还保存了进程范围内暂存的字符串文本。</li><li>默认域：用户代码会加载至该域。</li><li>动态域：通过 AppDomain.CreateDomain 根据需要创建，.NET Core 不提供该功能。</li></ul><p>所有共享代码由共享域负责处理，所有用户代码由单个默认域处理。系统域仅存在结构和逻辑，在进程内存中不可见。</p><h2 id="进程内存区域"><a class="anchor" href="#进程内存区域">#</a> 进程内存区域</h2><p>每个应用程序域，包括共享域、系统域、默认域及其它所有动态加载的域，都各自有自己的一组堆：</p><ul><li>High Frequency Heap (高频堆)：应用程序域基于其内部目的，将频繁访问的数据存储于此。<ul><li>CoreCLR 描述：这些堆用于分配应用程序域生命周期内始终存在的数据。为更好管理 page，应将频繁分配的对象分配到高频堆。</li><li>如详细的方法和字段描述等基元静态数据也存放在这。</li></ul></li><li>Low Frequency Heap (低频堆)：包含了较少使用的类型相关数据，如 EEClass、JIT 编译、反射、类型加载机制所需要的其它数据。</li><li>Stub Heap：文档描述 -- 保存了实现代码访问安全 (CAS)、COM 包装调用和 P/Invoke 的 sub</li><li>Virtual Call Stub：包含用于虚拟 stub 调度 (VSD) 技术所使用的数据结构和代码。<ul><li>VSD 技术：使用 stub 用于虚拟方法调用，而非使用传统的虚拟方法表。</li></ul></li><li>High Frequency Heap、Low Frequency Heap、Stub Heap 和各种 Virtual Call Stub 都统称为 Loader Heap 类型，因为它们存储的都是类型系统所需的各种数据 (因此加载任何一个类型时都需要它们)<ul><li>即虽然有 Loader Heap 这个术语，但内存其实不存在一个 Loader Heap，而是代表上述内存区域统称</li><li>注：加载至 Loader Heap 区域的类型的生命周期跟随应用程序域。</li></ul></li></ul><h2 id="类型系统"><a class="anchor" href="#类型系统">#</a> 类型系统</h2><p>Common Type System (通用类型系统)<br />.NET 中每种类型都由一个称为 MethodTable 的数据结构描述，其中包含类型的大量信息，最重要的有：</p><ul><li>GCInfo：用于垃圾回收器用途的数据结构</li><li>标志：描述各种类型的属性</li><li>基本实例大小：每个对象的大小</li><li>EEClass 引用：存储通常仅用于类型加载、JIT 编译或反射的『冷』数据，包括所有方法、字段和接口的描述信息。</li><li>调用所有方法 (包括继承自基类的方法) 所需要的描述信息。</li><li>静态字段有关的数据：包括与基元静态字段有关的数据。</li></ul><p>只要有需要，运行时将通过访问 MethodTable 的地址 (表示为 TypeHandle) 获取被加载的类型信息。</p><h3 id="类型的分类"><a class="anchor" href="#类型的分类">#</a> 类型的分类</h3><ul><li>值类型：这种类型的实例直接包含其所有数据 (值类型的值是自包含的)</li><li>引用类型：这种类型的实例包含对其数据的引用 (引用类型所描述的值指示其它值的位置)</li></ul><h4 id="生存期"><a class="anchor" href="#生存期">#</a> 生存期</h4><ul><li>值类型实例包含的数据，其生存期与实例本身一样长</li><li>引用类型的值描述了其它值的位置，那些值的生存期并不取决于引用类型值本身</li></ul><h4 id="可共享性"><a class="anchor" href="#可共享性">#</a> 可共享性</h4><ul><li>值类型的值不可共享，如果想在其它地方使用，默认只会按照字节复制一份出来。复制值不影响原始值。</li><li>引用类型的值可被共享，在传递之后会多出一个指向同一个位置的引用类型实例。</li></ul><h4 id="相等性"><a class="anchor" href="#相等性">#</a> 相等性</h4><ul><li>值类型不存在相等性，当且仅当它们值的二进制序列一样时才认为完全相同</li><li>引用类型当且仅当它们指示的位置一样就是完全相同的</li></ul><h3 id="类型的存储"><a class="anchor" href="#类型的存储">#</a> 类型的存储</h3><p>存储在堆栈，还是存储在堆？这是实现细节上的决策。通常值类型和引用类型存储位置的说法，并不准确，因为他们存在包含关系。<br />注：CLI 标准中并未指定关于存储位置的任何实现细节决策。</p><h3 id="值类型"><a class="anchor" href="#值类型">#</a> 值类型</h3><p>ECMA335：类似整数或浮点数，值类型使用了一种简单的将数据直接按位存储模式。每个值都有一个类型，该类型描述了它使用的存储空间以及它的表现方法中各个位 (bit) 的含义，也描述了对该表现方式进行的操作。在编程语言中，值通常用于表现简单类型和非对象。<br />通用语言规范 (CLS) 定义了两种值类型：</p><ul><li>结构：包括许多内置整型类型 (char/byte/integer)、浮点类型和布尔类型</li><li>枚举：基本是整型类型的扩展，由一组命名常量构成。从内存管理的角度看就是整型类型（内部本质上是结构）</li></ul><h4 id="值类型的存储"><a class="anchor" href="#值类型的存储">#</a> 值类型的存储</h4><p>『堆栈是一种轻量级机制，只需要创建一个大小合适的 activation frame 并在不再需要时将其关闭，就可以在堆栈上 分配 和 回收 对象』<br />但堆栈的生存期和值本身需要的生存期不匹配，生存期和值共享这两个因素，决定我们可以使用何种机制存储值类型数据。<br />值类型可能出现位置：</p><ul><li>方法中局部变量：具有非常严格和定义良好的生存期，其长度和方法的调用时长相同。<ul><li>CLI 指出：引用局部变量或参数变量的托管指针，有可能出现引用失效的问题，因为它的行为无法验证。</li></ul></li><li>方法的参数：可以完全被视作局部变量。</li><li>引用类型的实例字段：其生存期取决于父值的生存期。将于引用类型一并被分配于堆。</li><li>另一个值类型的实例字段：跟随父值。</li><li>(类 / 接口 / 模块中的) 静态字段：静态字段的生存期和定义此字段的类型等长，因此肯定不能使用堆栈保存。</li><li>局部内存池：生存周期与方法生存期严格等长，堆栈</li><li>evaluation stack 上临时值：处于性能考虑，JIT 显然会尽量使用 CPU 寄存器和堆栈。</li></ul><h4 id="结构"><a class="anchor" href="#结构">#</a> 结构</h4><ul><li>分配于堆上而非栈上：可以从实现细节上受益，例如避免 GC 管理它们所带来的开销。</li><li>较小：结构只存储其数据而无需存储任何额外的元数据，因此所需内存更小。</li><li>提供了更佳的数据局部性：由于结构更小，因此可以更密集地在集合中打包数据。</li><li>访问速度更快：直接包含数据，因此访问时无需进行额外的解引用 (dereferencing) 操作。</li><li>天然具有传值语义</li></ul><h4 id="结构概述"><a class="anchor" href="#结构概述">#</a> 结构概述</h4><p><img data-src="/blogimages/2023/2023-07-12/1515094104.jpeg" alt="1515094104.jpeg" /></p><p>上图内存区域可能位于堆栈、堆，甚至 CPU 寄存器。<br />不过当前 CLR 实现不允许直接在托管堆上使用上述布局，托管堆中的对象必须是自描述的引用类型。因此当需要在堆中存储结构时，将执行装箱 (boxing)。</p><ul><li>当结构被装箱，就将很难再获得结构的种种优点。结构的真正能力只在未被装箱的情况才能得以体现。</li></ul><p>优化内存和性能的核心规则之一是：避免分配，结构即是帮助我们应用这条规则的利器。<br />此外，由于结构的限制，比如不带继承功能，可以让编译器可以对其使用方式进行大量预判。</p><h4 id="结构的存储"><a class="anchor" href="#结构的存储">#</a> 结构的存储</h4><ul><li>ldloca.s 0：将第一个局部变量的地址推入 evaluation stack</li><li>initobj：从 evaluation stack 取出并移除地址，将其指向内存初始化为指定类型初始值</li><li>ldarg.0：将方法的第一个参数 (实例方法为 this) 推入 evaluation stack（后续参数依此类推）</li><li>ldloc.0：将第一个局部变量的值推入 evaluation stack</li><li>call：调用方法，结果放入 evaluation stack</li><li>ret：从方法返回至调用者</li><li>newobj：堆分配</li></ul><p>对于小型结构数据，JIT 可以仅使用 CPU 寄存器从而完全避免使用堆栈以极大优化性能 (生成的机器码中彻底没有了结构的概念)。<br />还可以对 (大型) 结构体使用传引用优化复制效率。<br />结构是高效的数据容器，其简洁性提供了极大的代码优化潜力，『局部结构类型变量被分配在堆栈上』确实不假，但实际情况可能比这更好，局部变量可以被优化成完全由 CPU 寄存器处理而无需用到堆栈，从而使按值传递也不过需要对 CPU 寄存器进行一些操作而已。<br />注 1：release 和 debug 模式编译后代码有很大差异。<br />注 2：影响 JIT 优化与否的大小大概是 24 字节，可以安全假设 JIT 将对不超过 16 字节的结构进行优化。(注意测试代码是 64 位 RyuJIT 编译器)<br /> 注 3：在一个结构体方法中可以将新值赋给 this 字段，是由于结构体直接存储数据，可看作再次初始化。</p><h3 id="引用类型"><a class="anchor" href="#引用类型">#</a> 引用类型</h3><p>通用规范中定义了两种主要的引用类型：</p><ul><li>对象类型： ECMA335 所述，对象是 自描述值的引用类型，类型显示存储于其表现形式中。包括类和委托。</li><li>指针类型：一个指向某个内存位置的特定于当前计算机的纯地址。指针分为托管指针和非托管指针两种。</li></ul><p>概念区分：</p><ul><li>一个引用类型的值是对其数据的引用，引用本身可被视为一个值类型，内部是个 32 位或 64 位地址，引用具有传值语义。</li><li>引用类型的数据：被引用的一段内存区域，标准中并未定义数据的存储位置，反正它肯定存储在引用本身以外的其它位置。</li></ul><p>引用可以被视为指针的一种，但与普通指针不同的是运行时为引用提供了额外的安全性。</p><p><img data-src="/blogimages/2023/2023-07-12/-1385607071.jpeg" alt="-1385607071.jpeg" /></p><p>注：存在一种逃逸分析的技术，也许可以让类分配于堆栈，不过 .NET 目前不支持。</p><h4 id="类"><a class="anchor" href="#类">#</a> 类</h4><p>由于 .NET 内存管理的设计方式，堆上每个对象都有严格的内存布局：</p><ul><li>object header：存储了需要附加到对象上的所有附加信息，大多数时候都是 0。<ul><li>常见的用途有：此对象上的 lock 信息或 GetHashCode 结果缓存值（遵循先到先得规则）</li></ul></li><li>method table reference：即 MethodTable 引用，指向类型描述数据结构中的一个相应条目 (位于 high frequency heap)。这里也是对象相互引用时的引用点。</li><li>数据占位符 (若类型没有字段)：当前垃圾回收器要求每个对象都至少有一个指针大小的字段。<ul><li>该字段不必专门用于垃圾回收，而是可以其它各种用途重用 (如用作存储对象第一个字段 - 如果有的话)</li></ul></li></ul><p><img data-src="/blogimages/2023/2023-07-12/-1159290546.jpeg" alt="-1159290546.jpeg" /></p><p>堆上每个对象都至少包含上述三个字段。<br />32 位 最小堆对象为 12 字节：</p><ul><li>4 字节用于对象标头</li><li>4 字节 (一个指针大小) 用于 method table reference</li><li>4 字节 (一个指针大小) 用于内部数据占位符</li></ul><p>64 位 最小堆对象位 24 字节：</p><ul><li>8 字节用于对象标头：实际只用到 4 个字节，另外以 0 填充的 4 字节仅用于对齐目的（64 位架构基于 8 字节对齐）</li><li>8 字节 (一个指针大小) 用于 method table reference</li><li>8 字节 (一个指针大小) 用于内部数据占位符</li></ul><p>一个包含 1 字节数据的分配于堆栈上的结构仅占用 1 字节空间 (内存对齐可能有额外开销)，而一个包含 1 字节数据的分配于堆上的类将在 64 位运行时占用 24 字节空间，两者内存开销相差明显。<br />另外，类生成的最终汇编代码也比结构更复杂，在测试代码中，类的性能与结构之间相差超过 4 倍。</p><h2 id="字符串"><a class="anchor" href="#字符串">#</a> 字符串</h2><p>字符串不可变性仅体现在 Basic Class Library 未提供任何修改字符串的 API，但在运行时并没有这个限制。</p><ul><li>它只是一段连续的、以某种方式表示字符的字节区块，完全可以使用 unsafe 模式使用指针修改 —— 当然这种做法是不受支持的。</li></ul><p>string.format、string.join 等常见辅助函数内部已经使用了 stringbuilder，为进一步优化甚至甚至进一步封装了 StringBuilderCache</p><ul><li>StringBuilderCache 内部存储了一个 thread static stringbuilder，每个线程上都会创建一个专门的实例，因此是线程安全的。</li></ul><p>字符串不可变优缺点：</p><ul><li>优点<ul><li>安全性</li><li>并发性</li></ul></li><li>缺点<ul><li>修改操作将导致额外字符串实例</li></ul></li></ul><h3 id="字符串暂存"><a class="anchor" href="#字符串暂存">#</a> 字符串暂存</h3><p>.NET 运行时内部有一个名为字符串暂存 (string interning) 的机制，此机制默认仅适用于字符串字面量 (string literal)。</p><ul><li>.NET 内部也提供了手动暂存的 API</li></ul><p>暂存的字符串由 StringLiteralMap 和 LargeHeapHandleTable 注册和管理，这几个数据结构生成周期与应用程序一样长。</p><p><img data-src="/blogimages/2023/2023-07-12/592931748.jpeg" alt="592931748.jpeg" /></p><p>字符串暂存优缺点</p><ul><li>优点<ul><li>消除重复字符串</li><li>提供相等比较性能</li></ul></li><li>缺点<ul><li>永续性：暂存字符串将永远保持可达状态</li><li>创建临时字符串：只能暂存已创建的字符串，因此即使仅用于检查是否存在某个已暂存字符串，也会有一个留存极短时间的未暂存字符串。</li></ul></li></ul><p>结论：字符串暂存仅在大量重复字符串需要长时间保留于内存下才有意义。(该场景似乎并不常见)</p><h2 id="装箱与拆箱"><a class="anchor" href="#装箱与拆箱">#</a> 装箱与拆箱</h2><p>是一个效率较低的操作，应尽量避免。例如避免在需要对象 (引用类型) 的地方使用值类型。</p><ul><li>作为一个通用规则：尽量避免在调用以 object 类型为参数的方法。</li></ul><p>注：以接口类型使用值类型实例 (若值类型实现了该接口)，由于接口是引用类型，因此同样会导致装箱。（可以考虑利用泛型优化，泛型方法将被编译为特定具体类型的方法）<br />foreach 遍历值类型列表，会导致隐式装箱。</p><ul><li>为何 list&lt;&gt; 这类常见集合类型采用结构实现枚举器？<ul><li>绝大部分场景中，枚举器都被当做一个局部变量，值类型可以快速低廉地在堆栈上分配 (好处超过装箱可能带来的问题)</li></ul></li></ul><p>与装箱对应是拆箱，不过拆箱不会导致太大内存开销。</p><h2 id="按引用传递"><a class="anchor" href="#按引用传递">#</a> 按引用传递</h2><p>我们可以按引用传递任何值，无论它是值类型实例还是引用类型实例。</p><h2 id="类型数据局部性"><a class="anchor" href="#类型数据局部性">#</a> 类型数据局部性</h2><p>结构的数据构造内存使用效率更好。<br />且结构体数组才是内存连续，而引用类型数组只包含连续的引用，实际值分散于整个托管堆。</p><ul><li>类实例数组有额外一次解引用，并且无法在内存中连续排列，因此类实例数组具有更差的数据局部性，加载类数组必须使用更多的 cache line，导致其性能会相差更大。</li></ul><h2 id="静态数据"><a class="anchor" href="#静态数据">#</a> 静态数据</h2><p>静态数据可以被视作程序中的一种全局变量。</p><ul><li>C# 仅支持一种静态数据类型：静态字段</li></ul><h3 id="静态字段"><a class="anchor" href="#静态字段">#</a> 静态字段</h3><p>静态字段的值被该类型的所有实例所共享，通过使用类型名称，在任何可以访问该类型的地方都可以访问该类型上定义的静态字段。</p><ul><li>静态数据具有应用程序域作用域 (每个应用程序域单独一份实例)</li><li>定义在一个程序集的类型上的静态数据将一直存活到应用程序域被卸载 (使其引用的静态数据和对象也将保持可达)。</li></ul><p>实现细节</p><ul><li>静态基元数据 (如数字) 存储于相应应用程序域的一个 HighFrequencyHeap 中</li><li>静态引用类型实例存储于常规 GC Heap 中，与普通对象区别在于额外被一个内部 static table 引用</li><li>静态用户自定义值类型实例 (结构) 将以装箱形式存储于常规 GC Heap 中</li></ul><p><img data-src="/blogimages/2023/2023-07-12/1274258931.jpeg" alt="1274258931.jpeg" /></p><p>访问</p><ul><li>对于基元类型静态字段，已知维护此字段的 DomainLocalModule 地址和要访问的字段在 statics blob 中的偏移量，计算后可得静态数据的绝对地址</li><li>对于引用类型静态字段 (包括结构类型，其以装箱形式分配在堆上)，已知对应 object [] 数组的地址和访问字段偏移量，计算出静态字段的绝对地址，获得指向托管堆真正实例数据的引用。</li></ul><p>访问基元静态字段的速度非常快，它唯一做的操作就是从适当的 statics blob 区域读取一个指定值。<br />访问类型 / 结构静态字段数据需要执行解引用操作，并随之带来额外开销。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;本篇包含原书的第三章和第四章，第三章主要讲了一些测试工具使用，我自己也看得也比较囫囵吞枣 (毕竟个人是搞 Unity3D，这块多数工具基本都是没用的，当然部分理论依</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Unity Addressables 笔记</title>
    <link href="https://wangjiaying.top/2023/07/10/Addressables-%E7%AC%94%E8%AE%B0/"/>
    <id>https://wangjiaying.top/2023/07/10/Addressables-%E7%AC%94%E8%AE%B0/</id>
    <published>2023-07-10T08:26:05.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>前两天公司其他同事在推荐让试一试 <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vd2VjaGF0LW1pbmlnYW1lL21pbmlnYW1lLXVuaXR5LXdlYmdsLXRyYW5zZm9ybS9ibG9iL21haW4vRGVzaWduL1VzaW5nQXNzZXRCdW5kbGUubWQ=">WXAssetBundle</span>，看看性能是不是真的有所提升，然后顺便就看到微信官方推荐使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vd2VjaGF0LW1pbmlnYW1lL21pbmlnYW1lLXVuaXR5LXdlYmdsLXRyYW5zZm9ybS9ibG9iL21haW4vRGVzaWduL1VzaW5nQWRkcmVzc2FibGUubWQ=">Addressables</span> 系统进行资源加载 (其实之前就有瞄到这文档，只是当时项目重点不在这，所以没怎么注意)<br /> 当然微信虽然推荐 Addressables ，也提到如果自己进行维护管理的 AB 包 性能肯定会比 AA (Addressables) 包更好 ——</p><blockquote><p>AA 包较大项目时生成的未压缩的 catalog 较大，加载效率低</p></blockquote><p>所以微信推荐的原因是：</p><ul><li>学习使用曲线平滑，便于使用和维护，并且能快速切换想要的资源管理技术。</li></ul><p>因此，就算我们还是在使用自己的包管理方式，先了解一下总无坏处：比如上面提到的 catalog，catalog 在 Addressables 中用来干什么的？</p><h1 id="总览"><a class="anchor" href="#总览">#</a> 总览</h1><p>Addressables 底层使用引用计数维护资源关系 (这是当然，我们自己的也是)，被引用自动加载时，Unity 自动维护其引用计数。不过当我们显式加载可寻址资源时，就必须在使用完该资源后释放该资源了。</p><ul><li>另外，资源使用的内存只有在其所属的 AssetBundle 也被卸载后才会被释放 (与我们自己维护的一样)</li></ul><p>所以，避免资源内存泄露的情况与使用自己的资源管理器是一样的：显式加载了记得释放。<br />另外需要注意：</p><ul><li>如果将 Resources 文件夹中的资源设置为可寻址，则 Unity 会将资源移出目录。可以选择自己将资源移动到项目中的其他文件夹，但不能将可寻址资源存储在 Resources 目录中。</li></ul><p>注：Windows 的文件路径限制为 260 个字符</p><h2 id="加载与卸载"><a class="anchor" href="#加载与卸载">#</a> 加载与卸载</h2><p>自动加载依赖及引用计数<br />主要有以下几种方式：</p><ul><li>AssetReferences<ul><li>一种资源引用，可以看做 可用于替换在 MonoBehaviour、ScriptableObject 定义的常规拖上去而使用的引用资源，例如对应 GameObject：AssetReferenceGameObject 或 AssetReferenceTexture 等，而 AssetReference 可认为是对应此前 Object 类型 (可以拖任何对象上去)</li><li>此外，也可以使用 AssetReferenceUILabelRestriction 限制能拖上去指定标签的 Addressables 对象</li><li>注：AssetReference.cs 中有详细列表</li></ul></li><li>通过地址 (路径) 加载<ul><li><code>Addressables.InstantiateAsync(path)</code></li><li><code>Addressables.LoadAssetAsync&lt;GameObject&gt;(path)</code></li></ul></li><li>通过标签加载</li><li>IResourceLocation</li></ul><p>与常规资源一样，加载之后需要对应卸载资源。</p><p>注：加载时也可以采用 async、await 异步方法，其 Load 方法中有  <code>Task</code>  属性</p><h2 id="分组和标签"><a class="anchor" href="#分组和标签">#</a> 分组和标签</h2><ul><li>分组用于组织具体内容，每个组可以有自己的打包设置 (如整个组单打为一个包，或分离打包、名字是否带 Hash 等)<ul><li>一个组打包成一个 Bundle</li><li>组内每个资源都单独打成一个 Bundle</li><li>组内同一标签的打成一个 Bundle</li></ul></li><li>同时也可以支持通过标签加载 (如果设置了标签的话)</li></ul><h1 id="资源清单catalogs"><a class="anchor" href="#资源清单catalogs">#</a> 资源清单 (catalogs)</h1><p>即 catalogs 文件，Addressables 用来管理资源加载、依赖啥的<br /> catalog_{日期}.hash</p><ul><li>检查 catalog.json 文件是否发生变化</li><li>先下载这个，再决定是否下载  catalog_{日期}.json 文件</li></ul><p>catalog_{日期}.json</p><ul><li>具体记录依赖关系啥的数据，Bundle 越多，该文件越大</li><li>可以在 AddressableAssetSettings 中设置命名方式</li></ul><p>可以自动加载，也可以手动加载，建议当然是手动加载比较好。Addressables 同样会缓存改文件，在 hash 发生变化时才会重新下载。</p><ul><li>哈希文件需要与目录位于同一位置并且具有相同的名称，路径的唯一区别是扩展名。</li></ul><h2 id="手动加载方式"><a class="anchor" href="#手动加载方式">#</a> 手动加载方式</h2><ul><li>Addressables.LoadContentCatalogAsync</li><li>可选参数是否自动释放句柄，官方建议直接传 true 自动释放</li><li>还可以手动调用 Addressables.CheckForCatalogUpdates 更新 (官方文档表示可以同时加载多个)</li></ul><h2 id="catalogs-大小优化方式"><a class="anchor" href="#catalogs-大小优化方式">#</a> catalogs 大小优化方式</h2><ul><li>压缩：打包进 AssetBundle，当然这样做会导致加载时间增加 (有提供选项)<ul><li>注：只影响本地的 catalog，即与整包打包到 SteamingAssets 目录的那个</li></ul></li><li>禁止包含额外资源：每个分组设置上的 IncludeXXXXX<ul><li>这个选项得看情况设置，最新 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5hZGRyZXNzYWJsZXNAMS4yMS9tYW51YWwvYnVpbGQtY29udGVudC1jYXRhbG9ncy5odG1s">Content catalogs 1.21.14</span> 提供了 Disable built-in scenes and Resources 选项（我自己测试版本是 1.19 ，没这个选项，只有一些 IncludeXXXXX）</li></ul></li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5hZGRyZXNzYWJsZXNAMS4yMS9tYW51YWwvTG9hZENvbnRlbnRDYXRhbG9nQXN5bmMuaHRtbA==">Manage catalogs at runtime | Addressables | 1.21.14</span></p><h1 id="资源组类型"><a class="anchor" href="#资源组类型">#</a> 资源组类型</h1><p>这里主要是指 『动态资源』、『静态资源』之分，其区别如下：</p><p>静态资源</p><blockquote><p>Content Update Restriction 设置为 Cannot Change Post Release<br /> 动态资源<br /> Content Update Restriction 设置为 Can Change Post Release</p></blockquote><p>同时，基于是否设置为 Remote 而确定属于： <code>本地静态资源</code> 、 <code>远程静态资源</code> 还是 <code>远程动态资源</code>  三类中的一类。</p><p>注：在进行完整构建之后，如果只是更新打包不要修改该项，否则对更新会有影响</p><h2 id="静态资源组"><a class="anchor" href="#静态资源组">#</a> 静态资源组</h2><p>分为  <code>本地静态资源</code> 、 <code>远程静态资源</code></p><p>在资源发生变更后，可以通过菜单的  <code>Tools-&gt;Check for Content Updates</code>  将其自动设置到一个名为  <code>ContentUpdate</code>  的新分组中：</p><p><img data-src="/blogimages/2023/2023-07-10/Snipaste_2023-07-10_16-33-16.jpg" alt="" /><br /><img data-src="/blogimages/2023/2023-07-10/Snipaste_2023-07-10_17-47-51.jpg" alt="" /></p><p>然后再使用 Build-&gt;Update Preview Build 就可以打出新组的包。</p><p>也就是说，更新打包时， <code>Check for Content Updates</code>  用于单独把修改过的资源挪到  <code>UpdateContent</code>  分组进行打包，这个分组默认设置就是  <code>远程动态资源组</code></p><blockquote><p>注：经测试，每次执行  <code>Check for Content Updates</code>  都会生成一个新的  <code>UpdateContent</code>  远程动态资源分组，分组重名则在后面加序号。</p></blockquote><h3 id="本地静态资源"><a class="anchor" href="#本地静态资源">#</a> 本地静态资源</h3><p>即  <code>Build&amp;LoadPaths</code>  设置为  <code>Local</code>  模式</p><p>在项目构建的时候 Addressables 会自动把资源拷贝到 SteamingAssets。</p><ul><li>试了下是真的 (PC 包)—— 另外 Remote (远程资源) 就不会跟随 Unity 打包进 SteamingAssets 目录。</li><li>简单来说，似乎就是  <code>Library\com.unity.addressables\aa</code>  下的会跟随打包拷入 SteamingAssets 目录。<ul><li>注： 因为  <code>Remote资源</code>  是在  <code>ServerData</code>  目录，这个目录是没有的</li></ul></li></ul><h3 id="远程静态资源"><a class="anchor" href="#远程静态资源">#</a> 远程静态资源</h3><p>即  <code>Build&amp;LoadPaths</code>  设置为  <code>Remote</code>  模式</p><p>远程静态资源一样会被复制到  <code>ServerData</code>  目录，这种就被称为  <code>远程静态资源</code> 。</p><ul><li>不过远程资源肯定都是没有就去下载，所以，暂时没弄明白  <code>远程静态资源</code> 和  <code>远程动态资源</code>  相比，除了更新时会单独把修改过的资源挪到  <code>UpdateContent</code>  分组外，还有其它啥明显的区别和作用？</li><li>感觉远程静态资源只会增加复杂性，所以还有其它在下没想到的设计考虑吗？</li></ul><p><img data-src="/blogimages/2023/2023-07-10/Snipaste_2023-07-10_17-53-38.jpg" alt="" /><br />如上图所示，远程静态资源 (动态资源也一样) 包括其下载路径都会直接存储到本地的  <code>catalog</code>  数据中。</p><h2 id="动态资源组"><a class="anchor" href="#动态资源组">#</a> 动态资源组</h2><p>动态资源组只存在  <code>远程动态资源</code>  (都动态了肯定是远程下载了对吧？)<br /> 发生变更的资源会重新打包，同时直接覆盖掉原资源 (如果是附加了 Hash，则与原资源同级新增)。<br />如果想要进行资源更新，必须使用  <code>Remote catalog</code> ，即  <code>远程动态资源组</code> ，上述静态资源组更新而自动创建的  <code>UpdateContent</code>  分组即为  <code>Remote</code>  动态资源组。</p><p>注：远程动态资源组确实很适合微信这种按需延迟下载使用的方式，使用流程跟正常的操作几乎一样方便。</p><h1 id="测试"><a class="anchor" href="#测试">#</a> 测试</h1><p>编辑器中提供了三种加载方式：</p><p><img data-src="/blogimages/2023/2023-07-10/Snipaste_2023-07-11_17-01-53.jpg" alt="" /></p><ul><li>Use Asset Database：使用 AssetDatabase 进行加载，不用打 AssetBundle 即可测试</li><li>Simulate Groups：模拟 AssetBundle 信息进行加载，不用打 AssetBundle 即可测试，相比第一种方式会有更多一些信息</li><li>Use Exising Build：需要打包后加载，加载真实 AssetBundle 包</li></ul><p>同时也直接提供了一个  <code>Hosting</code>  编辑器界面可用于本地打包后，开启一个模拟服务器测试远程加载资源情况，局域网内的设备也可以通过本地网络连测试资源的加载。</p><h2 id="eventviwer"><a class="anchor" href="#eventviwer">#</a> EventViwer</h2><p>需要勾选设置项的  <code>Send Profiler Events</code></p><p><img data-src="/blogimages/2023/2023-07-10/Snipaste_2023-07-11_17-12-46.jpg" alt="" /></p><p>这个界面初步看来，可以查看加载的 AssetBundle 对象及其依赖啥的。其它功能还待了解。</p><h2 id="analyze"><a class="anchor" href="#analyze">#</a> Analyze</h2><p>资源分析界面，可用来查找重复资源引用之类的，可以方便地将重复资源直接设置到一个新分组。</p><h1 id="注意"><a class="anchor" href="#注意">#</a> 注意</h1><ul><li>addressables_content_state.bin<ul><li>更新打包时需要用来对比 (Update Preview Build)</li></ul></li><li>Update Restrictions<ul><li>区分静态资源和动态资源</li><li>打包之后不要变更</li></ul></li></ul><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>过了一番流程之后，感觉官方的 Addressables 的使用确实已经比较方便，特别是连模拟加载及自带服务器模拟都提供了。<br />至于最开始前言提到的 &quot;catalog&quot; 作用，也知道了这该是属于 Addressables 的清单文件，记录了资源依赖之类的关系，必须首先加载才能进入后续流程。<br />当年 (记得好像是 2017 年？) 就听说官方要出新的资源管理方式，就不想去研究 AssetBundle，结果最后还是搞起了 AssetBundle，直到现在才过了一遍官方这个新的 Addressables... 如果以后我自己搞新项目，一定得实际尝试一番。</p><p>注：Addressables 是开源的。</p><h1 id="参考文档"><a class="anchor" href="#参考文档">#</a> 参考文档</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vd2VjaGF0LW1pbmlnYW1lL21pbmlnYW1lLXVuaXR5LXdlYmdsLXRyYW5zZm9ybS9ibG9iL21haW4vRGVzaWduL1VzaW5nQWRkcmVzc2FibGUubWQ=">Design/UsingAddressable.md · Ocean/minigame-unity-webgl-transform - Gitee.com</span><br /><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vd2VjaGF0LW1pbmlnYW1lL21pbmlnYW1lLXVuaXR5LXdlYmdsLXRyYW5zZm9ybS9ibG9iL21haW4vRGVzaWduL1Jlc291cmNlc0xvYWRpbmcubWQ=">Design/ResourcesLoading.md · Ocean/minigame-unity-webgl-transform - Gitee.com</span><br /><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5hZGRyZXNzYWJsZXNAMS4yMS9tYW51YWwvQWRkcmVzc2FibGVBc3NldHNNaWdyYXRpb25HdWlkZS5odG1s">Configure your project to use Addressables | Addressables | 1.21.14</span><br /><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MDExMDk3OTA=">Addressables 之远程内容分发</span><br /><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80OTkxNzI5MzM="> Addressables 之配置</span><br /><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vd2VjaGF0LW1pbmlnYW1lL21pbmlnYW1lLXVuaXR5LXdlYmdsLXRyYW5zZm9ybS9ibG9iL21haW4vRGVzaWduL1VzaW5nQWRkcmVzc2FibGUubWQ=">使用 Addressable Assets System 进行资源按需加载</span><br /><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81ODgxMjAwNTg="> Unity - Addressables 项目总结（一）：基础工作流</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;前两天公司其他同事在推荐让试一试 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRlZS5jb20vd2VjaGF0LW</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/categories/Unity3D/"/>
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/tags/Unity3D/"/>
    
    <category term="AssetBundle" scheme="https://wangjiaying.top/tags/AssetBundle/"/>
    
  </entry>
  
  <entry>
    <title>《.NET内存管理宝典》-笔记(2)</title>
    <link href="https://wangjiaying.top/2023/06/26/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-2/"/>
    <id>https://wangjiaying.top/2023/06/26/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-2/</id>
    <published>2023-06-26T02:23:19.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-底层内存管理"><a class="anchor" href="#第二章-底层内存管理">#</a> 第二章 底层内存管理</h1><h2 id="硬件"><a class="anchor" href="#硬件">#</a> 硬件</h2><ul><li>处理器 (CPU)：计算机的主单元，负责执行指令。包含算数逻辑单元 (ALU)、浮点单元 (FPU)、寄存器和指令来执行流水线 (负责高效执行被切分成一组更精简指令集的操作指令，并在可能的时候并行执行它们)</li><li>前端总线 (front side bus,fsb)：连接 CPU 和北桥的数据总线</li><li>北桥 (northbridge)：主要包含内存控制单元，负责控制内存和 CPU 之间的数据通信</li><li>RAM (随机存取存储器)：也叫易失性存储器</li><li>内存总线 (memory bus)：连接 RAM 和北桥的数据总线</li><li>南桥 (southbridge)：处理计算机所有 I/O 功能的芯片</li><li>存储 I/O：存储数据的永久性存储器</li></ul><p><img data-src="/blogimages/2023/2023-06-26/-430140174.jpeg" alt="-430140174.jpeg" /></p><p>注：现代计算机架构北桥芯片被内至于 cpu 中，由于内存控制器与 cpu 执行单元距离更近，降低了整体通信延迟</p><p><img data-src="/blogimages/2023/2023-06-26/313265336.jpeg" alt="313265336.jpeg" /></p><p>内存管理背后的主要问题是当今 cpu 的强大处理能力与内存和大容量存储子系统之间的不匹配</p><ul><li>当处理器需要访问内存时，都会导致额外的延迟</li><li>当 cpu 需要停下来等待对内存数据的访问 (无论写入或读取) 完成时，称之为停顿。停顿越多，cpu 利用率就越低</li></ul><p>目前主流内存的内部时钟频率非常低，依靠多种技巧提升频率。内存模块由内部存储单元和附加缓冲器组成，后者用于协助突破内部低时钟频率的限制。</p><ul><li>单个时钟周期内，从内部存储器单元发送两次数据：准确是是在时钟信号的下降和上升周期分别发送一次数据。例如：双倍数据传输率 (double data rate，ddr)</li><li>在单个时钟周期内，使用内部缓冲一次进行多次读取</li></ul><p>即使 DDR 内存已经应用了各种优化手段，但 CPU 的速度仍然比内存快。为克服这个问题，在不同层面都引入了一个相似方法：将一部分数据放到性能更好 (同时更昂贵) 的存储器中，即称为缓存。</p><h3 id="内存"><a class="anchor" href="#内存">#</a> 内存</h3><p>目前存在两种主要内存类型：</p><ul><li>静态随机存取存储器 (static random access memory，SRAM)：具备极高的访问速度但工艺复杂，占用面积大，每个存储单元由 6 个晶体管组成 (用于存储单个比特)。只要保持通电数据就可以一直保存，无需刷新。主要用于 cpu 缓存。</li><li>动态随机存取存储器 (dynamic random access memory，DRAM)：存储单元的结构简单很多 (比 SRAM 小很多)，由单个晶体管和电容器组成。<ul><li>由于电容会漏电，一个存储单元需要不断地刷新其自身保存的数据 (这将耗时宝贵的几豪秒并拖慢读取内存速度)。</li><li>从电容器读取的信号还需要被放大，导致整个过程更为复杂</li><li>由于电容器本身存在延迟，数据的读取和写入也需要额外耗时，且耗时时长并非线性 (需要等待一段时间以确保数据的正确读取和成功写入)</li></ul></li></ul><p>芯片面积和工艺决定芯片价格，同容量的 SRAM 价格更贵<br />我们计算机安装的内存，即 DRAM 为了减少成本，是进行行列地址复用的 (芯片引脚数不够)，通常寻址结构如下：</p><p><img data-src="/blogimages/2023/2023-06-26/484749549.jpeg" alt="484749549.jpeg" /></p><p>从一个指定单元读取 1 比特数据过程：</p><ul><li>将行号放在地址线上</li><li>行地址选通 (row address strobe，RAS) 信号在行地址线上触发对行地址的解码</li><li>将列号放在地址线上</li><li>列地址选通 (column address strobe，CAS) 信号在列地址线上触发对列地址的解码</li><li>读取 1 比特数据 (定位到特定的 DRAM 单元)</li></ul><p>上述每个步骤切换时长<br />对内存性能有巨大影响，比如内存延时标识如 DDR3-9-9-9-24：</p><ul><li>tCL (CAS)：列地址选通和起始应答 (获得数据) 之间的时长</li><li>tRCD (RAS 到 CAS 的延迟)：之间可能导致的最短延迟时长</li><li>tRP (行预冲)：访问一行之前，对它进行预冲 (precharge) 所花费的时长。使用一行之前必须先对它进行预冲。</li><li>tRAS (行激活延迟)：激活一行以访问其信息的最短时长。这个时长通常至少是上面 3 个时长之和。</li></ul><p>若已经设置了需要访问的行和列，其所在位置数据几乎可以被即时读取。</p><ul><li>如果需要更改读取列，将花费 tCL 个时钟周期。</li><li>如果想要更改读取行，情况会更糟：必须先预冲 (tRP 个周期)，然后再经历 RAS 和 CAS 所导致的延迟 (tCL 和 tRCD 个周期)</li></ul><p>DRAM 存储器架构和它的延迟时长对于内存管理的影响：</p><ul><li>更改访问的行是耗时最长的操作，它包含了 RAS 信号、预冲等带来的延迟</li><li>因此内存循序访问模式远快于非循序访问模式</li></ul><p>注：尽量避免对内存的非循序访问。</p><h3 id="cpu"><a class="anchor" href="#cpu">#</a> CPU</h3><p>cpu 运行机制中的一个核心角色是寄存器，因为当前所有计算机都是以寄存器机器的形式实现的。</p><ul><li>cpu 操作数据时，访问寄存器是即时可得的，整个操作可以在一个处理器周期内完成，不存在任何形式延迟</li><li>寄存器是最靠近 cpu 的数据存储位置（当然，寄存器存储的是当前指令所需要的数据）</li></ul><h4 id="cpu-缓存"><a class="anchor" href="#cpu-缓存">#</a> CPU 缓存</h4><p>采用 SRAM 芯片，容量较小，但由于采用了高成本的方案，其速度可以与 CPU 匹敌或仅慢上一两个数量级<br />注：从 ISA (instruction set architecture)<br /> 的角度看，不管是程序员或操作系统，都不需要对它的运作进行任何管理。理想情况下应当仅是 cpu 的责任。</p><h4 id="缓存命中与未命中"><a class="anchor" href="#缓存命中与未命中">#</a> 缓存命中与未命中</h4><p>当处理器执行的指令需要访问内存 (不管是写操作还是读操作)，它首先查看缓存，检查需要的数据是否已经位于缓存中。</p><ul><li>如果存在，则可以以极快速度获取数据，即为缓存命中</li><li>若不存在，即为缓存未命中，处理器就需要从内存中读取数据，再将数据放到缓存</li></ul><h4 id="数据的局部性data-locality"><a class="anchor" href="#数据的局部性data-locality">#</a> 数据的局部性 (data locality)</h4><p>缓存的理念基于一个重要概念：数据局部性</p><ul><li>时间局部性：如果访问了一些内存区域，那么很可能很快还需要重复访问</li><li>空间局部性：如果访问了一些内存区域，那么临近区域很可能也会访问到</li></ul><p>缓存是一把双刃剑，如果我们写出的程序破坏了数据局部性，缓存反而会带来不必要的负担。</p><h4 id="缓存的实现"><a class="anchor" href="#缓存的实现">#</a> 缓存的实现</h4><p>缓存行 (cache line)：在内存与缓存之间传输数据时，以此数据块进行。其具有固定大小，在当今计算机中，大小都是 64 字节。<br />注意：不能从内存中读出或写入小于 cache line 大小 (64 字节) 的数据。即使从内存读取 1 比特也会一次性读取出整个 64 字节大小的一块数据。</p><ul><li>设计目的是为了更好地遵循 DRAM 访问 (预冲、RAS 延迟)</li></ul><p>由于对 DRAM 访问是以 64 位 (8 字节) 为单位，因此填充一个 cache line 需要与内存进行 8 次数据传输。</p><ul><li>由于 8 次传输需要花费相当多 cpu 周期时间，因此发展出一些优化，如：关键词优先和提前重启动 (critical word first &amp; early restart)，首先读取最需要的字并执行，cache line 剩余部分异步填充</li></ul><p>注：缓存修改分为直写和回写策略<br />另外注意：<br /><img data-src="/blogimages/2023/2023-06-26/-493473709.jpeg" alt="-493473709.jpeg" /></p><p>如对二维数组进行逐行索引和逐列索引的差异</p><h4 id="数据对齐"><a class="anchor" href="#数据对齐">#</a> 数据对齐</h4><p>对齐的意思是指数据的起始地址是给定对齐方式 (指定为 N 字节) 的整数倍。一个数据结构的对齐方式取决于它的字段的对齐方式。<br />未对齐数据访问速度相比已对齐数据慢很多，对于 CLR 数据结构，数据布局由运行时自身进行管理。</p><h4 id="非时态访问non-temporal-access"><a class="anchor" href="#非时态访问non-temporal-access">#</a> 非时态访问 (non-temporal access)</h4><p>在大多数常见 cpu 中，不能绕过缓存去直接访问内存，cpu 对 DRAM 的所有内存读取和写入操作，都存储于缓存中。<br />假设想要初始化一个大数组，但并非立即使用，正常情况下：</p><ul><li>数组将分块以 cache line 为单位依次被写入</li><li>每次写入操作都包含 3 个步骤：将 cache line 读入缓存；修改缓存内容；将 cache line 写回主内存</li><li>仅仅为了把数据写回主内存就需要填充 cache line，且会抢占本来可以用于其它程序的缓存</li></ul><p>可以通过一种称为非时态访问的汇编指令避免上述所说的缓存占用，指令包括：MOVNTI/MOVNTQ/MOVNTDQ 等，可以让程序员向内存写入数据时避免把数据加载到缓存中。<br />注：C# 可以通过 P/Invokes 调用 _mm_stream_si128</p><h4 id="预取"><a class="anchor" href="#预取">#</a> 预取</h4><p>数据局部性是让缓存自动起作用的特性 (只要程序员不破坏数据局部性就行)<br /> 不过还有另一种提高缓存利用率的机制：将短期之内可能用到的数据提前填充到缓存，因此称之为预取。</p><ul><li>硬件驱动：当 cpu 注意到一些缓存未命中的情况存在某些特定模式时触发。</li><li>软件驱动：在代码中通过 C/C++ 的 _mm_prefetch () 函数调用 PREFETCH0 指令显式触发</li></ul><p>与其它所有缓存机制类似，预取也是一把双刃剑。<br />如果在内存中不以正确的方法排列数据，预取和基于 cache line 访问内存等特性对性能显然起不到多大正面作用。<br />内存不仅是一块平坦的空间，如果我们总是从这里读取 1 字节，从那里读取 1 字节，就必然会承受相应的代价。</p><h4 id="分层缓存"><a class="anchor" href="#分层缓存">#</a> 分层缓存</h4><p>对于 cpu 架构，一方面我们需要高性能，另一方面又希望成本可控。因此都引入了一种更复杂的分层缓存设计。</p><p><img data-src="/blogimages/2023/2023-06-26/82046390.jpeg" alt="82046390.jpeg" /></p><p>一级缓存：被分为两个独立部分，一个用于数据，一个用于指令<br />二级、三级缓存：指令和数据被同等对待</p><p><img data-src="/blogimages/2023/2023-06-26/193791621.jpeg" alt="193791621.jpeg" /></p><h4 id="多核分层缓存"><a class="anchor" href="#多核分层缓存">#</a> 多核分层缓存</h4><p>cpu 每个核心都有独占的一级、二级缓存，并共享同一个三级缓存。<br />每个核都有自己的一级和二级缓存，只有三级缓存共享，这种架构导致引入了一个复杂概念：缓存一致性</p><ul><li>该机制用于维护数据一致性，通过缓存一致性协议 (一种将数据变化告知各个核的方法) 实现</li><li>存在许多高级的缓存一致性协议以及扩展，如流行的 MESI（modified、exclusive、shared、invalid）</li></ul><p>缓存一致性协议可以导致产生很大的内存通信流量，从而严重影响程序总体性能。</p><ul><li>因此编写代码应尽量避免从不同的核去访问相同的 cache line 下内存地址，最好完全避免跨线程通信</li></ul><p>伪共享：位于一个 cache line 中且理论上未被修改的数据，由于受到其它线程的影响而导致其不断变为无效状态。</p><p><img data-src="/blogimages/2023/2023-06-26/1855023160.jpeg" alt="1855023160.jpeg" /></p><h2 id="操作系统"><a class="anchor" href="#操作系统">#</a> 操作系统</h2><h3 id="虚拟内存"><a class="anchor" href="#虚拟内存">#</a> 虚拟内存</h3><p>每个程序直接管理真实物理地址非常麻烦和危险 (如避免干扰其它程序)，为此引入了该概念：</p><ul><li>将内存管理逻辑从程序转移到操作系统，并向程序提供虚拟地址空间。</li><li>这意味着每个进程都认为它上系统中运行着的唯一一个进程，所有内存都为自己所用。</li><li>而且由于地址空间是虚拟的，因此甚至可以大过实际物理内存大小 (扩展内存)。</li></ul><p>内存管理程序两个主要职责：</p><ul><li>将虚拟地址空间映射到物理内存：32 位、64 位计算机分别使用对应位长的虚拟地址。（目前 64 位通常使用低 48 位，可以支持最大 128TB 内存寻址）</li><li>将一些此时不需要的内存区域从 DRAM 转移到硬盘 (page file、swap file)</li></ul><p>虚拟内存在 cpu 中通过内存管理单元 (memory management unit，MMU) 执行并与操作系统协同工作。<br />每个进程都有一个由操作系统维护的 page 目录，作用是将一个虚拟地址映射到物理地址：page 目录中的一个条目指向一个 page 的物理起始地址等信息，典型的 page 大小是 4KB。<br />虚拟地址向物理地址转换需要遍历一个 tree 结构完成，会有开销，因此引入了将转换结果缓存的组件：translation look-aside buffers (TLB)</p><ul><li>类似键值对 map 结构，未命中才会执行一次代价高昂的 full-page 目录遍历</li></ul><h3 id="large-page"><a class="anchor" href="#large-page">#</a> Large Page</h3><p>虚拟地址转换成本可能较高，可以使用较大的 page，由于同一个 page 可以容纳许多地址，TLB 缓存转换结果后，地址转换需求就变少了（但大 page 同样会浪费资源）</p><h3 id="通用内存布局"><a class="anchor" href="#通用内存布局">#</a> 通用内存布局</h3><p><img data-src="/blogimages/2023/2023-06-26/-1670233885.jpeg" alt="-1670233885.jpeg" /></p><p>虚拟地址空间被划分为两个部分：</p><ul><li>内核空间：高位地址空间被操作系统占用</li><li>用户空间：低位地址空间被分配给进程</li></ul><p>注：看起来 stack 和 heap 最终似乎有可能碰到一起，但因为两者大小都是受限的，因此永远不会发生。<br />内存段：</p><ul><li>数据段：包含已初始化和未初始化的全局变量和静态变量</li><li>text 段：包含应用程序二进制和字符串文本 (根据定义，只包含只读数据)</li></ul><h3 id="windows-内存管理"><a class="anchor" href="#windows-内存管理">#</a> Windows 内存管理</h3><p>当 Windows 为一个进程保留内存区域时，将遵循如下限制：</p><ul><li>内存区域的起始地址和大小，都必须是系统 page 大小（通常 4KB）和分配粒度（通常 64KB）的整数倍，否则若试图分配小于粒度的内存空间，剩余部分将被标记为不可用。</li><li>因此为避免浪费，应使用合适的对齐方式和大小使用内存块</li></ul><p>既然 page 大小是 4KB，为何分配粒度是 64KB？</p><ul><li>历史原因导致</li></ul><h3 id="windows-内存布局"><a class="anchor" href="#windows-内存布局">#</a> Windows 内存布局</h3><p><img data-src="/blogimages/2023/2023-06-26/197102419.jpeg" alt="197102419.jpeg" /></p><p>.Net 中默认栈大小：</p><ul><li>典型 32 位：1MB</li><li>典型 64 位：4MB</li></ul><p>注 1：Windows 上初始线程栈大小取自可执行文件标头，因此也可通过修改 .Net 可执行二进制文件标头修改<br />注 2：出于安全考虑，系统引入了一种地址空间布局随机化 (address space layout randomization,ASLR) 的机制，因此上图并不能代表内存中真正的布局</p><h3 id="linux-内存管理"><a class="anchor" href="#linux-内存管理">#</a> Linux 内存管理</h3><p>由于 Linux 使用了相同硬件技术，包括 page、MMU 和 TLB，因此前面已涵盖大部分知识。</p><ul><li>例如 64 位系统依然是 48 位寻址</li><li>（注：查了下为什么不是 64 位，据说是因为会增加系统复杂度和地址转换成本，而且现目前几乎不可能用得到，因此先仅保留使用 48 位）</li></ul><p>当在 Linux 上分配内存时，并不会立即分配物理资源，直到访问该特定的内存区域时才会分配 —— 称为惰性分配机制，类似 Windows 保留机制类似。<br />注：Windows 的内存分配粒度是 64KB，而 Linux 分配内存只需按照 page 大小，即 4KB</p><h3 id="linux-内存布局"><a class="anchor" href="#linux-内存布局">#</a> Linux 内存布局</h3><p><img data-src="/blogimages/2023/2023-06-26/1884609898.jpeg" alt="1884609898.jpeg" /></p><p>Linux 处理线程栈与 Windows 有显著差别，Linux 没有两步 (two-stage) 内存保留机制，Linux 进程的栈按照需要进行扩展，不会提前保留相应内存 page</p><ul><li>由于下一个 page 按需创建，因此线程栈不会位于连续内存区域</li></ul><h2 id="numa-和-cpu-组"><a class="anchor" href="#numa-和-cpu-组">#</a> NUMA 和 CPU 组</h2><p>对称多处理器 (symmetric multiprocessing,SMP)：装备了多个独立 cpu 的计算机<br /> NUMA（non-uniform memory architecture, 非统一内存访问）：因为在 cpu 之间共享数据会存在明显延迟，因此从性能角度看，并非所有共享内存都是一样的，软件应感知到 numa 存在并选择位于本地而非更远的内存。</p><h2 id="本章总结"><a class="anchor" href="#本章总结">#</a> 本章总结</h2><p>避免随机访问，拥抱循序访问</p><ul><li>注：随机访问不仅指完全随机，也指没有使用一种可预测的模式进行有序访问</li></ul><p>提高时间和空间数据局部性</p><ul><li>有时，只需要确保数据结构足够小、预先分配并重复使用就可以保证</li></ul><p>不要放弃使用更高技巧的可能性</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>说来惭愧，端午节还额外请了两天假，结果待在家里竟然... 又玩起《三国志幻想大陆》了...<br /> 这游戏几年前就玩过，这次都到三周年庆了，记得跟原神好像是同一年出的？</p><p>因此这个假期，最终也只把这本书的第二章... 结尾看完了 (之前就看了大半的)。</p><hr /><p>所以， <code>人类不能高估自己的自制力，最好的克制方式就是：不听、不思、不闻</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-底层内存管理&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#第二章-底层内存管理&quot;&gt;#&lt;/a&gt; 第二章 底层内存管理&lt;/h1&gt;
&lt;h2 id=&quot;硬件&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#硬件&quot;&gt;#&lt;/a&gt; 硬件&lt;/h2&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Assets、Resources 和 AssetBundles-翻译-笔记</title>
    <link href="https://wangjiaying.top/2023/06/16/Unity3DAssets-ResourcesAndAssetBundles-%E7%AC%94%E8%AE%B0/"/>
    <id>https://wangjiaying.top/2023/06/16/Unity3DAssets-ResourcesAndAssetBundles-%E7%AC%94%E8%AE%B0/</id>
    <published>2023-06-16T08:23:25.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>最开始是因为项目的一个问题：微信的 Unity 转小游戏，转出来的  <code>XXXX.webgl.data.unityweb.bin.txt(首包资源文件)</code>  文件极大，其中占据数量最多的是一系列的  <code>MonoScript</code> ，且经过对比检查，其它占用够大的 Shader、图片或冗余资源都被我一一处理过了，但是呢这个文件依然很大。</p><p>达到什么程度呢？公司其它项目转出来只有 7M，而我们的达到了 16M？！这正常吗？不正常吧！</p><p>最麻烦的一点是：经过  <code>AssetStudio</code>  打开看之后，排头的只有寥寥几个资源，而且都不算大：</p><p><img data-src="/blogimages/2023/2023-06-16/Snipaste_2023-06-16_16-29-42.jpg" alt="" /></p><p>与只有  <code>7M</code>  资源的对比， <code>AssetStudio</code>  列出的文件基本上也是一样的。</p><p>于是去查找信息，结果找到 <span class="exturl" data-url="aHR0cHM6Ly9nd2IudGVuY2VudC5jb20vY29tbXVuaXR5L2RldGFpbC8xMjUwMjc=">Unity 资源管理 - 资源（Assets）、对象（Objects）和序列化 - 腾讯游戏学堂</span> ，然后又顺着其贴的原始文档找到了：  <span class="exturl" data-url="aHR0cHM6Ly9sZWFybi51bml0eS5jb20vdHV0b3JpYWwvYXNzZXRzLXJlc291cmNlcy1hbmQtYXNzZXRidW5kbGVz">Assets, Resources and AssetBundles - Unity Learn</span> 文章，这篇文章看着算是官方对 Unity 的资源系统的一个比较详细的描述了，有点熟悉..... 以前是不是见过？曾经好像零零散散在某些文章看到过，但是并不齐全，于是这次就整体过了一遍。</p><p>注：本文也并不是全文翻译，而是取自己觉得重要、或都知道什么情况的知识点就暂且忽略了 (如 AssetBundle 依赖管理)。</p><p>(当然截止本文完成的时候，依然没有找出资源大小的具体原因，打算后续把  <code>AssetStudio</code>  源码拉下来调试一下，看是不是有什么隐藏资源)</p><h1 id="资源与序列化"><a class="anchor" href="#资源与序列化">#</a> 资源与序列化</h1><h2 id="assets-and-objects"><a class="anchor" href="#assets-and-objects">#</a> Assets and Objects</h2><p>Asset：指的是一个存在于磁盘上的资源文件<br /> UnityEngine.Objects：一组序列化数据，共同描述资源的特定实例<br />大多数 Object  类型都是内置类型，除了两个例外：</p><ul><li>ScriptableObject：提供一个方便的自定义数据类型的系统，这些类型可以由 Unity 自动序列化和反序列化，并在 Unity 编辑器窗口中进行操作。</li><li>MonoBehaviour：提供对 MonoScript 引用的包装，MonoScript 是 Unity 用于保存对特定程序集和命名空间中特定脚本类的引用的内部数据类型</li></ul><p>Assets 和 Objects 之间是一对多的关系：任何给定的资产文件都包含一个或多个对象。</p><h2 id="标识与引用"><a class="anchor" href="#标识与引用">#</a> 标识与引用</h2><p>所有 UnityEngine.Objects 都可以引用其他 UnityEngine.Objects，被引用的 Object 可能在同一个 Asset 文件中，也可能在导入的其它 Asset 文件中</p><ul><li>在序列化后，这些引用由两部分独立的数据组成：FileGUID (标识资源位置) 和 LocalID (标识资源中的对象 [Object])<ul><li>FileGUID 存储在 .meta 文件中</li><li>FileGUID 提供了文件特定位置的抽象，只要特定文件 GUID 可以与特定文件相关联，该文件在磁盘上的位置就变得无关紧要。该文件可以自由移动，而无需更新引用该文件的所有对象。<ul><li>由于任何给定的资产文件可能包含（或通过导入生成）多个 UnityEngine.Object 资源，因此需要 LocalID 来明确区分每个不同的对象。</li></ul></li><li>Unity 编辑器将文件路径和 FileGUID 进行映射，每当加载或导入 Asset 时，都会记录一个映射条目。</li></ul></li><li>注：如果 .meta 文件在 Unity 编辑器关闭时丢失，或者 Asset 的路径发生变化而 .meta 文件没有随 Asset 一起移动，那么对该 Asset 中对象的所有引用都将被破坏。</li></ul><p>尽管 FileGUID 和 LocalID 足够稳健，但 GUID 比较速度较慢</p><ul><li>因此 Unity 在内部维护了一份缓存（PersistentManager），它将 FileGUID 和 LocalID 转换成简单的、会话唯一（Session-unique）的整数：这些整数被称为 InstanceID，当有新的对象注册到缓存时，InstanceID 以简单的、单调递增的顺序分配</li><li>在启动时，游戏会立即初始化包含所有被项目需要的对象 (例如在内置场景中引用)、以及 Resources 文件夹中包含的所有对象的 InstanceID 缓存<ul><li>当在运行时创建新资源 (如 new Texture2D) 以及从 AssetBundle 加载对象时，新的条目也将添加到缓存中</li><li>在提供具体 FileGUID 和 LocalID 的 AssetBundle 被卸载时，会从缓存中移除 InstanceID 条目。这时原来的 InstanceID、FileGUID 和 LocalID 会被删除，如果再次加载了这个 AssetBundle，则会重新生成新的 InstanceID</li><li>注：当应用程序暂停时，可能从 iOS 上的图形内存中卸载图形资源，如果这些对象来源于已卸载的 AssetBundle，Unity 将无法重新加载对象的源数据。对这些对象的任何现有引用也将无效</li></ul></li><li>注：当构建项目时，FileGUID 和 LocalID 会被确定性地映射到更简单的格式 (这也是不能在运行时查询  Asset 的 FileGUID 的原因)，但概念仍然是相同的</li></ul><h1 id="monoscript"><a class="anchor" href="#monoscript">#</a> MonoScript</h1><p>其重点是 MonoBehaviour 引用 MonoScript (MonoBehaviour 就是 MonoScript 的包装器)，而 MonoScripts 只包含定位特定脚本类所需的信息，两种类型的对象都不包含脚本类的可执行代码。</p><ul><li>MonoScript 包含三个字符串：程序集名称、类名称和命名空间。</li></ul><p>当构建项目时，Unity 将 Assets 文件夹中所有松散的脚本文件编译成 Mono 程序集 (它们也是 MonoScript 引用的程序集)</p><ul><li>Plugins 子文件夹外的 C# 脚本被放入 Assembly-CSharp.dll</li><li>Plugins 子文件夹中的脚本被放入 Assembly-CSharp-firstpass.dll</li><li>注：还可以自定义程序集</li></ul><p>与其他资源不同，Unity 应用程序中包含的所有程序集都在应用程序启动时加载<br />这允许不同的 MonoBehaviours 引用特定的共享类，即使 MonoBehaviours 在不同的 AssetBundle 中。</p><h1 id="资源加载"><a class="anchor" href="#资源加载">#</a> 资源加载</h1><h2 id="加载方式"><a class="anchor" href="#加载方式">#</a> 加载方式</h2><p>在以下情况下会自动加载对象：</p><ul><li>映射到该对象的 InstanceID 被间接引用</li><li>该对象当前未加载到内存中</li><li>可以定位 (找到) 对象的源数据</li></ul><p>对象也可以在代码中显式加载，比如直接代码创建或调用资源加载 API (例如 AssetBundle.LoadAsset)<br /> 加载一个对象时，Unity 会尝试通过由每个被引用对象的 FileGUID 和 LocalID 转换而成的 InstanceID 来解析任何引用。<br />对象被间接引用而导致按需加载的条件：</p><ul><li>InstanceID 引用当前未加载的对象</li><li>InstanceID 具有在缓存中注册的有效 FileGUID 和 LocalID</li></ul><p>注 1：可以通过调用 Resources.UnloadAsset API 显式卸载来自 Resources 文件夹的对象，不过这些对象的 InstanceID 仍然有效，并且仍将包含有效的 FileGUID 和 LocalID 条目，只要被任何活动对象间接引用时，就会重新加载该对象<br />注 2：注意任何标有 HideFlags.DontUnloadUnusedAsset 和 HideFlags.HideAndDontSave 的东西都不会被卸载</p><h2 id="大资源加载消耗"><a class="anchor" href="#大资源加载消耗">#</a> 大资源加载消耗</h2><p>创建任何 GameObject 层次结构时，CPU 时间主要花费在以下几种方式上：</p><ul><li>读取源数据（从存储、AssetBundle、另一个 GameObject 等）</li><li>设置新 Transform 之间的父子关系</li><li>实例化新的游戏对象和组件</li><li>在主线程上唤醒新的游戏对象和组件</li></ul><p>后三种时间成本通常是不变的，无论层次结构是从现有层次结构中克隆还是从存储中加载。然而，读取源数据的时间随着序列化到层次结构中的组件和游戏对象的数量线性增加，并且还乘以数据源的速度。</p><ul><li>在所有当前平台上，从内存中的其他位置读取数据比从存储设备加载数据要快得多，加载操作的成本与存储 I/O 时间有关。</li></ul><p>如前所述，在序列化单体预制件时，每个 GameObject 和组件的数据都是单独序列化的，这可能会重复数据。</p><ul><li>例如，具有 30 个相同元素的 UI 屏幕会将相同元素序列化 30 次，从而产生大量二进制数据。</li><li>在加载时，必须从磁盘读取这 30 个重复元素中每一个的所有游戏对象和组件的数据，然后再传输到新实例化的对象。此文件读取时间是实例化大型预制件的总成本的主要消耗。</li><li>因此，大型层次结构对象应该在模块化中实例化，然后在运行时结合在一起。</li></ul><p>注：在实例化一个立即会重新设置为另一个对象子节点的新游戏对象时，请使用接受父对象参数的 GameObject.Instantiate 重载变体。使用此重载可避免为新游戏对象分配根变换层次结构。在测试中，这将实例化操作所需的时间加快了大约 5-10%。</p><h1 id="resources-目录"><a class="anchor" href="#resources-目录">#</a> Resources 目录</h1><p><strong>不要使用</strong><br />缺点很明显：</p><ul><li>使用 Resources 文件夹使细粒度的内存管理更加困难</li><li>资源文件夹使用不当会增加应用程序启动时间和构建时间</li><li>Resources 系统降低了项目向特定平台交付自定义内容的能力，并消除了增量内容升级的可能性<ul><li>AssetBundle Variants 可以用于根据每个设备调整内容</li></ul></li></ul><p>总之，官方是非常不推荐使用的，也许快速原型阶段可以使用，但当项目进入全面生产阶段时，应取消使用 Resources 文件夹<br />构建项目时，所有名为 Resources 的文件夹中的资源和对象都合并到一个序列化文件中。该文件还包含元数据和索引信息，类似于 AssetBundle。如 AssetBundle 文档中所述，该索引包括一个序列化查找树，用于将给定对象的名称解析为其适当的 FileGUID 和 LocalID。它还用于在序列化文件主体中的特定字节偏移处定位对象。</p><ul><li>在应用程序启动时，也会进行 Resources 资源数据结构的构建</li><li>在大多数平台上，查找数据结构是一个平衡的搜索树，其构建时间以 O (n log (n)) 的速度增长。随着资源文件夹中对象数量的增加，这种增长也会导致索引的加载时间以超线性方式增长。</li></ul><h1 id="assetbundle"><a class="anchor" href="#assetbundle">#</a> AssetBundle</h1><p>AssetBundle 由两部分组成：标头和数据段<br />标头</p><ul><li>包含有关 AssetBundle 的信息，例如其标识符、压缩类型和清单。清单是一个以对象名称为关键字的查找表。每个条目都提供一个字节索引，指示在 AssetBundle 的数据段中可以找到给定对象的位置。在大多数平台上，此查找表被实现为平衡搜索树。具体来说，Windows 和 OSX 衍生平台（包括 iOS）采用红黑树。因此，随着 AssetBundle 中资产数量的增长，构建清单所需的时间将超过线性增长。</li></ul><p>数据段</p><ul><li>数据段包含序列化 AssetBundle 中的 Assets 生成的原始数据。如果将 LZMA 指定为压缩方案，则会压缩所有序列化资产的完整字节数组。如果改为指定 LZ4，则单独压缩单独资产的字节。如果不使用压缩，数据段将保持为原始字节流。</li></ul><p>通常，Unity 会缓存一份 AssetBundle 的解压副本，以提高后续对同一个 AssetBundle 的加载请求的加载性能。</p><h2 id="加载-assetbundle-方式"><a class="anchor" href="#加载-assetbundle-方式">#</a> 加载 AssetBundle 方式</h2><h3 id="assetbundleloadfrommemoryasync"><a class="anchor" href="#assetbundleloadfrommemoryasync">#</a> AssetBundle.LoadFromMemory(Async)</h3><p>建议是不要使用这个 API</p><ul><li>这个 API 会从托管代码字节数组（C# 中的 byte []）加载 AssetBundle。它总是将源数据从托管代码字节数组复制到新分配的、连续的本机内存块中。如果 AssetBundle 是 LZMA 压缩的，它会在复制时解压 AssetBundle。未压缩和 LZ4 压缩的 AssetBundle 将被逐字复制。</li></ul><p>此 API 消耗的内存峰值量将至少是 AssetBundle 大小的两倍：一份在 API 创建的本机内存中，一份在传递给 API 的托管字节数组中。</p><ul><li>因此，从通过此 API 创建的 AssetBundle 加载的资源将在内存中复制三次：一次在托管代码字节数组中，一次在 AssetBundle 的本机内存副本中，第三次在资源本身的 GPU 或系统内存中</li></ul><h3 id="assetbundleloadfromfileasync"><a class="anchor" href="#assetbundleloadfromfileasync">#</a> AssetBundle.LoadFromFile(Async)</h3><p>这是一个高效的 API，用于从本地存储（如硬盘或 SD 卡）加载 AssetBundle。</p><ul><li>在桌面、控制台和移动平台上，API 只会加载 AssetBundle 的标头，剩余数据依然保留在磁盘上。<ul><li>AssetBundle 的对象将在调用加载方法（例如 AssetBundle.Load）或取消引用它们的 InstanceID 时按需加载。在这种情况下不会消耗过多的内存。</li></ul></li><li>在 Unity Editor 中，API 会将整个 AssetBundle 加载到内存中，就像从磁盘读取字节并使用 AssetBundle.LoadFromMemoryAsync 一样。如果在 Unity 编辑器中分析项目，此 API 可能会导致在 AssetBundle 加载期间出现内存峰值。这不影响真机性能，在采取修复措施之前应在真机设备上重新测试这些内存峰值情况。</li></ul><h3 id="unitywebrequestgetassetbundle"><a class="anchor" href="#unitywebrequestgetassetbundle">#</a> UnityWebRequest.GetAssetBundle</h3><p>这个 API 会使用工作线程，将下载的数据流式传输到固定大小的缓冲区，然后将缓冲的数据保存到临时存储或 AssetBundle 缓存，具体取决于下载处理程序的配置方式。</p><ul><li>所有这些操作都发生在本机代码中，从而消除了扩展托管堆的风险。</li><li>此外，此下载处理程序不会保留所有下载字节的本机代码副本，从而进一步减少了下载 AssetBundle 的内存开销</li></ul><p>注：LZMA 压缩的 AssetBundle 将在下载期间解压缩并使用 LZ4 压缩进行缓存。可以通过设置 Caching.CompressionEnabled 来更改此行为。</p><ul><li>如果缓存已满，Unity 将从缓存中删除最近最少使用的 AssetBundle</li><li>注：缓存系统中的 AssetBundle 仅由文件名标识 (而不是下载的完整 URL)</li></ul><p>下载完成后，AssetBundle 属性提供的对下载的 AssetBundle 的访问，与已在下载的 AssetBundle 上调用 AssetBundle.LoadFromFile 一样。</p><ul><li>如果向 UnityWebRequest 对象提供缓存信息，并且请求的 AssetBundle 已存在于 Unity 的缓存中，则此 API 的操作与 AssetBundle.LoadFromFile 相同。</li></ul><p>注 1：请确保下载程序代码在加载 AssetBundle 后正确调用 Dispose (或使用 using 语句)<br /> 注 2：更多缓存机制详情参考原文缓存机制部分<br />注 3：官方推荐若想自己实现细粒度资源下载管理，使用 C# HttpWebRequest 或自定义本机代码，官方强烈建议使用 Application.persistentDataPath 作为持久存储位置</p><h3 id="wwwloadfromcacheordownload"><a class="anchor" href="#wwwloadfromcacheordownload">#</a> WWW.LoadFromCacheOrDownload</h3><p>从 Unity 2017.1 开始，这个 API 只是对 UnityWebRequest 的包装，以后可能会直接弃用。</p><h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3><p>总之，应尽可能使用 AssetBundle.LoadFromFile，这个 API 在速度、磁盘使用和运行时内存使用方面都是最有效的。<br />对于必须下载或修补 AssetBundles 的项目，建议使用 UnityWebRequest。<br />对于需要独特、特定缓存或下载要求的项目，可以考虑使用自定义下载器。任何自定义下载器都应该与 AssetBundle.LoadFromFile 兼容。</p><h2 id="加载-assetbundle-中的资源"><a class="anchor" href="#加载-assetbundle-中的资源">#</a> 加载 AssetBundle 中的资源</h2><p>可以使用三个不同的 API 从 AssetBundle 加载，这些 API 都属于 AssetBundle 对象的实例方法 (并且可选同步或异步)：</p><ul><li>LoadAsset (LoadAssetAsync)</li><li>LoadAllAssets (LoadAllAssetsAsync)</li><li>LoadAssetWithSubAssets (LoadAssetWithSubAssetsAsync)</li></ul><p>这些 API 的同步版本总是比异步版本快至少一帧。</p><ul><li>异步加载将每帧加载多个对象，直到它们达到时间片限制 (参考底层加载细节)。</li></ul><p>LoadAllAssets</p><ul><li>应该在加载多个独立的 UnityEngine.Objects 时使用。仅当需要加载 AssetBundle 中的大部分或所有对象时才应使用它。与其他两个 API 相比，LoadAllAssets 比多次单独调用 LoadAssets 稍微快一些。</li><li>因此，如果要加载的资源数量较多，但一次需要加载的 AssetBundle 不到 66%，可以考虑将 AssetBundle 拆分成多个更小的 bundle，使用 LoadAllAssets。</li></ul><p>LoadAssetWithSubAssets</p><ul><li>应该在加载包含多个嵌入式对象的复合资产时使用，例如带有嵌入式动画的 FBX 模型或其中嵌入了多个精灵的精灵图集。</li><li>如果需要加载的 Object 都来自同一个 Asset，但是和很多其他不相关的 Object 存储在一个 AssetBundle 中，那么就使用这个 API。</li></ul><p>对于任何其他情况，使用 LoadAsset 或 LoadAssetAsync</p><h2 id="底层加载细节"><a class="anchor" href="#底层加载细节">#</a> 底层加载细节</h2><p>UnityEngine.Object 加载是在主线程之外执行的：对象的数据使用工作线程从磁盘读取。</p><ul><li>任何不涉及 Unity 系统的线程敏感部分（脚本、图形）的内容都将在工作线程上进行转换。</li><li>例如，VBO 将从网格创建，纹理将被解压等。</li></ul><p>从 Unity 5.3 开始，对象加载已经并行化。多个对象在工作线程上被反序列化、处理和集成。当一个对象完成加载时，将调用其 Awake 回调，并且该对象将在下一帧期间可供 Unity 引擎的其余部分使用。<br />同步 AssetBundle.Load 方法将暂停主线程，直到对象加载完成。它们还将对对象加载进行时间切片，限制每帧的占用的总的加载时间不会超过超过一定毫秒数。毫秒数由属性 Application.backgroundLoadingPriority 设置：</p><ul><li>ThreadPriority.High：每帧最多 50 毫秒</li><li>ThreadPriority.Normal：每帧最多 10 毫秒</li><li>ThreadPriority.BelowNormal：每帧最多 4 毫秒</li><li>ThreadPriority.Low：每帧最多 2 毫秒</li></ul><p>假设所有其他因素都相同，资产加载 API 的异步版本将始终比对应同步版本花费更长的时间来完成，因为发出异步调用和对象对引擎可用之间的至少也有最小一帧的延迟。</p><h2 id="assetbundle-依赖"><a class="anchor" href="#assetbundle-依赖">#</a> AssetBundle 依赖</h2><p>根据运行时环境，可以使用两个 API 自动跟踪 AssetBundle 之间的依赖关系：</p><ul><li>在 UnityEditor 中，可以通过 AssetDatabase API 查询 AssetBundle 依赖项</li><li>在运行时，Unity 提供了一个可选的 API ：AssetBundleManifest，可以加载在 AssetBundle 构建期间生成的依赖信息。</li></ul><p>如之前的序列化和实例部分所述，AssetBundle 充当其中包含的每个对象的 FileGUID 和 LocalID 标识的源数据的来源。<br />因为一个对象是在它的 InstanceID 第一次被间接引用时加载的，并且在加载一个 AssetBundle 时其中对象会被分配一个有效的 InstanceID，因此加载 AssetBundle 的顺序并不重要。</p><ul><li>相反，重要的是在加载对象本身之前加载所有包含对象依赖项的 AssetBundle (但不必显式去加载依赖资源)。</li><li>注：Unity 不会尝试自动加载任何被依赖的 AssetBundle 包本身</li></ul><h2 id="assetbundle-manifests"><a class="anchor" href="#assetbundle-manifests">#</a> AssetBundle manifests</h2><p>当使用 BuildPipeline.BuildAssetBundles API 执行 AssetBundle 构建时，Unity 会序列化一个包含每个 AssetBundle 的依赖信息的对象。</p><ul><li>此数据存储在单独的，与构建 AssetBundle 的父目录同名的 AssetBundle 中，其中包含一个 AssetBundleManifest 类型的对象。</li><li>例如构建目的目录为：<ul><li><em>(projectroot)/build/Client/</em></li><li>则包含清单的 AssetBundle 将被保存为：<em>(projectroot)/build/Client/Client.manifest</em></li></ul></li></ul><p>包含清单的 AssetBundle 可以像任何其他 AssetBundle 一样加载、缓存和卸载：</p><ul><li>AssetBundle bundle =AssetBundle.LoadFromFile((projectroot)/build/Client/Client)</li><li>AssetBundleManifest manifest =bundle.LoadAsset<AssetBundleManifest>(&quot;AssetBundleManifest&quot;);</li></ul><p>AssetBundleManifest 对象本身提供了 GetAllAssetBundles API 来列出与清单同时构建的所有 AssetBundle，并提供两种方法来查询特定 AssetBundle 的依赖项：</p><ul><li>AssetBundleManifest.GetAllDependencies 返回 AssetBundle 的所有层次依赖关系，包括 AssetBundle 的直接子项、其子项的子项等的依赖项</li><li>AssetBundleManifest.GetDirectDependencies 仅返回 AssetBundle 的直接子级依赖</li></ul><p>注意：这两个 API 都分配字符串数组。因此它们应该被谨慎使用，而不是在应用程序生命周期的性能敏感部分使用。</p><h2 id="卸载-assetbundle-方式"><a class="anchor" href="#卸载-assetbundle-方式">#</a> 卸载 AssetBundle 方式</h2><p>切换场景 (即当 SceneManager.LoadScene 被非附加地调用时)</p><ul><li>将销毁当前场景中的所有对象并自动调用 Resources.UnloadUnusedAssets</li></ul><p>脚本调用 Resources.UnloadUnusedAssets 时</p><ul><li>此过程仅卸载未引用的对象：仅当没有 Mono 变量持有对对象的引用并且没有其他活动对象持有对对象的引用时，才会卸载对象</li></ul><p>调用 AssetBundle.Unload (true) API 时，源自 AssetBundle 的对象会自动并立即卸载</p><ul><li>这会使对象实例 ID 的文件 GUID 和本地 ID 无效，并且对已卸载对象的任何实时引用都将成为 Missing 引用</li><li>在 C# 脚本中，尝试访问已卸载对象的方法或属性将产生 NullReferenceException</li><li>如果调用 AssetBundle.Unload (false)--<em> 不推荐使用</em>，来自已卸载 AssetBundle 的活动对象将不会被销毁，但 Unity 将使其 FileGUID 和 LocalID 引用无效。如果稍后从内存中卸载这些对象并且对卸载对象的实时引用仍然存在，Unity 将不可能重新加载这些对象。</li></ul><p>注：当 Unity 失去对其图形上下文的控制时，对象在运行时会从显存中移除。这可能发生在移动应用程序暂停并且应用程序被迫进入后台时。在这种情况下，移动操作系统通常会从 GPU 内存中逐出所有图形资源。当应用程序返回前台时，Unity 必须在场景渲染恢复之前将所有需要的纹理、着色器和网格重新加载到 GPU (如果 AssetBundle 已经被卸载，就会导致问题)</p><h2 id="注意-安卓"><a class="anchor" href="#注意-安卓">#</a> 注意 - 安卓</h2><p>安卓平台：</p><ul><li>在 Android 上，StreamingAssets 文件夹中的资源存储在 APK 中，如果它们被压缩可能需要更多时间来加载，因为存储在 APK 中的文件可以使用不同的存储算法。</li><li>使用 7-zip 等归档程序打开 APK 可以确定文件是否被压缩，如果是则 AssetBundle.LoadFromFile 肯定执行得更慢，这种情况下可以使用 UnityWebRequest.GetAssetBundle 作为解决方法来检索缓存的版本。通过使用 UnityWebRequest，AssetBundle 将在第一次运行期间被解压缩和缓存，从而使后续执行速度更快。但是将占用更多存储空间，因为 AssetBundle 将被复制到缓存中。</li><li>或者可以编辑 build.gradle 文件并将该扩展名添加到 noCompress 部分，这样使用 AssetBundle.LoadFromFile () 也能无需消耗额外解压缩成本。</li></ul><h2 id="总结-2"><a class="anchor" href="#总结-2">#</a> 总结</h2><p>多数情况下，最好在玩家进入程序的性能关键区域（例如主游戏关卡或世界）之前加载尽可能多的所需对象。这在移动平台上尤为重要，因为在移动平台上访问本地存储很慢，并且在运行时加载和卸载对象的内存波动会触发 GC<br /> 使用 AssetBundle.LoadFromFile 加载资源并采用 AssetBundle.Unload (true) 释放资源。</p><h1 id="参考文档"><a class="anchor" href="#参考文档">#</a> 参考文档</h1><p><span class="exturl" data-url="aHR0cHM6Ly9nd2IudGVuY2VudC5jb20vY29tbXVuaXR5L2RldGFpbC8xMjUwMjc=">Unity 资源管理 - 资源（Assets）、对象（Objects）和序列化 - 腾讯游戏学堂</span><br /><span class="exturl" data-url="aHR0cHM6Ly9sZWFybi51bml0eS5jb20vdHV0b3JpYWwvYXNzZXRzLXJlc291cmNlcy1hbmQtYXNzZXRidW5kbGVz"> Assets, Resources and AssetBundles - Unity Learn</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;最开始是因为项目的一个问题：微信的 Unity 转小游戏，转出来的  &lt;code&gt;XXXX.webgl.data.unityweb.bin.txt(首包资源文件)&lt;</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/categories/Unity3D/"/>
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/tags/Unity3D/"/>
    
    <category term="性能优化" scheme="https://wangjiaying.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="翻译" scheme="https://wangjiaying.top/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>《.NET内存管理宝典》-笔记(1)</title>
    <link href="https://wangjiaying.top/2023/06/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8_1/"/>
    <id>https://wangjiaying.top/2023/06/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8_1/</id>
    <published>2023-06-12T02:56:47.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>之前的几本书，都是  <code>全都读完</code>  之后，再将笔记从语雀转移到自己的 Hexo 博客上，但是想想一本书有多少？笔记就算记得再少也少不到哪里去。</p><p>这就导致一个问题：文字太多，自己都...em...</p><p>于是这次想转变一下思路和做法，感觉可以单独先『移记』一下的，那就先在整理到博客上。</p><h1 id="第一章-基本概念"><a class="anchor" href="#第一章-基本概念">#</a> 第一章 基本概念</h1><h2 id="术语"><a class="anchor" href="#术语">#</a> 术语</h2><p>位 (bit)：小写字母 b 指代位<br />字节 (byte)：使用大写字母 B 表示<br />随机存取存储器 (RAM)：允许不管访问的存储器区域如何，都能在相同的访问时间内读取数据<br />非均匀访问存储器：与 RAM 相反，访问存储器所需时间取决于其在物理存储器上的位置（在访问之前必须将存储介质放置，例如旋转到正确位置）<br />地址 (address)：表示整个存储区中的特定位置<br />算数逻辑单元 (ALU)：负责执行加法和减法运算，计算机核心。现代计算机包括多个 ALU，可实现计算并行化<br />控制单元 (control unit)：解码从内存中读取的程序指令 (操作码)。根据内部指令的描述，执行哪些算数或逻辑运算以及要对哪些数据进行运算</p><ul><li>控制单元存储一个称为指令指针 (IP) 或程序计数器 (PC) 的附加寄存器，以指向当前执行的指令。正常程序执行非常简单，只需要将存储在 PC 中的地址递增到后续指令即可，循环或跳出之类就像将指令指针的值更改为另一个地址和指定要移动程序执行的位置一样简单。</li><li>注：严格说，操作码只是指令的一部分，指令包括操作码和地址码</li></ul><p><img data-src="/blogimages/2023/2023-06-12/-1807417749.jpeg" alt="" /></p><p>寄存器 (register)：通常包含在内存中的可以直接从 ALU 和 / 或控制单元 (可以统称为执行单元) 快速访问的内存位置，速度极快，没有地方比它更接近执行单元的了<br />字 (word)：特定计算机设计中使用的固定大小的基本数据单位。反映在许多设计领域，如大多数寄存器大小、最大地址或在单个操作中传输的最大数块。常用位表示，称为字长。如 32 位或 64 位长寄存器。</p><h3 id="静态分配"><a class="anchor" href="#静态分配">#</a> 静态分配</h3><p>在编译期间，甚至在执行程序之前，就必须知道所需内存的数量和确切位置</p><h3 id="寄存器机"><a class="anchor" href="#寄存器机">#</a> 寄存器机</h3><p>使用寄存器 (或特殊情况下的累加器) 在算数逻辑单元 (ALU) 上操作的机器。<br />构成这种设计的机器称为寄存器机：因为在这样的机器上执行程序时，实际上是在寄存器上进行计算。如果要进行加法、除法或其它操作时，必须先将对应的数据从内存加载到对应的寄存器中，然后调用特定指令对其执行对应操作，然后调用另一个指令将其中一个寄存器的结果存储到内存中。</p><h3 id="堆栈stack"><a class="anchor" href="#堆栈stack">#</a> 堆栈 (Stack)</h3><p>概念上，堆栈是一种数据结构，可以简单地描述为 后进先出 (LIFO) 列表<br />堆栈一开始就与计算机编程有着内在联系，主要是因为子例程的概念<br />堆栈帧 (stack frame)：为特定目的保存在堆栈上的任何结构化数据</p><ul><li>嵌套调用子例程只需要重复这个模式，即可为每个调用添加一个活动帧</li><li>子例程调用的嵌套越多，堆栈上的活动帧就越多（这也使得无限嵌套调用成为不可能）</li></ul><p><img data-src="/blogimages/2023/2023-06-12/-888697750.jpeg" alt="" /></p><p>如图所示，堆栈指针 (SP) 保留一个指示堆栈当前边界的地址。程序计数器 (PC) 指向执行函数内部某个位置<br />现代计算机中的堆栈既有硬件层面 (通过为堆栈指针提供专用寄存器) 的支持，也有软件层面 (通过操作系统对线程及其指定为堆栈的内存部分的抽象) 的支持</p><ul><li>堆栈可以存储在 cpu 内部专用内存块或专用芯片上</li><li>也可以直接重用普通计算机内存（大多数现代架构中情况）</li></ul><h3 id="堆栈机"><a class="anchor" href="#堆栈机">#</a> 堆栈机</h3><p>与寄存器不同，在堆栈机中，所有指令都在专用表达式堆栈 (或求值堆栈) 上操作。</p><ul><li>注：此处堆栈机与前文讨论的堆栈不必相同</li></ul><p>在这样的计算机中，默认情况下，指令从表达式堆栈顶部获取参数，结果也存储在堆栈顶部，这种情况下它们被称为纯堆栈计算机</p><ul><li>与不纯的实现相对应 (当操作不仅可以从堆栈顶部访问值，而且还可以访问更深的值时，称为不纯的实现)</li></ul><p>表达式堆栈操作：</p><ul><li>例如，假想的乘法指令，将从求值堆栈顶部弹出两个值，将其相乘，然后将结果放回求值堆栈</li></ul><p>堆栈机概念带来了非常清晰和易于理解的代码</p><ul><li>与如何以及在何处存储临时值无关，不管是在寄存器、堆栈还是在主内存。<ul><li>从概念上将，比试图以最佳方式管理所有这些可能的目标更容易，因此简化了实现。</li></ul></li><li>由于存在许多无操作数或单操作数指令，因此在所需内存方面操作码可以更短<ul><li>这允许对指令进行高效的二进制编码，从而产生高密度的二进制代码。因此即使指令数量可能比基于寄存器机的方法要多 (由于更多的加载 / 存储操作)，但仍然是受益的</li></ul></li></ul><p>尽管堆栈机有其优点，但它很少在硬件上实现。但这种架构是设计独立于平台的虚拟机或执行引擎的好方法。（如 java 虚拟机和 .net 运行时就是堆栈机的完美示例，它们实现了堆栈机逻辑，并由 x86 或 ARM 寄存器机执行）<br />虚拟堆栈机 (不是由真正的硬件堆栈机执行的堆栈机) 可以在生成高性能代码的同时提供良好的平台独立性。<br />堆栈机代码的层次更高，可以更好地从实际底层硬件抽象出来，其概念非常简单、优雅和高效。</p><ul><li>另一方面，基于寄存器的虚拟机设计更接近其实际运行的真实硬件设计，对可能的优化更有用（所解释的代码与机器代码相似越多，效果越好）</li></ul><p>目前 .Net 执行引擎是作为一个堆栈机实现的，不过并不是完全纯的，例如会将求值堆栈映射到包含寄存器和内存的底层硬件上。<br />注：并非所有虚拟机和执行引擎都是堆栈机</p><h3 id="指针"><a class="anchor" href="#指针">#</a> 指针</h3><p>将位置地址存储在内存中的变量，允许通过地址引用内存中的其它位置。<br />指针大小与字长有关，由计算机架构决定，如今我们通常处理 32 位或 64 位宽的指针。由于只是内存的一小部分，因此也可以将其放置在堆栈中 (例如作为局部变量或函数参数) 或 cpu 寄存器上。<br />指针还可以提供指针算数，可以加上或减去内存的相对引用部分。</p><ul><li>例如增量运算符将指针的值加上指向的对象大小的值，而不是单个字节。</li></ul><p>悬空指针：释放后没有置为 null</p><h3 id="堆heap"><a class="anchor" href="#堆heap">#</a> 堆 (Heap)</h3><p>堆 (也称为自由存储区) 是一个用于动态分配对象的内存区域。</p><ul><li>自由存储区：没有体现任何内部结构，而只体现了一个目的。</li><li>与有序的堆栈空间相反，堆传统英语含义：混乱的地方</li><li>注：堆数据结构与堆没有关系</li></ul><p>堆是一种内存机制，能够提供具有指定大小的连续内存块。该操作被称为动态内存分配。</p><ul><li>由于内存的位置在编译时是不知道的，因此动态分配的内存必须要由指针来引用，因此指针与堆本质上是相关的。</li><li>指针可以存放在堆栈中、堆本身或其它任何地方。</li></ul><p>堆碎片：尽管堆上有足够可用空间，但是并不连续。</p><h2 id="自动内存管理"><a class="anchor" href="#自动内存管理">#</a> 自动内存管理</h2><p>最初在 lisp 语言中诞生，自动内存管理和垃圾回收名称可以互换使用。<br />可以将其定义为一种机制，该机制一旦创建对象，便会在不再需要时自动销毁 (并且恢复它们的内存)，从而使程序员无需承担手动内存管理的责任。<br />但，即使内存管理是完全自动化的，也会产生问题。</p><h3 id="mutator"><a class="anchor" href="#mutator">#</a> Mutator</h3><p>内存管理最基本也是最重要的概念，称为 mutator 的抽象。<br />最简单来看，可以将 mutator 定义为负责执行应用程序代码的实体，或者说所有可能修改内存的东西，无论是通过修改现有对象还是通过创建新对象。</p><ul><li>是应用程序中有关内存的所有更改的驱动器。</li></ul><p>为了完全可操作，mutator 需要为运行的应用程序提供以下三种操作：</p><ul><li>new (amount)：分配给定数量内存，然后由新创建对象使用（这种抽象级别上，不考虑对象的类型信息，只是提供所需分配的内存大小）</li><li>write (address,value)：在给定地址下写入指定值</li><li>read (address)：从指定地址读取一个值</li></ul><p>mutator 抽象最常见的一个实现是基于线程。不过就操作系统线程而言，不必将 mutator 实现为线程，例如 erlangVM、fiber</p><h3 id="分配器allocator"><a class="anchor" href="#分配器allocator">#</a> 分配器 (Allocator)</h3><p>分配器是一个负责管理动态内存分配和解除分配的实体。<br />分配器必须提供两个主要操作：</p><ul><li>Allocator.Allocate (amount)：分配指定数量内存<ul><li>如果类型信息可用于分配器，则可以通过能够为特定类型的对象分配内存的方法来扩展此方法，如被 Mutator.New 操作内部使用</li></ul></li><li>Allocator.Deallocate (address)：释放给定地址下的内存以供将来分配。<ul><li>在自动内存管理情况下，此方法为内部方法，不会暴露给 Mutotor (用户不可显式调用)</li></ul></li></ul><p>两种最流行的分配器：顺序和自由列表</p><h3 id="回收器collector"><a class="anchor" href="#回收器collector">#</a> 回收器 (Collector)</h3><p>当我们将 mutator 定义为负责执行应用程序代码的实体时，也可以将回收器定义为运行垃圾回收 (自动回收内存) 代码实体。<br />可达性并不意味着对象的存活性，而只是我们拥有的最佳近似值。</p><ul><li>如果某个对象无法从任何 mutator 到达，则可以安全回收。</li><li>但它的反面显然不是事实，可到达对象可以永远保持可到达状态 (由于一些复杂的引用图来保持)，但由于执行条件可能永远无法访问，因此实际上已经死了。（大多托管内存泄露都存活性和可到达性之间）</li></ul><p>mutator 在可达性方面的起点称为根，确切内容取决于特定 mutator 实现。不过大多情况，当 mutator 是一个线程时，可以是：</p><ul><li>局部变量和子例程参数，放置在堆栈或寄存器中</li><li>静态分配的对象，放置于堆上</li><li>存储在回收器自身内部的其它内部数据结构</li></ul><h2 id="引用计数"><a class="anchor" href="#引用计数">#</a> 引用计数</h2><p>自动内存管理的两种最流行的方法之一。<br />优点</p><ul><li>确定性释放时刻，我们知道只要引用计数降为零即会发生释放。</li><li>更少内存限制，内存回收与不再使用对象速度一样快，等待回收的对象不会占用任何内存开销</li><li>不需要运行时支持即可实现<ul><li>可以作为外部库的某些特定类型的附加机制来实现。(如 c++ 智能指针)</li></ul></li></ul><p>缺点</p><ul><li>增加大量开销 (简单在运行时引入)</li><li>多线程同步问题处理开销</li><li>降低 cpu 缓存使用效率</li><li>循环引用</li></ul><p>C++ 的智能指针是基于标准库之上，而不是语言本身。直接在设计中就引入智能指针的语言：</p><ul><li>rust</li><li>swift</li></ul><h2 id="跟踪回收器tracking-collector"><a class="anchor" href="#跟踪回收器tracking-collector">#</a> 跟踪回收器 (Tracking Collector)</h2><p>查找对象可达性很困难，因为它是对象的全局属性，而释放对象的简单显式调用是非常局部的，在该局部上下文中，我们并不了解全局上下文 —— 现在是否还有其它对象在使用该对象？</p><ul><li>引用计数试图通过只查看该局部上下文以及一些附加信息 (对象的引用计数) 来克服这一问题。会导致循环引用出现问题及一些其它缺点。</li></ul><p>跟踪垃圾回收器是基于对象生存期的全局上下文的了解，从而可以更好地决定是否是删除对象 (回收内存) 的最佳时机。</p><ul><li>这是一种非常流行的方法，当人们谈到垃圾回收器时，可能指的就是跟踪垃圾回收器。</li><li>核心思路是，跟踪垃圾回收器通过从 mutator 的根开始并递归地跟踪程序的整个对象图，来发现对象的真正可到达性。</li></ul><p>跟踪垃圾回收器最典型方法包括以下两个主要步骤：</p><ul><li>标记：回收器通过找到它们的可达性来确定内存中哪些对象可以被回收</li><li>回收：回收器将回收那些所发现的不再可到达的对象的内存</li></ul><p>例如 .net 中：标记 - 计划 - 清除 - 压缩</p><h3 id="标记阶段"><a class="anchor" href="#标记阶段">#</a> 标记阶段</h3><p>从 mutator 根开始，回收器遍历整个对象图并标记访问过的对象。在标记阶段结束时那些未标记对象将是不可达的。由于对象标记，将不再存在循环引用问题。<br />由于程序正常执行图会不断变化，遍历这样的图会很困难，因此在某些垃圾回收器实现中，所有 mutator 都在标记阶段的时间内停止。</p><ul><li>一旦线程恢复运行，回收器基于对象图所掌握的知识就会过时，但对于不可达对象来说不是问题：如果它以前不可达，那么将再也无法到达</li></ul><h4 id="保守垃圾回收器conservation-garbage-collector"><a class="anchor" href="#保守垃圾回收器conservation-garbage-collector">#</a> 保守垃圾回收器（conservation garbage collector）</h4><p>这种类型的回收器可以被看成一个保底的解决方案。</p><ul><li>当运行时或编译器无法通过提供确切的类型信息 (对象在内存中布局) 从而不能直接支持回收时，并且在使用指针进行操作时回收器不能获得 mutator 支持时可以使用的解决方案。</li></ul><p>如果保守回收器想要找出什么对象是可达的，就要扫描整个堆栈、静态数据区和寄存器</p><ul><li>由于没有任何帮助，它不知道什么是指针，只能试图去猜测 (即前面说的保底的意思)</li><li>通过检查一些东西来做到，最重要的一个检查是：将给定字解释为地址 (指针) 是否是指向由分配器堆区域管理的有效地址。</li><li>如果结果肯定，回收器将保守地假定它确实是一个指针，并把它当做一个引用来遵循。</li><li>显然猜测时可能犯错，随机会使有些位看起来像是具有正确地址的有效指针 (实际并不是)，将导致在垃圾回收中依旧保留对应内存不做回收。</li></ul><p>保守垃圾回收主要优点是可以在没有运行时支持的情况下工作，它仅扫描内存，因此不需要运行时支持 (引用跟踪)<br /> 不过，保守回收器需要分配器的支持才能解决未知对象的内存布局问题。<br />优点</p><ul><li>对于不支持从头开始进行垃圾回收的环境 (如早期运行时阶段或非托管语言) 而言，更容易使用</li></ul><p>缺点</p><ul><li>不精确：随机会导致看起来像一个指针的所有内容都会阻止内存被回收 (尽管并不常见)</li></ul><p>在简单方法中，对象不能移动 (压缩)，因为回收器不确定哪些是指针 (而且它不能仅仅更新一个仅假定为指针的值)</p><h4 id="精确垃圾回收器precise-garbage-collector"><a class="anchor" href="#精确垃圾回收器precise-garbage-collector">#</a> 精确垃圾回收器（precise garbage collector）</h4><p>与保守垃圾回收器相比，精确垃圾回收器则简单许多，因为编译器或运行时为回收器提供了有关对象的内存布局的全部信息。还可以支持堆栈爬网 (枚举堆栈上所有对象的根)。<br />从定义明确的根开始，只需要逐个对象来扫描内存。</p><h3 id="回收阶段"><a class="anchor" href="#回收阶段">#</a> 回收阶段</h3><p>跟踪垃圾回收器找到了可到达对象之后，就可以从所有其它死对象中回收内存。回收器的回收阶段可以有多种不同的方式进行设计。</p><h4 id="清除sweep"><a class="anchor" href="#清除sweep">#</a> 清除（sweep）</h4><p>在这种方法中，死对象被简单地标记为可用空间，以便以后重用。这可能是一个非常快速的操作，因为仅需更改存储块的单个单位标记。<br />另外还有不简单的实现，可能需要通过构建数据结构来存储有关可用内存块的信息，以便更快地检索，通常采用空闲列表的形式，而且这些空闲列表必须足够智能，以合并相邻的可用内存块。<br />虽然清除速度很快，但最终会导致内存碎片变大或变小：可能会导致尽管总体上有足够的空闲内存，但是没有单个连续的空闲空间来用于新对象。</p><h4 id="压缩compact"><a class="anchor" href="#压缩compact">#</a> 压缩（compact）</h4><p>消除碎片会降低性能，因为它需要在内存中的对象之间移动。<br />主要有两种方式：</p><ul><li>复制所有存活对象，会带来更大内存开销：因此一般只用于特定的小内存区域（而不是整个进程内存）</li><li>就地压缩：将对象移向彼此，以消除间隙。主要问题是：如何在不相互覆盖且不使用任何临时缓冲区的情况下相对于彼此来移动对象（如 .net）</li></ul><h3 id="比较"><a class="anchor" href="#比较">#</a> 比较</h3><p>保守垃圾回收器实现了清除回收，精确垃圾回收器实现了压缩回收。<br />跟踪垃圾回收器优缺点：</p><ul><li>优点<ul><li>从开发人员角度看，完全透明，内存被抽象为无限，开发人员无需考虑如何释放不再需要的对象内存</li><li>不存在循环引用问题</li><li>在 mutator 上没有太大开销</li></ul></li><li>缺点<ul><li>更复杂的实现</li><li>非确定地释放对象</li><li>停止标记阶段程序线程</li><li>更大的内存约束 —— 由于在不需要对象时无法快速回收对象，因此可能会引入更大的内存压力</li></ul></li></ul><p>主要是因为第一个优点，因此跟踪垃圾回收器在不同的运行时间和环境中非常流行。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>应该始终致力于扩展知识，以努力成为一名专业人士 —— 知识是不会自动跑到大脑里的，需要跳出舒适区。<br />如果不能理解原理，止步于用 .net、jvm 框架之类的，会像星期天的司机一样，只能从方向盘和踏板的角度来看待我们的车。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;之前的几本书，都是  &lt;code&gt;全都读完&lt;/code&gt;  之后，再将笔记从语雀转移到自己的 Hexo 博客上，但是想想一本书有多少？笔记就算记得再少也少不到哪里去</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>蛋糕</title>
    <link href="https://wangjiaying.top/2023/06/11/%E8%9B%8B%E7%B3%95/"/>
    <id>https://wangjiaying.top/2023/06/11/%E8%9B%8B%E7%B3%95/</id>
    <published>2023-06-11T13:57:28.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>前几天不是说趁着 618 买了做蛋糕的工具吗：<a href="/2023/06/04/%E7%83%A4%E7%AE%B1%E5%8E%A8%E5%B8%88%E6%9C%BA%E4%B8%8E%E7%94%B5%E9%A5%AD%E9%94%85/" title="烤箱、厨师机与电饭锅">烤箱、厨师机与电饭锅</a>，这几天陆续到货之后，前后也试了三次了。</p><p>于是简单记录一下。</p><h1 id="第一次"><a class="anchor" href="#第一次">#</a> 第一次</h1><p>这是拷完的样子：</p><p><img data-src="/blogimages/2023/2023-06-11/MVIMG_20230606_211842.webp" alt="" /></p><p>硬得像石头似的...</p><p><img data-src="/blogimages/2023/2023-06-11/MVIMG_20230606_213041.webp" alt="" /></p><p>用筷子戳出来，简直就是... 比蛋糕饼都不如，而且一股腥味 🤮<br />(为了不浪费，还是含泪挖了些吃了)</p><h1 id="第二次"><a class="anchor" href="#第二次">#</a> 第二次</h1><p>第一次失败之后，就再仔细查看了对应教程，以及效果、特别打发时间：想到第一次机器拿到手时，由于担心问题，只打发了 2~3 分钟吧？那肯定是不行的。<br />另外还有糖、面粉都是『盲放』，糖其实可以事先就跟蛋放一块一起打发。</p><p>于是第二次吸取教训，用勺子量了 24g 糖 (面粉还是盲放的)，一开始就放进去，并一直让机器打发了 12 分钟左右。</p><p>最后从搅拌桶拿出来时，手动搅拌面粉时太紧急，依然出了差错：</p><p><img data-src="/blogimages/2023/2023-06-11/MVIMG_20230609_202242.webp" alt="" /><br /><img data-src="/blogimages/2023/2023-06-11/IMG_20230609_204926.webp" alt="" /><br /><img data-src="/blogimages/2023/2023-06-11/MVIMG_20230609_205423.webp" alt="" /></p><p>第二次弄出来的，能吃，但是依然一股腥味，只是味道没有第一次那么浓烈了。</p><h1 id="第三次"><a class="anchor" href="#第三次">#</a> 第三次</h1><p>第二次之后，特意又查了下蛋糕『去腥』的方式，去超市买了白醋、白酒准备着。</p><p>总结了之前的失败经验：第一次打发时间，第二是混合面粉操作，第三跟糖有一点点关系</p><p>经过查询，感觉混合面粉这一步操作，可以直接在搅拌桶低低速混合的吧？毕竟第二次发出来那么多气泡。</p><p>于是这一次操作步骤是：</p><ol><li>先低速打发</li><li>然后高速</li><li>最后低速将大气泡混小</li><li>再最后中低速混合面粉</li></ol><p>如此效果感觉就好多了：</p><p><img data-src="/blogimages/2023/2023-06-11/IMG_20230611_162938.webp" alt="" /></p><p>烤了几分钟：</p><p><img data-src="/blogimages/2023/2023-06-11/IMG_20230611_163653.webp" alt="" /></p><p>160 度烤完：</p><p><img data-src="/blogimages/2023/2023-06-11/IMG_20230611_170253.webp" alt="" /></p><p>切开：</p><p><img data-src="/blogimages/2023/2023-06-11/IMG_20230611_170524.webp" alt="" /></p><p><img data-src="/blogimages/2023/2023-06-11/IMG_20230611_174001.webp" alt="" /></p><p>总之，虽然第三次弄出来的还是塌陷了，不过总算可以吃了，而且味道感觉还不错 🤤，当时就吃了两块 (醋和白酒还是有用)。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>目前配方：</p><ul><li>三个鸡蛋</li><li>若干面粉 (盲放)</li><li>24~30g 糖</li><li>几滴醋和白酒</li></ul><p>步骤：</p><ol><li>鸡蛋、糖、醋、白酒 同时放进去</li><li>低速 -&gt; 高速 -&gt; 中低速 -&gt; 中低速加面粉</li><li>入模</li><li>160 度烤半个小时 (这个不好说，感觉随便差不多就行了)</li></ol><p>后面除了上述步骤外，还准备加温后打发。</p><p>至于分蛋法... 全蛋能做何必分蛋呢，我像是会单独去用分蛋法的样子吗？<br />—— 麻烦，想拒绝。(而且分蛋器不知道为啥卡路上了，一周还没到。不过，就算到了可能也不会想用了，全蛋要是可以就不想麻烦地去分蛋了)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;前几天不是说趁着 618 买了做蛋糕的工具吗：&lt;a href=&quot;/2023/06/04/%E7%83%A4%E7%AE%B1%E5%8E%A8%E5%B8%88%E</summary>
      
    
    
    
    <category term="生活" scheme="https://wangjiaying.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://wangjiaying.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Timeline 整理翻译笔记</title>
    <link href="https://wangjiaying.top/2023/06/09/Timeline%E6%95%B4%E7%90%86%E7%BF%BB%E8%AF%91/"/>
    <id>https://wangjiaying.top/2023/06/09/Timeline%E6%95%B4%E7%90%86%E7%BF%BB%E8%AF%91/</id>
    <published>2023-06-09T09:02:49.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>主要来源于官方英文文档：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS50aW1lbGluZUAxLjgvbWFudWFsL2luZGV4Lmh0bWw=">Timeline|1.8.2</span><br /> 借助翻译软件，一边看一边整理和翻译。</p><blockquote><p>注 1：由于在过程中...Unity 官方文档竟然突然更新到了 1.8.3，而 1.8.3 文档完全跟 1.8.2 排版大变了模样，所以可能会有些不对劲的<br />注 2：不是全按照官方文档来的，而是记录的个人认为的重点</p></blockquote><h1 id="概览"><a class="anchor" href="#概览">#</a> 概览</h1><p>使用 Unity Timeline 创建的每个过场动画、电影或游戏序列都包含一个 TimelineAssets ，将 TimelineAssets 与 PlayableDirector 组件相关联会创建一个时间轴实例，并允许指定场景中的哪些对象由这个 TimelineAssets 进行操作<br />在选中某个对象创建新的 TimelineAssets 时，Timeline 编辑器会保存以下内容：</p><ol><li>TimelineAsset：存储轨道、剪辑和录制的动画，但不链接到正在动画的特定游戏对象。TimelineAssets 被保存到项目中。</li><li>TimelineInstance：存储指向正在动画化或受 Timeline 影响的特定游戏对象的链接，这些链接（称为绑定）被保存到场景中。</li></ol><p>要在场景中使用 TimelineAsset，需要使用 PlayableDirector 组件将 TimelineAsset 与游戏对象相关联，关联后会创建一个 TimelineInstance，并允许指定场景中的哪些对象由 TimelineAsset 设置动画 (如果想要为 GameObject 设置动画，它还必须有一个 Animator 组件)</p><ul><li>注：使用 Timeline 编辑器直接创建时，会自动给对象添加 PlayableDirector 并与对应 TimelineAsset 绑定</li></ul><h2 id="timeline-asset"><a class="anchor" href="#timeline-asset">#</a> Timeline Asset</h2><p>Timeline 编辑器将轨道和剪辑定义保存为 TimelineAsset。如果在创建电影、过场动画或游戏序列时录制关键动画，Timeline 编辑器会将录制的剪辑保存为时间轴资产的子项。</p><p><img data-src="/blogimages/2023/2023-06-09/spec-tl-overview-asset.png" alt="" /></p><p>根据 TimelineAsset Inspector 的 FrameRate 设置，帧将转换为秒或秒将转换为帧</p><h3 id="主要属性"><a class="anchor" href="#主要属性">#</a> 主要属性</h3><p><img data-src="/blogimages/2023/2023-06-09/insp-tl-asset.png" alt="" /></p><ul><li>Frame Rate：参考帧速率</li><li>Duration Mode：选择 Timeline 的持续时间是延伸到最后一个片段的结尾还是在特定时间或帧结束。<ul><li>Based On Clips：根据最后一个片段的结尾设置 Timeline 的长度</li><li>Fixed Length：将 Timeline 的长度设置为特定的秒数或帧数</li></ul></li><li>Duration：显示基于秒数或帧数的长度（基于片段的情况下无法设置，只能预览）</li><li>Scene Preview：启用以预览 Timeline 对场景的影响，建议始终启用</li></ul><h2 id="timeline-instance实例"><a class="anchor" href="#timeline-instance实例">#</a> Timeline instance (实例)</h2><p>要使用 TimelineAsset 为场景中的游戏对象设置动画，必须创建一个 TimelineInstance</p><ul><li>TimelineInstance 通过 PlayableDirector 组件将 TimelineAsset 与场景中的 GameObject 相关联</li></ul><p>当在具有 PlayableDirector 组件的场景中选择 GameObject 时，在 Timeline 窗口中即可看到 TimelineInstance 相关信息，例如绑定 (对象)—— 这个在 PlayableDirector 组件 (Inspector) 中也有显示。</p><p><img data-src="/blogimages/2023/2023-06-09/spec-tl-overview-instance.png" alt="" /></p><p>如上图所示，PlayableDirector 组件 显示时间轴资产 (蓝框) 及其绑定的游戏对象 (红框)，Timeline 界面 直接显示绑定对象 (红框)。</p><h3 id="playabledirector"><a class="anchor" href="#playabledirector">#</a> PlayableDirector</h3><p>PlayableDirector 组件存储 TimelineInstance 和 TimelineAsset 之间的链接。 并控制 Timeline 实例何时播放、更新其时钟以及完成播放时会发生什么。<br />主要属性</p><ul><li>Playable：关联的 TimelineAsset</li><li>Update Method<ul><li>Game Time：与游戏时间相同，受时间缩放影响</li><li>Unscaled Game Time：不受时间缩放的游戏时间</li><li>Manual：脚本手动更新</li></ul></li><li>Play on Awake：是否自动播放，默认启用</li><li>Wrap Mode：播放结束时的行为<ul><li>Hold：播放一次并保持在最后一帧直到播放中断。</li><li>Loop：重复播放，直到播放中断。</li><li>None：仅播放一次</li></ul></li><li>Initial Time：开始播放的时间（以秒为单位），在 Timeline 际开始之前添加以秒为单位的延迟。</li><li>Current Time：运行时可见，当前 Timeline 实例已播放时间</li><li>Bindings：场景中游戏对象与关联 TimelineAsset（可播放）中的轨道之间的链接</li></ul><h2 id="timelineassets-的重用"><a class="anchor" href="#timelineassets-的重用">#</a> TimelineAssets 的重用</h2><p>TimelineAssets 和 TimelineInstance 是分开的，所以可以对多个 TimelineInstance 重复使用相同的 TimelineAssets。</p><ul><li>因为 TimelineAssets 可重用，因此对其的修改会使所有使用这个 TimelineAssets 的 TimelineInstance 都发生变化。</li></ul><p>在 Timeline 编辑器可以看到对应 TimelineInstance 的名字</p><h2 id="嵌套-timeline-实例"><a class="anchor" href="#嵌套-timeline-实例">#</a> 嵌套 Timeline 实例</h2><p>Timeline 支持嵌套 Timeline 实例</p><ul><li>嵌套 Timeline 实例是指添加在另一个 Timeline 中的 Timeline 实例。</li><li>主 Timeline 实例是指包含其他 Timeline 实例 的 Timeline 实例。</li></ul><p>通过使用嵌套的 Timeline 实例，可以让不同的人处理不同的动画，然后将这些动画组合到一个 Timeline 中<br />操作方式</p><ul><li>在场景中找到与要嵌套在主 Timeline 中的 Timeline 实例相关联的游戏对象 (PlayableDirector)</li><li>将带 PlayableDirector 的 GameObject 拖到主 Timeline 窗口的剪辑视图中，会自动生成一个控制轨道</li></ul><p>双击嵌套 Timeline 可以直接跳转至嵌套 Timeline，且标题也会有对应的显示：</p><p><img data-src="/blogimages/2023/2023-06-09/image.png" alt="" /></p><p>注 1：嵌套 Timeline 的时间就是实际整个嵌套 Timeline 的总时长<br />注 2：如果发现嵌套 Timeline 的名称旁边会出现一个警告图标，则表示主 Timeline 播放时间超出嵌套 Timeline 的范围，并会自动禁用（如果不想自动禁用，可在嵌套 Timeline 上将 &quot;Control Activation&quot; 字段的勾去掉，这样会使嵌套 Timeline 在主 Timeline 的整个持续时间内处于活动状态）<br />注 3：&quot;禁用&quot; 是指关联 GameObject 都整个禁用了</p><h3 id="local-and-global"><a class="anchor" href="#local-and-global">#</a> Local and Global</h3><p>局部与全局时间基准，指嵌套 Timeline 的时间标尺</p><ul><li>全局时间是相对于主 Timeline 中 嵌套 Timeline 片段而言的。例如，全局标尺下，如果控制剪辑位于主 Timeline 的第 70 帧，则在嵌套 Timeline 时，时间轴标尺将从第 70 帧开始。</li></ul><h1 id="主界面"><a class="anchor" href="#主界面">#</a> 主界面</h1><h2 id="创建"><a class="anchor" href="#创建">#</a> 创建</h2><p>从 Window-&gt;Sequencing &gt; Timeline 打开<br />其中显示的信息与当前选中的与某个 TimelineAsset 关联的游戏对象有关</p><ul><li>即挂载了 PlayableDirector 并关联了 TimelineAsset 的 GameObject</li><li>另外点击 TimelineAsset 也可以看到预览，不过只会显示与其关联的轨道和剪辑，不会有轨道绑定到场景中的游戏对象 (所以也不能播放)</li></ul><p>注：TimelineInstance 保存 Timeline 与场景中的 GameObjects 绑定<br />在 Timeline 菜单上也可以直接根据相关名字选择场景中的所有 TimelineInstance。</p><h2 id="编辑器设置"><a class="anchor" href="#编辑器设置">#</a> 编辑器设置</h2><ul><li>Playback Scrolling Mode：播放时，当前展示的界面是否跟随播放进度<ul><li>None：不做自动滚动</li><li>Pan：当播放条到达可视区域的边缘时，内容视图会平移。</li><li>Smooth：内容视图滚动，同时将播放条保持在内容视图的中心，并平滑地滚动内容视图。</li></ul></li><li>Snap to Frame：启用帧吸附，启用后拖动片段时，会自动吸附到对应每帧 (否则可能会是小数)<ul><li>注：吸附与设置的时间单位有关</li></ul></li><li>Edge Snap：当定位、修剪和创建混合片段时，启用该选项后，将片段拖动到距离 10 像素以内时，片段的开头或结尾会对齐。</li></ul><h2 id="快捷操作"><a class="anchor" href="#快捷操作">#</a> 快捷操作</h2><ul><li>按住鼠标中键拖动可以平移</li><li>F 键 聚焦功能在这里边也有效</li><li>A 键 或者未选择时按下 F 键，可以缩放显示至所有对象</li><li>水平缩放可以使用 鼠标滚轮或 -、= 键</li><li>垂直缩放通过按下 Ctrl + 鼠标滚轮 进行</li></ul><h2 id="平铺片段"><a class="anchor" href="#平铺片段">#</a> 平铺片段</h2><ul><li>选中片段后，右键选择菜单 -&gt;Tile，选中片段之间会直接相连放置不留间隙</li></ul><h2 id="拆分片段"><a class="anchor" href="#拆分片段">#</a> 拆分片段</h2><ul><li>将一个片段拆分为两个</li></ul><h2 id="重置片段"><a class="anchor" href="#重置片段">#</a> 重置片段</h2><ul><li>右键 -&gt;Reset</li></ul><h2 id="场景预览选项"><a class="anchor" href="#场景预览选项">#</a> 场景预览选项</h2><p>该选项打开后，可允许实时预览 Timeline 的控制操作，默认打开</p><p><img data-src="/blogimages/2023/2023-06-09/tl-preview-off.png" alt="" /></p><p>启用 “场景预览” 选项可以预览 TimelineInstance 对场景的影响，并且处于启用时，Timeline 编辑器还会自动管理和保护场景及其场景数据。</p><ul><li>建议始终启用场景预览选项。</li></ul><h1 id="轨道tracks"><a class="anchor" href="#轨道tracks">#</a> 轨道 (Tracks)</h1><p>其中，轨道头包含轨道的名称或其绑定信息</p><ul><li>&quot;轨道绑定&quot; 即具体操作对象，保存在与 TimelineAsset 的游戏对象关联的 PlayableDirector 组件中</li><li>这种关联也称为 TimelineInstance</li></ul><p>每个轨道头都有一个颜色，可以标识轨道类型：</p><ul><li>Activation tracks：绿色，在轨道生效时激活绑定对象，否则禁用绑定对象。</li><li>Animation tracks：蓝色</li><li>Audio tracks：橙色</li><li>Control tracks：青绿色，使用控制轨道添加 ControlClips，这些剪辑用于控制嵌套 TimelineInstance、粒子系统、预制体实例或 ITimeControl 脚本。ControlClips 的创建方式决定了它控制的内容。</li><li>Playable tracks：白色，每个 PlayableClip 都绑定到一个脚本，使用 Playables API 来创建自定义动画工具、效果或游戏机制<ul><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9QbGF5YWJsZXMuaHRtbA==">https://docs.unity3d.com/Manual/Playables.html</span></li></ul></li></ul><p>每个轨道头还有一个图标，如果轨道存在绑定错误或绑定的游戏对象被禁用，则代表轨道的图标将变为警告图标</p><h2 id="轨道模式"><a class="anchor" href="#轨道模式">#</a> 轨道模式</h2><p>Mix mode：混合模式；默认，允许两个动画重叠部分会进行混合<br /> Ripple mode：这个模式下；拖动对象时会与与前一个对象末尾进行吸附，并且两者无法进行重叠操作<br /> Replace mode：替换模式；这个模式下，若拖动的两个动画之间有重叠，处于下方的动画会被直接删除掉重叠部分</p><h2 id="轨道操作"><a class="anchor" href="#轨道操作">#</a> 轨道操作</h2><p>选择：支持 Shift 或 Ctrl 快捷键对轨道或轨道片段的选择<br />复制：可以复制轨道，不过若复制的轨道绑定到游戏对象，绑定将重置为空<br />删除：删除轨道操作是破坏性行为，会修改一个 TimelineAsset，并影响所有基于该 TimelineAsset 的 TimelineInstance<br /> 锁定：锁定轨道后可以避免被无意编辑<br />静音：暂时禁用该轨道功能</p><h2 id="轨道排序及优先级"><a class="anchor" href="#轨道排序及优先级">#</a> 轨道排序及优先级</h2><p>在 Timeline 界面中，优先级是从最后一个轨道到第一个轨道，其中最后一个轨道优先，可以重新排序轨道以更改其优先级。</p><ul><li>优先级主要是指：例如一个 Timeline 实例有四个动画轨道，其中第二个和第四个动画轨道为同一个游戏对象设置动画。那么第四条轨道覆盖前面任何轨道上的动画。此动画优先级也是动画覆盖轨道作为子轨道添加到动画轨道下的原因。</li></ul><h2 id="轨道组"><a class="anchor" href="#轨道组">#</a> 轨道组</h2><p>可以使用轨道组来组织轨道，将同一类型的轨道组织在一起，避免过多轨道造成的混乱。</p><ul><li>选择 菜单 -&gt;Track Group 可以创建一个新的轨道组</li><li>一个轨道组也可以有任意数量的轨道子组 (嵌套)</li></ul><h2 id="轨道状态"><a class="anchor" href="#轨道状态">#</a> 轨道状态</h2><p>具有源资引用的片段（例如动画片段或音频片段）会显示箭头，指示片段排除其部分源动画、音频波形或其他源内容。</p><ul><li>比如，如果动画片段仅使用其『源资源』完整动画的一部分，则白色箭头表示关键帧存在于片段开始之前或结束之后<br /><img data-src="/blogimages/2023/2023-06-09/tl-clip-arrows.png" alt="" /></li></ul><h1 id="动画"><a class="anchor" href="#动画">#</a> 动画</h1><h2 id="动画录制"><a class="anchor" href="#动画录制">#</a> 动画录制</h2><h3 id="infinite-clip"><a class="anchor" href="#infinite-clip">#</a> Infinite clip</h3><p>可以直接将动画录制到动画轨道，当直接录制到一个空的动画轨道时，会创建一个『Infinite clip』</p><ul><li>Infinite clip 是包含通过 Timeline 界面录制的基本关键动画的判断，其无法定位、修剪或拆分，因为它没有定义具体持续时间：相当于跨越整个动画轨道。</li><li>在创建 Infinite clip 之前，必须先有一个空的动画轨道，单击空动画轨道的红色圆形录制按钮可启用录制模式</li></ul><p>注：可直接将需要录制动画的对象拖到动画轨道目标上，Unity 会自动给它添加一个 Animator，后续操作跟 Animation 录制差不多（甚至可以双击 Infinite clip 点开 Animation 窗口）<br />保存 TimelineAsset 时，录制动画会作为子对象被保存在 TimelineAsset 中</p><h3 id="转换为-animation-clip"><a class="anchor" href="#转换为-animation-clip">#</a> 转换为 Animation clip</h3><p>在 Timeline 录制的 InfiniteClip 作为 TimelineAsset 的一部分保存在一块的<br />同时，由于 InfiniteClip 没有持续时间定义，因此也无法定位、修剪或拆分。如果想要对 Infiniteclip 进行这些剪辑操作，必须先将其转换为 AnimationClip</p><ul><li>注：这个操作是单向的，AnimationClip 无法再转换回 InfiniteClip</li></ul><p>转换方式很简单：单击动画轨道，选择 &quot;Convert to Clip Track&quot; 即可</p><h2 id="人形动画"><a class="anchor" href="#人形动画">#</a> 人形动画</h2><p>直接将 AnimationClip 拖到 Timeline 动画轨道上即可，与之绑定的对象会自动跟着 Timeline 播放</p><h3 id="位置跳跃"><a class="anchor" href="#位置跳跃">#</a> 位置跳跃</h3><p>两个不同的 AnimationClip 会导致角色发生位置跳跃，这是两位两个 AnimationClip 之间，上一个结束点位置与下一个开始位置不匹配导致。</p><ul><li>若想修改位置跳跃问题，需要匹配每个 AnimationClip 的位置偏移。</li><li>Timeline 提供了两个选项：Match Offsets to Previous Clip 或 Match Offsets to Next Clip</li><li>简单点击轨道上第二个 AnimationClip，然后选择 &quot;Match Offsets to Previous Clip&quot;，Unity 会自动设置第二个动画片段的位置偏移。<br /><img data-src="https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/images/insp-clip-anim-playable-walk.png" alt="" /></li></ul><p>同时，上述选项允许多选，以使可以同时设置</p><h3 id="姿势跳跃"><a class="anchor" href="#姿势跳跃">#</a> 姿势跳跃</h3><p>修复位置跳跃问题后，两个动画片段之间动画仍然会存在跳跃，因为人形处于不同的姿势<br />因此还需要进『混合』：<br /><img data-src="https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/images/tl-human-blend.png" alt="" /><br />将后一个 AnimationClip 与前一个重叠，重叠区域即为混合动画，这样可以在两个动画之间创建平滑过渡</p><h3 id="脚滑问题"><a class="anchor" href="#脚滑问题">#</a> 脚滑问题</h3><p>动画混合后，可以消除两个动画衔接姿势之间的明显跳跃，大多数身体部位之间的过渡看起来应该会很自然，但也可能还会存在例外情况：</p><ul><li>比如脚的不同位置之间的混合而导致不自然的脚滑动</li></ul><p>选中轨道上的 AnimationClip，点击 Animation Playable Asset-&gt;Clip Transform Offsets-&gt; 方向按钮 即可预览，如图所示：<br /><img data-src="https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/images/spec-scene-insp-move-gizmo.png" alt="" /><br />如果确实出现了这个情况，还可以通过手动调整 AnimationClip 的偏移量再修复一下，使脚的位置变化不那么剧烈</p><h3 id="动画覆盖轨道及-avatar-mask"><a class="anchor" href="#动画覆盖轨道及-avatar-mask">#</a> 动画覆盖轨道及 Avatar Mask</h3><p>可以使用 AnimationOverrideTrack (动画覆盖轨道) 和 AvatarMask 来组合动画轨道的上下半身动画<br />使用该技术可以制作人形动物的组合动画，如：抱着某个物体奔跑<br />创建方式</p><ol><li>单击动画轨道，选择 &quot;Add Override Track&quot;，一个动画覆盖轨道会链接到动画轨道<br /><img data-src="https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/images/tl-mask-override.png" alt="" /></li><li>然后将新的动画拖到动画覆盖轨道上即可，不过此时覆盖轨道上的动画会完全覆盖原动画。要将一个 AnimationClip 的下半身动画与另一个 AnimationClip 的上半身动画相结合，需要为动画覆盖轨道指定一个 AvatarMask</li><li>点击覆盖轨道，Inspector 面板上就会显示相关设置<br /><img data-src="https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/images/insp-override-track-props.png" alt="" /></li><li>将对应 AvatarMask 拖上去即可</li></ol><p>覆盖轨道上有设置对应的 AvatarMask 之后，就会显示一个 AvatarMask 图标，单击该图标可以启用 / 禁用 AvatarMask</p><p><img data-src="https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/images/tl-avatar-mask-icon.png" alt="" /></p><h3 id="主要属性-2"><a class="anchor" href="#主要属性-2">#</a> 主要属性</h3><ul><li>Clip Transform Offsets：两个动画片段位置和旋转匹配偏移</li><li>Offsets Match Fields：使用偏移匹配字段选择匹配偏移时要匹配的变换 (transforms)，若关闭，则会有不同轴的旋转和位置进行设置</li><li>Remove Start Offset：启用使动画片段位置和旋转从零开始。若启用可以更轻松地将动画片段与之前的动画片段相匹配。</li><li>Foot IK：如果动画片段正在为人形动物制作动画并且想要使用反向运动学来解决足部问题，则启用；否则为非人形对象则禁用</li></ul><h2 id="动画间隙gap-extrapolation"><a class="anchor" href="#动画间隙gap-extrapolation">#</a> 动画间隙 (Gap extrapolation)</h2><p>指在动画片段之间的间隙，该间隙由前后的两个动画片段进行推测，主要目的是避免动画异常。根据绑定到动画轨道的游戏对象，这些异常可能是在两个变换之间跳跃的游戏对象，或者是在不同姿势之间跳跃的人形动物。</p><ul><li>Pre-Extrapolate：控制动画数据在动画剪辑之前的间隙中如何近似。</li><li>Post-Extrapolate：控制动画数据如何在动画剪辑之后的间隙中延伸。</li></ul><p>例如，默认情况下为 Hold，即保持为前一个动画片段的最后一个动作</p><p><img data-src="https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/images/tl-extrap-pre-post-hold.png" alt="" /></p><p>若前一个动画片段的 Post-Extrapolate 设置为 None，则处于间隙中则会保持为后一个动画判断的第一个动作</p><ul><li>某些情况下 Pre-Extrapolate 设置会被隐藏：比如前一个动画设置了 Post-Extrapolate 或者两个动画片段之间没有间隙</li></ul><p>关于 Pre-Extrapolate 和 Post-Extrapolate 设置的具体选项：</p><ul><li>None：关闭（例如想在场景中游戏对象的运动和动画剪辑之间创建缓入效果可以考虑）</li><li>Hold：固定姿势</li><li>Loop：循环播放 (会重置位置)</li><li>Ping Pong：来回播放</li><li>Continue：继续循环播放 (注：与 Loop 不一样的是该选项不会重置位置，而是以当前位置为准)</li></ul><h2 id="动画关键帧"><a class="anchor" href="#动画关键帧">#</a> 动画关键帧</h2><p>每个关键帧都有切线可以控制，用于修改关键帧之间动画曲线的形状</p><ul><li>该切线默认是两条切线共同相连控制，也可以选择打断连接，使每条切线可以单独控制关键帧左边或右边曲线</li><li>另外，切线还有一些平滑算法可以选择，右键即可选择</li></ul><p>切线类型：切线类型可以更好地控制关键帧前后动画曲线的形状和斜率（关键帧之间动画曲线形状的插值算法）</p><h3 id="操作"><a class="anchor" href="#操作">#</a> 操作</h3><p>添加：右键 -&gt;Add Key 或双击<br />选择：</p><ul><li>按住 Ctrl 键单击可以选取不连续的关键帧</li><li>按住 Shift 键并单击 (或拖动) 关键帧可选择连续的关键帧</li><li>单击空白位置取消选择</li></ul><p>移动：按住 Shift 键，可以单纯在水平或垂直其中一个轴上对齐移动。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>总体来看，官方 Timeline 文档本身基本都是界面相关的内容，若是涉及代码，比如上文提到的  <code>Playable tracks</code> ，即自定义轨道，单独在另外一处：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9QbGF5YWJsZXMuaHRtbA==">https://docs.unity3d.com/Manual/Playables.html</span></p><p>最近公司项目也比较忙，导致花费时间也有点超预期了，一个多星期才忙里偷闲把文档看完：</p><p><img data-src="/blogimages/2023/2023-06-09/Snipaste_2023-06-09_18-20-07.jpg" alt="" /></p><p>继续吧，后续是 URP 和 DOTS 的官方文档。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;主要来源于官方英文文档：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2t</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/categories/Unity3D/"/>
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/tags/Unity3D/"/>
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="翻译" scheme="https://wangjiaying.top/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》-笔记</title>
    <link href="https://wangjiaying.top/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%AC%94%E8%AE%B0/"/>
    <id>https://wangjiaying.top/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%AC%94%E8%AE%B0/</id>
    <published>2023-06-04T11:57:25.000Z</published>
    <updated>2023-06-04T12:17:56.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>例行总结一下时间：</p><p><img data-src="/blogimages/2023/2023-06-04/Snipaste_2023-06-04_20-09-24.png" alt="" /></p><p>满打满算的话，怕是也花了一个月。主要是这本书涉及需要理性思考的更多，想不明白的话，就得多花点时间了。</p><p>加上这个月还插入了一些其它的东西，比如前几天的 <a href="/2023/05/28/%E6%B7%BB%E5%8A%A0%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%BB%9F%E8%AE%A1/" title="优化博客加载、添加文章统计等">优化博客加载、添加文章统计等</a> 之类的就花去了挺多时间。</p><p>本书我是非常推荐的，看完之后，对很多算法原理性的东西认识都更深了 <span class="spoiler" title="你知道得太多了！">(虽然现在又忘了不少了，所以才需要笔记呢，等我跟着笔记再复习下)</span></p><h1 id="第一章-复杂度分析"><a class="anchor" href="#第一章-复杂度分析">#</a> 第一章 复杂度分析</h1><h2 id="精确统计法事后统计法"><a class="anchor" href="#精确统计法事后统计法">#</a> 精确统计法（事后统计法）</h2><ul><li>运行一次代码，通过监控和统计手段得到算法执行的时间和占用内存大小</li><li>缺点<ul><li>测试结果受环境影响</li><li>测试结果受测试数据影响</li></ul></li></ul><h2 id="大-o-复杂度表示法"><a class="anchor" href="#大-o-复杂度表示法">#</a> 大 O 复杂度表示法</h2><ul><li>粗略估计算法执行效率</li></ul><h3 id="时间复杂度"><a class="anchor" href="#时间复杂度">#</a> 时间复杂度</h3><ul><li>表示算法执行时间与数据规模之间的增长关系（并不能度量在特定的数据规模下，代码执行的时间具体多少）</li><li>分析方法<ul><li>加法法则：代码总的复杂度等于量级最大的那段代码的复杂度</li><li>乘法法则：嵌套代码复杂度等于嵌套内外代码复杂度的乘积</li></ul></li><li>常见时间复杂度量级<ul><li>O (1)：常量级，代码执行时间不随数据规模 n 变化</li><li>O (n)：线性阶</li><li>O (n*n)：平方阶</li><li>O (logn)、O (nlogn)：对数阶时间复杂度</li><li>O (m+n)、O (mn)：复杂度由两个数据规模决定</li></ul></li><li>常见增长趋势排序：O (logn)-&gt;O (n)-&gt;O (nlogn)-&gt;O (n*n)</li></ul><h3 id="空间复杂度"><a class="anchor" href="#空间复杂度">#</a> 空间复杂度</h3><ul><li>表示算法存储空间与数据规模之间的增长关系</li><li>常见量级与时间复杂度一样</li><li>注：代码空间复杂度指的是除原本的数据存储空间外，算法运行过程中需要额外申请的存储空间</li></ul><h3 id="其它"><a class="anchor" href="#其它">#</a> 其它</h3><ul><li>最好时间复杂度</li><li>最坏时间复杂度</li><li>平均时间复杂度</li><li>均摊时间复杂度</li></ul><h1 id="第二章-数组-链表-栈和队列"><a class="anchor" href="#第二章-数组-链表-栈和队列">#</a> 第二章 数组、链表、栈和队列</h1><ul><li>线性表结构</li><li>线性表：线性表中数据只有前后两个方向</li></ul><h2 id="数组"><a class="anchor" href="#数组">#</a> 数组</h2><p>用一块连续内存空间存储相同类型的一组数据</p><h3 id="特点"><a class="anchor" href="#特点">#</a> 特点</h3><ul><li>线性表结构</li><li>连续内存空间</li><li>相同类型的数据</li></ul><h3 id="重要特性"><a class="anchor" href="#重要特性">#</a> 重要特性</h3><ul><li>随机访问：支持在 O (1) 时间复杂度内按照下标快速访问数组中的元素</li></ul><p>排好序的数组，通过二分查找，时间复杂度为 O (logn)<br /> 数组支持随机访问，因此根据下标访问元素的时间复杂度为 O (1)</p><h3 id="插入删除低效"><a class="anchor" href="#插入删除低效">#</a> 插入删除低效</h3><ul><li>时间复杂度为 O (n)</li><li>优化<ul><li>若不需要有序，将插入位置元素搬到最后，再插入元素 (或直接插入最后)</li><li>或标记删除，空间不足时才删除元素</li></ul></li></ul><h3 id="其它-2"><a class="anchor" href="#其它-2">#</a> 其它</h3><ul><li>下标：确切定义应该是偏移，相对于首地址偏移量，若从 1 开始，每次访问都需要做一次减法运算</li><li>一维数组偏移：baseAddress+i*typeSize</li><li>二维数组偏移：baseAddress+(m*i+j)*typeSize</li><li>注：二维数组，C# 中可不是这样的</li></ul><h2 id="链表"><a class="anchor" href="#链表">#</a> 链表</h2><p>链表不需要一块连续内存，通过指针将一组零散内存块串联起来使用。</p><ul><li>比较擅长 插入、删除操作，时间复杂度为 O (1)<ul><li>注：前提是已知前驱节点，否则操作时间复杂度为 O (n)</li></ul></li><li>随机访问需要遍历，时间复杂度为 O (n)</li></ul><h3 id="循环链表"><a class="anchor" href="#循环链表">#</a> 循环链表</h3><h3 id="双向链表"><a class="anchor" href="#双向链表">#</a> 双向链表</h3><p>比单链表更加常用，双向链表可以快速找到某个节点的前驱节点，支持双向遍历 (会占用多一些内存)</p><ul><li>随机访问时间复杂度与单链表一致，为 O (n)</li><li>插入、删除 操作比单链表更加高效（单链表不支持直接获取前驱节点），时间复杂度为 O (1)</li></ul><h3 id="数组与链表性能对比"><a class="anchor" href="#数组与链表性能对比">#</a> 数组与链表性能对比</h3><ul><li>数组使用连续内存空间存储数据，可以更有效利用 cpu 缓存机制，提高访问效率。链表则不然</li><li>数组大小固定，占用连续内存空间，扩容耗时。链表则本身没有大小限制，天然支持动态扩容</li><li>链表需要额外数据，总体内存消耗更高</li></ul><h3 id="问题"><a class="anchor" href="#问题">#</a> 问题</h3><ul><li>寻找链表中间节点<ul><li><s>遍历求长度，再遍历取值</s></li><li>快慢指针</li></ul></li><li>单链表反转<ul><li>遍历，存储下一个节点，将当前节点下一个节点设置为上一个节点，将当前节点设置为上一个节点，进入下一轮</li></ul></li><li>删除链表倒数第 n 个节点<ul><li><s>遍历求长度，再遍历删除</s></li><li>双指针法，快指针先前进 n 步，然后两个指针一块走，快指针走到尾的时候，慢的指针就处于节点 n 上</li></ul></li><li>链表中环检测<ul><li>快慢指针，相遇则有环 (快追慢)，无环则末尾</li></ul></li></ul><h2 id="栈"><a class="anchor" href="#栈">#</a> 栈</h2><p>先进后出，后进先出<br />操作受限的线性表数据结构</p><ul><li>用数组实现的栈称作顺序栈，用链表实现的栈称为链式栈</li><li>应用<ul><li>函数调用</li><li>表达式求值</li><li>括号匹配</li><li>浏览器前进后退 (两个栈)</li></ul></li></ul><h2 id="队列"><a class="anchor" href="#队列">#</a> 队列</h2><p>先进先出<br />操作受限的线性表数据结构</p><ul><li>用数组实现的队列称为顺序队列，基于链表实现的队列称为链式队列</li><li>基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的无锁并发队列，因此循环队列比链式队列应用更加广泛</li><li>应用<ul><li>有限资源池的请求排队功能 (如线程池)</li><li>注：C# 队列是循环队列，扩容时尾指针比头指针小时，会有两次复制操作</li></ul></li></ul><h1 id="第三章-递归-排序-二分查找"><a class="anchor" href="#第三章-递归-排序-二分查找">#</a> 第三章 递归、排序、二分查找</h1><h2 id="递归"><a class="anchor" href="#递归">#</a> 递归</h2><h3 id="条件"><a class="anchor" href="#条件">#</a> 条件</h3><ul><li>待求解问题可以分解为几个子问题的解</li><li>待求解问题与分解后子问题除数据规模差异，求解思路相同</li><li>存在递归终止条件</li></ul><h3 id="思考方式"><a class="anchor" href="#思考方式">#</a> 思考方式</h3><ul><li>对于一个问题 A，只需要思考问题 A 及其分解问题的两层之间关系，屏蔽递归细节</li><li>不需要一层层往下思考子问题与子问题的关系</li><li>不要试图以人脑分解递归每个步骤，而是通过总结递推公式找出终止条件方式</li></ul><h3 id="问题-2"><a class="anchor" href="#问题-2">#</a> 问题</h3><ul><li>堆栈溢出</li><li>重复计算</li><li>函数调用耗时多</li><li>空间复杂度高</li></ul><h3 id="尾递归"><a class="anchor" href="#尾递归">#</a> 尾递归</h3><ul><li>有限制</li><li>并不是所有的编程语言都支持尾递归优化</li><li>并不是所有递归都可以改成尾递归</li><li>能改成尾递归的都可以改成迭代</li><li>尾递归代码可读性差</li></ul><h2 id="排序"><a class="anchor" href="#排序">#</a> 排序</h2><h3 id="执行效率"><a class="anchor" href="#执行效率">#</a> 执行效率</h3><ul><li>最好时间复杂度、最坏时间复杂度和平均时间复杂度<ul><li>原始数据有序程度对排序执行时间有较大影响</li></ul></li><li>时间复杂度的系数、常数和低阶<ul><li>实际排序中，规模可能较小，因此需要考虑</li></ul></li><li>比较次数和交换 (/ 移动) 次数<ul><li>比较元素大小的耗时少于交换 (/ 移动) 元素位置</li><li>两者需要区分统计</li></ul></li></ul><h3 id="内存消耗"><a class="anchor" href="#内存消耗">#</a> 内存消耗</h3><ul><li>原地排序算法：在原存储空间上完成排序操作</li><li>非原地排序算法：需要额外的非常量级数据存储空间才能完成排序</li><li>注：空间复杂度为 O (1) 的一定是原地排序算法，反过来原地排序算法空间复杂度不一定是 O (1)</li></ul><h3 id="算法稳定性"><a class="anchor" href="#算法稳定性">#</a> 算法稳定性</h3><ul><li>待排序数据中存在值相等元素，经排序后是否可能发生改变</li></ul><h3 id="排序类型"><a class="anchor" href="#排序类型">#</a> 排序类型</h3><h4 id="冒泡排序稳定排序"><a class="anchor" href="#冒泡排序稳定排序">#</a> 冒泡排序（稳定排序）</h4><p>两层循环，第一层为  <code>i&lt;length，第二层 j&lt;length-i-1</code></p><ul><li>最好时间复杂度 (已经有序)：O (n)<ul><li>注：若某一次没有任何元素交换，可提前退出</li></ul></li><li>最坏时间复杂度 (倒序排列)：O (n*n)</li><li>平均时间复杂度：O (n*n)</li></ul><h4 id="插入排序稳定排序"><a class="anchor" href="#插入排序稳定排序">#</a> 插入排序（稳定排序）</h4><p>将数组分为两个区间：已排序区与未排序区<br />取未排序区元素插入已排序区合适位置，保持插入后依然有序</p><ul><li>注：虽然理论时间复杂度与冒泡一样，但实际插入排序比冒泡排序性能好，插入交换操作只有一条，冒泡有 3 条</li></ul><h4 id="选择排序不稳定排序"><a class="anchor" href="#选择排序不稳定排序">#</a> 选择排序（不稳定排序）</h4><p>与插入排序一样，将数组划分为已排序区和未排序区<br />每次从未排序区寻找最小元素，将其放 (交换) 到已排序区末尾</p><ul><li>不稳定：若从大到小 1、1、2、7，7 与第一个 1 交换，此时两个 1 顺序就已经被交换了</li><li>时间复杂度都是 O (n*n)</li></ul><h4 id="归并排序稳定排序"><a class="anchor" href="#归并排序稳定排序">#</a> 归并排序（稳定排序）</h4><p>分治算法思想：由下到上，先处理子问题，再合并<br />分治算法一般是用递归实现</p><ul><li>注：分治是一种解决问题的处理思想，递归是一种编程技巧</li></ul><p>归并排序的执行效率与原始数组的有序程度无关，任何情况下时间复杂度都非常稳定，执行时间复杂度都一样。但不是原地排序算法，空间复杂度较高，因此没有快速排序应用广泛。</p><ul><li>时间复杂度：O (nlogn)</li><li>空间复杂度：O (n)</li></ul><h4 id="快速排序不稳定排序"><a class="anchor" href="#快速排序不稳定排序">#</a> 快速排序（不稳定排序）</h4><p>分治算法思想：由上往下，先分区，再处理子问题</p><ul><li>时间复杂度：O (nlogn)<ul><li>最坏：O (n*n)</li><li>退化到 O (n*n) 的概率较小，而且可以通过合理选择 pivot 避免极端情况发生</li></ul></li><li>空间复杂度 (递归深度，函数调用栈空间)：O (logn)<ul><li>最坏：O (n)</li></ul></li></ul><p>注：最好是指被中心点分割的区间均衡，最坏是指分区极不均衡</p><h3 id="线性排序"><a class="anchor" href="#线性排序">#</a> 线性排序</h3><p>时间复杂度是线性的，不基于比较的排序算法，排序过程不涉及元素之间的比较操作，排序的速度快于任何比较排序算法。</p><h4 id="桶排序bucket-sort"><a class="anchor" href="#桶排序bucket-sort">#</a> 桶排序（bucket sort）</h4><p>定义几个有序的『桶』，将要排序的数据分到这几个桶里，对每个桶的数据单独进行排序，再把每个桶数据按照顺序依次取出，组成的序列即有序</p><ul><li>或者，若数据排序值较低，则直接划分为值数量的桶（例如，根据年龄排序，划分 150 个年龄桶），填充完毕后，依次遍历即已经排好序了</li></ul><p>平均时间复杂度：O (n+k)<br /> 空间复杂度：O (n+k)<br /> 桶排序比较适合用在外部排序中：外部排序即数据存储在外部磁盘中，数据量比较大，而内存有限，无法全部加载内存处理</p><h4 id="计数排序counting-sort"><a class="anchor" href="#计数排序counting-sort">#</a> 计数排序（counting sort）</h4><p>桶排序的一种特殊情况<br />当要排序的 n 个数据所处范围并不大的时候，如最大值为 k，那么就可以把数据划分成 k 个『桶』，每个桶内数据都是相等的，省掉了桶内排序时间</p><ul><li>计数 (遍历待排序数组，计算每个数据个数)</li><li>求每个计数累加和 (遍历计数数组累加)</li><li>整理<ul><li>从后往前遍历待排序数组，扫描到的元素的数据即为计数数组的下标</li><li>从计数数组取出下标对应值 (整数索引)，该值即代表扫描元素应该处于新的排序数组所在位置</li><li>将元素放入排序数组中，计数减一（从后往前处理数组，是为了保持排序算法稳定性，即相同数据元素保证依然排在前面）</li></ul></li></ul><p>平均时间复杂度：O (n+k)<br /> 空间复杂度：O (k)-- 听说是为了返回而创建的新数组不算？</p><ul><li>计数排序时间复杂度为 O (n+k)，k 表示要排序的数据范围，若 k 远小于 n，那么时间复杂度可以表示为 O (n)</li><li>计数排序只能用在数据范围不大的场景，若数据范围 k 比要排序的数据 n 大很多，就不适合了</li><li>除此之外，计数排序只能给非负整数排序，若待排序数据是其它类型，就得将其在不改变相对大小的前提下，转换为非负整数</li></ul><p>其它优化方式</p><ul><li>k 大小取待排序的数组中元素大小的极值差 + 1（max-min+1），确保不会造成额外不需要的空间浪费</li></ul><p>注：通常会用于基数排序的子过程</p><h4 id="基数排序radix-sort"><a class="anchor" href="#基数排序radix-sort">#</a> 基数排序（radix sort）</h4><p>将整数按位数切割成不同的数字，然后每个『位』的数进行依次排序<br />注：按照每位排序算法必须稳定，否则就会有问题：非稳定排序算法，后一次排序不会兼顾前一次排序之后的数据顺序，那么之前所做的基于低位的排序就相当于白做了<br />根据每一位排序的排序算法，可以使用桶排序或计数排序（有多少位就做多少次额外排序）<br />平均时间复杂度：O (n*k)<br /> 空间复杂度：O (n+k)<br /> 要求</p><ul><li>数据可以分割出独立的『位』，并且位之间有递进关系 (如手机号码)：如果 a 数据的高位比 b 数据大，那么剩下低位就不用比较了</li><li>另外，不等长数据也可以经过处理满足要求（例如根据单词排序，单词字母数量不一致，补齐到相同长度）</li><li>每一位数据范围不能太大，可以使用其它线性排序算法来排序，否则基数排序时间复杂度就无法达到 O (n) 了</li></ul><h4 id="总结"><a class="anchor" href="#总结">#</a> 总结</h4><p>上述三种线性排序算法对数据有一定特殊要求，因此应用不是非常广泛，但如果数据正好符合这些排序算法要求，应用会更加高效，时间复杂度可达到 O (n)<br /> 桶排序 (每个桶存储一定范围的数值) 与计数排序 (每个桶只存储单一值) 思想类似，都是针对范围不大的数据，将数据划分到不同『桶』里实现排序<br />基数排序则要求数据可以划分成高低位，位之间有递进关系，且每一位的数据范围不能太大，因为基数排序需借助桶排序或计数排序完成每一个位的排序工作<br />另外，理论上 计数排序 是最快的</p><h3 id="排序优化"><a class="anchor" href="#排序优化">#</a> 排序优化</h3><h4 id="优化快速排序"><a class="anchor" href="#优化快速排序">#</a> 优化快速排序</h4><p>如果数据原来就是有序或接近有序，每次分区点选最后一个数据，那么性能就会退化到 O (n*n)<br /> 理想的分区点是，被分区点分开的两个小区间大小接近相等</p><ul><li>选择合理分区点方式<ul><li>三数取中法：从区间首尾中分别取出一个数据，对比大小，取中间值作为分区点</li><li>随机法：每次从待排序区间随机选取一个元素作为中心点</li></ul></li><li>为避免堆栈溢出，限制递归深度，该用其它排序，或采用模拟实现函数调用栈</li></ul><h3 id="二分查找"><a class="anchor" href="#二分查找">#</a> 二分查找</h3><p>对有序数据的一种快速查找算法<br />时间复杂度：O (logn)<br /> 对数运算的逆运算就是指数运算，该算法及其高效</p><ul><li>mid=low+(high-low)/2</li><li>或 mid=low+((high-low)&gt;&gt;1)</li></ul><h4 id="二分查找变体问题"><a class="anchor" href="#二分查找变体问题">#</a> 二分查找变体问题</h4><p>通常的二分查找，只能查找不重复元素，若元素重复，那么查出来的结果就不能确定是重复元素中的哪个了<br />若对查找出的元素没有顺序要求，自然也无所谓，不过若有一定要求，那么就涉及变体问题<br />因此，其又分为以下四种变体方式：</p><ul><li>查找第一个值等于给定值元素<ul><li>简洁写法<ul><li>while(low&lt;=high){a[mid]&gt;value high=mid-1 else low=mid+1} if(low&lt;n&amp;&amp;a[low]==value return low</li><li>注意循环退出条件，并注意返回值，返回的是 low，此时 low 应该比 high 大，low 和 high 通过不断逼近 value 实现，最后 low 和 high 交错而过，low</li></ul></li><li>清晰写法<ul><li>a [mid] 与要查找的 value 大小关系有三种情况：大于、小于和等于，主要特殊处理等于的情况</li><li>a[mid]&gt;value;high=mid-1</li><li>a[mid]&lt;value;low=mid+1</li><li>if(mid==0)||(a[mid]-1!=value) return mid;else high=mid-1</li></ul></li></ul></li><li>查找最后一个值等于给定值的元素（同上）</li><li>查找第一个值大于或等于给定值的元素（同上）</li><li>查找最后一个值小于或等于给定值的元素（同上）</li></ul><h1 id="第四章-哈希表-位图和哈希算法"><a class="anchor" href="#第四章-哈希表-位图和哈希算法">#</a> 第四章 哈希表、位图和哈希算法</h1><p>哈希表 (hash table) 是数组的一种扩展，由数组演化而来，底层依赖数组支持按下标快速访问元素的特性</p><ul><li>如果没有数组，就没有哈希表</li><li>即：哈希表利用数组通过下标访问元素的时间复杂度为 O (1) 的特性，利用哈希函数把元素的键值映射为数组的下标存储；当按照键值查询元素时，使用同样的哈希函数将键值转化为数组下标，然后通过索引直接取值</li></ul><p>哈希函数涉设计时 3 个基本要求：</p><ul><li>哈希函数计算得到的值是一个非负整数（因为数组下标从 0 开始）</li><li>如果 key1=key2，hash (key1)=hash (key2)</li><li>如果 key1≠key2，hash (key1)≠hash (key2)<ul><li>这个要求满足比较困难，也叫哈希冲突，即使 md5 都会出现冲突；而且数组存储空间有限，因此更加大了冲突概率</li><li>哈希冲突需要进行解决</li></ul></li></ul><h2 id="哈希冲突解决"><a class="anchor" href="#哈希冲突解决">#</a> 哈希冲突解决</h2><h3 id="开发寻址法open-addressing"><a class="anchor" href="#开发寻址法open-addressing">#</a> 开发寻址法 (open addressing)</h3><p>一旦出现冲突，就通过重新探测新位置的方法来解决冲突</p><ul><li>线性探测法 (linear probing)<ul><li>当插入数据时，若对应位置已经被占据，那就从该位置向后依次查找，直到找到一个空闲位置为止</li><li>线性探测法删除时需要特殊处理，避免影响查找节点逻辑（查找若探测到空位置，就会导致直接返回空），方式是标记为 delete，查找探测时，遇到 delete 不会停止</li><li>对于线性探测法，随着插入数据越来越多，空闲位置越来越少，哈希冲突概率就会越来越大，探测时间也会越来越长（最差时间复杂度 O (n)）</li></ul></li><li>二次探测法<ul><li>与线性探测法很像，只是探测步长变为原来的二次方</li><li>hash (key)+0、hash (key)+pow (1,2)、hash (key)+pow (2,2) 等</li></ul></li><li>双重哈希法<ul><li>使用多个哈希函数，若第一个哈希函数计算得出位置已经被占用，就用第二个、第三个哈希函数重新计算...... 直到找到空闲位置</li></ul></li></ul><h3 id="链表法chaining"><a class="anchor" href="#链表法chaining">#</a> 链表法 (chaining)</h3><p>是一种更加常用的解决哈希冲突的方法<br />在哈希表中，每个『桶』或者『槽』会对应一个链表，将哈希值相同的元素放到相同的槽位对应的链表中</p><ul><li>当插入元素时，通过哈希函数计算出对应的槽位，然后将元素插入槽位对应的链表中；查找、删除元素同理</li><li>插入时间复杂度是 O (1)，且当链表中元素不多（哈希冲突不是那么高）时，其它操作 (查找、删除) 也可以粗略认为操作时间复杂度是 O (1)</li></ul><p>装载因子 (load factor)= 元素个数 / 哈希表长度 (槽个数)<br /> 装载因子越大，说明链表长度越长，哈希表性能就会更低</p><h2 id="工业级哈希表"><a class="anchor" href="#工业级哈希表">#</a> 工业级哈希表</h2><p>若所有数据都被装到一个链表，哈希表退化后时间复杂度为 O (n)，是原本的执行消耗的 n 倍</p><ul><li>精心设计的数据能使其退化造成性能急剧下降，形成拒绝服务攻击，这就是哈希表碰撞攻击的基本原理</li></ul><h3 id="设计哈希函数"><a class="anchor" href="#设计哈希函数">#</a> 设计哈希函数</h3><p>哈希函数设计好坏，决定了哈希表冲突概率大小，也直接决定了哈希表的性能</p><ul><li>哈希函数不能过于复杂，否则会消耗更多计算时间</li><li>哈希函数生成的值应尽可能随机分布</li></ul><h3 id="解决装载因子过大"><a class="anchor" href="#解决装载因子过大">#</a> 解决装载因子过大</h3><p>动态扩容</p><ul><li>动态扩容后，需要通过哈希函数重新计算每个数据在新的哈希表中位置</li><li>触发扩容的操作时间复杂度为 O (n)</li></ul><h4 id="避免低效扩容增量扩容"><a class="anchor" href="#避免低效扩容增量扩容">#</a> 避免低效扩容（增量扩容）</h4><p>集中扩容会导致某一次插入时，耗时过高，因此可以考虑增量扩容</p><ul><li>当装载因子达到阈值时，仅创建新的表，但并不立即将数据全部移到新表中</li><li>当插入新数据时，还会从原数据表中搬运一个数据到新表中，经过多次插入后，原表数据就被一点点移到新表中了，使扩容消耗分散，所有插入操作都变得很快</li><li>缺点：原表数据没有搬移完成时，内存无法释放，且为了兼容，查询操作需要同时在两张表中进行</li></ul><h3 id="选择合适的冲突解决方法"><a class="anchor" href="#选择合适的冲突解决方法">#</a> 选择合适的冲突解决方法</h3><h4 id="开放寻址法"><a class="anchor" href="#开放寻址法">#</a> 开放寻址法</h4><p>优点</p><ul><li>数据直接存储在数组中，可有效利用 cpu 缓存加快查询速度</li><li>不涉及链表和指针，方便序列化</li></ul><p>缺点</p><ul><li>所有数据都存在一个数组，发生冲突概率更高</li><li>因此装载因子不能过大，必须小于 1，所有需要消耗更多空间<ul><li>装载因子接近 1 时，会有大量的哈希冲突，导致大量探测、再哈希等，性能急剧下降</li></ul></li><li>删除数据比较麻烦，需要额外特殊标记删除数据</li></ul><p>因此，当数据量小，装载因子小时，适合采用开发寻址法</p><h4 id="链表法"><a class="anchor" href="#链表法">#</a> 链表法</h4><p>链表法相比开放寻址法，对大装载因子容忍度更高</p><ul><li>只要哈希函数计算得到的值比较随机且均匀，即便装载因子变成 10，也只是链表长度变长了点，性能下降并不多</li></ul><p>缺点</p><ul><li>链表中节点要额外存储 next 指针，对于小对象存储，有可能会让内存消耗翻倍（当然若存储大对象，远大于指针消耗，那么指针内存消耗就可以忽略了）</li><li>链表节点在内存种零散分布，对 cpu 缓存不友好</li></ul><p>也可以考虑将链表改造成其它高效数据结构，例如红黑树，这样即便出现哈希冲突，在极端情况下所有数据都哈希到了同一个『桶』，最终哈希表也只是退化成红黑树，查询效率也不会太差 (O (logn))</p><h3 id="总结-2"><a class="anchor" href="#总结-2">#</a> 总结</h3><p>需满足要求</p><ul><li>支持快速查询、插入、删除操作</li><li>内存占用合理，不浪费过多内存空间</li><li>性能稳定，在极端情况下，哈希表性能也不会退化到无法接受的程度</li></ul><p>设计思路</p><ul><li>设计一个合适的哈希函数</li><li>设置合理的装载因子阈值 (开放寻址法)，并设计动态扩容策略</li><li>选择合适的哈希冲突解决方法</li></ul><h2 id="利用哈希表优化-lru-缓存淘汰算法"><a class="anchor" href="#利用哈希表优化-lru-缓存淘汰算法">#</a> 利用哈希表优化 LRU 缓存淘汰算法</h2><p>哈希表对应链表中对应节点，节省遍历链表开销</p><ul><li>虽然哈希表支持高效插入、删除和查找操作，但哈希表中数据经哈希函数打乱后是无规律存储的，无法支持按照某种顺序遍历并输出数据</li><li>因此可以将其与有序链表结合使用</li></ul><p>有序链表支持按照某种顺序遍历并输出数据，哈希表与其结合，就可以实现：既可以快速插入、删除和查找操作，又支持 O (n) 时间复杂度按顺序遍历并输出数据</p><h2 id="位图网址链接去重"><a class="anchor" href="#位图网址链接去重">#</a> 位图：网址链接去重</h2><p>假设一条网址平均长度 64B，10 条网址为 60G 左右<br />对基于链表法解决冲突的哈希表，在查询网址链接时，找到对应链表后，还需要用待判重网址链接依次对比，对比也操作较耗时</p><h3 id="位图bitmap"><a class="anchor" href="#位图bitmap">#</a> 位图（bitmap）</h3><p>原理：申请对应长度的 bool 数组，使用 bool 进行标记，标记对应元素是否存在<br /> char 类型表示一个长度为 16 的位图</p><ul><li>存取位图数据时，用数据除以 16，得到数据存储元素，然后与 16 取余，得到具体哪个二进制位上</li></ul><h3 id="布隆过滤器bloom-filter"><a class="anchor" href="#布隆过滤器bloom-filter">#</a> 布隆过滤器（Bloom filter）</h3><p>基于位图实现，是对位图的一种改进，用于改进存储空间的利用<br />做法</p><ul><li>尽管数据范围增大了，但是依然使用更低范围的位图，但是使用哈希函数进行索引</li><li>哈希函数必然有冲突，其做法是定义多个哈希函数，并同时将对应下标处置为 true，即用 k 个二进制位而非一个表示一个元素是否存在</li><li>判断是否存在时，判断所有哈希函数计算的下标都为 true 才通过</li></ul><p>缺点</p><ul><li>存在『误判』，即不存在的被判断为存在</li><li>多个元素的哈希函数重叠设置导致</li></ul><p>对于误判情况，某些业务场景可以容忍的情况下，是可以使用的<br />另外，误判只会误判断『已经存在』，数据存在的情况下不会导致判断『不存在』</p><ul><li>利用该特定，也可以在例如查询数据库之前，利用布隆过滤器判断数据是否存在，不存在就可以省略查询开销</li></ul><p>布隆过滤器非常适合不需要完全准确，允许存在小概率误判的大规模判重场景<br />其误判概率主要与哈希函数个数、位图大小有关，更适合静态数据，当数据越来越多，false 越来越少，误判率就会增高（因此对于动态数据，布隆过滤器还需要支持动态扩容，阈值）</p><h3 id="总结-3"><a class="anchor" href="#总结-3">#</a> 总结</h3><p>位图和布隆过滤器，相比哈希表，在内存消耗上降低了许多，在特定场景下，优势更明显<br />而且位图属于 cpu 密集型，哈希表由于链表存在，若进行判重还需要读取对应数据 (内存密集型) 对其元素进行额外对比，因此理论上位图性能更好</p><h2 id="哈希算法"><a class="anchor" href="#哈希算法">#</a> 哈希算法</h2><p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射规则就叫做『哈希算法』，原始数据映射后得到的二进制值串就称为『哈希值』<br />一般要求</p><ul><li>哈希值不能反向推导出原始数据（因此也叫单向哈希算法）</li><li>对数据变化敏感，原始数据哪怕变动一个二进制，对应哈希值也大不同</li><li>哈希冲突概率要小</li><li>执行效率要高</li></ul><h3 id="应用-安全加密"><a class="anchor" href="#应用-安全加密">#</a> 应用 - 安全加密</h3><p>MD5（message-digest 5）、SHA（secure hash algorithm）<br />需求</p><ul><li>很难根据哈希值反向推导出原始数据</li><li>哈希冲突概率要很小</li></ul><p>哈希冲突无法完全避免</p><ul><li>巢鸽理论（抽屉理论）：将 11 只鸽子放进 10 个鸽巢，那么肯定有一个鸽巢中鸽子数量多于一个，即肯定有两只鸽子在一个鸽巢内</li><li>例如 MD5 最大 128 位，表示数据也有限，而需要计算的原始数据是无穷大的</li><li>另一个角度看，哈希值越长的算法，哈希冲突概率就越低（相应计算时间就越长）</li></ul><h3 id="应用-唯一标识"><a class="anchor" href="#应用-唯一标识">#</a> 应用 - 唯一标识</h3><p>例如海量图库中查询是否存在，例如从图片开头取 100B、中间取 100B、末尾取 100B，然后放在一块计算哈希值</p><h3 id="应用-数据校验"><a class="anchor" href="#应用-数据校验">#</a> 应用 - 数据校验</h3><p>例如 BT 分块文件的校验，通过将下载文件块与种子文件记录的哈希进行对比避免文件块出现问题</p><h3 id="应用-哈希函数"><a class="anchor" href="#应用-哈希函数">#</a> 应用 - 哈希函数</h3><p>哈希函数是设计哈希表的关键，不过相比其它，对冲突容忍度更高，一般比较简单，更追求效率</p><h3 id="应用-负载均衡"><a class="anchor" href="#应用-负载均衡">#</a> 应用 - 负载均衡</h3><p>会话沾滞：属于同一会话所有请求都会被路由到同一台服务器上</p><h3 id="应用-数据分片"><a class="anchor" href="#应用-数据分片">#</a> 应用 - 数据分片</h3><p>统计 1TB 大小日志 “搜索关键词” 出现的次数</p><ul><li>从日志文件依次读取每个搜索关键词，通过哈希算法计算哈希值，然后与机器个数求模取余</li><li>假设得出值为 k，那么数据就会发送至编号为 k 的机器</li><li>相同关键词会被分配给相同机器处理，每台机器分别计算统计结果，最后合并</li></ul><h3 id="应用-分布式存储"><a class="anchor" href="#应用-分布式存储">#</a> 应用 - 分布式存储</h3><p>哈希算法计算哈希值，求模取余，最终值即为对应缓存机器编号</p><ul><li>该方式在新增机器后，会有扩容问题：数据需要在机器之间重新分配，即缓存失效</li></ul><p>为解决缓存失效问题，于是有一致性哈希算法</p><ul><li>假设 k 台机器，数据的哈希值范围是 [0,Max]，将整个范围划分为 m 个区间（m 远大于 k），每台机器负责 m/k 个小区间</li><li>当有新机器加入，就将某几个小区间数据搬入新机器</li><li>这样既不需要全部重新计算哈希值并搬移数据，又保持了各个机器上数据量的均衡</li></ul><h2 id="总结-4"><a class="anchor" href="#总结-4">#</a> 总结</h2><p>哈希算法作为密码存储，可以加『盐』以提高用户密码复杂度，增加字典攻击的破解难度</p><h1 id="第五章-树"><a class="anchor" href="#第五章-树">#</a> 第五章 树</h1><h2 id="树和二叉树"><a class="anchor" href="#树和二叉树">#</a> 树和二叉树</h2><h3 id="树的定义"><a class="anchor" href="#树的定义">#</a> 树的定义</h3><ul><li>节点的高度 = 节点到叶子节点的最长路径长度</li><li>节点的深度 = 根节点到这个节点的路径长度</li><li>节点的层 = 节点的深度 + 1</li><li>节点的高度 = 根节点的高度</li></ul><h3 id="二叉树"><a class="anchor" href="#二叉树">#</a> 二叉树</h3><p>每个节点最多两个子节点，但是并不要求每个节点必须要有两个子节点<br />分类</p><ul><li>满二叉树：除叶子节点外，每个节点都有左右两个子节点</li><li>完全二叉树：叶子节点分布在最下层和倒数第二层，最下面一层 (若只有一个节点) 的叶子节点都靠左排列</li></ul><p>注：满二叉树是完全二叉树的一种特殊情况</p><h3 id="二叉树的存储"><a class="anchor" href="#二叉树的存储">#</a> 二叉树的存储</h3><p>一般两种方法</p><ul><li>基于指针的链式存储方式（通用）</li><li>基于数组的顺序存储方式（适用完全二叉树）<ul><li>若节点 x 存储于数组 i 处</li><li>左子节点 = 2i</li><li>右子节点 = 2i+1</li><li>父节点 = i/2</li></ul></li></ul><p>完全二叉树仅浪费一个下标 0 的存储空间，对于非完全二叉树，会浪费比较多的存储空间，因此非完全二叉树一般采用链式存储<br />采用数组方式更节省内存，且不需要记录左右子节点指针，因此完全二叉树单独提出，这也是完全二叉树要求最下层节点需要全部靠左排列的原因</p><h3 id="二叉树的遍历"><a class="anchor" href="#二叉树的遍历">#</a> 二叉树的遍历</h3><ul><li>前序：根左右</li><li>中序：左根右</li><li>后序：左右根</li></ul><p>遍历时间复杂度：O (n)</p><h2 id="二叉查找树binary-search-tree"><a class="anchor" href="#二叉查找树binary-search-tree">#</a> 二叉查找树（binary search tree）</h2><p>也称为二叉搜索树，也是二叉树中常用的一种类型<br />用来组织动态数据集合，可以支持数据的快速插入、删除和查找操作</p><ul><li>对于二叉查找树中任意节点，左子树值都小于这个节点的值，右子树值都大于这个节点的值</li></ul><h3 id="操作"><a class="anchor" href="#操作">#</a> 操作</h3><h4 id="查找操作"><a class="anchor" href="#查找操作">#</a> 查找操作</h4><ul><li>while(p!=null)<ul><li>if(data&lt;p.data) p=p.left</li><li>else if(data&gt;p.data) p=p.right</li><li>else return p</li></ul></li></ul><h4 id="插入操作"><a class="anchor" href="#插入操作">#</a> 插入操作</h4><p>与查找类似，判断节点大小插入叶子节点</p><h4 id="删除操作"><a class="anchor" href="#删除操作">#</a> 删除操作</h4><ul><li>待删除节点没有子节点，直接将父节点指向该节点指针置为 null</li><li>待删除节点有一个子节点，更新父节点指向删除节点指针，使其重新指向待删除节点的子节点</li><li>待删除节点有两个子节点，需要找到这个节点<strong>右子树</strong>中最小节点，将其替换到删除的节点位置</li></ul><p>另外，还有一个比较简单、取巧的处理方法：只将删除节点标记为已删除，而并不真正删除。这样删除操作就会变得很简单，缺点是占用了内存并会降低查询效率</p><h4 id="其它-3"><a class="anchor" href="#其它-3">#</a> 其它</h4><p>中序遍历可以从小到大有序输出数据，且时间复杂度为 O (n)</p><ul><li>因此二叉查找树也称二叉排序树</li></ul><h3 id="支持重复数据的二叉查找树"><a class="anchor" href="#支持重复数据的二叉查找树">#</a> 支持重复数据的二叉查找树</h3><p>针对包含值相同的节点的二叉树，有两种存储方式</p><ul><li>每一个节点存储不是一个数据，而是一组数据，把值相同的数据存储在同一个节点上</li><li>每个节点仍然只存储一个数据，当插入数据时，如果碰到一个节点的值与插入数据的值相同，就将插入的数据放到该节点的右子树。即某个节点的右子树存储的是大于等于该节点的值的节点</li></ul><h3 id="二叉查找树的性能"><a class="anchor" href="#二叉查找树的性能">#</a> 二叉查找树的性能</h3><p>在二叉查找树中，查找、插入和删除等操作与树的高度成正比</p><ul><li>最坏时间复杂度 (退化为链表)：O (n)</li><li>最好时间复杂度 (完全二叉树)：O (logn)</li></ul><h3 id="哈希表与二叉查找树"><a class="anchor" href="#哈希表与二叉查找树">#</a> 哈希表与二叉查找树</h3><p>哈希表不能替代二叉查找树</p><ul><li>哈希表数据无序存储，若需要输出有序数列，需要先排序，或配合有序链表使用（二叉查找树中序遍历即可）</li><li>哈希表扩容耗时，当哈希冲突时，性能不稳定（二叉查找树性能也不稳，但平衡二叉查找树是稳定 O (logn) 的）</li><li>O (logn) 有时不一定比 O (1) 慢，取决于具体数据规模、常量、系数等。因此哈希表由于哈希冲突、哈希计算等，不一定比之高效</li><li>哈希表构造比二叉查找树复杂，需要考虑更多：哈希函数设计、冲突解决、扩容、缩容 等。平衡二叉查找树只需要考虑如何维护平衡性</li></ul><h2 id="平衡二叉查找树"><a class="anchor" href="#平衡二叉查找树">#</a> 平衡二叉查找树</h2><p>普通二叉查找树在频繁动态更新过程中，可能会树的高度远大于 log2n 的情况，导致各个操作效率下降。特别是极端情况下退化为链表，时间复杂度变成 O (n)<br /> 因此有了平衡二叉查找树</p><h3 id="定义"><a class="anchor" href="#定义">#</a> 定义</h3><p>二叉树中任意一个节点的左右子树的高度相差不大于 1（完全二叉树、满二叉树均为平衡二叉树）<br />平衡二叉查找树不仅满足平衡二叉树定义，同时满足二叉查找树的特点</p><ul><li>种类：AVL、红黑树、Treap (树堆)、Splay Tree (伸展树)</li><li>AVL 树：最先被提出的平衡二叉查找树是 AVL 树，它严格符合平衡二叉查找树的定义，是一种高度平衡的二叉查找树</li><li>红黑树：并没有严格符合平衡二叉查找树的定义，从根节点到各个叶子节点的最长路径有可能会比最短路径长一倍</li></ul><h3 id="红黑树的定义"><a class="anchor" href="#红黑树的定义">#</a> 红黑树的定义</h3><p>Red-Black Tree,R-B Tree，是一种相对平衡的二叉查找树，并不符合严格意义上的平衡二叉查找树的定义</p><ul><li>根节点是黑色</li><li>每个叶子节点都是黑色的空节点 (叶子节点不存储数据)</li><li>任何上下相邻的节点不能同时为红色，红色节点被黑色节点隔开（不会有连续的红色节点）</li><li>对每个节点，从该节点到叶子节点的所有路径，都包含相同数目的黑色节点</li></ul><h3 id="红黑树性能"><a class="anchor" href="#红黑树性能">#</a> 红黑树性能</h3><p>平衡二叉查找树提出是为了解决二叉查找树因为动态更新导致性能退化问题<br />『平衡』可以等价为性能不退化，『近似平衡』可以等价为性能退化不太严重</p><ul><li>红黑树比高度平衡的 AVL 树高了一倍，性能损失不会太大。红黑树维护节点平衡成本更低，因此性能并不比 AVL 树差</li></ul><p>为何红黑树更受欢迎？</p><ul><li>AVL 是一种高度平衡的二叉树，查找数据效率非常高。但为了维护平衡，每次插入、删除数据都要对树中节点的分布做调整，操作复杂耗时</li><li>红黑树只做近似平衡，因此维护平衡成本比 AVL 树更低，性能又损失不大。</li></ul><h2 id="递归树"><a class="anchor" href="#递归树">#</a> 递归树</h2><p>借助 树 求递归算法的时间复杂度</p><h2 id="b树"><a class="anchor" href="#b树">#</a> B + 树</h2><p>通过二叉查找树演化而来</p><ul><li>B + 树由 m 叉查找树和有序链表组合而成</li><li>每个节点中子节点个数不能超过 m，也不能小于 m/2</li><li>根节点的子节点个数可以不超过 m/2，这是例外</li><li>一般情况下，根节点会被存储在内存，其它节点存储在磁盘</li></ul><p>其它，与 B- 树差异（注：B - 就是 B 树） BalanceTree、B-Tree</p><ul><li>B+ 树中节点不存储数据，只是索引，而 B 树中节点存储数据</li><li>B 树中的叶子节点并不需要链表串联<ul><li>即 B 树只是一个每个节点的子节点个数不能小于 m/2 的 m 叉树</li></ul></li></ul><h1 id="第六章-堆"><a class="anchor" href="#第六章-堆">#</a> 第六章 堆</h1><h2 id="堆如何维护动态集合的最值"><a class="anchor" href="#堆如何维护动态集合的最值">#</a> 堆：如何维护动态集合的最值</h2><h3 id="堆的定义"><a class="anchor" href="#堆的定义">#</a> 堆的定义</h3><ul><li>堆必须是一个完全二叉树</li><li>堆中每个节点的值必须大于或等于 (或小于等于) 其子树中每个节点的值<ul><li>即堆中每个节点的值都大于或等于 (或小于或等于) 其左右子节点的值</li><li>注：由于该特性，堆不一定是二叉查找树，左子节点不一定比右子节点小</li></ul></li></ul><p>若堆中每个节点的值都大于或等于子树中每个节点的值，称为大顶堆<br />若堆中每个节点的值都小于或等于子树中每个节点的值，称为小顶堆<br />注：下述理论部分特指大顶堆</p><h3 id="堆的存储"><a class="anchor" href="#堆的存储">#</a> 堆的存储</h3><p>完全二叉树比较适合用数组存储，因此堆也适合用数组存储</p><ul><li>用数组存储完全二叉树非常节省内存，因为不需要存储左右子节点指针，只需要通过数组下标运算就可以找到某个节点的左右子节点和父节点</li></ul><p>对于下标为 i 的节点，根存储于 1 处，有：</p><ul><li>左子节点：2i</li><li>右子节点：2i+1</li><li>父节点：i/2</li></ul><p>另外，也可以将根节点存储于 0 处：</p><ul><li>左子节点：2i+1</li><li>右子节点：2i+2</li><li>父节点：(i-1)/2</li></ul><p>对比来看，将根节点从 1 开始存储，计算父子节点下标更方便<br />比较常用操作：插入元素、获取堆顶元素、删除堆顶元素</p><ul><li>不常用操作：按照节点指针 (数组下标) 删除任意元素</li></ul><h3 id="在堆中插入元素"><a class="anchor" href="#在堆中插入元素">#</a> 在堆中插入元素</h3><p>若将新元素插入堆的末尾 (数组的末尾)，堆就不满足定义要求了，因此需要调整，调整过程称为『堆化』<br />堆化分为两种：自上而下和自下而上</p><ul><li>自下而上：假设堆化节点为 a，顺着节点 a 所在路径向上对比，若节点 a 大于父节点，就将其与父节点交换，重复该过程</li><li>自上而下：从堆顶元素开始，对父子节点进行对比，对于不满足大小关系的父子节点互换位置，重复该过程直到满足要求</li></ul><h3 id="删除堆顶元素"><a class="anchor" href="#删除堆顶元素">#</a> 删除堆顶元素</h3><p>对于大顶堆，当删除堆顶节点后，需要将第二大节点放到堆顶，并迭代处理后续节点<br />不过如此处理后，最后对就不是完全二叉树树了（叶子节点出现空洞），因此有另一种处理方式：</p><ul><li>将最后一个节点放到堆顶，然后利用自上而下的堆化方式让堆重新满足定义</li></ul><h3 id="删除任意元素"><a class="anchor" href="#删除任意元素">#</a> 删除任意元素</h3><p>将堆中最后一个元素替换到删除元素位置，分条件执行堆化</p><ul><li>替换的元素大于删除元素，进行自下而上的堆化</li><li>替换的元素小于删除元素，进行自上而下的堆化</li><li>替换元素等于删除元素，不需要堆化</li></ul><h3 id="性能"><a class="anchor" href="#性能">#</a> 性能</h3><p>获取堆顶元素（最大最小值)：O (1)<br /> 插入、删除、删除任意元素时间复杂度：O (logn)</p><h2 id="堆排序"><a class="anchor" href="#堆排序">#</a> 堆排序</h2><p>堆排序时间复杂度：O (nlogn)<br /> 空间复杂度：O (1)<br /> 堆排序的时间复杂度要比快速排序稳定，但性能比快速排序慢</p><ul><li>数据访问方式对 cpu 不友好 (数据跳着访问，堆排比较的几乎都不是相邻元素)，且实际交换可能会比快排更多</li><li>建堆会降低数据有序度，例如对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了</li></ul><p>排序整个过程分为两步：建堆、排序</p><h3 id="建堆"><a class="anchor" href="#建堆">#</a> 建堆</h3><p>先将数组中数据原地组织成一个堆<br />两种思路</p><ul><li>借助堆中插入数据处理思路<ul><li>将堆中数据划分为前后两个部分，前半部分表示已建好堆的数据，后半部分表示非堆中数据</li><li>开始堆中只存在下标为 1 的数组元素，将下标 2~n 依次插入堆中，执行自下而上的堆化，执行完毕后所有数据即组织成堆结构</li><li>建堆时间复杂度：O (nlogn)</li><li>每个节点堆化时间复杂度：O (logn)</li></ul></li><li>从后往前处理数组，对每个数据执行自上而下的堆化（效率更好）<ul><li>因为叶子节点不需要堆化，对于完全二叉树，下标 n/2-1~n 的节点都是叶子节点</li><li>因此只需要对 n/2~1 的数据依次执行自上而下堆化</li><li>建堆时间复杂度：O (n)</li><li>每个节点堆化时间复杂度：O (logn)</li></ul></li></ul><h3 id="排序-2"><a class="anchor" href="#排序-2">#</a> 排序</h3><p>建堆结束后，堆中数据已经是按照大顶堆的特性来组织的了（注：左右子节点中，左子节点不一定大于右子节点）</p><ul><li>将最大元素与最后一个元素 k 交换<ul><li>k=k-1</li><li>然后执行从 0~k 的自上而下堆化</li></ul></li><li>反复进行，直到最后只剩一个元素即排序完成</li></ul><h2 id="堆的应用"><a class="anchor" href="#堆的应用">#</a> 堆的应用</h2><p>经典应用是求 topK 一类的问题，另外还有例如优先级队列、求中位数和求百分位数</p><h3 id="优先级队列"><a class="anchor" href="#优先级队列">#</a> 优先级队列</h3><p>在优先级队列中，数据并不是先进先出，而是按照优先级的高低，优先级最高的最先出队<br />堆天然就是一个优先级队列</p><h4 id="合并多个有序文件"><a class="anchor" href="#合并多个有序文件">#</a> 合并多个有序文件</h4><p>使用优先级队列 (堆) 维护动态数据最小值的时间复杂度是 O (logn)，更高效</p><h4 id="高性能定时器"><a class="anchor" href="#高性能定时器">#</a> 高性能定时器</h4><p>常规做法是每指定间隔 (如 1s) 扫描一次定时任务，该做法比较低效：任务可能间隔还很久、每次扫描整个任务列表消耗大<br />使用堆做优先级队列存储任务，队首存储最先执行任务</p><ul><li>将队首任务执行时间与当前时间相减，得到时间间隔 t，t 代表从当前时间开始，需要等待多久才会有第一个任务被执行，如此定时器就可以设定 t 秒后再来执行任务</li><li>t 秒后取队首任务执行，然后计算新的队首任务的执行时间与当前时间之差</li></ul><h3 id="求-topk"><a class="anchor" href="#求-topk">#</a> 求 TopK</h3><ul><li>静态数据，事先确定，不会再变<ul><li>建堆、堆化</li><li>时间复杂度：O (nlogK)</li></ul></li><li>动态数据，有数据会动态加入集合<ul><li>插入时维护堆</li></ul></li></ul><h3 id="求中位数和百分位数"><a class="anchor" href="#求中位数和百分位数">#</a> 求中位数和百分位数</h3><p>如果数据个数是奇数，把数据从小到大排列，第 n/2+1 就是中位数<br />如果数据个数是偶数，中位数有两个：n/2 和 n/2+1</p><ul><li>静态数据集合<ul><li>建堆后排序即可</li></ul></li><li>动态数据集合<ul><li>维护一个大顶堆和一个小顶堆</li><li>大顶堆存储动态集合前半部分数据，小顶堆存储后半部分数据，且小顶堆数据都大于大顶堆数据</li><li>如此，大顶堆中堆顶元素即为中位数（偶数情况下，则大小堆顶元素）</li><li>插入元素时，判断元素大小，以决定插入哪个堆</li><li>插入后若元素个数不满足要求，则将其中一个堆顶元素移到另一个堆，以保持平衡</li></ul></li></ul><p>求百分位数</p><ul><li>与中位数原理一致，同样维护两个大小顶堆，只是元素个数比例调整为规定的百分比</li></ul><h1 id="第七章-跳表-并查集-线段树和树状数组"><a class="anchor" href="#第七章-跳表-并查集-线段树和树状数组">#</a> 第七章 跳表、并查集、线段树和树状数组</h1><h2 id="跳表"><a class="anchor" href="#跳表">#</a> 跳表</h2><p>我们只需要对链表稍加改造，就可以支持类似『二分』的查找算法，改造后的数据结构可称为跳表 (skip list)<br /> 如 Redis 中有序集合就是用跳表实现</p><ul><li>按区间查找：跳表可以以 O (logn) 时间复杂度定位区间起点，然后在原始链表中顺序向后遍历，直到遇到区间终点节点</li><li>相比红黑树，跳表更灵活、易实现</li></ul><p>跳表实现非常灵活，可以通过改变索引构建策略，平衡空间、时间复杂度<br />注：跳表是有序的</p><h3 id="跳表的由来"><a class="anchor" href="#跳表的由来">#</a> 跳表的由来</h3><p>在链表中的数据，即使有序存储，查找数据的时间复杂度也是为 O (n)<br /> 于是对链表建立一级『索引』，每指定间隔 (如两个) 节点提取到索引层，这样查找节点时，先遍历索引层，然后跳入原始链表层，节省遍历时间</p><ul><li>第三级索引：2 个节点</li><li>第二级索引：4 个节点</li><li>第一级索引：8 个节点</li><li>原始链表：16 个节点</li></ul><p>即，假设原始链表包含 n 个节点，第一级大约 n/2 个节点，每上升一级大约减少一半节点，依次类推直到剩下两个节点为止</p><h3 id="跳表效率"><a class="anchor" href="#跳表效率">#</a> 跳表效率</h3><p>时间复杂度：O (logn)，与二分查找相同</p><ul><li>不过由于查询效率提升的前提是构建多级索引，属于空间换时间的设计思路</li></ul><p>空间复杂度：O (n)</p><ul><li>不过可以通过增加抽取节点间隔控制索引节点占用的存储空间，以达到时间复杂度和空间复杂度的平衡</li></ul><p>插入、删除时间复杂度：O (logn)</p><ul><li>若删除节点在索引中也有出现，除删除原始链表节点外，还需要删除索引中对应节点</li></ul><h3 id="跳表索引动态更新"><a class="anchor" href="#跳表索引动态更新">#</a> 跳表索引动态更新</h3><p>跳表借助随机函数更新索引结构<br />如通过随机函数得到某个值 k，就将该节点添加到第一级到第 k 级索引中</p><h2 id="并查集union-find-set"><a class="anchor" href="#并查集union-find-set">#</a> 并查集（Union-find set）</h2><p>根据对象两两之间的直接关系来快速查询任意两个对象之间是否存在关系（直接或间接）</p><ul><li>即 若 a、b 存在关系，b、c 存在关系，那么 a 和 c 就是存在关系的</li></ul><p>基于操作的对象 (集合) 和行为 (并和查)，将这种数据结构称为并查</p><h3 id="基于链表的实现"><a class="anchor" href="#基于链表的实现">#</a> 基于链表的实现</h3><p>通过链表来表示集合，链表头节点作为集合代表标识集合<br />假设原始数据存储在一个数组中，通过</p><ul><li>将链表头节点作为集合的『代表』，每个链表节点除存储 next 指针外，还存储一个指向『代表』的头节点 R 指针</li><li>合并集合时，将两个链表合并，并更新其中一个链表所有节点的 R 指针指向新的表头</li><li>查询两个对象是否属于同一个集合时，判断指向头节点的 R 指针是否指向相同即可</li></ul><p>查找时间复杂度：O (1)<br /> 合并时间复杂度：O (n)</p><ul><li>主要是更新指向头节点指针耗时</li></ul><h3 id="基于树的实现"><a class="anchor" href="#基于树的实现">#</a> 基于树的实现</h3><p>为降低 union 操作时间复杂度，可以使用树的方式实现<br />基于树的并查集实现，使用树来表示集合，树的根节点作为集合代表来标识集合</p><ul><li>判断节点所属集合时，通过借助节点父节点指针，向上追溯，沿着节点路径到达根节点</li><li>合并时，只需要把一棵树拼接到另一棵树：让其中一棵树的根节点指针指向另一棵树的根节点即可</li></ul><p>因此，按树实现方式虽然会减少合并消耗，但是会增加查找时间复杂度<br />为避免查询时间复杂度增加过高，需要尽量让树 矮胖 而非 高瘦</p><ul><li>按秩合并<ul><li>记录树的高度，称为秩 (rank)</li><li>若两棵树的秩不同，合并后的秩为原高度大的树的秩</li><li>若两棵树的秩相同，合并后的秩等于原秩 + 1</li></ul></li><li>路径压缩（更有效）<ul><li>在借助父节点指针追溯根节点时，将经过路径上的所有节点父节点指针都更新为指向根节点（再次查找就快了）</li></ul></li></ul><p>合并时间复杂度：O (1)<br /> 查找时间复杂度：路径压缩后，O (1)<br /> 两个优化是可以同时支持的</p><h2 id="线段树"><a class="anchor" href="#线段树">#</a> 线段树</h2><p>如果我们需要罗列落在某个区间的所有数据，基于跳表的实现方案最优<br />但若是只需要统计落在某个区间的数据『个数』，即解决区间统计问题时，线段树更加高效</p><ul><li>假设数据集合最大值为 m，且数据都是正整数，可以构建一棵特殊的二叉树，每个节点代表一个区间，包含 3 个基本数据：区间起始点、区间结束点和统计值 (如数据个数，具体视需求而定)</li><li>根节点表示最大区间 [1,n]，左右子节点分别代表 [1,n/2]、[n/2+1,n]</li><li>可采用数组形式存储（虽然不是完全二叉树，可能会浪费一定空间，不过由于线段树叶子节点主要集中在最后两层，整体空洞不大，可以接受。另外还有链式方式）</li></ul><p>空间复杂度：O (n)</p><ul><li>与数据集合个数无关，与数据集合最大值有关</li></ul><p>时间复杂度：</p><ul><li>构建：O (n)</li><li>插入、删除：O (logn)</li></ul><p>线段树能解决的问题统一称为区间统计问题，除统计区间数据个数外，还可以统计某个区间数据之和、最大值和最小值，以及某个区间第 k 大值<br />注：关于线段树数据存储大小</p><ul><li>如果 n 恰好是 2 的 k 次幂，由于线段树最后一层的叶子节点存储的是数组元素本身，最后一层的节点数就是 n，前面所有层的节点数之和是 n−1，那么总节点数就是 2×n−1。为了方便起见，分配 2×n 的空间。</li><li>如果 n 不是 2 的 k 次幂，最坏的情况就是 n=2k+1，那么有一个元素需要开辟新的一层来存储，需要 4×n−5 的大小。为了方便起见，可以分配 4×n 的空间</li></ul><h2 id="树状数组"><a class="anchor" href="#树状数组">#</a> 树状数组</h2><p>可以解决大部分基于区间上的更新以及求和问题</p><ul><li>所有树状数组能做的，线段树也能做，不过树状数组的优点是简单（但是原理反而感觉更难理解一些）、效率更高点</li><li>利用线段树可以解决区间统计问题，利用树状数组可以解决前缀和问题，区间统计包括 前缀和</li></ul><p>时间复杂度：O (logn)，</p><ul><li>相比线段树系数更少</li><li>缺点是功能有限，不能解决复杂区间问题</li></ul><h3 id="前缀和"><a class="anchor" href="#前缀和">#</a> 前缀和</h3><p>标准做法：创建一个 n+1 大小的前缀和数组，遍历计算，前缀和数组下标从 1 开始</p><ul><li>preSum[i]=preSum[i-1]+array[i]</li><li>要么更新元素慢 (更新时计算)，要么查询前缀和操作慢 (查询时计算)</li></ul><p>任何一个数，都可以分解为一组 2 的 k 次方的和</p><ul><li>6=b110=2<sup>2+2</sup>1+2^0</li><li>7=b111=2<sup>2+2</sup>1+2^1</li></ul><p>lowbit：求某一个数的二进制表示中最低的一位 1，例如 6 返回 2</p><ul><li><s>先消掉最后一位 1，然后再用原数减去消掉最后一位 1 后的数</s></li><li>求负数的二进制补码表示：负数的补码为其绝对值取反后加 1，然后与原数进行与操作  i&amp;(-i)，正好得到最低一位 1</li></ul><p>前缀和可通过递推公式计算</p><ul><li>假设数组 c 存放所有通过 lowbit 计算出来的对应数值的和</li><li>那么前缀和 preSum=preSum [i-lowbit (i)]+c [i]</li></ul><p>借助树状数组，可以将前缀和更新操作的时间复杂度降低到 O (logn)</p><h1 id="第八章-字符串匹配算法"><a class="anchor" href="#第八章-字符串匹配算法">#</a> 第八章 字符串匹配算法</h1><p>概念：主串和模式串，所有字符串匹配算法都会用到</p><ul><li>如果在字符串 a 中查找字符串 b，那么字符串 a 就是 主串，字符串 b 就是模式串</li><li>将主串长度记作 n，模式串长度记作 m</li><li>一般情况下，n 大于或等于 m；若 n 小于 m，则主串中必然不存在模式串</li></ul><h2 id="bf算法"><a class="anchor" href="#bf算法">#</a> BF 算法</h2><h3 id="原理与实现"><a class="anchor" href="#原理与实现">#</a> 原理与实现</h3><p>BF（Brute Force，暴力匹配）算法，也称为朴素匹配算法，该算法比较暴力，简单直接，因此性能不高</p><ul><li>如果模式串长度为 m，主串长度为 n，那么在主串中就会有 n-m+1 个长度为 m 的子串</li><li>只需要暴力对比这 n-m+1 个子串与模式串，就可以找出主串与模式串匹配的子串</li></ul><h3 id="性能-2"><a class="anchor" href="#性能-2">#</a> 性能</h3><p>最坏时间复杂度：O (nm)<br /> 虽然时间复杂度较高，但实际却比较常用</p><ul><li>实际开发中，大部分情况模式串和主串长度不会太长，数据规模较小（小规模下性能与更加高效的 KMP、BM 算法可能相差无几）</li><li>每次模式串与主串中字符串匹配时，若中途遇到不能匹配字符，可提前终止</li><li>BF 算法思想简单，代码实现也简单（意味着不容易出错）</li></ul><h2 id="rk算法rabin-karp"><a class="anchor" href="#rk算法rabin-karp">#</a> RK 算法（Rabin-Karp）</h2><p>对 BF 算法的优化，借助哈希算法提高匹配效率</p><h3 id="原理"><a class="anchor" href="#原理">#</a> 原理</h3><p>通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较</p><ul><li>若某个哈希值相等，则说明匹配</li></ul><p>哈希计算优化</p><ul><li>假设主串和模式串对应字符集只包含 k 个字符，那么就可以用一个 k 进制数表示一个子串</li></ul><p>时间复杂度：O (n)</p><ul><li>RK 算法的执行效率取决于哈希算法</li><li>若事先缓存，则会有额外空间复杂度消耗</li></ul><h2 id="bm算法boyer-moore"><a class="anchor" href="#bm算法boyer-moore">#</a> BM 算法（Boyer-Moore）</h2><p>模式串和主串的匹配过程可以看做模式串在主串中不停地往后滑动，当遇到不匹配字符串时，BF 算法和 RK 算法的做法：将模式串往后滑动一位，从模式串第一个字符重新开始匹配</p><ul><li>BM 算法本质上就是在寻找某种规律，借助这种规律，在模式串与主串匹配过程中，能够跳过一些肯定不会匹配的情况，将模式串往后多滑几位，以此提高效率</li></ul><h3 id="原理-2"><a class="anchor" href="#原理-2">#</a> 原理</h3><ul><li>坏字符串规则（bad character rule）<ul><li>按照模式串下标从大到小顺序倒序进行</li><li>当发现某个字符无法匹配，就将该字符称为坏字符（指主串中字符）</li><li>用坏字符在模式串中查找，发现不存在则可以直接滑到坏字符之后</li><li>若坏字符在模式串中存在，则滑动对应位数，使其与模式串对齐，再重新匹配</li><li>滑动规则<ul><li>坏字符对应模式串下标记为 si，若在模式串存在，则记作 xi，不存在则 xi=-1</li><li>往后滑动位数 = si-xi，所以若不存在，滑动位数等于模式串字符个数 (length-1-(-1))</li><li>计算滑动位数有可能是负数，因此有好后缀规则补充</li></ul></li></ul></li><li>好后缀规则（good suffix rule）</li></ul><p>最坏时间复杂度：O (n)<br /> 最好时间复杂度：O (n/m)<br /> 注：空间复杂度较高</p><h2 id="kmp算法"><a class="anchor" href="#kmp算法">#</a> KMP 算法</h2><p>与 BM 算法本质一样，希望匹配过程中找到一些规律，多滑几位</p><ul><li>从前往后匹配</li><li>将不能匹配的字符称为坏字符</li><li>已经匹配的那段字符串称为好前缀</li></ul><p>空间复杂度：O (m) m 表示模式串长度<br />时间复杂度：O (m+n)</p><h2 id="trie树字典树"><a class="anchor" href="#trie树字典树">#</a> Trie 树（字典树）</h2><p>又叫前缀树 (prefix tree)，属于多模式串匹配算法<br />是一个树形结构，用来解决在一组字符串集合中快速查找某个字符串的问题<br />本质上是利用字符串之间的公共前缀，将重复的前缀合并在一起</p><ul><li>根节点不包含信息</li><li>其它每个节点表示字符串中一个字符</li><li>从根节点到到某节点一条路径表示字符串集合中的一个字符串（添加字符串时，需要将字符串结尾节点设置为 EndingChar，以使查找时能区分）</li></ul><h3 id="效率"><a class="anchor" href="#效率">#</a> 效率</h3><p>构建时间复杂度：O (m*len)</p><ul><li>len 表示模式串平均长度，m 表示模式串个数</li></ul><p>查询时间复杂度：O (k)</p><ul><li>k 表示待查询字符串长度</li></ul><p>字符串匹配非常高效，不过由于借助了空间换时间的设计思路，内存消耗较大</p><ul><li>例如每个节点存储字符串的数据结构，需借助有序数组、哈希表、红黑树</li></ul><h3 id="总结-5"><a class="anchor" href="#总结-5">#</a> 总结</h3><p>对于精确匹配，哈希表或红黑树更加适合<br />对于模糊查找，例如查找前缀匹配字符串，Trie 树更合适、无可替代</p><ul><li>如关键词提示</li><li>自动输入补全</li></ul><h2 id="ac自动机多模式串匹配实现敏感词过滤"><a class="anchor" href="#ac自动机多模式串匹配实现敏感词过滤">#</a> AC 自动机：多模式串匹配实现敏感词过滤</h2><ul><li>单模式串匹配算法是指在一个模式串和一个主串之间进行匹配</li><li>多模式匹配串算法是指在多个模式串和一个主串之间作匹配（在一个主串中同时查找多个模式串）<ul><li>只需要扫描一遍主串，就可以在主串中一次性查找多个模式串是否存在</li></ul></li></ul><h3 id="基于-trie-树的敏感词过滤"><a class="anchor" href="#基于-trie-树的敏感词过滤">#</a> 基于 Trie 树的敏感词过滤</h3><p>对敏感词库进行预处理，构建成 Trie 树</p><ul><li>将用户输入作为主串，从第一个字符开始，在 Trie 树中进行匹配</li><li>当匹配到 Trie 树叶子节点或中途遇到不匹配字符时，将主串起始匹配位置向后移一位，重新从根节点开始</li></ul><h3 id="基于-ac自动机的敏感词过滤"><a class="anchor" href="#基于-ac自动机的敏感词过滤">#</a> 基于 AC 自动机的敏感词过滤</h3><p>借鉴单模式串匹配算法优化思路，对 Trie 树进行优化，进一步提高效率，产生 AC 自动机</p><ul><li>类似于单模式串匹配算法中 BF 与 KMP 的关系</li></ul><p>主要操作</p><ul><li>将多个模式串构建成 Trie 树</li><li>在 Trie 树上构建失败指针<ul><li>失败指针指向『最长可匹配后缀子串』</li><li>例如 abc 后缀子串为 bc、c，将其与其它模式串匹配，若两个都能匹配上，则最长可匹配后缀子串为 bc</li></ul></li></ul><p>匹配的时间复杂度：O (n*len)</p><ul><li>与 Trie 树一样</li><li>但实际情况下，由于失败指针优化，可以接近 O (n)</li></ul><h1 id="第九章-图"><a class="anchor" href="#第九章-图">#</a> 第九章 图</h1><h2 id="图的表示如何存储社交网络中好友关系"><a class="anchor" href="#图的表示如何存储社交网络中好友关系">#</a> 图的表示：如何存储社交网络中好友关系</h2><h3 id="图的定义"><a class="anchor" href="#图的定义">#</a> 图的定义</h3><p>图 (graph) 与树一样，也是一种非线性表，不过相比树更复杂</p><ul><li>对应树中元素称为节点，图中的元素称为顶点 (vertex)</li><li>图中一个顶点可以与任意其它顶点建立连接关系，这种连接关系称为边 (edge)</li><li>与顶点相连接的边的条数，称为顶点的度 (degree)</li><li>边有方向的称为有向图，边没有方向的称为无向图</li><li>无向图中顶点的度表示此顶点有多少条边与之相连，有向图中则分为入度 (in-degree) 和出度 (out-degree)</li><li>带权图 (weighted graph)：每条边都有一个权重</li></ul><h3 id="邻接矩阵的存储方法"><a class="anchor" href="#邻接矩阵的存储方法">#</a> 邻接矩阵的存储方法</h3><p>邻接矩阵（adjacency matrix），底层依赖二维数组</p><ul><li>对于无向图，若顶点 i 与 j 之间有边，则将 A [i][j] 和 A [j][i] 标记为 1</li><li>对于有向图，则只标记有连接的为 1</li><li>对于带权图，数组中存储对应权重</li></ul><p>邻接矩阵存储方式，可能比较浪费空间，特别是对于稀疏图（sparse matrix）来说，顶点很多，每个顶点的边并不多</p><h3 id="邻接表的存储方法"><a class="anchor" href="#邻接表的存储方法">#</a> 邻接表的存储方法</h3><p>邻接表（adjacency list），每个顶点对应一条链表</p><ul><li>对于有向图，每个顶点对应的链表存储其指向的顶点</li><li>对于无向图，每个顶点对应的链表存储的是与这个顶点有边相连的顶点</li></ul><p>邻接矩阵存储起来比较浪费空间，但使用起来更高效<br />邻接表存储起来比较节省空间，但使用起来就没那么高效了（当然邻接表的链表数据结构也可以再优化，换成更合适的数据结构）</p><h2 id="深度优先搜索与广度优先搜索"><a class="anchor" href="#深度优先搜索与广度优先搜索">#</a> 深度优先搜索与广度优先搜索</h2><p>六度分割理论：只需要六层关系就能认识任何一个陌生人；即与任何一个陌生人之间能通过 5 个中间人建立关系</p><h3 id="搜索算法"><a class="anchor" href="#搜索算法">#</a> 搜索算法</h3><p>搜索：在图中寻找从一个顶点出发到另一个顶点的路径<br />深度、广度优先搜索是针对无权图的搜索算法</p><h3 id="广度优先搜索breadth-first-searchbfs"><a class="anchor" href="#广度优先搜索breadth-first-searchbfs">#</a> 广度优先搜索（Breadth First Search，BFS）</h3><p>是一直地毯式层层推进的搜索策略，首先查找距离起始顶点 s 最近的，然后是次近的，依次往外搜索，直到找到终止顶点<br />时间复杂度：O (V+E)</p><ul><li>V 表示顶点个数</li><li>E 表示边的个数</li></ul><p>空间复杂度：O (V)</p><h3 id="深度优先搜索depth-first-searchdfs"><a class="anchor" href="#深度优先搜索depth-first-searchdfs">#</a> 深度优先搜索（Depth First Search，DFS）</h3><p>不撞南墙不回头策略<br />即走完一条路径之后，才可能搜索下一个节点路径<br />时间复杂度：O (V+E)<br /> 空间复杂度：O (V)</p><h2 id="拓扑排序"><a class="anchor" href="#拓扑排序">#</a> 拓扑排序</h2><p>拓扑排序运行在有向无环图上<br />一般可用于通过局部顺序推导全局顺序问题，还能检测图中是否存在环</p><ul><li>通过局部的依赖关系、先后顺序，推导出一个满足所有局部依赖关系的执行序列</li><li>解决算法主要有两种：Kahn 算法和深度优先搜索</li></ul><h3 id="kahn算法实现拓扑排序"><a class="anchor" href="#kahn算法实现拓扑排序">#</a> Kahn 算法实现拓扑排序</h3><p>Kahn 算法利用贪心算法思想<br />在定义数据结构时，若 s 需要先于 t 执行，就添加一条 s 指向 t 的边</p><ul><li>因此每个顶点的入度表示这个顶点依赖多少个其它顶点</li><li>若某个顶点入度变成 0，则表示该顶点没有依赖的顶点了（或者说依赖都已执行）</li><li>从图中找出一个入度为 0 的顶点，将其输出到拓扑排序结果序列，所有依赖它的顶点入度都可以减 1（即将该顶点可达顶点入度减 1）<ul><li>循环执行该过程，最后输出序列即为满足所有局部依赖关系的一个拓扑排序</li></ul></li></ul><p>时间复杂度：O (V+E)</p><h3 id="深度优先搜索实现拓扑排序"><a class="anchor" href="#深度优先搜索实现拓扑排序">#</a> 深度优先搜索实现拓扑排序</h3><p>或者应该叫『深度优先遍历』，需要遍历图中所有顶点，而非只是搜索一个顶点到另一个顶点的路径</p><ul><li>通过邻接表构建逆邻接表</li><li>在邻接表中，s-&gt;t 表示 s 先于 t 执行，即 t 依赖于 s</li><li>在逆邻接表中，s-&gt;t 表示 s 后于 t 执行，即 s 依赖于 t</li><li>递归处理每个顶点，先输出其可达所有顶点，再输出自己</li></ul><p>时间复杂度：O (V+E)</p><h3 id="利用拓扑排序检测环"><a class="anchor" href="#利用拓扑排序检测环">#</a> 利用拓扑排序检测环</h3><p>对于 Kahn 算法，如果最终输出顶点个数少于图中顶点个数，也就是图中还存在入度不是 0 的顶点，就说明图中存在环</p><h2 id="单源最短路径"><a class="anchor" href="#单源最短路径">#</a> 单源最短路径</h2><p>例如地图做优出行路线<br />适用于场景抽象成有权图的搜索<br />单源最短路径算法不仅能求得单个源点到单个终点的最短路径，还能一次性求得单个源点到多个终点的最短路径</p><h3 id="dijkstra算法"><a class="anchor" href="#dijkstra算法">#</a> Dijkstra 算法</h3><p>类似于广度优先搜索，每次找到与起点最近的顶点，往外扩展</p><ul><li>用一个优先级队列记录已经遍历的顶点</li><li>取与起点路径长度最小顶点进行扩展</li></ul><p>构建于有向有权图之上，要求不能存在负权边</p><ul><li>将所有顶点除初始顶点外的距离初始化为 int.max</li><li>将起始顶点距离初始化为 0，放入优先级队列中</li><li>从优先级队列中取出距离最短的顶点，然后考察该顶点可达的所有顶点</li><li>若顶点距离加上前往考察顶点边权重，的值小于考察顶点距离，则将其距离更新为顶点距离 + 权重，并将考察顶点加入优先级队列（重复该过程）</li></ul><p>时间复杂度：O (ElogV)</p><h2 id="多源最短路径"><a class="anchor" href="#多源最短路径">#</a> 多源最短路径</h2><h3 id="floyd算法"><a class="anchor" href="#floyd算法">#</a> Floyd 算法</h3><p>Floyd 算法：可以一次性计算出图中任意两个顶点之间的最短路径<br />与 Dijkstra 算法一样，既可以处理有向图，也可以处理无向图，但 Floyd 算法允许图中存在负权边（但不允许存在负权环）<br />该算法利用了动态规划思想，状态转移方程式：</p><ul><li>dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j])</li></ul><p>多阶段决策模型：将整个算法划分为 v 个阶段，每个阶段引入一个中转节点，基于上一个节点状态，推导下一个阶段状态<br />时间复杂度：O (V^3)</p><h2 id="启发式搜索"><a class="anchor" href="#启发式搜索">#</a> 启发式搜索</h2><p>heuristically search algorithm</p><h3 id="a算法"><a class="anchor" href="#a算法">#</a> A * 算法</h3><p>能实现快速寻找次优路线，对 dijkstra 算法的优化改造<br /> dijkstra 算法可能跑偏，因为其主要按照顶点与起点的路径长度排出出队顺序，与起点越近的顶点，就会越早出队，但是并未考虑其与终点距离</p><ul><li>因此，将顶点到终点距离也考虑进去，综合判断哪个顶点应该先出队列，避免跑偏</li></ul><p>不过，尽管 A * 算法可以更加快速地找到起点到终点的路线，但并不能像 Dijkstra 算法那样找到最短路径</p><ul><li>A * 算法只要找到终点即结束，不会考察所有路线</li><li>Dijkstra 算法则是终点出队结束，实际上考察了从起点到终点所有路线</li></ul><p>启发式搜索算法利用估价函数避免跑偏，贪心地朝着最有可能到达终点的方向前进，因此找出并非最短路径，而是次优路径。但工程中路径规划问题往往不需要如此精确，因此启发式搜索算法能更好地平衡路线质量和执行效率，应用更加广泛</p><h2 id="最小生成树随机生成迷宫地图"><a class="anchor" href="#最小生成树随机生成迷宫地图">#</a> 最小生成树：随机生成迷宫地图</h2><h3 id="什么是最小生成树"><a class="anchor" href="#什么是最小生成树">#</a> 什么是最小生成树</h3><p>假设图包含 V 个顶点和 E 条无向有权边，要连通所有顶点，至少需要 V-1 条边（对于一个连通图，V-1 肯定小于或等于 E）</p><ul><li>这 V-1 条边和 V 个顶点构成一棵树，称为生成树</li><li>图的生成树并不是唯一的，如果某棵生成树包含的 V-1 条边的权重和最小，那么这棵树就称为最小生成树（Minimum Spanning Tree，MST）</li></ul><p>最小生成树在现实生活中应用就很多，例如 V 个城市建立通信网络最省铺设线路方式、道路建设等</p><h3 id="kruskal算法"><a class="anchor" href="#kruskal算法">#</a> Kruskal 算法</h3><p>贪心算法思想</p><ul><li>利用并查集，初始时每个顶点对应一个集合，按照权重从小到大依次考察每条边</li><li>如果某条边对应的两个顶点不在同一个集合中，就将这条边选入最小生成树中，并将两个顶点对应集合合并<ul><li>若某条边对应两个顶点在同一个集合，说明两个顶点已经连通，若再添加一条边会导致形成环</li></ul></li><li>依此类推，考察每条边，直到最小生成树中包含 V-1 条边为止</li></ul><p>时间复杂度：O (ElogE)</p><h3 id="prim算法"><a class="anchor" href="#prim算法">#</a> Prim 算法</h3><p>同样利用贪心算法思想<br />在 Prim 算法中，使用优先级队列存储待考察顶点、以及前驱顶点与这个顶点之间的边的权重</p><ul><li>先初始化一棵只包含图中最小边的最小生成树</li><li>基于当前的最小生成树，考察与最小生成树相连的所有边，找到权重最小且加入不会导致最小生成树中包含环的那个边，将这个边加入最小生成树</li><li>依此类推，重复第二步，直到最小生成树中包含 V-1 条边</li></ul><p>具体步骤</p><ul><li>初始选择一个顶点，将该顶点相连的边放入优先级队列</li><li>从优先级队列中取出队首元素</li><li>若边的两个顶点均已访问，则不进行任何处理，跳入下一轮</li><li>若边对应顶点中，有一个顶点未访问，则将这条边加入最小生成树中，并考察与其相连的所有边</li><li>直到有 V-1 条边出队，此时即为最小生成树</li></ul><p>时间复杂度：O (ElogE)</p><h3 id="随机-prim算法"><a class="anchor" href="#随机-prim算法">#</a> 随机 Prim 算法</h3><p>将迷宫中元素分为两类：道路、墙</p><ul><li>初始迷宫没有任何道路，可以将迷宫中每个单元格看作图中一个顶点，墙看作一条边</li><li>一堵墙要么连接左右两个道路单元格，要么连接上下两个道路单元格</li><li>在这样一个图上，寻找一棵生成树，生成树中包含的边代表墙将被打通（移除）</li><li>因为生成树包含所有的顶点，且连通所有的顶点，将生成树中边对应的墙从迷宫地图移除，所以所有这样的道路单元格就打通了</li><li>任选一个迷宫的起点和终点，都会有相应的通路</li></ul><p>随机 Prim 算法与 Prim 算法处理思路几乎相同，唯一区别在于将优先级队列改为了随机队列，从随机队列取出的元素是随机选择元素，而非权重最小元素</p><ul><li>对于随机生成迷宫问题，抽象出来的是无权图，只需要求得生成树即可满足要求</li></ul><h2 id="最大流"><a class="anchor" href="#最大流">#</a> 最大流</h2><p>针对一张有向权图，选定两个顶点分别作为源点 s 和汇点 t，计算从源点到汇点的最大流量</p><ul><li>即源点可以发出的最大流量，也等于汇点可以接受的最大流量</li></ul><p>最大流算法很多，大体可以分为两类：</p><ul><li>基于增广路径（augmenting path）的算法</li><li>基于推送 - 重贴标签（push relabel）的算法</li></ul><p>例如应用于网络流</p><h3 id="ford-fulkerson方法"><a class="anchor" href="#ford-fulkerson方法">#</a> Ford-Fulkerson 方法</h3><p>基于增广路径<br />之所以称为方法而非算法，是因为其只给出了求解最大流框架思路，而非具体实现<br />基本原理非常简单：即通过不停地在残余网络中寻找增广路径来求解最大流。不过也需要对基本原理进行修正，通过增加反向边对之前的增广路径实现『改道』</p><ul><li>用 g [i][j] 表示顶点 i 到顶点 j 的边的权值 (容量)，初始从源点到汇点的最大流值 maxflow=0</li><li>在图中找出一条从源点到汇点的可达路径 p<ul><li>假设路径中最小边的权值是 delta，也就表示这条路径可以输送 delta 大小的流量</li></ul></li><li>将 delta 值加到 maxflow 上，并将路径 p 中所有边的容量都减去 delta</li><li>这条流量为 delta 的路径称为增广路径，将增广路径从图中移除后，剩下的图即为残余网络，使用 c [i][j] 记录残余网络中顶点 i 到顶点 j 的残余容量</li><li>不停在残余网络中寻找增广路径，然后增加 maxflow 值 -&gt; 移除增广路径，直到残余网络中没有增广路径为止</li><li>最后得到的 maxflow 值就是图的最大流，此时 g [i][j]-c [i][j] 就是对应 maxflow 每条边流过的流量</li></ul><p>注 1：指的是所有路径加起来的流量，以及所有可以自己独立运行，不互相干涉的路径<br />单纯像上述计算，会有缺陷，可能找出的不一定是最大流</p><ul><li>调整方式：其它逻辑不变，当找到一条增广路径后，不仅将其从图中移除，还会将反向的增广路径添加至残余网络</li><li>即，例如找到 i~j，将其流量减掉后，反向添加 j~i 的流量（即，使存在反向边）</li></ul><h3 id="edmonds-karp算法"><a class="anchor" href="#edmonds-karp算法">#</a> Edmonds-Karp 算法</h3><p>利用广度优先搜索实现的 Ford-Fulkerson 方法称为 Edmonds-Karp 算法</p><h2 id="最大二分匹配"><a class="anchor" href="#最大二分匹配">#</a> 最大二分匹配</h2><p>对于一个二分图，图中顶点分为左右两个部分，所有的边都横跨左右两部分，起始顶点在左，结束顶点在右<br />如果某两个顶点有边相连，称其为可匹配，一个顶点最多与一个顶点匹配成功<br />找出二分图中最大可匹配树，即为最大二分匹配</p><ul><li>例如单身交友联谊匹配问题</li></ul><p>可在二分图上补充两个顶点，一个源点，一个汇点。源点连接左半部分，汇点连接右半部分，即可转换为最大流问题</p><h1 id="第十章-贪心-分治-回溯和动态规划"><a class="anchor" href="#第十章-贪心-分治-回溯和动态规划">#</a> 第十章 贪心、分治、回溯和动态规划</h1><h2 id="贪心算法greedy-algorithm"><a class="anchor" href="#贪心算法greedy-algorithm">#</a> 贪心算法（greedy algorithm）</h2><p>应用：霍夫曼编码 (Huffman coding)、Prim、最小生成树等<br />针对一组数据，事先定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大</p><ul><li>套用贪心算法模型</li><li>尝试用贪心算法解决；每次选择对限制值同等贡献量的情况下，对期望值贡献最大的数据</li><li>举例验证算法是否正确</li></ul><p>注：使用贪心算法解决问题，并不总能给出最优解</p><ul><li>主要原因在于贪心选择过程中前面的选择会影响后面的选择</li><li>例如即便第一步选择了最优解 (权值最小)，但也可能因为这一步的选择，导致后面可选择的路径不是最好的</li></ul><p>对于贪心算法，最难的是将要解决的问题抽象成贪心算法模型，只要完成这一步，贪心算法就会很简单</p><h3 id="霍夫曼编码"><a class="anchor" href="#霍夫曼编码">#</a> 霍夫曼编码</h3><p>霍夫曼编码是一种非常有效的编码方法，广泛应用于数据压缩中，压缩率通常为 20%～90%<br /> 霍夫曼编码使用一种特别的方法为信号源中的每个符号设定二进制码。出现频率更大的符号将获得更短的比特，出现频率更小的符号将被分配更长的比特，以此来提高数据压缩率，提高传输效率</p><ul><li>其不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率</li><li>根据频率不同，选择不同长度的编码，使用这种不等长的编码方法进一步提高压缩效率</li><li>由于编码不定长，因此解压缩时比较复杂，另外为了避免歧义，要求各个字符编码之间不能出现某个编码是另一个编码前缀的情况</li></ul><p>编码方式</p><ul><li>将每个字符看作一个节点，并把对应的出现频率一起放到优先级队列中</li><li>从优先级队列中取出出现频率最小的两个节点 A、B</li><li>新建一个节点 C，其频率设置为两个节点之和，然后将两个节点设置为 C 节点的子节点</li><li>将 C 节点放入优先级队列中（A、B 节点将标记为已处理）</li><li>重复操作直到队列没有未处理数据，最终将得到一棵霍夫曼树</li><li>霍夫曼树构造完成对树进行编码，左子节点标记为 0，右子节点标记为 1（左 0 右 1），从根节点到叶子节点的路径就是叶子节点对应的霍夫曼编码（二进制）</li></ul><h2 id="分治算法"><a class="anchor" href="#分治算法">#</a> 分治算法</h2><p>分治算法（divide and conquer）核心思想其实就 4 个字：分而治之</p><ul><li>将原问题划分成 n 个规模更小并且结构与原问题相似的子问题，递归地解决这些子问题，然后合并结果得出原问题解</li></ul><p>条件</p><ul><li>原问题与分解成的小问题具有相同的结构</li><li>由原问题分解成的子问题可以独立求解，相互没有相关性（与动态规划的明显区别）</li><li>具备分解终止条件</li><li>可以将子问题合并成原问题的结果</li></ul><h3 id="应用示例"><a class="anchor" href="#应用示例">#</a> 应用示例</h3><p>求一组数据的逆序对个数<br />我们使用一组数据中包含的有序对或逆序对个数来表示有序度或逆序度</p><ul><li>有序度：一组数据的有序程度</li><li>逆序度：一组数据的无序程度</li></ul><p>使用归并排序，排序合并两个元素组时顺便统计：合并时判断左边元素是否大于右边元素进行统计</p><h2 id="回溯算法"><a class="anchor" href="#回溯算法">#</a> 回溯算法</h2><p>如深度优先搜索即利用回溯算法思想<br />我们一生中，会遇到很多重要的『岔路口』，每个选择都会影响我们今后的人生。有的人在每个岔路口都能做出正确的选择，生活、事业达到一个新的高度。而有的人一旦选错，最后可能碌碌无为。<br />贪心算法，每次面对选择时，都能做出『当下』最优选择，期望这一局部最优使我们达到全局最优。但是，贪心算法不一定能得到最优解。</p><h3 id="理解"><a class="anchor" href="#理解">#</a> 理解</h3><p>回溯的处理思想有点类似枚举（或穷举），枚举所有的解，找出其中满足期望的解</p><ul><li>为了有规律枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段</li><li>每个阶段都会面对一个『岔路口』，先随意选择一条路走，当发现这条路走不通时 (不符合期望解)，就回退到上一个『岔路口』，另选一种走法继续走</li></ul><h3 id="应用"><a class="anchor" href="#应用">#</a> 应用</h3><ul><li>八皇后问题</li><li>0~1 背包问题（经典解法是动态规划，回溯算法也可以，但性能没那么好）</li><li>正则表达式匹配</li><li>图的着色</li><li>旅行商</li><li>数独</li><li>求全排列</li></ul><h2 id="动态规划"><a class="anchor" href="#动态规划">#</a> 动态规划</h2><p>动态规划比较适合用来求最值问题，如最大值最小值等，可以显著降低时间复杂度，提高代码执行效率<br />大部分动态规划能解决的问题，也可以通过回溯算法解决，不过时间复杂度较高<br />动态规划可以避免重复计算，并利用上一阶段的最优状态来推导下一个阶段的状态，但是动态规划的空间复杂度也提高了，相当于空间换时间的算法思想</p><h3 id="理论"><a class="anchor" href="#理论">#</a> 理论</h3><p>一个模型和三个特征</p><ul><li>一个模型指动态规划适合解决的问题的模型：多阶段决策模型<ul><li>一般用动态规划来解决最优问题，并把解决问题过程划分为多个决策阶段，每个决策阶段对应一组状态</li><li>寻找一组决策序列，经过这组决策序列能够产生最终期望求解的最优指</li></ul></li><li>三个特征<ul><li>最优子结构：问题的最优解包含子问题的最优解，可以通过子问题最优解推导出问题最优解（后面阶段状态可以通过前面阶段状态推导而来）</li><li>无后效性：在推导后面阶段状态时，只关心前面阶段状态的状态值，不关心这个状态是如何推导出来的。某阶段状态一旦确定，就不受之后阶段的决策影响</li><li>重复子问题</li></ul></li></ul><h3 id="两种解题方法"><a class="anchor" href="#两种解题方法">#</a> 两种解题方法</h3><p>状态转移表法</p><ul><li>先设计一个状态表（一般是二维的）</li><li>每个状态包含 3 个变量：行、列和数组值</li><li>根据决策先后过程，分阶段填充状态表中的每个状态</li><li>将递推填表过程翻译成代码</li></ul><p>状态转移方程法</p><ul><li>有点类似递归思路：需要分析某个问题如何通过子问题来求解，找最优子结构，根据最优子结构写递推公式，即状态转移方程</li></ul><h2 id="四种算法对比"><a class="anchor" href="#四种算法对比">#</a> 四种算法对比</h2><p>贪心、回溯、动态规划可以划分为一类，分治可以单独作为一类。前三个算法解决问题模型多数可以抽象成多阶段决策模型，分治虽然也是求最优解，但大部分不能抽象为多阶段决策最优解模型<br />回溯是个比较万金油算法，对于能用动态规划、贪心解决的问题基本也能用回溯解决。回溯相当于穷举搜索，穷举所有情况对比得到最优解，因此时间复杂度较高，为指数级别，只能用于解决小规模问题<br />在重复子问题上，动态规划和分治算法区别明显：分治算法要求分解后的子问题不能有重复子问题，动态规划正好相反，正是为了解决分解后子问题有重复而存在<br />贪心实际上动态规划的一种特殊情况，具有贪心选择性：通过局部最优解能产生全局最优选择</p><h1 id="总结-6"><a class="anchor" href="#总结-6">#</a> 总结</h1><p>总之，比较推荐，图文并茂。就算之前知道的，说不定都会有新的认识</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;例行总结一下时间：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;/blogimages/2023/2023-06-04/Snipaste_2023-06-04_20</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://wangjiaying.top/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>DOTS1.0(Metaverse大衍神君系列)-笔记</title>
    <link href="https://wangjiaying.top/2023/05/29/DOTS1-0-Metaverse%E5%A4%A7%E8%A1%8D%E7%A5%9E%E5%90%9B%E7%B3%BB%E5%88%97-%E7%AC%94%E8%AE%B0/"/>
    <id>https://wangjiaying.top/2023/05/29/DOTS1-0-Metaverse%E5%A4%A7%E8%A1%8D%E7%A5%9E%E5%90%9B%E7%B3%BB%E5%88%97-%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-29T07:30:30.000Z</published>
    <updated>2023-06-04T11:58:57.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>主要内容来源于：Metaverse 大衍神君  <code>RoadToDotsTutorials</code>  相关教程，本文为个人笔记<br /><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x3d2hiL1JvYWRUb0RvdHNUdXRvcmlhbHMuZ2l0"> https://github.com/lwwhb/RoadToDotsTutorials.git</span><br /><img data-src="/blogimages/2023/2023-05-29/Snipaste_2023-05-29_16-33-01.jpg" alt="" /><br /> 注：暂且先从语雀笔记搬过来，还会继续进行整理、修改</p><h2 id="dots-是什么"><a class="anchor" href="#dots-是什么">#</a> Dots 是什么？</h2><ul><li>Data-Oriented Technology Stack（面向数据的技术堆栈）</li><li>由 5 个核心包定义构成：<ul><li>C# Job System</li><li>Burst Compiler<ul><li>优化 C# 代码的编译器</li></ul></li><li>Unity Mathematics<ul><li>可以在 JobSystem 使用的数学库，同时针对 burst 编译器特别优化</li></ul></li><li>Unity Collections</li><li>Entities（esc）</li></ul></li><li>其它包<ul><li>Entities.Graphics</li><li>Netcode</li><li>Physics<ul><li>Unity Physics (无状态、确定性)</li><li>Hovak Physics (有状态、不具备确定性，但是更稳定)</li></ul></li><li>Animation(wip)</li><li>Audio(wip)</li></ul></li><li>应用<ul><li>需要多线程加载、通讯、并行</li><li>CPU 密集型都可以使用</li><li>充分利用现代 CPU 的多核、及缓存效率</li></ul></li><li>学习方法<ul><li>看、查、学、改、调、写、交流</li></ul></li><li>程序设计方法<ul><li>指令化编程</li><li>函数化编程</li><li>过程化编程</li><li>面向对象编程 / 设计 (oop/ood)</li><li>面向数据设计 (dod)<ul><li>本质是面向内存、缓存友好的设计</li><li>开发人员需要考虑需要什么数据以及如何在内存中如何构造和组织数据，以便 cpu 处理数据时能更有效地访问数据</li></ul></li></ul></li><li>缓存层级结构<ul><li>L1 Cache：每个指令处理单元独享（分为数据缓存和指令缓存）</li><li>L2 Cache：核心内多个指令处理单元共享</li><li>L3 Cache：CPU   多个核心共享</li><li>fetch+decode+execution 构成一次 cycle</li><li>因此当某一级缓存未命中时，向下一级缓存取数据要花费数倍时间</li><li><img data-src="/blogimages/2023/2023-05-29/476232314.jpeg" alt="" /></li></ul></li><li>缓存行：一般根据 cpu 结构不同，为 32 或 64 个字节</li><li>Cache 的 3c 与 3r：<ul><li>compulsory misses：首次读取数据时，必然 miss</li><li>capacity misses：缓存空间不足时，连续使用期间访问数据过多的话，无法保存所有活动的数据</li><li>conflict misses：发生访问冲突时，由于数据映射到相同的缓存行，导致缓存抖动<ul><li>缓存抖动发生比较多，一次 cacheline 没有需要的，实际访问数据不连续</li></ul></li><li>rearrange：重新排列（代码、数据），更改布局以增加数据空间的局部性</li><li>reduce：减少（大小、缓存行读取），更小更智能的格式、压缩（如位运算）</li><li>reuse：重用，增加数据的时间和空间的局部性（对齐、连续访问、减少发生缓存抖动几率）</li></ul></li><li>Cache<ul><li>L1 致力于更快的速度，L2 致力于命中率</li><li>Cache 如果做大了取一个字的时候时间就会增加，把 L1 做大后显然命中时间和整个延迟开销会增加</li><li>缓存分层本质是物理距离决定的（价格与平衡）</li></ul></li><li>Cache 层级与排队管理<ul><li>计算机执行类似排队</li><li>dots 设计队列结构</li><li>ecs 组织队列规则</li><li>jobsystem 队列调度</li><li>三级缓存由指令调度需求决定？</li></ul></li><li>面向数据设计需要思考的问题<ul><li>array of structures (AoS) 结构数组 - 面向对象组织</li><li>structure of arrays (SoA) 数组结构 - 面向数据组织</li><li>这分别代表着两种不同的数组组织形式</li></ul></li><li>dots 面向数据设计原则<ul><li>先设计，后编码</li><li>为高效使用内存与缓存而设计</li><li>为 bittable data 设计</li><li>为普通情况设计</li><li>拥抱迭代</li></ul></li></ul><h2 id="ecs"><a class="anchor" href="#ecs">#</a> ECS</h2><ul><li>实体组件系统 (ecs) 架构<ul><li>遵循组合优于继承原则</li><li>面向数据设计</li><li>弱耦合</li><li>常用于游戏开发</li></ul></li><li>本质：组合的是数据的数组，而非对象的数组</li><li>Entity：虽然叫实体，但并非对象，也不是容器，而是一个对象索引的 id、一个标识符，用来指示某个对象的存在，其中并不包含任何数据和逻辑，可通过组件分配某些属性</li><li>conponent：数据的容器 (不是对象的容器)，其中不包含任何逻辑</li><li>注：entity 与 conponent 关系 ——entity 充当数据的标识符或 key 来使用</li><li>system：真正负责对数据进行操作的部分</li></ul><hr /><ul><li>IJobEntity 被自动生成为 IJobChunk</li><li>oop：数组的结构（array of structs）<ul><li>同一个对象放一起</li></ul></li><li>esc：结构数组（structs of array）<ul><li>所有同一类型放一起</li></ul></li><li>chunk 大小固定，于是 archytypes 固定，方便动态插入新数据<ul><li>每个 chunk 数量也应该考虑，否则会出现无效空白内存块</li><li>每个 chunk 还有其它额外数据</li><li>例如只读的加上 readonly 特性，避免 versionnumber 自增（还有参数只读 in）</li></ul></li></ul><hr /><ul><li>archetypes (原型)：依然是一个标识符，标识所有具有相同 conponent 组合的实体类型<ul><li><img data-src="/blogimages/2023/2023-05-29/1940844859.jpeg" alt="1940844859.jpeg" /></li><li>可以理解为不同的 entity 在内存中的布局</li></ul></li><li>archetype chunk：每个 archetype 所标记的内存会被分为固定大小、连续的非托管内存块<ul><li><img data-src="/blogimages/2023/2023-05-29/2050743949.jpeg" alt="2050743949.jpeg" /></li><li>包含共享同一原型的实体组件数组</li><li>默认设置下每个 chunk 为 16kb，实体填充不满也会留白</li><li>方便做数据并行计算，方便做做缓存的 prefetch</li><li>数据对齐同时可以匹配缓存行</li><li>查询时利用纵向纬度分块对齐方式做 slice 切片</li></ul></li><li>world：一系列 entity 的组合，每个 entity 在一个 world 中唯一，统一受 entitymanager 管理（所以通过 id 查找 entity 并不安全）</li><li>entitymanager：负责创建、销毁、修改 世界中的实体</li><li>structural change：所有导致需要重新组织内存块或内容的操作<ul><li>改变结构</li><li>改变 (内存块) 内容</li><li>两个都只能在主线程进行，资源密集型操作，效率差<ul><li>如添加或删除一个 entity 对应的组件导致所属原型发生变化</li><li>创建、销毁实体</li><li>设置 shared component 值</li></ul></li><li>尽量避免</li><li>确定运行时无需修改可在编辑器做 bake 提高效率</li></ul></li><li>query：通过切片方式组织查询，让人感觉上是连续的，但并不会造成内存上的移动</li></ul><h1 id="unity-jobs-system"><a class="anchor" href="#unity-jobs-system">#</a> Unity Jobs System</h1><ul><li>包含 C# Jobs System 和 C++ Jobs System</li><li>安全多线程</li><li>可与 ECS 结合使用，也可单独使用</li><li>Blitable：在 C++ 下与 C# 下内存表述一致的类型<ul><li>C# bool 值占用 4 个字节，c++ 1 字节，不一致</li><li>Jobs 只能使用 Blitable 或 非托管堆数据</li><li><span class="exturl" data-url="aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL3poLWNuL2RvdG5ldC9mcmFtZXdvcmsvaW50ZXJvcC9ibGl0dGFibGUtYW5kLW5vbi1ibGl0dGFibGUtdHlwZXM=">可直接复制到本机结构中的类型和非直接复制到本机结构中的类型 - .NET Framework</span></li></ul></li><li>Allocation Types<ul><li>persistent：长生命周期内存</li><li>tempjob：只在 job 中存在的短生命周期，4 帧以上会收到警告</li><li>temp：一个函数返回前的短生命周期</li></ul></li><li>调度方式<ul><li>run：主线程立即顺序执行</li><li>schedule：单个工作线程或主线程，每个 job 顺序执行</li><li>scheduleparallel：在多个工作线程同时执行，性能最好，但多个工作线程访问同一数据时可能发生冲突</li></ul></li><li>job 可以链式依赖，或同时依赖多个 jobhandle，避免 race condition</li><li>job safety checks：安全检查，在发生 job 访问数据冲突时会抛出异常（仅编辑器生效，可开关，为谨慎性而提供，并不智能）<ul><li>nativedisablecontainersafetyrestriction 特性，关闭对指定数据安全检查</li><li>readonly 特性标签也可以避免安全检查抛出异常</li></ul></li></ul><h1 id="entities"><a class="anchor" href="#entities">#</a> Entities</h1><h2 id="基础"><a class="anchor" href="#基础">#</a> 基础</h2><ul><li>少用分支语句，会造成 cache 不友好</li><li>authoring 模式：编辑器创建<ul><li><p>创建 entitysubscene</p></li><li><p>在 subscene 创建 gameobject 对象</p></li><li><p>为 gameobject 添加默认 conponent 和 自定义 icomponentdata 数据</p></li><li><p>自定义 icomponentdata 完成数据编排</p></li><li><p>authoring-baking (隐式)-runtime</p></li><li><p>baker：用来创建自定义数据</p></li><li><p>bakersystem：运行于 baker 之后，处理复杂 baking 情况，可选处理</p></li></ul></li><li>runtime 模式：完全代码创建<ul><li>创建一个 world</li><li>通过 world 中 entitymanager 创建、管理 entity 对象<ul><li>entity：整形 id 和 version 数据组成的结构体</li></ul></li><li>通过 world 中 entitymanager 创建 entity 对应 conponent<ul><li>icomponent：一个 c# 结构体，可以被 entities id 索引，一般无法被托管对象引用，内存紧密排列。</li></ul></li><li>根据创建的 entity 或 entityarchetype 实例化 entity</li><li>通过 system 实现对应 entity 逻辑管理<ul><li>systembase：托管类，简单，运行于主线程，不能被 burst 编译</li><li>isystem：struct，非托管，可以被 burst 编译，快但更复杂</li></ul></li></ul></li></ul><h2 id="components-类型"><a class="anchor" href="#components-类型">#</a> Components 类型</h2><ul><li>内存类型划分<ul><li>非托管（常用）<ul><li>blitable type</li><li>bool</li><li>char</li><li>blobassetreference</li><li>collections.fixedstring</li><li>collections.fixedlist</li><li>Fixed array</li><li>And so on（不变数据结构、长度、固定大小）</li></ul></li><li>托管<ul><li>可存储如何数据类型，但无法使用 jobs 访问，也无法使用 burst 编译，且声明 data 对象必须是无参数构造函数</li><li>不会存储在 chunk 中，而是所属 world 一个大数组中，chunk 仅存储索引，因此查找 entity 托管类型组件时需要处理额外索引查找工作，更慢</li></ul></li></ul></li><li>功能类型划分<ul><li>一般 component</li><li>shared component</li><li>tag component<ul><li>标识 entity 方便查找</li><li>不占用存储空间，非常好用于分类功能组件</li></ul></li><li>enableable component<ul><li>运行时启用、禁用</li></ul></li><li>cleanup component<ul><li>错误状态防止销毁 entity</li></ul></li><li>singleton component<ul><li>一个 world 下唯一存在（多个 world 可重复）</li></ul></li></ul></li><li>数据访问类型划分<ul><li>按 entity 访问</li><li>按 chunk 访问</li><li>按 element 访问</li></ul></li><li>按接口类型划分<ul><li>Ienableablecomponent</li><li>Isystemstatecomponent</li><li>Isystemstatesharedcomponent</li><li>Icomponentdata</li><li>Isharedcomponentdata</li><li>Ibufferelementdata</li></ul></li><li>entities 包中的数据大类<ul><li>componentdata</li><li>bufferdata</li><li>isharedcomponentdata</li><li>entitydata</li><li>unitycomponentobject</li></ul></li></ul><h2 id="system"><a class="anchor" href="#system">#</a> System</h2><h3 id="类型"><a class="anchor" href="#类型">#</a> 类型</h3><ul><li>isystem：提供对非托管内存访问</li><li>systembase：用于访问存储托管数据</li><li>注：任何 system 都能访问任何 world 下的 entity（不推荐）</li><li>编辑器下，system 窗口会显示每个操作时间消耗，默认小数点 2 位，可设置更高精度</li></ul><h3 id="更新"><a class="anchor" href="#更新">#</a> 更新</h3><ul><li>同 systemgroup 下调整 system 更新顺序<ul><li>[updatebefore]</li><li>[updateafter]</li></ul></li><li>指定 system 到特定的 ComponentSystemGroup 下<ul><li>[updateingroup]</li></ul></li><li>控制 system 的创建与销毁顺序<ul><li>[createbefore]</li><li>[createafter]</li><li>注：被修饰的 system 的销毁顺序与创建顺序相反</li></ul></li><li>禁止 System 被默认创建并添加到默认 ComponentSystemGroup 中<ul><li>[DisableAutoCreation]</li><li>注：被修饰的 System 需手动调用 world.getoncreatesystem 创建，及手动调用 xxxsystem.update 更新</li></ul></li><li>空的 systemgroup 与空的 monobehavior 函数一样，都会有时间开销</li><li>使用 system 注意点<ul><li>不要在 system 中定义 public 数据，应将其组织为 component 数据</li><li>在 system 更新时，尽量采用 system state 中的 getentityquery、getcomponenttypehandle 等访问 chunk component 数组，而不是通过 entitymanager 方法访问 (有额外开销)</li></ul></li></ul><h3 id="遍历与查询"><a class="anchor" href="#遍历与查询">#</a> 遍历与查询</h3><ul><li>dots 程序三大主要工作<ul><li>设计与组织数据</li><li>遍历与查找数据</li><li>修改与更新数据</li></ul></li><li>遍历查询 entity 数据的 5 种方式<ul><li>systemapi.query + foreach<ul><li>只能在 system 调用</li><li>不能存储结果，并在一个或多个 foreach 使用（因为模板类型需要在编译时确定并生成代码）</li><li>只能用于主线程</li><li>不能过滤同时『包含』的 chunk</li><li>有七种重载：iaspect、icomponentdata、dynamicbuff&lt;&gt;、refro&lt;&gt;、refrw&lt;&gt;、enabledrefro&lt;&gt;、enabledtefrw&lt;&gt;</li></ul></li><li>Ijobentity<ul><li>与 Entities.foreach 类似，每个 entity 调用一次</li><li>可在多个 system 重用</li><li>底层通过 ijobchunk 实现</li><li>可通过参数特性修饰查询</li><li>entityindexinquery 特性获取当前 entity 遍历查询索引</li></ul></li><li>Ijobchunk<ul><li>更底层实现，遍历 archetype chunk</li><li>每个 chunk 调用一次</li><li>一般用于不需要遍历每个 chunk 中 entity 的情况或对 chunk 内的 entity 执行多次遍历或以不寻常顺序遍历的情况</li><li>useenabledmask 与 chunkenablemask 辅助过滤 enableable component 未激活的 entity（不会自动过滤）</li></ul></li><li>Entities.foreach<ul><li>只用于 systembase 创建的 system</li><li>定义一个 lambda 表达式</li><li>使用限制较多，一般不用</li></ul></li><li>Manually（手动遍历）<ul><li>entitymanager.getallentities()</li><li>entitymanager.getallchunks()</li><li>限制较小，但性能上不划算</li></ul></li></ul></li></ul><h3 id="system-其它特性"><a class="anchor" href="#system-其它特性">#</a> System 其它特性</h3><ul><li>[requirematchingqueriesforupdate]<ul><li>每个 entity 结果都是空时则强制跳过 system onupdate 调用</li></ul></li><li>state.requireforupdate&lt;&gt;()<ul><li>只有指定组件存在时，该 system 才运行</li></ul></li></ul><h2 id="aspect"><a class="anchor" href="#aspect">#</a> Aspect</h2><ul><li>Aspect 中可包含的数据类型<ul><li>entity</li><li>refrw&lt;&gt;、refro&lt;&gt;</li><li>enanledrefrw 和 enabledrefro</li><li>dynamicbuff&lt;&gt;</li><li>其它 aspect 类型</li><li>注：tranformaspect 是 unity 内置的唯一一个 aspect，封装各种 local、world 坐标系下的旋转、缩放、位置及其它一些组件数据</li></ul></li></ul><h2 id="内置组件"><a class="anchor" href="#内置组件">#</a> 内置组件</h2><h3 id="componentlookupt-随机访问"><a class="anchor" href="#componentlookupt-随机访问">#</a> ComponentLookup<T> 随机访问</h3><ul><li>componentlookup&lt;&gt;<ul><li>本质上是个 nativecontainer</li><li>可使用 job 同时在不同的一组实体上迭代</li><li>[NativeDisableParallelForRestrictionAttribute] 特性可解除对并行写入的限制（如确定每个 job 写入索引不冲突）</li><li>注：若希望在 job 之外访问 entity 组件，可考虑使用 entitymanager.getcomponentdata 做随机访问，避免创建 componentlookup 开销</li></ul></li><li>entitystorageinfolookup<ul><li>测试一个 entity 是否存在</li><li>通过存在的 entity id 获得 entitystorageinfo</li></ul></li></ul><h3 id="entity-command-buffer"><a class="anchor" href="#entity-command-buffer">#</a> Entity Command Buffer</h3><p>可以记录更改实体数据的命令，然后在稍后的主线程回放 ECB 时执行这些命令，基于命令模式设计</p><ul><li>RenderCommandBufer：同步统一执行渲染状态的改变</li><li>EntityCommandBuffer：与 RenderCommandBufer 类似，不过 ECB 是同步统一执行 Entity 相关数据的改变</li><li>Job 中不能直接创建和销毁 Entity</li><li>Job 中不能添加和删除 Entity 组件<ul><li>只能使用 Entity Command Buffer 来处理这些操作</li><li>ECB 具有很多与 EntityManager 相同的方法</li></ul></li><li>ECB 的 Playback 方法必须在主线程调用，记录 ECB 命令的 Job 必须在 Playback 方法调用前完成<ul><li>ECB 需要在调用 Playback 后销毁</li><li>（子线程数据同步至主线程）</li><li>奇偶线程只是记录命令，主线程调用 Playback 才是实际生产</li><li>state.Dependency.Complete();</li><li>ecb.Playback(state.EntityManager);</li><li>ecb.Dispose();</li></ul></li></ul><h3 id="entity-command-buffer-system"><a class="anchor" href="#entity-command-buffer-system">#</a> Entity Command Buffer System</h3><ul><li>使用 ecb 更简便<ul><li>world.getexistingSystemManaged&lt;&gt;().CreateCommandBuffer()</li><li>不需要手动调用 playback 及释放</li></ul></li><li>创建自定义 ECB System 继承自 EntityCommandBufferSystem（通常不需要）</li><li>Unity 提供了默认一些 ECB System（单例），可直接获取使用</li><li>SystemAPI.GetSingleton&lt;T.Singleton&gt;()：<ul><li>BeginInitializationEntityCommandBufferSystem：代表在下一帧开始时创建</li><li>EndInitializationEntityCommandBufferSystem</li><li>BeginSimulationEntityCommandBufferSystem</li><li>EndSimulationEntityCommandBufferSystem</li><li>BeginFixedStepSimulationEntityCommandBufferSystem</li><li>BeginPresentationEntityCommandBufferSystem</li></ul></li></ul><h3 id="dynamicbuffercomponent"><a class="anchor" href="#dynamicbuffercomponent">#</a> DynamicBufferComponent</h3><ul><li>非托管内存下一个可以调整大小的数组</li><li>继承自 IBufferElementData 接口</li><li>capacity：容量，默认 128 字节以内元素，共 8 个元素，每个元素 16bytes<ul><li>可使用 [InternalBufferCapacity] 特性修改</li></ul></li><li>internal ptr：指向缓冲区数据的具体位置</li><li>buffer 长度超过内部容量后，会销毁原本 chunk 数组并移到外部更大 chunk 中，即使缩小也回不去了</li><li>获取：entitymanager.getbuff&lt;&gt;</li><li>structure change 会对 dbc 检索产生影响<ul><li>jobs 读写访问也有影响（只读无所谓）</li></ul></li><li>可使用 ecb 修改 dbc<ul><li>ecb.addbuffer、ecb.setbuffer、ecb.appendbuff</li></ul></li><li>若两个 dbc 大小相同，可以用一个解释另一个（类似于联合）</li></ul><h3 id="enableablecomponent"><a class="anchor" href="#enableablecomponent">#</a> EnableableComponent</h3><ul><li>运行时禁用、启用 entity 对象上某个组件，用于处理频繁修改组件状态的情况</li><li>避免直接增删组件导致的 structural change</li><li>还可以替换一组零大小的 tagcomponent 来表示 entity 状态的情况，以减少 entity archetype 数量，得到更好的 chunk 利用率</li><li>只能用于 icomponentdata、ibufferelementdata 类型并同时继承实现 ienableablecomonent 的接口</li><li>使用 EnableableComponent 不会改变 entity，也不会造成任何数据移动（意味着可以直接在 job 中开启或禁用组件）</li><li>使用具有对 enableable 组件写访问权限的 job 可能会导致线程操作阻塞，即使 job 没有在任何 entity 上启用或禁用组件</li><li>操作<ul><li>entitymanager</li><li>componentlookup</li><li>entitycommandbuffer</li><li>archetypechunk</li><li>的 iscomponentenabled&lt;&gt;、setcomponentenabled&lt;&gt; 启用或禁用</li></ul></li><li>默认情况下通过 createentity 创建的新 entity 会启用所有可用组件，从 prefabs 实例化的 entity 则继承之前组件状态</li><li>查询时，entityquery 会不匹配禁用组件，不过可以手动忽略<ul><li>ignorefilter</li><li>entityqueryoption.ignorecomponentenabledstate 查询</li></ul></li></ul><h3 id="sharecomponent"><a class="anchor" href="#sharecomponent">#</a> ShareComponent</h3><ul><li>共享组件数据存储在与 ecs chunk 分离的数组中</li><li>world 中的 chunk 则存储句柄，用来定位共享组件在分离数组中的值</li><li>同一个 chunk 中实体共享相同的 sharecomponent 的值</li><li><img data-src="/blogimages/2023/2023-05-29/-2144605345.jpeg" alt="-2144605345.jpeg" /></li><li>若更改了 entity 的共享组件值，该 entity 会被移动到新的共享组件的 chunk 中<ul><li>若共享组件值在数据组中存在相等的值，则 entity 被移动至存储现在有值索引的 chunk 中</li><li>否则，添加新值到共享组件值中，并将 entity 移动到存储新值索引的新的 chunk 中</li><li><img data-src="/blogimages/2023/2023-05-29/-1348735719.jpeg" alt="-1348735719.jpeg" /></li><li>意味着更改共享组件值一定会带来 structual change</li><li>应尽量避免频繁更新</li><li>避免大量有独特值的共享组件 (会导致不同共享值的实体被分割，出现空 chunk 块)</li><li>避免实体具有多个共享组件类型组合，避免 archetype 碎片化 (可以想象成 shader 的关键字，与其增长速度是一样的，也会造成内存碎片化)</li></ul></li><li>分为托管与非托管类型的 sharedcomponent<ul><li>根据组件中存储的数据的 blitable type 类型划分</li><li>托管与非托管类型的共享组件分开存储</li><li>非托管：继承 isharedcomponentdata（可选继承 iequatable）</li><li>托管：除继承 isharedcomponentdata ，还必须实现 iequatable，并实现 equals 及 gethashcode</li></ul></li><li>因为共享同一 ShareComponent 的 entity 会被放入一个 chunk，因此也可以利用这一点进行分组（当然需要注意内存碎片化问题）</li><li>进阶用法<ul><li>不同 world 使用共享组件共享同一个托管对象</li><li>共享组件内包含对象引用类型或指针的情况</li></ul></li></ul><h3 id="blobasset"><a class="anchor" href="#blobasset">#</a> BlobAsset</h3><ul><li>Blob (binary large object):：是 unity 中存储数据的一种格式，为流式传输优化的二进制数据片，在内存中是存储连续字节块中的不可变的非托管二进制数据</li><li>只读，创建时设置后不可变</li><li>一次性分配，可以用 memcpy 重新定位，不能包含虚类对象数据</li><li>unity 的 blobification 框架可以更紧密打包数据，借助 reduce copy 减少重复数据，并使 blob asset 可以 relocatable 重新定位从磁盘直接读取</li><li>dots 中的 Blob asset<ul><li>同样可以有效优化数据存储与内存使用</li><li>dots 下不能直接使用，而是通过 blobAssetRef</li><li>当不需要时，需通过调用 blobAssetReference dispose 释放</li><li>bake entity 引用的 blob asset 会与场景一起序列化加载</li><li>注意与 sharecomponent 差异</li><li><img data-src="/blogimages/2023/2023-05-29/-683181080.jpeg" alt="-683181080.jpeg" /></li><li>dota 中 blob 数据类型<ul><li>普通 blitable type 数据类型</li><li>blobString</li><li>blobArray</li><li>blobPtr</li></ul></li></ul></li></ul><h3 id="cleanupcomponent"><a class="anchor" href="#cleanupcomponent">#</a> CleanupComponent</h3><ul><li>当销毁一个包含该组件的 entity 时，unity 会删除所有非该组件的其它组件，实际上这个 entity 还存在</li><li>该组件不会随 entity 复制到另一个 world 中</li><li>主要用于在创建实体后帮助初始化或销毁实体后帮助清理</li><li>根据继承不同，分为不同类型<ul><li>例如分为托管和非托管类型、dynamic buffer 类型、shared component 类型</li></ul></li><li>在 dots 创建 entity<ul><li>4 种方法：</li><li><ol><li>通过 ibaker 接口将 prefab bake 成原型，然后运行时通过 entitymanager 根据原型实例化新的 entity 对象</li></ol><ul><li>使用简单，好理解，不过在 world 中会有额外一个原型存在</li></ul></li><li><ol start="2"><li>entitymanager.CreateEntity()</li></ol><ul><li>然后添加 requestentityprefabloaded 即 prefab 异步加载并转化为 entity 的组件</li><li>组件加载转化完成后，会在 entity 上自动添加 prefabloadedresult 组件，可以从该组件上的 prefabroot 字段拿到 prefab 转化后的 entity</li></ul></li><li><ol start="3"><li>混合方式</li></ol><ul><li>直接将 prefab 数组引用在 baker 中保存至 componentdata 中</li><li>通过继承 systembase 的 system 直接使用 instantiate 实例化</li><li>该方法本质上还是 gameobject 处理，无法利用 dots 的数据结构优势（不推荐）</li></ul></li><li><ol start="4"><li>完全动态创建（entity graphics 核心包）</li></ol></li></ul></li></ul><h3 id="chunkcomponent"><a class="anchor" href="#chunkcomponent">#</a> ChunkComponent</h3><ul><li>按 chunk 而不是按 entity 存储的组件</li><li>同样继承 icomponentdata</li><li>使用一组不同的 api 进行操作</li><li>如果只是想只读，使用 query 查询时传入 chunkcomponentreadonly</li><li>在 entity 上添加或删除 chunkcomponent 会导致 structual change</li><li>在执行 job 时由于其按 chunk 存储，一般用 ijobchunk 而不是 ijobentity</li><li><img data-src="/blogimages/2023/2023-05-29/1201698463.jpeg" alt="1201698463.jpeg" /></li><li>具有相同 archetype 的 entity，指向在 chunk 中同一个 chunkcomponent，否则指向同一 chunk 不同的 chunkcomponent</li><li><img data-src="/blogimages/2023/2023-05-29/-854237890.jpeg" alt="-854237890.jpeg" /></li></ul><h1 id="entities-graphics-包"><a class="anchor" href="#entities-graphics-包">#</a> Entities Graphics 包</h1><ul><li>充当 dots 与 unity 现有渲染架构的桥梁</li><li>使用 ecs entity 而不是 gameobject 来改善大型场景中运行时内存布局与性能</li><li>保持 unity 现有工作流的兼容与易用性</li></ul><h2 id="gameobject-转化系统"><a class="anchor" href="#gameobject-转化系统">#</a> GameObject 转化系统</h2><ul><li>将 gameobject 转化为等效 dots entity 的系统，支持编辑器与运行时转化换</li><li>meshrender meshfilter-&gt;rendermesh</li><li>lodgroup-&gt;meshlodgroupcomponent</li><li>transform-&gt;localtoworld</li><li>最好的运行时实例化 entity 方式<ul><li>prefabs</li><li>rendermeshutility.addcomponent api</li></ul></li><li>不要手动添加渲染组件，效率低，有可能与未来 entity graphics 包不兼容</li><li>不推荐 monobehavior 创建 entity</li><li>运行时创建 entity<ul><li>entity graphics 渲染需要包含最小组件集</li><li>推荐 rendermeshutility.addcomponent api—— 不过这是一个主线程 api，不适合创建大量实体，最好通过原型实例化克隆现有实体</li></ul></li></ul><h2 id="material-覆写"><a class="anchor" href="#material-覆写">#</a> Material 覆写</h2><p>两种方法：</p><ul><li>使用 material override asset</li><li>使用 c# burst code（推荐）<ul><li>定义的 componentdata 类用 materialproperty 特性修饰</li></ul></li><li>禁用渲染<ul><li>disablerender tag 组件</li><li>仅仅是不渲染，实际还在更新</li><li>会导致 structural change</li></ul></li></ul><h2 id="batchrendergroup-api"><a class="anchor" href="#batchrendergroup-api">#</a> BatchRenderGroup API</h2><ul><li>GPUInstancing<ul><li>DrawMeshInstanced：有 1024 个数量限制</li><li>DrawMeshInstancedIndirect：有兼容性和剔除方面限制</li><li>BatchRenderGroup</li></ul></li><li>(BRG) 是一个用于执行可自定义的高性能实例对象渲染接口，可以提前设置批次，使用描述如何加载网格和材质的共享元数据来设置实例组</li><li>当 Unity 渲染 BatchRenderGroup 时，会调用 OnPerformCulling 回调执行可见性剔除，并可声明一个可变大小绘制命令列表，描述如何渲染 BatchRenderGroup  可见部分</li><li>每个绘制命令都指示 Unity 使用特定的网格和材质渲染给定批次中的一组实例</li><li>Entities Graphics 就是构建在 BatchRenderGroup API 之上的，此 API 将 Entities Graphics 连接到 Unity 引擎后端渲染<ul><li>注：其实 BatchRenderGroup API 可以脱离 Dots 直接脚本调用</li></ul></li></ul><h3 id="用途"><a class="anchor" href="#用途">#</a> 用途</h3><ul><li>渲染 DOTS 实体</li><li>渲染大量使用单个 GameObject 的资源密集型环境对象 (如程序化放置的植物或岩石)</li><li>渲染自定义地形，可使用不同的网格或材质显示不同级别的详细信息</li></ul><h3 id="使用限制"><a class="anchor" href="#使用限制">#</a> 使用限制</h3><ul><li>不支持 BuildIn 管线，需要 SRPBatcher 选项开启</li><li>不能剔除 BRG 的变体<ul><li>BatchRenderGroup Variants 需要设置为 KeepAll</li><li>URP 最好在设置中直接关闭 StripUnusedVariants 避免被剔除变体</li></ul></li><li>需要开启 unsafe 选项（允许不安全代码）</li><li>主流平台基本都支持 BRG 接口，不过 Android 上需要 Vulkan 支持<ul><li>OpenGL 下可以使用 const buffer 处理一些不兼容情况，但是渲染提升并不明显<ul><li>opengle 和 opengles 上只能使用 ConstantBuffer，其他的都是使用 RawBuffer</li></ul></li><li>所以最好选用 Vulkan 图形 API</li></ul></li></ul><h3 id="创建流程"><a class="anchor" href="#创建流程">#</a> 创建流程</h3><ol><li>创建 BatchRenderGroup 实例，使用 OnPerformCulling 的实现进行初始化 (主要入口)<ul><li>Visibility Culling：基于 BatchCullingContext 参数确定哪些渲染实例对象可见，输出实际绘制命令以渲染这些实例</li><li>OnPerformCulling 逻辑可在回调实现，也可以在 BurstJob 完成 (更高效)</li></ul></li><li>向 BRG 中注册网格和材质<ul><li>Mesh 与 Material 是 Unity 托管 C# 对象，不能在 Burst C# 使用，必须预先注册 (与 EntitiesGraphicsSystem 一致)</li><li>通过 BatchRenderGroup.RegisterMesh/BatchRenderGroup.RegisterMaterial 注册，其返回 BatchMeshID 与 BatchMaterialID (是包含 Burst 兼容句柄的普通数据结构体)</li><li>即使用 BRG 前必须先注册对象 Mesh 与 Material，且材质必须支持 DOTS Instancing</li></ul></li><li>创建批次 Batch<ul><li>绘制命令之前需要为每个实例提供数据，如变化矩阵、光照探针系数、光照贴图、纹理坐标等</li><li>BRG 使用 Batch 的概念，每个 Batch 都有一组元数据和一个 GraphicsBuffer 的概念，批处理中的每个实例都共享这些数据</li><li>通过 BatchRenderGroup.AddBatch 接受元数据值的数组以及 GraphicsBuffer 的句柄，Unity 会将 Batch 中的数据传递给 Shader (未传入默认为 0)，并将 GraphicsBuffer 绑定为 unity_DOTSInstanceData</li><li>注 1：创建 Batch 元数据后不能修改，若想修改必须创建新的替换 (可通过 SetBatchBuffer 随时修改 Batch 的 GraphicsBuffer)—— 即数据的 Layout 不能修改，但数据内容可以修改</li><li>注 2：创建 Batch 时不需要指定大小，相反、必须确保 Shader 能够正确处理传递给它的实例索引：意味着 SRP Shader 在传递的索引处的缓冲区必须有有效的实例数据</li></ul></li><li>创建绘制命令 DrawCommands<ul><li>创建绘制命令需要使用 BatchRenderGroup.OnPerformCulling 回调和回调参数<ul><li>BatchCullingOutput 参数包含一个带单个元素的 NativArray，可以直接修改其内容，不需要复制数据</li><li>NativeArray 中的元素是个 BatchCullingOutputDrawCommands 结构，它包含实际绘制命令</li><li>OnPerformCulling 回调中生成任意数量的绘制命令，可以是只使用一个网格和材质的简单命令，也可以是使用成千上万个网格和材质的复杂命令</li><li>为提供最大灵活性，Unity 不会预先分配 BatchCullingOutputDrawCommands 输出结构中的数组而是将其存储为原始的指针<ul><li>这样就可以更轻松低从 Burst Job 中分配和使用（需要使用 UnsafeUtility.Malloc 和 Allocator.TempJob 分配器来分配数组）</li><li>另外在 OnPerformCulling 回调中不会释放这些数据内存，而是在 Unity 使用绘制命令完成渲染后释放</li></ul></li></ul></li></ul></li></ol><h2 id="hybrid-entities"><a class="anchor" href="#hybrid-entities">#</a> Hybrid Entities</h2><ul><li>允许将 MonoBehavior 组件附加到 DOTS Entity，而不需要将其转化为 ComponentData<ul><li>转换系统将调用 AddBybridComponent 将托管组件附加到 DOTS Entity 上</li></ul></li><li>默认情况会禁用 Camera 组件转换，因为场景主 Camera 不能是 HybridEntity<ul><li>需要启用，可使用宏 HYBRID_ENTITY_CAMERA_CONVERSION</li></ul></li><li>当 Unity 更新 DOTS LocalToWorld 时，都会更新 HybridEntity 转换</li></ul><h1 id="unity-physics"><a class="anchor" href="#unity-physics">#</a> Unity Physics</h1><ul><li>是一个完整的确定性的刚体物理系统</li><li>功能上仅是 Physics 或 Havok 的子集</li><li>完全使用 HPC# 编写，遵循 DOTS 整体设计理念</li><li>遵循最小依赖性和完全可控制性</li></ul><p>特性</p><ul><li>无状态：该帧信息不会被缓存到下一帧</li><li>模块化</li><li>高性能</li><li>互通性</li></ul><h2 id="物理模拟顺序"><a class="anchor" href="#物理模拟顺序">#</a> 物理模拟顺序</h2><ul><li>获取实体上组件当前状态</li><li>检测激活实体边界，进行快速碰撞检测</li><li>根据碰撞器形状计算确切接触点</li><li>基于碰撞点、质量、摩擦系数、弹性等参数做出碰撞反应</li><li>处理碰撞结果，并根据 Joint 等限制结算出刚体新的速度</li><li>根据动力学物理的线速度和角速度按时间步长移动物理体</li><li>将新的变换 Transform 应用到该物体实体上</li></ul><h2 id="设置方式"><a class="anchor" href="#设置方式">#</a> 设置方式</h2><ul><li>PhysicsSharp 组件 + PhysicsBody 组件</li><li>PhysicsSharp 组件 + RigidBody 组件<ul><li>底层实际通过 Authoring 将 RigidBody 转换为 PhysicsBody 组件</li></ul></li><li>其设置不受 ProjectSetting 中 Physics 全局设置影响了<ul><li>可以在场景添加 PhysicsStep 用作场景的全局物理设置</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;主要内容来源于：Metaverse 大衍神君  &lt;code&gt;RoadToDotsTutorials&lt;/code&gt;  相关教程，本文为个人笔记&lt;br /&gt;
&lt;span</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/categories/Unity3D/"/>
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/tags/Unity3D/"/>
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DOTS" scheme="https://wangjiaying.top/tags/DOTS/"/>
    
  </entry>
  
  <entry>
    <title>优化博客加载、添加文章统计等</title>
    <link href="https://wangjiaying.top/2023/05/28/%E6%B7%BB%E5%8A%A0%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%BB%9F%E8%AE%A1/"/>
    <id>https://wangjiaying.top/2023/05/28/%E6%B7%BB%E5%8A%A0%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%BB%9F%E8%AE%A1/</id>
    <published>2023-05-28T04:19:26.000Z</published>
    <updated>2023-06-04T11:42:34.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本来最开始只是因为  <code>JsDeliver</code>  ... 又又又挂了，导致部分用到的 CDN 在家里访问不了 —— 本来上次就已经把大部分脚本引用从  <code>JsDeliver</code>  切换到  <code>Staticfile</code>  了，然而还是有少几个在  <code>Staticfile</code>  没有的导致没法换<br />然后就发现，一旦这『少数』脚本出了问题，网页就会一直卡在那儿等它... 等半天真的是</p><p>于是就想办法搞，比如 fancybox、justifiedGallery、jquery、valine、whatwg-fetch 等</p><h1 id="处理"><a class="anchor" href="#处理">#</a> 处理</h1><p>之前  <code>fancybox</code> 、 <code>justifiedGallery</code> 、 <code>jquery</code>  三个是由原  <code>Shoka</code>  作者合并申请的：</p><blockquote><p>#! DO NOT EDIT THE FOLLOWING  <code>vendors</code>  SETTINGS<br />#! UNLESS YOU KNOW WHAT YOU ARE DOING<br />#! Script dependencies will be combined with jsDelivr (<span class="exturl" data-url="aHR0cDovL2Nkbi5qc2RlbGl2ci5uZXQ=">cdn.jsdelivr.net</span>)</p></blockquote><p>于是先是把合并的拆开，找地方再把拆开的给一一引用起来，弄好后又发现新问题：右键页面空白处，也会弹出图片菜单，开始还以为我引用搞出问题了，结果测试半天发现，不是  <code>fancybox</code>  那一坨的问题...</p><p>找不到原因了，反正也基本没用过，于是干脆直接删了，然后禁用图片点击</p><p>而后，又回到最开始界面卡加载慢的原因： <code>whatwg-fetch</code>  ，查到原仓库，看到描述说是为了兼容  <code>polifill</code>  而写的，另外已经两年没更新了</p><p>这个 CDN 国内找了几个都没有，考虑到目前新浏览器已经是自己支持  <code>fetch</code>  操作了，于是调了一阵子还是将其『瘦身』掉了</p><h1 id="页顶大图修改"><a class="anchor" href="#页顶大图修改">#</a> 页顶大图修改</h1><p>然后去搜索了一下网上同样使用  <code>Shoka</code>  的，结果基本全挂了，少数几个还能正常访问的，例如 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbg==">lavenderdh</span></p><p>然后... 看到<span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbi9wb3N0cy8zOTI4OTY2Mjg3Lw=="> lavenderdh 文章</span> ，是说把页顶图片放大至全屏的修改 —— 这个本来以前刚换  <code>Shoka</code>  的时候就见过，这次感觉：哎，还不错，于是加上了</p><h1 id="添加文章统计"><a class="anchor" href="#添加文章统计">#</a> 添加文章统计</h1><p>然后，顺便翻了下博主的主页 —— 虽然看着已经很久没更新了，不过页面的文章统计功能这次吸引了我的注意，再一翻，竟然还写了相关文章记录的，于是参考着给我的也加上。</p><p>跟着步骤还是挺顺利，然而博主的嵌入方式有点不优雅... 好像有点问题，我想把这功能加入主题配置中，然后改成按需加载。</p><p>于是... 花费的研究时间就足以让我也写篇文章记录一下了。</p><h2 id="图表显示问题"><a class="anchor" href="#图表显示问题">#</a> 图表显示问题</h2><p>首先，图表显示有点问题，例如统计图只显示当前一个月的、饼图重叠等...</p><p>比如：</p><p><img data-src="/blogimages/2023/2023-05-28/Snipaste_2023-05-31_11-09-37.jpg" alt="" /></p><p>跟着博主参考的链接进去看了下，一通改，算是修好了</p><h2 id="发布日历显示问题"><a class="anchor" href="#发布日历显示问题">#</a> 发布日历显示问题</h2><p>这个功能该是博主 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbi9zdGF0aXN0aWNzLw==">lavenderdh</span> 自己加的，然而在我这有些问题 —— 博主上边显示的是  <code>每一年</code>  的，到我这又不对劲，就只有一年的了</p><p>另外整体显示极小：大概是因为一年日期的网格，没法填满宽度导致的</p><p>后面对比了下网页源码上图表数据代码：</p><p>我的 (博主博文贴出来的)：</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token literal-property property">series</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'heatmap'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token literal-property property">coordinateSystem</span><span class="token operator">:</span> <span class="token string">'calendar'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token literal-property property">calendarIndex</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token literal-property property">data</span><span class="token operator">:</span> $<span class="token punctuation">&#123;</span>datePosts<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">]</span></pre></td></tr></table></figure><p>博主的：</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token literal-property property">series</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'heatmap'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token literal-property property">coordinateSystem</span><span class="token operator">:</span> <span class="token string">'calendar'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token literal-property property">calendarIndex</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token literal-property property">data</span><span class="token operator">:</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'heatmap'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token literal-property property">coordinateSystem</span><span class="token operator">:</span> <span class="token string">'calendar'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token literal-property property">calendarIndex</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token literal-property property">data</span><span class="token operator">:</span> </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'heatmap'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token literal-property property">coordinateSystem</span><span class="token operator">:</span> <span class="token string">'calendar'</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token literal-property property">calendarIndex</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token literal-property property">data</span><span class="token operator">:</span> </pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">]</span></pre></td></tr></table></figure><p>这代码完全不一样了好吧... 其它诸如格子大小不对劲、偏移导致年份、星期显示不出来也是，可能是博主后面改了，没更新博文</p><p>于是对比着生成的 HTML 网页源码改了下，把显示宽度问题解决了，至于统计多年提交... 想了想放弃了，显示一年也行吧，还要 Git 上提交记录不也只展示最近一年么？</p><p>—— 不然改起来又要研究咋动态去生成 (不然总不可能直接写死的吧？也许还真是写死的...？看着 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbi9zdGF0aXN0aWNzLw==">lavenderdh 的统计页面</span> 切换主题的代码，手动设置了三个日历的数据)<br /> 在这里浪费的时间够多了，本来是因为昨天在写 <a href="/2023/05/27/Cinemachine%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" title="Cinemachine文档整理翻译">Cinemachine文档整理翻译</a> 文章的时候，本地预览看到网页显示比较慢，结果......</p><h2 id="延迟加载执行问题"><a class="anchor" href="#延迟加载执行问题">#</a> 延迟加载执行问题</h2><p>原本的嵌入方式，第一次 fetch 页面（不是刷新），会导致什么都没有，白屏<br />主要原因是：操作代码是 JS，而且嵌入网页中的，引用却是外部的 Script：<span class="exturl" data-url="aHR0cHM6Ly9jZG4uc3RhdGljZmlsZS5vcmcvZWNoYXJ0cy81LjQuMi9lY2hhcnRzLm1pbi5qcw==">https://cdn.staticfile.org/echarts/5.4.2/echarts.min.js</span></p><p>导致在  <code>echarts</code>  本身的 Script 还没拉取下来之前，先一步执行自己的逻辑代码，就要遭（这是分析了一阵流程发现的）</p><ul><li>博主说的解决方式是直接全局引用  <code>echarts</code> ，这个后续我也尝试过</li></ul><p>首先，按照原本的做法把功能弄了进来，并且修改为了配置模式：</p><figure class="highlight yml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># statistics 文章统计功能</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token key atrule">postStatistics</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token key atrule">beginDate</span><span class="token punctuation">:</span> 2015<span class="token punctuation">-</span><span class="token number">12</span> <span class="token comment">#开始统计日期</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token key atrule">tagCount</span><span class="token punctuation">:</span> <span class="token number">10</span> <span class="token comment">#统计标签个数</span></pre></td></tr></table></figure><p>然后，意图采用延迟加载的方式去解决这个问题，发现没能解决，也是这时候有点意识到问题了</p><p>想了想又研究着改成全局加载做尝试，然而发现  <code>echarts</code>  这东西... 内容有点丰富，单文件都  <code>999KB</code> ，约等于  <code>1M</code>  大小了</p><p>要是只有几十 KB 我倒无所谓了，但这种大小全局加载，就感觉太不优雅了，还是想改成  <code>按需加载</code>  的方式</p><p>Shako 自带的延迟加载逻辑一样不行（ <code>vendorJs(XX)</code> ）</p><p>后面又想到，既然现在的主要问题是内嵌入网页的代码先执行导致，那么将两者都变成外部引用呢？</p><p>如果尝试的话，问题就变成如何动态生成可以被链接的代码了，因为  <code>Shoka</code>  默认是把所有生成代码合并成一个  <code>app.js</code> ，加那里边又是代码膨胀了</p><hr /><p>最后加到了新创建的那个  <code>charts.js </code>  里边</p><p>主要是  <code>echarts-init</code>  执行初始化，其中代码是调用生成动态的那几个图表函数：</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">&lt;</span>script id<span class="token operator">=</span><span class="token string">"echartsInit"</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">function</span> <span class="token function">switchPostChart</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      <span class="token comment">// 这里为了统一颜色选取的是 “明暗模式” 下的两种字体颜色，也可以自己定义</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token keyword">let</span> color <span class="token operator">=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">'data-theme'</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token string">'#fff'</span> <span class="token operator">:</span> <span class="token string">'#000'</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'posts-calendar'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>          <span class="token keyword">let</span> postsCalendarNew <span class="token operator">=</span> postsCalendarOption</pre></td></tr><tr><td data-num="7"></td><td><pre>          postsCalendarNew<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="8"></td><td><pre>          postsCalendarNew<span class="token punctuation">.</span>title<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="9"></td><td><pre>          postsCalendarNew<span class="token punctuation">.</span>visualMap<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="10"></td><td><pre>          postsCalendarNew<span class="token punctuation">.</span>calendar<span class="token punctuation">.</span>itemStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="11"></td><td><pre>          postsCalendarNew<span class="token punctuation">.</span>calendar<span class="token punctuation">.</span>yearLabel<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="12"></td><td><pre>          postsCalendarNew<span class="token punctuation">.</span>calendar<span class="token punctuation">.</span>monthLabel<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="13"></td><td><pre>          postsCalendarNew<span class="token punctuation">.</span>calendar<span class="token punctuation">.</span>dayLabel<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="14"></td><td><pre>          postsCalendar<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>postsCalendarNew<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'posts-chart'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>          <span class="token keyword">let</span> postsOptionNew <span class="token operator">=</span> postsOption</pre></td></tr><tr><td data-num="18"></td><td><pre>          postsOptionNew<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="19"></td><td><pre>          postsOptionNew<span class="token punctuation">.</span>title<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="20"></td><td><pre>          postsOptionNew<span class="token punctuation">.</span>xAxis<span class="token punctuation">.</span>axisLine<span class="token punctuation">.</span>lineStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="21"></td><td><pre>          postsOptionNew<span class="token punctuation">.</span>yAxis<span class="token punctuation">.</span>axisLine<span class="token punctuation">.</span>lineStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="22"></td><td><pre>          postsChart<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>postsOptionNew<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'tags-chart'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>          <span class="token keyword">let</span> tagsOptionNew <span class="token operator">=</span> tagsOption</pre></td></tr><tr><td data-num="26"></td><td><pre>          tagsOptionNew<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="27"></td><td><pre>          tagsOptionNew<span class="token punctuation">.</span>title<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="28"></td><td><pre>          tagsOptionNew<span class="token punctuation">.</span>xAxis<span class="token punctuation">.</span>axisLine<span class="token punctuation">.</span>lineStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="29"></td><td><pre>          tagsOptionNew<span class="token punctuation">.</span>yAxis<span class="token punctuation">.</span>axisLine<span class="token punctuation">.</span>lineStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="30"></td><td><pre>          tagsChart<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>tagsOptionNew<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'categories-chart'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>          <span class="token keyword">let</span> categoriesOptionNew <span class="token operator">=</span> categoriesOption</pre></td></tr><tr><td data-num="34"></td><td><pre>          categoriesOptionNew<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="35"></td><td><pre>          categoriesOptionNew<span class="token punctuation">.</span>title<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="36"></td><td><pre>          categoriesOptionNew<span class="token punctuation">.</span>legend<span class="token punctuation">.</span>textStyle<span class="token punctuation">.</span>color <span class="token operator">=</span> color</pre></td></tr><tr><td data-num="37"></td><td><pre>          categoriesChart<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>categoriesOptionNew<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="38"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>  document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">"theme"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>switchPostChart<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">venderJs</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="42"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">[</span><span class="token string">'echartload'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="44"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>      <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>    <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>    script<span class="token punctuation">.</span>onload <span class="token operator">=</span> script<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>      script<span class="token punctuation">.</span>onload <span class="token operator">=</span> script<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>      script <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>    script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'$&#123;hexo.theme.config.vendors.js.echart&#125;'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>    window<span class="token punctuation">[</span><span class="token string">'echartload'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>    document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="58"></td><td><pre>  <span class="token function">venderJs</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="59"></td><td><pre>    <span class="token function">Do_postsCalendar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>    <span class="token function">Do_postsChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="61"></td><td><pre>    <span class="token function">Do_tagsChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="62"></td><td><pre>    <span class="token function">Do_categoriesChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>外面统计页面，就只保持最低限度的几个 HTML 配置了：</p><figure class="highlight html"><figcaption data-lang="HTML"></figcaption><table><tr><td data-num="1"></td><td><pre>---</pre></td></tr><tr><td data-num="2"></td><td><pre>title: 文章统计</pre></td></tr><tr><td data-num="3"></td><td><pre>date: 2023-5-28</pre></td></tr><tr><td data-num="4"></td><td><pre>copyright: false</pre></td></tr><tr><td data-num="5"></td><td><pre>echart: true</pre></td></tr><tr><td data-num="6"></td><td><pre>---</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">&lt;!-- 文章发布日历 --></span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>posts-calendar<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">border-radius</span><span class="token punctuation">:</span> 8px<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span> <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">&lt;!-- 文章发布时间统计图 --></span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>posts-chart<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">border-radius</span><span class="token punctuation">:</span> 8px<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span> <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">&lt;!-- 文章标签统计图 --></span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tags-chart<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">border-radius</span><span class="token punctuation">:</span> 8px<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span> <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">&lt;!-- 文章分类统计图 --></span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>categories-chart<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">border-radius</span><span class="token punctuation">:</span> 8px<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 450px<span class="token punctuation">;</span> <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">&lt;!-- 初始化使用 --></span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>echarts-init<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><p>效果如下所示：</p><!-- 文章发布日历 --><div id="posts-calendar" style="border-radius: 8px; height: 300px; padding: 10px;"></div><!-- 文章发布时间统计图 --><div id="posts-chart" style="border-radius: 8px; height: 300px; padding: 10px;"></div><!-- 文章标签统计图 --><div id="tags-chart" style="border-radius: 8px; height: 300px; padding: 10px;"></div><!-- 文章分类统计图 --><div id="categories-chart" style="border-radius: 8px; height: 450px; padding: 10px;"></div><!-- 初始化使用 --><div id="echarts-init"></div><h2 id="标签统计图显示不全"><a class="anchor" href="#标签统计图显示不全">#</a> 标签统计图显示不全</h2><p>主要发生在刻度过多时 —— 我加了个自定义的标签的配置，然后随便配了个  <code>15</code>  就出现了</p><p>参考 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTc3NzMwL2FydGljbGUvZGV0YWlscy8xMDkzMDc1OTU=">柱状图 x 轴坐标显示不全</span> 可以解决 (但是压缩起来叠加会很难看，我又去掉了)</p><h2 id="其它"><a class="anchor" href="#其它">#</a> 其它</h2><h3 id="hexo-系统变得缓慢"><a class="anchor" href="#hexo-系统变得缓慢">#</a> Hexo 系统变得缓慢</h3><p>原因似乎是因为  <code>charts</code>  注册的  <code>after_render:html</code>  会对项目中生成的每个  <code>HTML</code>  作解析判断<br />想加入页面开关避免无谓解析呢，但是貌似已经获取不到  <code>page.XXX</code>  这种信息了，相当于页面已经渲染完毕，因此只能在最开始多判断一层，少解析一些速度会快点</p><h3 id="图表没有去重"><a class="anchor" href="#图表没有去重">#</a> 图表没有去重</h3><p>导致子分类会被单独归为另外一类，得做一次去重</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>其它还修了一波其它问题，比如  <code>vendorJS</code>  函数会反复插入  <code>js</code>  脚本的 BUG (不知道是不是我改出来的)</p><p>就这样</p><p>对于  <code>echats</code>  统计功能，虽然不能说封装完美，至少做到了  <code>按需加载</code> ，不会因为第一次  <code>fetch</code>  进统计页面白屏，也不会因为一个页面使用就必须始终加载 —— 感觉这样才优雅一些</p><p>如果用我修改的主题的话，只需要新建一个  <code>statistics</code>  页面，直接就可以用了，统计开始时间也在  <code>config</code>  配置中：</p><figure class="highlight yml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># statistics 文章统计功能</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token key atrule">postStatistics</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token key atrule">beginDate</span><span class="token punctuation">:</span> 2015<span class="token punctuation">-</span><span class="token number">12</span> <span class="token comment">#开始统计日期</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token key atrule">tagCount</span><span class="token punctuation">:</span> <span class="token number">10</span> <span class="token comment">#统计标签个数</span></pre></td></tr></table></figure><p>周末时间折腾了一天搞这个，还是挺心疼的... 终于弄完了，这两天本来计划趁周末把算法之美收尾，然后将阅读笔记复习一遍上传博客的，结果尽搞其它去了...</p><p>一通操作下来，虽然感觉我已经可以做到自动生成 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbi9zdGF0aXN0aWNzLw==">lavenderdh 的统计页面</span> 那种多年分的日历图<br />貌似其实挺简单的：理论上通过  <code>JSON.stringify</code>  将对应字典转换成  <code>json</code>  赋值给  <code>series</code>   <code>heatmap</code>  就行了， <code>tagsChart</code>  就是一个很好的示例</p><p>不过考虑了下时间关系和本身效果 —— 还是先算了，本来也不是很重要的效果</p><p>今天待会儿先把博客弄规矩，以及 <a href="/2023/05/27/Cinemachine%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" title="Cinemachine文档整理翻译">Cinemachine文档整理翻译</a> 再过一遍看有没有写的不通畅的，然后把 DOTS 笔记也上传一下</p><p>将算法之美的笔记整理成文章... 只能等明天或者后天再说了</p><p>不过... 这个 <span class="exturl" data-url="aHR0cHM6Ly9lY2hhcnRzLmFwYWNoZS5vcmcvZXhhbXBsZXMvemgvaW5kZXguaHRtbCNjaGFydC10eXBlLXBpZQ==">echarts</span> 确实厉害，效果相当好，以后有需要没准也用得上</p><h1 id="参考文章"><a class="anchor" href="#参考文章">#</a> 参考文章</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGF2ZW5kZXJkaC5jbi9wb3N0cy8zMjY1MTczNzAxLw==">Shoka 主题：新增文章统计页面</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmV1cmtvbi5jb20vcG9zdC8xMjEzZWY4Mi5odG1s">Hexo 博客文章统计图</span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;本来最开始只是因为  &lt;code&gt;JsDeliver&lt;/code&gt;  ... 又又又挂了，导致部分用到的 CDN 在家里访问不了 —— 本来上次就已经把大部分脚本引</summary>
      
    
    
    
    <category term="博客" scheme="https://wangjiaying.top/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客" scheme="https://wangjiaying.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Cinemachine文档整理翻译</title>
    <link href="https://wangjiaying.top/2023/05/27/Cinemachine%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    <id>https://wangjiaying.top/2023/05/27/Cinemachine%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/</id>
    <published>2023-05-27T11:51:46.000Z</published>
    <updated>2023-10-02T09:13:03.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>主要内容来源于官方 Cinemachine2.8 英文文档：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5jaW5lbWFjaGluZUAyLjgvbWFudWFsL0NpbmVtYWNoaW5lVXNpbmcuaHRtbA==">https://docs.unity3d.com/Packages/com.unity.cinemachine@2.8/manual/CinemachineUsing.html</span></p><p>花了一个星期，学习之余，借助翻译软件一边看一边验证（顺便翻译，注：并不完全按照文档来的）</p><h1 id="virtual-camera"><a class="anchor" href="#virtual-camera">#</a> Virtual Camera</h1><h2 id="基本情况"><a class="anchor" href="#基本情况">#</a> 基本情况</h2><p>首先，场景中一般只有一个 Unity 相机（或者单独分离的 UI 相机），但可以有多个虚拟相机（不过一般只有一个活动）</p><p>虚拟相机应该算是  <code>Cinemachine</code>  中主要的一个组件，在某个虚拟相机处于活动状态时， <code>Cinemachine</code>  会将其移动和旋转等控制同步到 Unity 相机上。</p><ul><li>一般只有一个活动虚拟相机会控制 Unity 相机，除非设置了从一个虚拟摄像机到下一个虚拟摄像机进行混合操作，处于混合状态下的情况。</li></ul><p>虚拟相机的主要功能有：</p><ul><li>控制场景中的 Unity 相机位置</li><li>将 Unity 相机对准目标</li><li>向 Unity 相机添加程序噪声，模拟诸如手持效果或车辆震动之类的东西</li></ul><p>虚拟相机本身消耗很少，不过如果场景对性能敏感也可以直接禁用不需要的虚拟相机。<br />建议对于每个镜头都使用独立的虚拟相机进行拍摄，然后再进行剪切或混合，例如：</p><ul><li>对于两个角色交换对话的过场动画，使用三个虚拟相机：一个相机用于两个角色的中间镜头，另一个虚拟相机用于每个角色的特写镜头，使用 Timeline 将音频与虚拟摄像机同步</li><li>复制一个现有的虚拟摄像机，使两个虚拟摄像机在场景中处于相同的位置，对于第二个虚拟相机，更改 FOV 或拍摄视图。当玩家进入触发空间时，Cinemachine 会从第一个虚拟摄像机混合到第二个虚拟摄像机以强调动作的变化</li></ul><p>另外 Cinemachine 支持正交摄影机，将 Unity 摄像机的投影设置为正交投影时，Cinemachine 会自动进行调整适应，在镜头的虚拟相机属性中，FOV 被 OrthographicSize 取代</p><ul><li>在正交环境中，旋转相机通常没有意义。因此 Cinemachine 提供了 FramingTransposer 来处理取景和构图，而无需旋转摄像机</li></ul><h2 id="创建方式"><a class="anchor" href="#创建方式">#</a> 创建方式</h2><p>在 Unity 菜单中选择 GameObject &gt; Cinemachine &gt; Virtual Camera</p><ul><li>在场景创建 Virtual Camera 时，若主相机没有 CinemachineBrain，会自动挂一个 CinemachineBrain 上去，主相机及与虚拟相机位置会自动同步并保持一致</li></ul><h2 id="通用属性"><a class="anchor" href="#通用属性">#</a> 通用属性</h2><h3 id="移动或瞄准"><a class="anchor" href="#移动或瞄准">#</a> 移动或瞄准</h3><p>虚拟相机有两个主要目标：</p><ul><li>Follow 目标指定一个 GameObject 供虚拟相机移动<ul><li>指定 Follow 后，则虚拟相机位置会与跟随对象以 FollowOffset 偏移保持一致 (取决于 Body 配置)</li></ul></li><li>LookAt 目标指定要瞄准的 GameObject<ul><li>指定 LookAt 后，则虚拟相机朝向会始终朝向于 LookAt 对象 (取决于 Aim 配置)</li></ul></li></ul><p>主要参数有 Aim、Body 和 Noise 的配置，用于指定虚拟相机如何为位置、旋转和其它属性设置动画</p><ul><li>当 Cinemachine Brain 或 Timeline 将 Unity 摄像机的控制权转移到虚拟摄像机时，虚拟摄像机将这些设置应用于 Unity 摄像机</li><li>在任何时候，每个虚拟相机都可能处于以下状态之一：<ul><li>Live：Virtual Camera 主动控制具有 Cinemachine Brain 的 Unity 摄像机。当 Cinemachine Brain 从一个虚拟摄像机混合到另一个虚拟摄像机时，两个虚拟摄像机都是活动的，混合完成后，只有一个活动虚拟摄像机</li><li>Standby：Virtual Camera 不控制 Unity 相机，但仍然跟随并瞄准目标，并在每一帧更新。处于此状态的虚拟摄像头已激活，其优先级与实时虚拟摄像头相同或更低</li><li>Disabled：Virtual Camera 不控制 Unity 相机并且不主动跟随或瞄准其目标。这种状态下的虚拟相机没有性能消耗，停用其游戏对象即可禁用。不过即使禁用，如果参与混合或者被 Timeline 调用，虚拟相机仍然可以控制 Unity 相机</li></ul></li></ul><p>Cinemachine 包括各种算法来控制移动和瞄准，每个算法都解决一个特定的问题，并且如果有特殊需要也可以进行自定义</p><ul><li>Cinemachine 将这些算法实现为 CinemachineComponent 对象，可使用 CinemachineComponent 类来实现自定义移动或瞄准行为</li></ul><p>Body 配置提供了以下用于在场景中移动虚拟相机的算法：</p><ul><li>Transposer (默认)：以与 Follow 目标的固定关系移动，具有可选的阻尼</li><li>3rd Person follow：围绕玩家水平和垂直旋转的相机，指向跟随目标</li><li>Do Nothing：虚拟相机不会跟随移动 (但是会瞄准)</li><li>Framing Transposer：以固定的屏幕空间关系移动到 Follow 目标，可选择阻尼</li><li>Orbital Transposer：以可变关系移动到 Follow 目标，可选择接受玩家输入</li><li>Tracked Dolly：沿着预定义的路径移动</li><li>Hard Lock to Target：将相机位置设置为与跟随目标一致</li></ul><p>Aim 配置提供了以下用于旋转虚拟相机以面向 LookAt 目标的程序算法：</p><ul><li>Composer：将 Look At 目标保持在相机框架中，并具有构图限制</li><li>Group Composer：在相机画面中保留多个 Look At 目标</li><li>Do Nothing：不旋转虚拟相机</li><li>POV：根据用户的输入旋转虚拟相机</li><li>Same As Follow Target：将相机的旋转设置为跟随目标的旋转</li><li>Hard Look At：将注视目标保持在相机框架的中心</li></ul><h3 id="主要属性"><a class="anchor" href="#主要属性">#</a> 主要属性</h3><ul><li>Solo：似乎只是编辑器使用，可以暂时切换到当前的这个虚拟相机进行预览</li><li>Game Window Guides：在游戏视图中切换构图提示框的可见性 (就是点开 Aim 之后的区域显示)</li><li>Save During Play：选中以在播放模式下应用更改，使用此功能可以播放模式直接微调虚拟相机，这是一个全局属性，适用于所有虚拟相机</li><li>Priority：此虚拟相机对于下一个镜头选择的重要程度，较高的值表示较高的优先级。<ul><li>Cinemachine Brain 从所有激活的虚拟摄像机中选择下一个实时虚拟摄像机，并且与当前实时虚拟摄像机具有相同或更高的优先级。使用带 Timeline 控制时，此属性无效</li></ul></li><li>Follow：跟随目标对象，Body 属性使用此目标来更新 Unity 相机的位置。将此属性留空可以手动控制虚拟相机变换的位置，例如在 Timeline 中为虚拟相机设置动画</li><li>Look At：瞄准的目标对象。 Aim 属性使用此目标来更新 Unity 相机的旋转</li><li>Standby Update：控制虚拟相机不活动时更新频率</li><li>Position Blending：与此虚拟相机混合位置的方式<ul><li>Linear (线性)</li><li>Spherical (球形)：如果有注视目标，则围绕注视位置进行球形混合</li><li>Cylindrical (圆柱形)：如果有注视目标，则围绕注视位置进行圆柱混合，垂直坐标被线性插值</li></ul></li><li>Lens：在 Unity 相机属性中的对应项<ul><li>Field Of View</li><li>Presets：常用镜头预设，可以点击下拉菜单选择或保存</li><li>Orthographic Size：使用的 Unity 相机是正交相机时有用</li><li>Near Clip Plane</li><li>Far Clip Plane</li><li>Dutch (荷兰角度 / 斜角镜头)：将相机相对于场景倾斜，以度为单位在 z 轴上倾斜 Unity 相机。此属性是虚拟相机独有的</li><li>Mode Override：当 Cinemachine 激活此虚拟摄像机时，允许选择不同的摄像机模式应用于 Unity 摄像机<ul><li>None</li><li>Orthographic：正交相机模式</li><li>Perspective：透视相机模式</li><li>Physical：物理相机模式</li></ul></li><li>Blend Hint：混入或混出虚拟相机位置的提示（暂时不知道具体做什么）</li><li>Inherit Position：启用后，只要此虚拟摄像机活动，就会强制初始位置与 Unity 摄像机的当前位置相同（如果可能）</li><li>Extensions：向虚拟相机添加额外行为的组件<ul><li>Cinemachine 自带了部分扩展，继承 CinemachineExtension 类可以创建自己的自定义扩展</li></ul></li></ul></li></ul><h2 id="body-properties"><a class="anchor" href="#body-properties">#</a> Body properties</h2><p>使用 Body 属性指定在场景中移动虚拟相机的方法</p><h3 id="3rd-person-follow"><a class="anchor" href="#3rd-person-follow">#</a> 3rd Person Follow</h3><p>第三人称跟随会将相机保持在相对于 Follow 目标的恒定位置和距离，跟踪目标的移动和旋转，并直接提供了相机与目标间的障碍检测功能。</p><ul><li>ShoulderOffset：如同名字一样，偏移<ul><li>当其 X 值有值的时候，后续 CameraSide 才有效</li></ul></li><li>CameraSide：当 ShoulderOffset X 轴有值时，该项才有效，影响往左偏还是往右偏 (0~1)<ul><li>实测若 0.5 则不变，也就是居中，当这个不为 0.5 时，ShoulderOffset X 才有效</li></ul></li><li>Vertical Arm Length：手相对于肩的垂直偏移。当相机垂直旋转时，臂长会影响跟随目标的屏幕位置，对于第一人称相机，这可以设置为 0</li><li>Camera Radius：指定相机在不调整其位置的情况下可以接近可碰撞障碍物的距离</li><li>Damping Into Collision：指定相机如何移动以校正遮挡，数字越大越慢</li><li>Damping From Collision：返回正常位置速度，数字越大，相机恢复速度越慢</li></ul><h3 id="framing-transposer"><a class="anchor" href="#framing-transposer">#</a> Framing Transposer</h3><p>专为 2D 和正交相机而设计</p><ul><li>这种虚拟相机机身算法将相机以固定的屏幕空间关系移动到跟随目标<ul><li>还可以指定偏移量、阻尼和合成规则</li><li>Framing Transposer 仅更改相机在空间中的位置，不会重新定向或以其他方式瞄准相机</li></ul></li><li>注 1：Framing Transposer 忽略 LookAt 目标 - 仅使用 Follow 目标，如果同时使用了 Aim 相关操作可能会有冲突</li><li>注 2：Framing Transposer 专为 2D 和正交相机而设计，但它也适用于透视相机和 3D 环境<ul><li>该算法首先沿相机 Z 轴移动相机，直到 Follow 目标与相机的 X-Y 平面相距达到所需的距离。然后它在 X-Y 平面中移动相机，直到跟随目标位于相机屏幕上的所需点</li></ul></li></ul><p>主要属性</p><ul><li>Lookahead Time<ul><li>根据目标的运动调整虚拟相机与跟随目标的偏移量</li><li>Cinemachine 预测目标将在未来这么多秒的时间点</li><li>此功能对嘈杂的动画很敏感，会放大噪音，从而导致不良的相机抖动。如果在目标运动时相机抖动不可接受，请调低此属性，或使目标动画更平滑</li></ul></li><li>Lookahead Smoothing<ul><li>预测算法的平滑度。较大的值可以消除抖动的预测并增加预测滞后</li></ul></li><li>Screen X/Y：相机跟随目标的屏幕位置</li><li>Camera Distance：跟踪距离</li><li>Dead Zone Width/Height：在此范围时，不移动相机</li><li>Dead Zone Depth：如果跟随目标与相机距离在此距离内，不沿其 z 轴移动相机</li><li>Soft Zone Width/Height：当目标在此范围内时，移动相机以将目标框在 DeadZone 内，阻尼属性影响相机移动的速率</li><li>Bias X/Y：软区的中心的偏移</li></ul><h3 id="hard-lock-to-target"><a class="anchor" href="#hard-lock-to-target">#</a> Hard Lock to Target</h3><p>将虚拟相机机身直接设置为 Follow 目标的位置</p><ul><li>换句话说，目标充当虚拟相机的安装点</li></ul><h3 id="orbital轨道-transposer"><a class="anchor" href="#orbital轨道-transposer">#</a> Orbital (轨道) Transposer</h3><p>可以选择接受玩家输入，允许玩家动态控制相机相对于目标的位置<br />这种虚拟相机机身算法将 Unity 相机移动到虚拟相机的跟随目标的可变关系中</p><ul><li>看着是绕目标的一个『圆环』轨道</li><li>可以设置移动限制角度范围，可选超出则停止或 Wrap 到另一个角度</li><li>Orbital Transposer 引入了航向的概念，即目标移动或面向的方向<ul><li>Orbital Transposer 尝试定位相机，使其指向与前进方向相同的方向</li><li>默认情况下，此位置位于目标的正后方，可通过调整 Heading-&gt;Bias 属性来控制这种关系</li></ul></li><li>Heading：指定如何计算 Follow 目标的航向<ul><li>Definition<ul><li>Position Delta：根据上次更新和当前帧的目标位置差异计算航向</li><li>Velocity：选择速度以使用目标刚体的速度，如果目标没有 Rigidbody 组件，则恢复为 Position Delta</li><li>Target Forward：使用目标的本地 Forward 轴作为航向</li><li>World Forward：使用恒定的世界空间 Forward 作为航向</li></ul></li><li>Velocity Filter Strength：在定义中使用 Position Delta 或 Velocity 时控制速度的平滑度</li><li>Bias：相对于航向放置相机的轨道中的角度偏移，以度为单位</li></ul></li><li>Recenter To Target Heading：勾选后，当玩家没有输入时控制自动重新居中<ul><li>注：当 Definition 选 Position Delta 或 Velocity 时可能没用</li></ul></li><li>X Axis：航向控制，此处的设置控制相机响应玩家输入的行为<ul><li>Wrap：如果选中，则轴在最小值和最大值处环绕，形成一个循环</li><li>Speed Mode：轴如何响应输入<ul><li>MaxSpeed（默认值）：限制轴可以改变的最大速度，与输入无关</li><li>InputValueGain：将输入值乘以 MaxSpeed</li></ul></li><li>Invert：反向</li></ul></li></ul><h3 id="tracked-dolly"><a class="anchor" href="#tracked-dolly">#</a> Tracked Dolly</h3><ul><li>限制虚拟相机沿预定义路径移动，使用路径位置属性指定将虚拟相机放置在路径上的位置</li><li>使用 Auto-Dolly 模式将虚拟相机移动到路径上最接近 Follow 目标的位置。启用后，Auto-Dolly 会自动将虚拟相机的位置动画化到路径上最接近目标的位置<ul><li>注：提示：使用 Auto-Dolly 模式时请谨慎选择路径形状，这在围绕某个点形成弧形的路径上会出现问题。作为一个极端的例子，考虑一个以 Follow 目标为中心的完美圆形路径。路径上的最近点变得不稳定，因为圆形路径上的所有点都同样接近目标，在这种情况下，将 Follow 目标移动一小段距离会导致相机在轨道上移动很远的距离</li></ul></li><li>Path Position：沿路径放置相机的位置，可直接设置或启用 Auto-Dolly，采用 Position Units 指定的单位</li><li>Position Units：路径位置的度量单位<ul><li>Path Units：沿途使用路标，值 0 表示路径上的第一个路点，1 表示第二个路点，依此类推</li><li>Distance：使用沿路径的距离</li><li>Normalized：值 0 表示路径的开始，1 表示路径的结束</li></ul></li><li>Path Offset：相机相对于路径的位置偏移</li><li>X/Y/Z Damping：移动阻尼，影响移动速度，越大越慢</li><li>Camera Up：如何为虚拟相机设置朝向<ul><li>Default：不修改虚拟相机的朝向，但会使用 Cinemachine Brain 中的 World Up Override 属性控制 (如果有的话)</li><li>Path：在当前点使用路径的朝向</li><li>Path No Roll：在当前点使用路径的朝向，但不旋转校正</li><li>Follow Target：使用 Follow 目标变换中的朝向</li><li>Follow Target No Roll：使用来自 Follow 目标变换的向上矢量，但不旋转校正</li></ul></li><li>Pitch/Yaw/Roll Damping：旋转阻尼，小数字使相机更灵敏，数字越大，相机响应越慢</li><li>Auto Dolly：控制如何自动移动相机，使用此功能需要有 Follow target<ul><li>Enabled：启用自动移动<ul><li>注意：这可能会对性能产生一些影响，具体取决于 Search Resolution 参数</li></ul></li><li>Position Offset：从路径上最近的点到跟随目标的偏移量，以 Position Units 为单位</li><li>Search Radius：当前段两侧的段数。对整个路径使用 0。当路径的形状相对于目标位置导致路径上的最近点变得不稳定时，使用较小的数字</li><li>Search Resolution：Cinemachine 通过将路径分成许多直线片段来搜索，数字越大，结果越准确。数值越高性能消耗也越大</li><li>注：该功能可以配合 DollyCart 使用（Cinemachine-&gt;DollyTrackWithCart，DollyCart 能够自动跟随路径点移动），再配合循环路点就可以无限环绕了</li></ul></li></ul><h4 id="cinemachine-path"><a class="anchor" href="#cinemachine-path">#</a> Cinemachine Path</h4><ul><li>是一个定义世界空间路径的组件，由一组路径点组成</li><li>使用 Bezier 插值来计算路点之间的位置以获得平滑且连续的路径，路径经过所有路点</li><li>可调整的控制属性相对 SmoothPath 更多</li><li>主要属性<ul><li>Resolution：路径采样分辨率</li><li>Looped：使路径循环封闭</li><li>Selected Waypoint：当前选中路径点的属性信息</li><li>Prefer Tangent Drag：当切线和位置的 Gizmo 在场景视图中重合时，选中以使用 Gizmo 作为路点的切线</li><li>Path Details<ul><li>Position：路径局部空间中的位置（即相对于路径对象本身）</li><li>Tangent：与位置的偏移量，它定义了路径点处曲线的切线</li><li>Roll：此路点的路径旋转，其他方向轴是从切线和 World Up 推断出来的（影响不会传递给其它路径点，只影响该路径点相连的两条边）</li></ul></li></ul></li></ul><h4 id="cinemachine-smooth-path推荐"><a class="anchor" href="#cinemachine-smooth-path推荐">#</a> Cinemachine Smooth Path (推荐)</h4><ul><li>是一个定义世界空间路径的组件，由一组路点组成</li><li>使用 Bezier 插值来计算路点之间的位置以获得平滑且连续的路径，路径经过所有路点</li><li>与 Cinemachine Path 不同，一阶和二阶连续性得到保证，这意味着不仅位置而且沿路径动画的对象的角速度都将是平滑和连续的，但也因此使我们对路径位置的控制更少</li><li>主要属性<ul><li>Waypoints：定义的所有路径点列表，使用贝塞尔曲线进行插值<ul><li>Position：路径点在在局部路径空间中的位置</li><li>Roll：此路点的路径旋转，其他方向轴是从切线和 World Up 推断出来的（影响会传递给其它路径点）</li></ul></li></ul></li></ul><p>注：可以设置为循环路点</p><h4 id="cinemachine-dolly-cart"><a class="anchor" href="#cinemachine-dolly-cart">#</a> Cinemachine Dolly Cart</h4><p>CinemachineDollyCart 是一个组件，可使用它沿着 Cinemachine Path 或 Cinemachine Smooth Path 路径为游戏对象设置路径移动动画，或作为虚拟相机的跟随目标<br />主要属性</p><ul><li>Path：路径</li><li>Update Method：当速度不为零时何时移动，使用 Update 进行正常的 MonoBehaviour 更新，使用 Fixed Update 进行与物理模块 FixedUpdate () 同步的更新，或 LateUpdate</li><li>Position Units：位置的度量单位<ul><li>Path Units：沿途使用路标，值 0 表示路径上的第一个路点，1 表示第二个路点，依此类推</li><li>Distance：使用沿路径的距离，根据路径的 Resolution 属性对路径进行采样。，Cinemachine 会创建一个距离查找表并存储在内部缓存中</li><li>Normalized：使用归一化 0~1 作为首尾</li></ul></li><li>Speed：以此速度移动，该值根据 PositionUnits 进行解释</li><li>Position：当前处于路径中的位置，可以直接设置动画，或者如果速度不为零，将自动更新，该值根据 PositionUnits 进行解释</li></ul><h3 id="transposer"><a class="anchor" href="#transposer">#</a> Transposer</h3><p>该算法将虚拟相机以固定偏移量移动到跟随目标，可应用阻尼</p><ul><li>固定偏移量可以有多种模式选择</li></ul><p>参数</p><ul><li>Binding Modes：绑定模式定义了 Unity 用来解释相机与目标的偏移量和阻尼的坐标空间<ul><li>Lock To Target：使虚拟相机使用 Follow 目标的本地坐标，当目标旋转时，相机也随之旋转以保持偏移并保持目标的相同视图</li><li>Lock To Target No Roll：使虚拟相机使用 Follow 目标的本地坐标，但不进行 Roll 的旋转 (实测是不受对象的 Z 轴旋转了)</li><li>Lock To Target On Assign：在激活虚拟相机或分配目标时，使虚拟相机的方向与 Follow 目标的局部坐标匹配。此偏移量在世界空间中保持不变。相机不随目标旋转</li><li>Lock To Target With World Up：使虚拟相机使用倾斜和滚动为 0 的跟随方式，此绑定模式忽略除 Yaw 之外的所有目标旋转</li><li>World Space：偏移量在世界空间中解释为相对于跟随目标的原点，目标旋转时相机不会改变位置</li><li>Simple Follow With World Up：此模式模拟人类摄像师在被指示跟随目标时将采取的行动，相机尝试尽可能少地移动以与目标保持相同的距离；相机相对于目标的方向无关紧要。无论目标的方向如何，相机都会尝试与其保持相同的距离和高度</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5jaW5lbWFjaGluZUAyLjgvbWFudWFsL0NpbmVtYWNoaW5lQmluZGluZ01vZGVzLmh0bWw=">https://docs.unity3d.com/Packages/com.unity.cinemachine@2.8/manual/CinemachineBindingModes.html</span></li></ul></li><li>Follow Offset：相对于跟随目标的距离</li><li>X/Y/Z Damping：响应阻尼</li><li>Pitch/Yaw/Roll Damping：旋转阻尼</li></ul><h2 id="aim-properties"><a class="anchor" href="#aim-properties">#</a> Aim properties</h2><p>使用该属性下的设置指定虚拟相机如何旋转</p><h3 id="do-nothing"><a class="anchor" href="#do-nothing">#</a> Do Nothing</h3><p>本身什么都不做，可以用于静态镜头或直接使用自定义脚本设置旋转动画</p><h3 id="composer"><a class="anchor" href="#composer">#</a> Composer</h3><p>此虚拟相机始终旋转相机以面向注视目标</p><ul><li>Center On Activate：选中后，当相机变为活动状态时，强制相机位于屏幕中央，否则位于最近的 DeadZone 边缘</li><li><img data-src="/blogimages/2023/2023-05-27/1.png" alt="" /></li><li>Tracked Object Offset：从 Look At 目标的中心偏移，可用于当所需区域不是被跟踪对象的中心时，微调跟踪目标位置</li><li>Lookahead Time：根据注视目标的运动调整偏移量，该算法预估目标将在未来指定时间运动 (秒)<ul><li>测试：随着值的增加，当物体运动时，追踪的中心点变了，处于预估位置</li><li>此功能对嘈杂的动画很敏感。它会放大噪声，导致不希望出现的相机抖动。如果在目标运动时相机抖动不可接受，请调低此属性或使目标动画更平滑</li></ul></li><li>Lookahead Smoothing：控制 Lookahead Time 算法的平滑度，较大的值可以消除预测抖动并增加预测滞后</li><li>Lookahead Ignore Y：预测计算忽略沿 Y 轴的移动</li><li>Horizontal/Vertical  Damping：相机在屏幕方向上跟随目标的响应速度，较小的数字会让相机旋转更灵敏、快速，以将目标保持在 DeadZone 内。对更重、响应更慢的相机使用更大的数字</li><li>Screen X/Y：DeadZone 中心的屏幕位置，摄像机旋转保持目标处于这里</li><li>Dead Zone Width/Height：在该区域中相机忽略目标的任何移动，也不会更新其旋转。这对于忽略较小的目标移动很有用</li><li>Soft Zone Width/Height：如果目标出现在屏幕的这个区域，相机将旋转以将保持于 DeadZone</li><li>Bias X/Y：SoftZone 相对于 DeadZone 的偏移</li></ul><h3 id="group-composer"><a class="anchor" href="#group-composer">#</a> Group Composer</h3><p>这种 Virtual Camera Aim 算法将相机瞄准多个游戏对象</p><ul><li>它的行为与 Composer 相同并且具有相同的设置</li><li>如果 Look At 目标是 Cinemachine Target Group，可以调整 FOV 和摄像机距离，以确保正确瞄准目标组</li></ul><h4 id="cinemachine-target-group"><a class="anchor" href="#cinemachine-target-group">#</a> Cinemachine Target Group</h4><p>使用 Cinemachine Target Group 将多个游戏对象视为单个 Look At 目标， Target Group 与虚拟相机 Group Composer 算法结合使用</p><ul><li>Position Mode<ul><li>Group Center：使用包含目标组所有对象的轴对齐边界框的中心</li><li>Group Average：使用目标组中各个对象位置的加权平均值</li></ul></li><li>Rotation Mode<ul><li>Manual：使用目标组变换的旋转属性中指定的值 (推荐)</li><li>Group Average：目标组中所有对象方向的加权平均值</li></ul></li><li>Update Method<ul><li>Update：在正常的 MonoBehaviour Update () 方法中更新</li><li>Fixed Update：在 FixedUpdate () 中与物理模块同步更新</li><li>Late Update：在 MonoBehaviour LateUpdate () 中更新</li></ul></li><li>Targets<ul><li>Weight：对象权重，不能为负</li><li>Radius：对象半径，用于计算边界框，不能为负</li></ul></li></ul><h3 id="hard-look-at"><a class="anchor" href="#hard-look-at">#</a> Hard Look At</h3><p>旋转虚拟相机以将注视目标始终保持在相机框架的中心</p><h3 id="pov"><a class="anchor" href="#pov">#</a> POV</h3><p>这种 Virtual Camera Aim 算法会根据用户的输入来控制相机旋转</p><ul><li>Vertical/Horizontal  Axis：控制虚拟相机旋转<ul><li>Value：当前相机瞄准的轴的度数，以度为单位。可接受的值为 -90 到 90</li><li>Value Range：虚拟相机垂直轴可允许旋转的最小和最大度数</li><li>Wrap：如果选中，轴环绕 ValueRange 范围形成一个循环</li><li>Speed Mode：轴如何响应输入<ul><li>MaxSpeed（默认值）：限制轴可以改变的最大速度，与输入无关</li><li>InputValueGain：将输入值乘以 MaxSpeed</li></ul></li><li>Accel Time：加速时间</li><li>Decel Time：减速时间</li><li>Input Axis Name：在 Unity 输入管理器中指定的该轴的名称，要禁用则将此属性设置为空字符串</li><li>Input Axis Value：输入轴的值。值为 0 表示没有输入，可以直接从自定义输入系统驱动它，或者也可以设置输入轴名称并让值由 Unity 输入管理器驱动</li><li>Invert：在使用 InputAxisName 输入的值之前反转原始值</li></ul></li><li>Vertical/Horizontal  Recentering：当玩家没有输入时控制自动返回居中</li></ul><h3 id="same-as-follow-target"><a class="anchor" href="#same-as-follow-target">#</a> Same As Follow Target</h3><p>与目标旋转保持一致</p><ul><li>当与 Body 属性中的 Hard Lock to Target 算法一起使用时，该算法使虚拟相机匹配控件 GameObject 的路径和旋转</li></ul><h2 id="noise使用噪声模拟相机抖动"><a class="anchor" href="#noise使用噪声模拟相机抖动">#</a> Noise：使用噪声模拟相机抖动</h2><p>现实世界中的物理相机一般比较笨重，由摄像师手持或安装在例如移动的车辆等不稳定的物体上<br />可以使用噪声属性来模拟这些真实世界的效果：例如在跟随奔跑的角色时添加相机抖动</p><ul><li>在每次帧更新时，Cinemachine 都会添加与摄像机运动分开的噪声以跟随目标</li><li>噪声不会影响相机在未来帧中的位置，这种分离可确保阻尼等属性按预期运行</li></ul><p>Cinemachine 包含一个基本多通道 Perlin 组件，可以将 Perlin 噪声添加到虚拟摄像机的运动中</p><h3 id="属性设置"><a class="anchor" href="#属性设置">#</a> 属性设置</h3><ul><li>Noise Profile：要使用的噪声配置文件资产</li><li>Amplitude Gain：应用于噪声曲线中定义的振幅的增益<ul><li>使用 1 以使用噪声配置文件中定义的振幅，将此设置为 0 可禁用</li><li>提示：设置此属性的动画可使噪声效果上下倾斜</li></ul></li><li>Frequency Gain：应用于噪声配置文件中定义的频率的系数<ul><li>使用 1 以使用噪声配置文件中定义的频率</li><li>使用较大的值可以更快地摇动相机</li><li>提示：设置此属性的动画可使噪声效果上下倾斜</li></ul></li><li>Pivot Offset：旋转相机时，在应用旋转噪声时将相机的枢轴偏移指定的 x、y 和 z 距离。这会产生一些与旋转噪声相对应的位置变化</li></ul><h3 id="噪声配置文件"><a class="anchor" href="#噪声配置文件">#</a> 噪声配置文件</h3><p>噪声配置文件是定义相机噪声程序曲线的资源</p><ul><li>Basic Multi Channel Perlin 组件将噪声配置文件应用于相机的移动， Cinemachine 在计算出摄像机的位置后应用噪声移动</li><li>可以设置位置、旋转的振幅、频率以合成随机噪声效果</li></ul><p>注：</p><ul><li>对于振幅，对更宽的镜头使用更大的值以显着地抖动相机。对于长焦镜头，使用较小的振幅值，因为较窄的 FOV 会放大效果</li><li>对于频率，典型的低频范围为 0.1-0.5 Hz，中频范围为 0.8-1.5，高频范围为 3-4。最高有用频率取决于游戏的帧速率。游戏通常以 30 或 60Hz 运行，高于游戏帧速率的噪声频率介于奈奎斯特速率之间。换句话说，它们不会被直接跟踪<ul><li>例如，如果游戏以 60 帧 / 秒的速度运行并且将频率设置为 100，将获得不连贯的相机噪音</li><li>这是因为游戏无法渲染比帧速率更快的物体</li></ul></li></ul><p>参数</p><ul><li>Preview Time：在检查器的图形中显示的秒数，用于编辑时在检查器中预览时长</li><li>Preview Height：预览框高度</li><li>Animated：预览噪声波动的移动表示</li><li>Position Noise：相机移动的所有轴的所有噪声层的图形表示<ul><li>Frequency：噪声层中波的频率，以 Hz 为单位</li><li>Amplitude：噪声层中波的振幅（高度），以距离为单位</li><li>Non-random wave if checked：选中以从噪声层中移除 Perlin 噪声 (随机化频率和振幅，同时保持在所选值的附近)，没有 Perlin 噪声会使用常规正弦波</li></ul></li><li>Rotation Noise：相机旋转所有轴的所有噪声层的图形表示（设置同位置）</li></ul><h2 id="虚拟相机之间的混合"><a class="anchor" href="#虚拟相机之间的混合">#</a> 虚拟相机之间的混合</h2><p>使用混合属性指定 CinemachineBrain 组件如何在虚拟摄像机之间执行混合</p><ul><li>Cinemachine 混合不是淡入淡出、擦除或溶解，而是执行从一个虚拟摄像机到下一个虚拟摄像机时 Unity 摄像机的位置、旋转和其他设置的平滑动画</li><li>对于特定虚拟摄像机之间的混合，使用 CinemachineBrain 组件中的自定义混合列表，使用 CinemachineBrain 中的默认混合属性来指定没有自定义混合的虚拟摄像机之间的混合<ul><li>From 和 To 设置是基于<strong>名称</strong>的，而不是引用</li><li>这意味着 Cinemachine 通过将名称与设置相匹配来查找摄像机，而非链接到特定的游戏对象，内置下拉菜单可用于从当前场景中选择虚拟摄像机，或者直接在文本框中输入名称，如果名称与当前场景中的任何虚拟摄像机都不匹配，则该字段将以黄色突出显示</li></ul></li><li>当 Cinemachine 开始从一个虚拟摄像机过渡到另一个虚拟摄像机时，它将在此资设置中查找与即将到来的过渡相匹配的条目，并应用该混合定义<ul><li>如果未找到，则将应用 CinemachineBrain 的 DefaultBlend 设置</li><li>如果在资产设置中找到读个匹配，Cinemachine 将选择具有最强特异性的一个。例如，如果从 vcam1 混合到 vcam2，并且自定义混合资产包含 vcam1-to-AnyCamera 的条目和 vcam1-to-vcam2 的另一个条目，则 vcam1-to-vcam2 条目将适用</li><li>如果 Custom Blends 资产中的多个条目与即将到来的过渡具有同样强烈的特异性，那么找到的第一个将适用</li></ul></li></ul><h3 id="属性"><a class="anchor" href="#属性">#</a> 属性</h3><ul><li>From：要混合的虚拟摄像机的名称。使用名称 <strong>ANY CAMERA</strong> 从任何虚拟相机进行混合。此属性仅适用于自定义混合</li><li>To：要混合到的虚拟摄像机的名称。使用名称 <strong>ANY CAMERA</strong> 混合到任何虚拟相机。此属性仅适用于自定义混合</li><li>Style Default Blend：混合曲线<ul><li>Cut：没有混合，直接切换</li><li>Ease In Out：S 型曲线，过渡平缓流畅</li><li>Ease In：从传出的虚拟摄像机中线性 (Linear) 淡出，并缓和到混入新的虚拟摄像机中</li><li>Ease Out：缓和淡出虚拟摄像机，并线性混合到新的虚拟摄像机中</li><li>Hard In：从旧的虚拟摄像机中缓出，并加速进入新的虚拟摄像机</li><li>Hard Out：加速离开旧的的虚拟摄像机，并缓缓进入新的虚拟摄像机</li><li>Linear：线性混合</li><li>Custom：自定义曲线</li></ul></li><li>Time：混合的持续时间（以秒为单位）</li></ul><h2 id="composing-a-shot拍摄视图"><a class="anchor" href="#composing-a-shot拍摄视图">#</a> Composing a shot（拍摄视图）</h2><p>Framing Transposer、Composer 和 Group Composer 算法定义相机框架中的区域，以供构图：</p><ul><li>空区 (Dead zone)：Cinemachine 将目标保留在画面中的区域</li><li>软区 (Soft zone)：如果目标进入画面的这个区域，相机将重新定向以将其放回盲区。根据阻尼设置中指定的时间，它会缓慢或快速地执行此操作</li><li>屏幕 (Screen)：死区中心的屏幕位置。 0.5 是屏幕的中心。</li><li>阻尼 (Damping)：模拟真实摄像师在操作重型物理摄像头时引入的滞后。阻尼指定相机在跟踪目标时目标进入软区时快速或缓慢地做出反应。使用较小的数字来模拟更灵敏的相机，快速移动或瞄准相机以将目标保持在盲区内。较大的数字模拟较重的摄像机，值越大，Cinemachine 越允许目标进入软区</li></ul><p><img data-src="/blogimages/2023/2023-05-27/2.png" alt="" /></p><p>如上图所示：</p><ul><li>空白区域表示空区 (Dead zone)<ul><li>(没大明白)</li></ul></li><li>蓝色区域表示软区 (Soft zone)</li><li>红色区域表示目标永远不会进入的禁区，黄色方块表示目标</li></ul><p>调整这些区域可以获得各种相机行为，例如使用更大的阻尼值来模拟更大、更重的相机，或者扩大软区和死区以在相机框架的中间创建一个不受目标运动影响的区域。例如用于动画循环之类的事情、比如如果不希望目标移动一点点相机就跟踪目标</p><h1 id="分组虚拟像机"><a class="anchor" href="#分组虚拟像机">#</a> 分组虚拟像机</h1><p>分组摄像机可以同时管理多个虚拟摄像机，但从 CinemachineBrain 和 TimeLine 的角度来看，只将其当做单个虚拟摄像机对象</p><h2 id="freelook-camera"><a class="anchor" href="#freelook-camera">#</a> FreeLook Camera</h2><p>该组件可以接受玩家输入<br /> Cinemachine Free Look Camera 组件提供第三人称视角的相机体验</p><ul><li>该组件沿着由三个独立的摄像机装置指定的位置围绕其主体运行：顶部、中部和底部</li><li>三个部位，每个部位都定义一个围绕目标的环，具有自己独立的设置，与常规虚拟相机的属性相同</li><li>接受玩家输入时，会根据对应输入在轨道之间进行混合</li></ul><p>沿 x 轴和 y 轴使用玩家输入</p><ul><li>x 轴控制沿着顶部、中间或底部水平轨道的轨道位置，就像轨道转置器一样</li><li>y 轴控制垂直位置，使用样条曲线确定相机之间的位置</li></ul><p>整体上是一个圆环，可视作处于目标周围一个圆的表面的移动<br />主要属性</p><ul><li>Binding Modes：同 Transposer 的模式</li><li>Spline Curvature：连接钻机轨道的线的曲率，这条线决定了 y 轴上的最终位置</li><li>Height, Radius：Top、Middle 和 Bottom 三个环相对于 Follow 目标的半径和高度</li></ul><h2 id="cinemachine-mixing-camera"><a class="anchor" href="#cinemachine-mixing-camera">#</a> Cinemachine Mixing Camera</h2><p>Cinemachine 混合摄像机组件使用其子虚拟摄像机的加权平均值来计算 Unity 摄像机的位置和其他属性<br /> Mixing Camera 最多管理八个子虚拟摄像机，通过场景右键创建时，会自动添加两个子虚拟相机</p><ul><li>在 Mixing Camera 组件中，这些 Virtual Cameras 是固定的插槽，而不是动态数组</li><li>Mixing Camera 使用此实现来支持 Timeline 中的权重动画，Timeline 不能为数组元素设置动画</li></ul><p>主要属性</p><ul><li>Child Camera Weights：虚拟相机的重量，注意将一个相机的权重设置为 1 不会将其他权重设置为零。任何单个相机的权重贡献是它的权重除以所有子权重的总和</li><li>Mix Result：子虚拟相机权重的图形表示，每个子相机的条形的浅色部分代表其对混合相机最终位置的贡献比例，当条形完全变暗时，摄像机对混合摄像机的位置将没有任何影响</li></ul><h2 id="cinemachine-blend-list-camera"><a class="anchor" href="#cinemachine-blend-list-camera">#</a> Cinemachine Blend List Camera</h2><p>Cinemachine 混合列表摄像机组件在其子虚拟摄像机之间执行一系列混合或剪切</p><ul><li>当混合列表相机被激活时，它会执行其指令列表，激活列表中的第一个子虚拟相机，保持指定的时间，然后剪切或混合到下一个子对象，依此类推</li><li>混合列表摄像机保留到最后一个虚拟摄像机，直到 CinemachineBrain 或时间轴停用混合列表摄像机</li></ul><p>提示：使用 Blend List Camera 而不是 Timeline 以获得更简单的自动序列<br />通过场景右键创建时，会自动添加两个子虚拟相机<br />主要属性</p><ul><li>Follow：子虚拟相机移动的默认目标，当子虚拟相机没有指定跟踪目标时，BlendList 相机使用这个目标，如果子虚拟相机都定义了自己的目标，则可以为空</li><li>LookAt：Unity 相机瞄准的默认目标，当子虚拟相机没有指定跟踪目标时，BlendList 相机使用这个目标，如果子虚拟相机都定义了自己的目标，则可以为空</li><li>Loop：启用后，子虚拟摄像机将无限循环，而不是停在列表中的最后一个虚拟摄像机上</li><li>Hold：到达位置后的停止时间，停止指定时间后继续</li></ul><h2 id="cinemachine-clear-shot-camera"><a class="anchor" href="#cinemachine-clear-shot-camera">#</a> Cinemachine Clear Shot Camera</h2><p>该组件在其子虚拟相机中选择拍摄目标时，选取镜头质量最好的相机，使用 ClearShot 设置场景的复杂多摄像机覆盖范围，以保证目标的清晰视野<br />这个功能很强大，具有 CinemachineCollider 扩展的虚拟相机子项分析场景中的目标障碍物、最佳目标距离等， ClearShot 使用此信息来选择最适合激活的一个</p><ul><li>如果多个子摄像头的镜头质量一样，Clear Shot 摄像头会选择优先级最高的一个</li><li>还可以定义清晰镜头子相机之间的自定义混合</li></ul><p>注 1：『镜头质量』应该指没有被障碍物遮挡<br />注 1：如果想要为所有虚拟摄像机子项使用单个 CinemachineCollider，可以直接将 CinemachineCollider 扩展添加到 ClearShot 对象，而非每个子虚拟摄像机单独挂。这样这个 CinemachineCollider 扩展会适用于所有的子相机（如同每个相机都有个单独的 Collider 扩展一样）</p><ul><li>通过场景创建的 ClearShotCamera 会创建一个子虚拟相机，默认创建的子相机会默认附带一个 CinemachineCollider，但是其 AvoidObstacles 默认是没有启用的！需要注意</li></ul><p>主要属性</p><ul><li>Activate After：在当前相机已经不是最佳视野相机后 (碰到障碍物)，至少等待指定时间才会切换到另外的相机</li><li>Min Duration：在当前相机已经不是最佳视野相机后 (碰到障碍物)，且该相机已经保持了指定时间，才可以切到新相机去</li><li>Randomize Choice：如果多个虚拟摄像机的镜头质量相同，选择这些中的一个随机摄像机。否则使用子虚拟相机的顺序及其优先级为准</li><li>Priority：优先级</li></ul><h2 id="cinemachine-state-driven-camera"><a class="anchor" href="#cinemachine-state-driven-camera">#</a> Cinemachine State-Driven Camera</h2><p>状态驱动摄像机，该组件会在动画目标更改状态时激活子虚拟相机</p><ul><li>例如，角色的本地运动系统和轨道相机<ul><li>当角色跑动时相机晃动幅度更大会让游戏对玩家来说感觉更生动，而当其行走时，则使用阻尼值更大的虚拟相机</li></ul></li></ul><p>属性里的动画目标指的是一个由 AnimatorController 控制的 Animator 组件的对象</p><ul><li>状态驱动相机有一个列表，可以将子虚拟相机分配给对应动画状态</li></ul><p>主要属性</p><ul><li>Animated Target：包含 AnimatorController 的对象</li><li>Layer：要在动画目标中检测的动画层</li><li>State：虚拟相机将映射到的动画状态</li><li>Wait：进入此状态后激活虚拟相机的延迟（以秒为单位），即新的动画状态激活时间指定时间后，相机才切换过去</li><li>Min：虚拟相机在激活后必须保持活动状态的最短时间（以秒为单位）</li></ul><h1 id="相机扩展"><a class="anchor" href="#相机扩展">#</a> 相机扩展</h1><p>扩展是增强虚拟相机行为的组件，Cinemachine 默认包含了一些扩展，也可以通过继承自 CinemachineExtension 类来创建自定义扩展</p><h2 id="默认扩展"><a class="anchor" href="#默认扩展">#</a> 默认扩展</h2><h3 id="cinemachine-collider"><a class="anchor" href="#cinemachine-collider">#</a> Cinemachine Collider</h3><p>碰撞处理<br />它对虚拟相机的最终位置进行后处理，以尝试与虚拟相机的目标保持清晰的视线，主要通过将相机推离阻挡视线的游戏对象来实现这一点</p><ul><li>主要功能包括碰撞检测、镜头质量评估</li><li>注：使用 PhysicsRaycaster 进行碰撞检测</li></ul><p>主要属性</p><ul><li>Collide Against：碰撞检测层级</li><li>Transparent Layers：忽略的层级</li><li>Ignore Tag：带有此标签的障碍物将被忽略</li><li>Minimum Distance From Target：与跟踪目标的距离小于该数值的障碍物会被忽略</li><li>Avoid Obstacles：选中后，在目标被障碍物遮挡时才会移动相机进行避障</li><li>Distance Limit：经试验看着是 从相机到目标 发射射线的距离，配置 0 则直连无限制</li><li>Camera Radius：检测到障碍物并进行避障时，与障碍物保持的距离</li><li>Strategy：避障策略<ul><li>Pull Camera Forward：沿 Z 轴向前移动相机，直到它位于距离目标最近的障碍物前面</li><li>Preserve Camera Height：将相机移动到另一个视角，同时尝试将相机保持在其原始高度</li><li>Preserve Camera Distance：将相机移动到另一个视点，同时尝试将相机保持在与目标的原始距离（比如往左或往上之类的偏同样距离）</li></ul></li><li>Smoothing Time：将相机保持在离目标最近的点的最小时间，可用于在有很多障碍物的环境中减少相机的过度移动 (开启避障时可用)</li><li>Damping：障碍消失后，将相机返回到正常位置的阻尼</li><li>Damping When Occluded：移动相机以避开障碍物的阻尼</li><li>Optimal Target Distance：如果大于零，则当目标更接近此距离时，镜头质量评分更高，将此属性设置为 0 可禁用此功能</li><li>Minimum Occlusion Time：遮挡至少持续了指定时间才进行避障操作</li><li>Maximum Effort：要处理的障碍物数量的上限，较高的数字可能会影响性能。在大多数环境中，四 (4) 次就足够了</li></ul><h3 id="cinemachine-confiner"><a class="anchor" href="#cinemachine-confiner">#</a> Cinemachine Confiner</h3><p>使用该扩展将摄像机的位置限制在一个区域（对于正交相机，还有一个附加选项可以限制屏幕边缘）</p><p>主要属性</p><ul><li>Confine Mode：使用 2D bounding 或 3D bounding 进行操作</li><li>Bounding Volume：一个 Collider 碰撞体</li><li>Confine Screen Edges：在正交相机将屏幕边缘限制在该区域，未选中时仅限制相机中心（透视模式无效）</li></ul><h3 id="cinemachine-follow-zoom"><a class="anchor" href="#cinemachine-follow-zoom">#</a> Cinemachine Follow Zoom</h3><p>此扩展调整镜头的 FOV，使目标物体在屏幕上保持恒定大小，而不管相机和目标位置如何<br />主要属性</p><ul><li>Width：在目标距离处以世界单位保持的视野宽度。将自动调整 FOV，使得不管两者距离如何，对象在视野中都具有同样的大小</li><li>Min FOV：FOV 调整下限</li><li>Max FOV：FOV 调整上限</li></ul><h3 id="cinemachine-pixel-perfect"><a class="anchor" href="#cinemachine-pixel-perfect">#</a> Cinemachine Pixel Perfect</h3><p>Pixel Perfect Camera 和 Cinemachine 都会修改相机的正交尺寸，在一个场景中一起使用这两个系统会导致它们争夺对相机的控制权并产生不需要的结果，CinemachinePixelPerfect 扩展用于解决这种不兼容问题</p><ul><li>注：<ul><li>Pixel Perfect Camera：2D Pixel Perfect 包中包含 Pixel Perfect Camera 组件，可确保像素图像在不同分辨率下始终保持锐利清晰，并在运动中保持稳定</li></ul></li><li>看着是处理 2D Sprites 的</li></ul><h3 id="cinemachine-post-processing"><a class="anchor" href="#cinemachine-post-processing">#</a> Cinemachine Post Processing</h3><p>该扩展用于将 Postprocessing V2 配置文件附加到虚拟摄像机</p><ul><li>注：对于 HDRP 和 URP 7 及更高版本，PostProcessing 包已弃用，由 HDRP 和 URP 直接实现， URP 用 CinemachineVolumeSettings 扩展代替</li></ul><h3 id="cinemachine-volume-settings"><a class="anchor" href="#cinemachine-volume-settings">#</a> Cinemachine Volume Settings</h3><p>使用该扩展可以将 HDRP/URP VolumeSettings 配置文件附加到虚拟摄像机<br />该扩展可以指定一个 VolumeSettingsProfile 资源，在激活时应用于虚拟摄像机。如果摄像机正在与另一个虚拟摄像机混合，则混合权重也会应用于设置效果<br />主要属性</p><ul><li>Focus Tracking：如果配置文件具有适当的重载，则会将基本焦距设置为从所选目标到相机的距离。然后 Focus Offset 字段将修改该距离<ul><li>None</li><li>Look At Target：相对于 LookAt 目标的焦点偏移</li><li>Follow Target：相对于 Follow 目标的焦点偏移</li><li>Custom Target：相对于自定义目标的焦点偏移</li><li>Camera：相对于相机的焦点偏移</li></ul></li><li>Focus Offset：当 Focus Tracking 不是 None 时有效，将最中心点从聚焦目标的位置偏移<ul><li>要求后处理包括 DepthOfField</li></ul></li></ul><h3 id="cinemachine-storyboard"><a class="anchor" href="#cinemachine-storyboard">#</a> Cinemachine Storyboard</h3><p>Cinemachine Storyboard 在屏幕空间中将静止图像放置在 Unity 摄像机的输出之上，故事板可以简化动画，可以以故事版 (原画) 为基准，对场景进行构建<br />可随时使用 Storyboard 组件中的属性来隐藏和显示图像，并可以在全局级别禁用，以将其与 Unity 相机的实际渲染进行比较<br />主要属性</p><ul><li>Storyboard Global Mute：启用后，所有故事板都将全局禁用</li><li>Show Image：切换故事板图像的可见性</li><li>Aspect：图像显示模式<ul><li>Best Fit：保持垂直和水平比例，在不裁剪图像的情况下，将图像在屏幕上尽可能大地显示</li><li>Crop Image To Fit：保持垂直和水平比例，调整图像大小以填满屏幕，必要时进行裁剪</li><li>Stretch To Fit：调整图像大小以填满屏幕，必要时会拉伸填充</li></ul></li><li>Mute Camera：该项可以防止虚拟相机更新 Unity 相机，使用此功能可防止时间轴将相机混合到场景中的意外位置</li><li>Waveform Monitor：打开波形监视器窗口</li></ul><h3 id="cinemachine-3rd-person-aim"><a class="anchor" href="#cinemachine-3rd-person-aim">#</a> Cinemachine 3rd Person Aim</h3><p>这个扩展被认为是第三人称相机的一部分<br />为了保持瞄准精度，此扩展故意消除所有旋转噪音，并强制仔细瞄准目标点，不过如果噪声影响相机位置而不是旋转，那么相机位置噪声依然有效</p><ul><li>如果 AimTargetReticle (准星) 不为空，则此扩展将从 Follow 目标的位置投射一条射线，并找到与该射线碰撞的第一个对象。然后，Aim Target Reticle 对象将被放置在游戏视图中的那个点上，以指示玩家在开枪时会击中什么</li><li>注：如果检测到的对象足够近以致于由于玩家和相机之间的偏移而受到视差的影响，则该点可能与相机所看到的不同</li></ul><p>主要属性</p><ul><li>Aim Collision Filter：检测层</li><li>Ignore Tag：忽略标签对象</li><li>Aim Distance：物体检测射线投射多远</li><li>Aim Target Reticle：是一个 2D 对象，将定位在游戏视图中的光线投射命中点（如果有）上方，或者如果未检测到命中点，则将保留在屏幕中央。可以为空，在这种情况下屏幕上不会出现指示符</li></ul><h3 id="cinemachine-recomposer"><a class="anchor" href="#cinemachine-recomposer">#</a> Cinemachine Recomposer</h3><p>这个扩展是 CinemachineVirtualCamera 的附加模块，它为相机合成添加了最后的调整。主要用于 Timeline 的环境，如果希望在其中手动调整程序或记录的相机瞄准的输出的话<br />所有这些属性都可以在 Timeline 中进行动画处理<br />主要属性</p><ul><li>Apply After：当此虚拟相机处于活动状态时要激活的设置<ul><li>Body：相机已定位但尚未旋转时</li><li>Aim：相机已旋转和定位，但未应用噪声或碰撞解决方案时</li><li>Noise：已定位、旋转相机，并已应用噪点和其他校正后</li><li>Finalize：在所有标准虚拟相机处理发生后应用</li></ul></li><li>Tilt：将垂直旋转添加到相机的当前旋转</li><li>Pan：将水平旋转添加到相机的当前旋转</li><li>Dutch：为当前相机的旋转添加倾斜（局部 Z 旋转）</li><li>Zoom Scale：缩放当前相机视野 (FOV) 大小</li><li>Follow Attachment：当该值小于 1 时，跟随目标的阻尼会增加，当该值为零时，阻尼是无限的</li><li>Look At Attachment：当该值小于 1 时，注视目标 (旋转) 阻尼会增加，当该值为零时，阻尼是无限的</li></ul><h1 id="multiple-unity-cameras"><a class="anchor" href="#multiple-unity-cameras">#</a> Multiple Unity cameras</h1><p>分屏和画中画效果需要使用多个 Unity 相机，每个 Unity 摄像机在玩家屏幕上呈现自己的视图<br /><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5jaW5lbWFjaGluZUAyLjgvbWFudWFsL0NpbmVtYWNoaW5lTXVsdGlwbGVDYW1lcmFzLmh0bWw="> https://docs.unity3d.com/Packages/com.unity.cinemachine@2.8/manual/CinemachineMultipleCameras.html</span><br /> 注意将 Culling Mask 设置为适当的层</p><h1 id="cinemachine-brain"><a class="anchor" href="#cinemachine-brain">#</a> Cinemachine Brain</h1><p>属于 Unity 相机上的一个组件，用于监控场景中所有活动的虚拟相机<br />将虚拟摄像机或其他 Cinemachine 对象添加到场景时，如果 Unity 相机上尚无 Cinemachine Brain 组件，Unity 会自动添加一个<br />如果想切换到下一个虚拟相机，可以激活或禁用对应的虚拟相机对象，Cinemachine Brain 会选择最近激活的虚拟相机，并在之前虚拟相机和新激活的虚拟相机之前进行剪切或混合</p><ul><li>注 1：可以利用 Cinemachine Brain 实时响应动态游戏事件，在游戏逻辑中控制优先级，这对于实时游戏玩法特别有用，因为其中的动作并不总是可以预测的</li><li>注 2：使用 Timeline 在可预测的情况下编排摄像机，例如过场动画。 Timeline 覆盖 Cinemachine Brain 优先级系统，提供精确的帧摄像机控制</li></ul><p>注：使用 Timeline 控制虚拟相机时，Timeline 会覆盖 CinemachineBrain 做出的决定<br />主要属性</p><ul><li>Blend Update Method：何时混合并更新主相机<ul><li>Late Update：在 MonoBehaviour LateUpdate 中 (默认)</li><li>Fixed Update：仅当更新方法为 FixedUpdate 并且在混合时看到抖动时才使用此设置</li></ul></li><li>Default Blend：当没有明确定义两个虚拟相机之间的混合时使用的默认混合方式</li><li>Custom Blends：包含场景中特定虚拟相机 (取决于名字) 之间混合的自定义设置的资源引用</li><li>Camera Cut Event：当虚拟相机激活并且没有混合时会触发此事件</li><li>Camera Activated Event：当虚拟相机激活时会触发此事件，如果涉及混合，则事件会在混合的第一帧触发</li></ul><h1 id="cinemachine-and-timeline"><a class="anchor" href="#cinemachine-and-timeline">#</a> Cinemachine and Timeline</h1><p>使用时间轴在虚拟相机之间激活、停用和混合。在时间轴中，将 Cinemachine 与其他游戏对象和资产相结合，以交互方式实现和调整丰富的过场动画，甚至是交互式过场动画。</p><ul><li>注：对于简单的镜头序列，最好使用 Cinemachine Blend List Camera 而不是 Timeline</li></ul><p>Timeline 会覆盖 CinemachineBrain 做出的基于优先级的决定，当 Timeline 结束时，控制返回给 CinemachineBrain</p><ul><li>可以使用 CinemachineShotClip 控制 Timeline 中的虚拟摄像机，每个镜头剪辑都指向一个虚拟相机以激活然后停用，使用一系列镜头剪辑来指定每个镜头的顺序和持续时间</li><li>将 Clip 彼此相邻放置可以在两个虚拟摄像机之间切换，重叠 Clip 可以在两个虚拟摄像机之间混合</li></ul><p>创建</p><ul><li>在场景中创建一个空的 GameObject，它可以作为创建时间轴资源和实例</li><li>在场景中选择对象，点击 Timeline 窗口的 Create 可以创建一个本地资源</li><li>可以单击锁按钮锁定 TImeline 窗口，以便更轻松地添加和调整轨道</li><li>将带有 CinemachineBrain 组件的 Unity 摄像机拖到时间轴编辑器上，然后从下拉菜单中选择 “Create Cinemachine Track”</li></ul><p>将 CinemachineShotClips 添加到 Cinemachine 轨道：</p><ul><li>在 CinemachineTrack 中，右键单击并选择 Add Cinemachine Shot Clip</li><li>执行以下操作之一：<ul><li>将已存在的虚拟相机添加到引用上</li><li>点击 Create 创建一个新的相机</li></ul></li><li>在时间轴编辑器中，调整镜头剪辑的顺序、持续时间、剪切和混合</li><li>调整虚拟相机的属性以将其放置在场景中并指定瞄准或跟随的目标</li><li>要为 VirtualCamera 的属性设置动画，需要为其创建一个 AnimationTrack 并像任何其他 GameObject 一样设置动画</li><li>组织 Timeline 轨道以微调场景</li></ul><h1 id="top-down-games"><a class="anchor" href="#top-down-games">#</a> Top-down games</h1><p>Cinemachine Virtual Cameras 以人类摄像机操作者及其操作真实摄像机的方式为蓝本</p><ul><li>因此，它们对上 / 下轴很敏感，并且总是尽量避免将滚动 (Roll 旋转) 引入相机取景</li><li>由于这种敏感性，虚拟相机避免长时间直线上升或下降。如果 Look At 目标长时间直线上升或下降，那么将不会始终得到所需的结果</li></ul><p>如果目的是构建一个 Top-down 的游戏，其中摄像机直接向下看，最佳做法是重新定义向上的方向，以供摄像机使用。为此可以将 CinemachineBrain 中的 WorldUpOverride 属性设置为一个游戏对象，该对象的本地向上指向希望虚拟摄像机正常向上的方向，这适用于该 CinemachineBrain 控制的所有虚拟摄像机</p><h1 id="alternative-input-systems"><a class="anchor" href="#alternative-input-systems">#</a> Alternative Input Systems</h1><p>一些 Cinemachine 组件（例如 FreeLook、POV、OrbitalTransposer）需要用户输入来定位或定向摄像机<br />默认情况下，Cinemachine 通过查询标准 Unity Input.GetAxis (name) 获取用户输入</p><ul><li>Cinemachine 定义了一个接口：Cinemachine.AxisState.IInputAxisProvider</li><li>如果将实现此接口的 MonoBehaviour 添加到虚拟相机或 FreeLook，则将调用自定义的脚本输入而不是标准输入系统</li></ul><p>CinemachineInputProvider 是一个输入源重载，它会使虚拟相机使用新的 UnityEngine.Input 包而不是标准的 Unity 输入系统来获取输入，当项目中安装了 UnityEngine.Input 包时可用</p><h1 id="cinemachine-impulse"><a class="anchor" href="#cinemachine-impulse">#</a> Cinemachine Impulse</h1><p>Cinemachine Impulse 生成并管理相机抖动以响应游戏事件</p><ul><li>例如使用 Impulse 在一个 GameObject 与另一个 GameObject 发生碰撞或场景中的某物爆炸时使 CinemachineVirtualCamera 抖动</li></ul><p>Impulse 分为三部分：</p><ul><li>Raw vibration signal：多达 6 个维度的振动曲线：X、Y、Z、pitch、roll、yaw</li><li>Impulse Source：从场景空间中的一个点发出原始振动信号的组件，并定义信号特征，如持续时间、强度和范围</li><li>ImpulseListener：一种 Cinemachine 扩展，允许虚拟摄像机侦测到脉冲信号，并通过震动对其做出反应</li></ul><p>要在场景中设置和使用 Impulse，请执行以下操作：</p><ul><li>将 Cinemachine Impulse Source 或 Cinemachine Collision Impulse Source 组件添加到一个或多个要触发相机震动的游戏对象</li><li>将原始信号连接到脉冲源，这些可以是 6D 噪声配置文件、3D 固定信号或自定义信号类型</li><li>将 Cinemachine Impulse Listener 扩展添加到一个或多个 Cinemachine 虚拟摄像机，以便它们可以检测脉冲并对其做出反应<ul><li>注：不能直接 AddComponent 添加，而得在虚拟相机的 AddExtension 添加才有效，试了好一会才发现问题</li></ul></li></ul><h2 id="cinemachine-impulse-sources"><a class="anchor" href="#cinemachine-impulse-sources">#</a> Cinemachine Impulse Sources</h2><p>脉冲源是从场景空间中的一个点发出振动信号的组件，游戏事件可以导致脉冲源从事件发生的地方发出信号，事件触发脉冲源，脉冲源产生脉冲，带有 Impulse Listener 扩展的虚拟摄像机通过震动对脉冲做出反应<br />自带两种脉冲源组件：</p><ul><li>Cinemachine Collision Impulse Source：对象碰撞或触发区域触发脉冲生成</li><li>Cinemachine Impulse Source：碰撞以外的事件触发脉冲</li></ul><p>使用示例</p><ul><li>巨人的每只脚上，使巨人走路时地面震动</li><li>在击中目标时爆炸的射弹上</li><li>在 gelatin planet 的表面上，当有东西接触到它时会摇晃</li></ul><p>关键属性（Implus Type 为 Legacy 才有）</p><ul><li>振幅 (<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5jaW5lbWFjaGluZUAyLjgvbWFudWFsL0NpbmVtYWNoaW5lSW1wdWxzZVNvdXJjZU92ZXJ2aWV3Lmh0bWwjQW1wbGl0dWRl">Amplitude</span>)：原始脉冲信号的振幅，控制每次撞击的振动强度</li><li>旋转和方向 (<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5jaW5lbWFjaGluZUAyLjgvbWFudWFsL0NpbmVtYWNoaW5lSW1wdWxzZVNvdXJjZU92ZXJ2aWV3Lmh0bWwjT3JpZW50YXRpb24=">Orientation and direction</span>)：脉冲可以转换信号，使振动与产生振动的冲击方向一致<ul><li>为了产生逼真的振动，最强脉冲信号应该沿着冲击轴，并且其振幅（或强度）应该与冲击力成正比</li><li>在下图中，振动的主轴 (A) 与锤子撞击墙壁 (B) 时的行进方向一致：</li></ul></li><li><img data-src="/blogimages/2023/2023-05-27/3.png" alt="" /><ul><li>注：不需要为每个可能的冲击方向和强度单独定义信号，而是使用 “局部空间” 的概念来定义原始信号</li><li>Impulse 假定冲击的主要方向是 “向下”，因此作为一般规则，信号应该沿 Y 轴施加更多振动（6D 抖动噪音预设就是这样做的），然后可以依靠局部空间旋转和缩放来为每次撞击发生产生正确的振动</li></ul></li><li>时间膜 (<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5jaW5lbWFjaGluZUAyLjgvbWFudWFsL0NpbmVtYWNoaW5lSW1wdWxzZVNvdXJjZU92ZXJ2aWV3Lmh0bWwjVGltZUVudmVsb3Bl">Time envelope</span>)：控制信号的起音、维持和衰减，使信号淡入和淡出到适当的强度并具有有限的持续时间<ul><li>现实世界中的撞击产生的振动会变强，直到达到峰值强度，然后减弱，直到振动停止。这个周期需要多长时间取决于影响的强度以及所涉及的游戏对象的特性</li></ul></li><li>空间范围 (<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5jaW5lbWFjaGluZUAyLjgvbWFudWFsL0NpbmVtYWNoaW5lSW1wdWxzZVNvdXJjZU92ZXJ2aWV3Lmh0bWwjU3BhdGlhbFJhbmdl">Spatial range</span>)：控制信号在完全淡出之前在场景中传播的距离</li></ul><h2 id="fixed-signals"><a class="anchor" href="#fixed-signals">#</a> Fixed Signals</h2><p>CinemachineFixedSignal 可以定义简单的 3D 曲线，使用三个轴的曲线进行信号自定义</p><ul><li>Inspector 显示每个轴的曲线预览，单击预览窗格可为该轴定义自己的曲线，如果留空则不会沿该轴移动</li><li>注：点击齿轮按钮可以选择将当前曲线添加到曲线预设库中</li></ul><h2 id="cinemachine-impulse-listener"><a class="anchor" href="#cinemachine-impulse-listener">#</a> Cinemachine Impulse Listener</h2><p>主要用于使虚拟摄像机侦测到脉冲振动信号并对其做出反应</p><ul><li>在现实世界中，一些相机的安装不如其他相机牢固，因此更容易晃动，可以通过 Impulse Listener 的 Gain 属性放大或衰减脉冲振动信号来模拟</li></ul><p>另外，可通过 CinemachineImpulseChannels 可以对信号源进行过滤</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>果然最好的学习方式还是跟着官方文档走一遍（前提是文档足够全面），现在 unity 的文档感觉也是详细了很多，总体还是挺顺利，多数都有详细解释，搞不清楚跟着操作一遍也能了解个七七八八<br />一边看，一边试验，这样走下来基本各项功能就感觉熟悉了 —— 因此决定继续，下一个就是 Timeline，然后是 DOTS 或 URP</p><h1 id="参考文档"><a class="anchor" href="#参考文档">#</a> 参考文档</h1><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5jaW5lbWFjaGluZUAyLjgvbWFudWFsL0NpbmVtYWNoaW5lVXNpbmcuaHRtbA==">https://docs.unity3d.com/Packages/com.unity.cinemachine@2.8/manual/CinemachineUsing.html</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;主要内容来源于官方 Cinemachine2.8 英文文档：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9kb2NzLnVua</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/categories/Unity3D/"/>
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/tags/Unity3D/"/>
    
    <category term="翻译" scheme="https://wangjiaying.top/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>渲染基础-Unity3D-笔记</title>
    <link href="https://wangjiaying.top/2023/05/12/%E5%9B%BE%E5%BD%A2%E5%9F%BA%E7%A1%80-Unity3D/"/>
    <id>https://wangjiaying.top/2023/05/12/%E5%9B%BE%E5%BD%A2%E5%9F%BA%E7%A1%80-Unity3D/</id>
    <published>2023-05-12T09:36:44.000Z</published>
    <updated>2023-06-11T11:16:20.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>部分来源于网络，并注明来源（已丢失除外），性能优化、批处理则主要整理自 Unity 官方文档<br />注 1：参考文档均在对应位置标注，文章末尾也贴了对应链接<br />注 2：对文章内容，后续可能会还会进行调整</p><h1 id="硬件"><a class="anchor" href="#硬件">#</a> 硬件</h1><h2 id="gpu的渲染架构"><a class="anchor" href="#gpu的渲染架构">#</a> GPU 的渲染架构</h2><h3 id="imrimmediate-mode-rendering主要用于pc平台"><a class="anchor" href="#imrimmediate-mode-rendering主要用于pc平台">#</a> IMR（Immediate Mode Rendering，主要用于 PC 平台）</h3><ul><li>即渲染模式。每个像素渲染的时候直接访问 DRAM，并写入到 FrameBuffer 上。PC 平台的显卡都是 IMR 架构</li></ul><h3 id="tbrtile-based-rendering基于tile渲染主要用于移动平台"><a class="anchor" href="#tbrtile-based-rendering基于tile渲染主要用于移动平台">#</a> TBR（Tile-Based Rendering，基于 Tile 渲染，主要用于移动平台）</h3><p>为了减少 GPU 访问 SystemMemory 的次数（延迟高、功耗高），将屏幕分成一小块儿一小块儿，确保这一小块渲染所需要的绝大部分数据都能同时装进小小的 OnChip memory，从而实现整个渲染大部分操作都可以在带宽较高的 OnChip memory 上完成</p><ul><li>大幅减少对显存带宽的消耗</li></ul><p>TBR 是以牺牲执行效率为代价，换来功耗降低。在移动平台直接访问 FrameBuffer 会有很大的带宽开销，进而影响功耗。所以 TBR 把屏幕分成格子之后，每个格子可以访问 SRAM（OnChip memory），一整块都访问好之后，再整理转移回 DRAM</p><ul><li>大部分手机的 GPU 用的都是手机的 System memory 和一块容量很小的，带宽比 System memory 更高的专供 OnChip memory<ul><li>SRAM，GPU 的 OnChip memory</li><li>DRAM，显存，离 GPU 较远，容量大访问速度慢</li></ul></li><li>从 GPU 直接对 FrameBuffer 的访问，就相当于一辆货车大量的在家（GPU）和市中心超市（DRAM）之间往返运输。带宽的消耗和发热量之大，是手机上无法接受的<ul><li>对移动平台而言，功耗是第一位。因为功耗意味着发热量、耗电量、芯片大小等等。</li><li>对功耗影响最大的是带宽。所以对移动芯片而言，第一考虑的不是渲染性能，而是如何通过缓存减少带宽消耗。即，减少对显存的访问</li></ul></li><li>实际上直接对 DRAM 进行读写速度是最快的。TBR 需要一块儿块儿的绘制然后往 DRAM 拷贝。可以简单理解为 TBR 是牺牲了执行效率，来解决更重要也更难处理的带宽功耗</li></ul><h4 id="其它"><a class="anchor" href="#其它">#</a> 其它</h4><ul><li>DeferredRenderingPath：对 Tile-Based GPUs (移动平台) 启用了 NativeRenderPass 选项的有优化，没启用要避免。原理是 合并 GBuffer 和光照通道存储至 Title Memery 中以优化延迟渲染，NativeRenderPass 在 Tile-Based GPUs 应该启用<ul><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NzQ1NDAzMjk=">URP 延迟渲染 + Native Renderpass 踩坑记录</span></li></ul><blockquote><p>利用移动端 TB (D) R 的硬件架构，相比于传统延迟管线在 basepass 结束后将 gbuffer store 回 system memory, 之后再在 lightpass 中 load 回来这种带宽压力极大的方案，Native Renderpass 可以在每个 tile 的 basepass 结束后将 gbuffer 保存在 On-Chip Memory 上，以供接下来的 lightpass 直接使用，直接优化掉了两个 pass 之间的 store/load 操作，极大减缓了带宽压力，这种形式的 rt 也被称之为 memoryless</p></blockquote></li></ul><h3 id="tbdrtile-based-deferred-rendering-针对tbr做了进一步优化主要是powervr在用"><a class="anchor" href="#tbdrtile-based-deferred-rendering-针对tbr做了进一步优化主要是powervr在用">#</a> TBDR（Tile-Based Deferred Rendering 针对 TBR 做了进一步优化，主要是 PowerVR 在用）</h3><p>基于 Tile 的延迟渲染。只对玩家能看到的像素做 pixel shader。通过 HSR 将不可见的点剔除掉。大幅减少对显存带宽的消耗</p><ul><li>IOS 一般都是 TBDR</li><li>HSR (隐藏面消除) Hidden Surface Removal，TBDR 新增的一个阶段，在光栅化阶段真正开始前实现像素级裁剪。</li></ul><p>TBDR，相对于 IMR，多了一个 FrameData 的数据，里面包含了有效信息，可以进行剔除操作</p><h3 id="mrtmulti-render-targets"><a class="anchor" href="#mrtmulti-render-targets">#</a> MRT(Multi Render Targets)</h3><p>OpenGL ES 多目标渲染，OpenGL ES 3.0 新特性，它允许应用程序一次渲染到多个缓冲区。</p><h2 id="early-z"><a class="anchor" href="#early-z">#</a> Early-Z</h2><p>在执行像素着色器之前，先进行一轮深度测试，避免会被深度测试剔除的片元，执行复杂的像素着色器的逻辑。这样可以减少显存带宽的消耗</p><ul><li>如果没有 Early-Z，那么很有可能屏幕上一个像素点会被渲染七八次，显存带宽消耗成倍的增加</li><li>discard 或 clip 会导致 Early-Z Culling 无效</li></ul><h2 id="渲染顺序"><a class="anchor" href="#渲染顺序">#</a> 渲染顺序</h2><ul><li>不透明物体，离摄像机近的先绘制，这样它会因为 ZTest 剔除掉后面的渲染内容，性能更好</li><li>半透明物体，必须从后往前画，先画离摄像机远的物体，才能保证渲染结果正确</li><li>Shader 非常复杂的模型，尽量后绘制。更加容易被 Z-Culling 剔除掉</li><li>不透明物体 (2000)----AlphaTest 物体 (2450)---- 半透明物体 (3000)，这个渲染顺序有利于 HSR 或者 Early-Z 的优化<ul><li>Alpha-Test 在不透明物体绘制完毕之后再绘制，可以避免 Alpha-Test 导致 EarlyZ 失效，最后绘制，至少不会影响到之前不透明物体的 EarlyZ</li><li>RenderQueue2500，区分了不透明和半透明。半透明物体（2500 以上）永远在不透明物体（2500 以下）后绘制<ul><li>如果物体的 RenderQueue 在 2500 的同一侧，则 sortingOrder 优先级更高：</li><li>Camera Depth &gt; Sorting Layer &gt; Order In Layer &gt; RenderQueue &gt; 距离相机的距离</li></ul></li></ul></li></ul><h1 id="性能状态"><a class="anchor" href="#性能状态">#</a> 性能状态</h1><h2 id="drawcall"><a class="anchor" href="#drawcall">#</a> DrawCall</h2><p>通常情况下，DrawCall 的准备工作比 DrawCall 本身更耗费资源</p><ul><li>准备 DrawCall：CPU 设置资源并更改 GPU 上的内部设置，即渲染状态<ul><li>对渲染状态的更改（例如切换到不同的材质）是图形 API 执行的资源密集型操作</li><li>由于渲染状态更改是资源密集型的，因此对其进行优化非常重要。优化渲染状态更改的主要方法是减少它们的数量</li></ul></li><li>优化：<ul><li>减少 DrawCall 调用数量，这同样会减少改变渲染状态的次数</li><li>合批：如果可以使用相同的渲染状态来执行多个 DrawCall，那么就可以将 DrawCall 组合在一起，而不需要执行太多的渲染状态更改</li></ul></li><li>Unity 提供优化：<ul><li>GPU instancing</li><li>Static batching、Dynamic batching</li><li>SRP Batcher</li><li>手动合批</li></ul></li></ul><p>注：对于移动设备，Drawcall 不只影响 CPU，还会影响到 GPU</p><ul><li>在 PC 上 Drawcall 和顶点数量对 GPU 没有太多严重影响。但是对于 TBDR，DrawCall 过多意味着 FrameData 数据过多，严重情况下可能会出现内存放不下的情况，这种情况下对 FrameData 的访问速度奇慢<br /><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9vcHRpbWl6aW5nLWRyYXctY2FsbHMuaHRtbA=="> Unity - Manual: Optimizing draw calls</span></li></ul><h2 id="setpasscall"><a class="anchor" href="#setpasscall">#</a> SetPassCall</h2><p>渲染 Pass 的数量：一帧中切换 Shader Pass 的次数，一个 Shader 可能包含多个用于渲染的 Pass，每个 Pass 都需要 Unity 绑定一个新的着色器，必然会带来 CPU 开销</p><ul><li>内置渲染管线：是所有材质球的渲染 Pass 的数量</li><li>URP：渲染不同 Pass 的数量，与内置管线以材质球为准不一样，以 Shader 和关键字都一样为准，其中渲染的 Pass 通道</li><li>注：经测试，两个同一个 Sahder 材质，内置渲染管线启用禁用时，Batches 和 SetPassCall 均发生变化，而 URP 仅 Batches 发生变化<br /><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9SZW5kZXJpbmdTdGF0aXN0aWNzLmh0bWw="> Unity - Manual: The Rendering Statistics window</span></li></ul><h2 id="降低-cpu-渲染成本"><a class="anchor" href="#降低-cpu-渲染成本">#</a> 降低 CPU 渲染成本</h2><ul><li>通常，CPU 渲染时间的最大消耗是向 GPU 发送渲染命令的成本</li><li>渲染命令包括 DrawCall (绘制几何图形的命令)、以及在绘制几何图形之前更改 GPU 设置的命令</li><li>可考虑优化方式<ul><li>减少渲染的对象数量<ul><li>远景使用天空盒模拟</li><li>剔除</li><li>缩小相机的远裁剪平面</li><li>Camera.layerCullDistances</li></ul></li><li>减少渲染每个对象的次数<ul><li>使用光照贴图</li><li>前向渲染中，减少实时光 (影响物体) 数量</li><li>注意实时阴影的使用，非常耗性能</li></ul></li><li>合批<ul><li>减少准备和发送渲染命令所需的工作量</li></ul></li></ul></li><li>上面的优化方式，部分既可减轻 CPU 负担，也可以同时降低 GPU 消耗 (如减少渲染对象数量)</li></ul><h2 id="降低-gpu-渲染消耗"><a class="anchor" href="#降低-gpu-渲染消耗">#</a> 降低 GPU 渲染消耗</h2><ul><li>像素填充率问题<ul><li>降低片段着色器的复杂度</li><li>减少 overdraw ：UI、粒子和 Sprite</li><li>动态分辨率 (DynamicResolution)</li></ul></li><li>内存带宽问题：一般由于纹理过多或分辨率过大<ul><li>启用 3D 空间对象纹理的 Mipmap，会增加内存使用量和存储空间，但可以提高运行时 GPU 的性能</li><li>选择合适的压缩格式减小内存中纹理大小</li></ul></li><li>顶点处理问题<ul><li>降低顶点着色器的复杂度</li><li>优化网格</li><li>LOD，会增加内存使用，但可以提高 GPU 效率</li></ul></li><li>降低帧率，可以考虑比如打开静态 UI 后，降低帧率，即按需渲染<ul><li>OnDemandRendering：独立于所有其他子系统（如物理、输入或动画）来控制和查询有关应用程序渲染速度（注：独立于 Application.targetFrameRate）<br /><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9PcHRpbWl6aW5nR3JhcGhpY3NQZXJmb3JtYW5jZS5odG1s">Unity - Manual: Graphics performance fundamentals</span></li></ul></li></ul><h1 id="批处理"><a class="anchor" href="#批处理">#</a> 批处理</h1><p>Unity 批处理顺序：</p><ul><li>SRP Batcher and static batching<ul><li>注：Unity 还支持与 SRP Batch 兼容的 GameObjects 的静态批处理</li></ul></li><li>GPU instancing</li><li>Dynamic batching</li></ul><h2 id="静态批处理static-batching"><a class="anchor" href="#静态批处理static-batching">#</a> 静态批处理 (Static batching)</h2><ul><li>两种方式，一种是编辑器标记 Static Batching，一种是运行时代码调用 StaticBatchingUtility 接口合并<ul><li>编辑器标记的方式会在打包时统一合并，增加磁盘空间</li><li>代码合并则消耗运行时 CPU，且必须启用 Mesh 的 read/write</li></ul></li><li>增加磁盘空间、内存消耗、运行时无法移动<ul><li>将组合的 Mesh 转换到世界空间，并为它们构建一个共享顶点和索引缓冲区，使得一个 DrawCall 可以将合批对象都绘制出来</li><li>每个游戏对象都会创建一个 Mesh 副本，并将每个副本插入组合的 Mesh 中，意味着就算同一实例也会导致额外内存</li></ul></li><li>好处如同名字一样，按照官方说法，可以显著降低 DrawCall 开销，对于可见的 Mesh 执行更轻量级的 DrawCall</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9zdGF0aWMtYmF0Y2hpbmcuaHRtbA==">Unity - Manual: Static batching</span></li><li>注：需要先启用 PlayerSetting StaticBatching 选项</li><li>具有相同材质的对象才能进行批处理、对象不能为负缩放</li></ul><h2 id="动态批处理dynamic-batching"><a class="anchor" href="#动态批处理dynamic-batching">#</a> 动态批处理 (Dynamic batching)</h2><p>运行时每帧在 CPU 上动态合并网格，只有当合并消耗小于 DrawCall 消耗时才是一种优化，在现代图形 API，例如 IOS (Apple Metal) 上，基本上是消耗大于收益</p><ul><li>注：在现代消费类硬件上，动态批处理在 CPU 上所做的工作可能大于 DrawCall 本身的开销。这会对性能产生负面影响（言外之意就是不要用了，HDRP 已经移除支持）</li><li>注：需要先启用 PlayerSetting DynamicBatching 选项</li></ul><p>限制</p><ul><li>具有相同材质的对象才能进行批处理 (除 shadow caster rendering 外)</li><li>对象不能为负缩放</li><li>使用顶点属性低于 900 个，例如 Shader 同时使用 顶点位置、顶点法线、UV0、UV1 和顶点切线，则 Unity 只能批处理 180 个顶点 (900/5=180)</li><li>如果有光照贴图，必须指向同一个地方 (可忽略)</li><li>多 Pass 支持也有问题，例如只有第一个 Pass 生效，后续额外的像素光是无效的</li></ul><h2 id="手动合批"><a class="anchor" href="#手动合批">#</a> 手动合批</h2><ul><li>使用 API Mesh.CombineMeshes</li><li>注：手动合批的网格无法单独剔除</li></ul><h2 id="gpu-instancing"><a class="anchor" href="#gpu-instancing">#</a> GPU instancing</h2><ul><li>两种方式，一种是直接由 Unity 引擎自动处理，一种是使用代码一次性绘制<ul><li>支持 MaterialPropertyBlock 修改 Shader 中定义的 Instancing 属性</li></ul></li><li>材质自带的与 SRPBatcher 不兼容，优先 SRPBatcher<ul><li>如果开启了 SRP Batcher ，需要移除 Shader 中对 SRP Batcher 的兼容性<ul><li>只要 UnityPerMaterial 常量缓冲区中不存在材质属性，就会使着色器与 SRP Batcher 不兼容</li><li>使用 MaterialPropertyBlock 也会使 SRP Batcher 不兼容</li></ul></li></ul></li><li>注：使用完全相同的材质渲染大量相同的网格，GPU 实例化可能比 SRP Batcher 更高效</li></ul><h3 id="api"><a class="anchor" href="#api">#</a> API</h3><ul><li>Graphics.RenderMeshInstanced：可以使用实例化着色器多次渲染同一网格<ul><li>注 1：RenderParams.worldBounds 可以自定义边界</li><li>注 2：该接口一次最多只能渲染 1023 个实例</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL1NjcmlwdFJlZmVyZW5jZS9HcmFwaGljcy5SZW5kZXJNZXNoSW5zdGFuY2VkLmh0bWw=">Unity - Scripting API: Graphics.RenderMeshInstanced</span></li></ul></li><li>Graphics.RenderMeshIndirect：使用 commandBuffer 命令进行实例化渲染 (对实例数量没有限制)<ul><li>注 1：RenderParams.worldBounds 可以自定义边界</li><li>注 2：要求支持  compute shaders，着色器中有额外取值方式需求</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL1NjcmlwdFJlZmVyZW5jZS9HcmFwaGljcy5SZW5kZXJNZXNoSW5kaXJlY3QuaHRtbA==">Unity - Scripting API: Graphics.RenderMeshIndirect</span></li></ul></li><li>注：其它还有 DrawMeshInstanced、DrawMeshInstancedIndirect (可以直接做剔除) 等 API 效果同上，不过据说 RenderMeshInstanced 接口更新，例如接受 NativeArray</li><li>注：可通过 SystemInfo.supportsInstancing 判断平台是否支持</li><li>缺点：Unity 会自动计算此网格的所有实例的边界，并会将该网格的所有实例作为单个实体进行剔除和排序 (所以优先级才在 SRPBatcher 之下吧)</li></ul><h3 id="兼容性"><a class="anchor" href="#兼容性">#</a> 兼容性</h3><ul><li>OpenGL ES 3.0+(3.1 均没问题)</li><li>IOS 的 Metal 均支持 (Metal 从 iPhone 5s 开始支持)</li><li>具有相同材质、同一个 Mesh 的对象才能进行批处理</li></ul><h2 id="srp-batcher"><a class="anchor" href="#srp-batcher">#</a> SRP Batcher</h2><ul><li>支持 mesh 或 skinned mesh（非粒子）</li><li>不支持 MaterialPropertyBlock，使用 MaterialPropertyBlock 会导致 SRP Batcher 兼容失败</li><li>允许不同材质，同一个 Shader，同样的变体即可</li><li>支持代码启用禁用：GraphicsSettings.useScriptableRenderPipelineBatching = true</li></ul><h3 id="工作原理"><a class="anchor" href="#工作原理">#</a> 工作原理</h3><p>一般优化 DrawCall 的方式是减少调用数量，而 SRP Batcher 则主要减少了绘制调用之间的渲染状态更改<br /><img data-src="/blogimages/2023/2023-05-12/1.png" alt="" /><br /> SRP Batcher 通过一系列组合将 bind 和 draw 命令合并，每个命令序列称为 SRP Batch<br /> 为优化性能，一个 SRP Batch 应包含尽可能多的 bind and draw 命令 (少用 Shader 变体)<br /> 当检测到新的材质时，CPU 会绑定相关属性到 GPU 常量缓冲区 (constant buffers)，使材质属性持久保存在显存中，若材质没有发生更改，SRP Batcher 就不会更改渲染状态</p><ul><li>所有材质均持久存在于 GPU 的显存 (常量缓冲区) 中</li><li>随后 CPU 再使用专门方式在 GPU 大型常量缓冲区进行每个物体的属性更新或管理<br /><img data-src="/blogimages/2023/2023-05-12/2.png" alt="" /></li><li>当 Shader 发生变化时，只需要<ul><li>重新绑定 Material CBUFFER (材质属性)</li><li>重新绑定 large CBUFFER (物体属性)</li><li>然后就可以执行新的渲染 (DrawCall)<br /><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9TUlBCYXRjaGVyLmh0bWw=">Unity - Manual: Scriptable Render Pipeline Batcher</span></li></ul></li></ul><h2 id="batchrenderergroupbrg"><a class="anchor" href="#batchrenderergroupbrg">#</a> BatchRendererGroup(BRG)</h2><p>物体不会参与到 Unity 场景 Render 的剔除，他真正的是管理每一个物体的剔除，也就是说如果有 1000 个小物体他们会分别计算剔除。最重要的是，RenderBatchGroup 给你的是一组相机参数，这意味着我们能在这里能对于每个 View 分别做 LOD 相关的东西</p><ul><li>比 GPU Instancing 更高效，并且可以在 CPU 上使用多线程、可以自定义剔除等</li><li>建立在 SRP Batcher 之上</li><li>要求<ul><li>需要禁用变体剔除选项，避免 Shader 中 DOTS Instancing 变体被剔除</li><li>需要启用不安全代码 (Allow unsafe code)</li></ul></li><li>兼容性：OpenGL, GLES and WebGL 暂不支持</li><li><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS51bml0eS5jb20vdGhyZWFkcy9uZXctYmF0Y2hyZW5kZXJlcmdyb3VwLWFwaS1mb3ItMjAyMi0xLjEyMzA2Njkv">https://forum.unity.com/threads/new-batchrenderergroup-api-for-2022-1.1230669/</span></li></ul><h3 id="使用步骤"><a class="anchor" href="#使用步骤">#</a> 使用步骤</h3><ul><li>创建 BatchRendererGroup 实例</li><li>new BatchRendererGroup(this.OnPerformCulling, IntPtr.Zero);</li><li>注册 Mesh 和材质<ul><li>可以重复注册，内部使用引用计数维护注册数量，注册一次递增 1，注销一次减 1，引用计数达到 0 内部才会才真的注销</li><li>已注册 Mesh 或 Material 的 RegisterMesh 或 RegisterMaterial 调用返回与上一次调用相同的 BatchMeshID 或 BatchMaterialID（若彻底注销后，重复注册返回不同 id）<br /><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjIuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9iYXRjaC1yZW5kZXJlci1ncm91cC1jcmVhdGluZy1hLXJlbmRlcmVyLmh0bWw=">Unity - Manual: Creating a renderer with BatchRendererGroup</span></li></ul></li></ul><h2 id="dots-instancing"><a class="anchor" href="#dots-instancing">#</a> DOTS Instancing</h2><p>DOTS 实例化比传统实例化更具有优势</p><ul><li>实例数据存储在 GraphicsBuffer 中，并在 GPU 上保持持久性<ul><li>这意味着 Unity 不需要在每次渲染实例时再次设置它，仅在实例实际更改时设置数据</li><li>注：传统的实例化需要一个引擎在每帧为每个实例设置所有数据</li></ul></li><li>设置实例数据的过程与设置 DrawCall 调用是分开的<ul><li>DrawCall 消耗更低</li><li>BRG 通过 SRP Batcher 一个特殊的快速通道使得每个 DrawCall 只做最少工作</li><li>可以更好地控制在每次绘制调用中渲染什么</li></ul></li><li>绘制调用的大小不再受常量或统一缓冲区中可以容纳多少实例数据的限制<ul><li>BRG 可以通过一个 DrawCall 来渲染更多的实例数量</li><li>注：实例索引的数量仍然限制了绘制调用的大小，因为每个索引仍然需要一些数据。然而，一个索引消耗的内存远远少于一组完整的实例化属性，这意味着更多的实例可以放在一个常量或统一的缓冲区中。例如，每个索引需要 16 个 byte，因此如果特定平台上缓冲区的内存限制为 64kb，则缓冲区中可以容纳 4096 个索引</li></ul></li><li>如果每个实例对给定的属性使用相同的值，则可以让所有实例从内存中的同一位置加载该值。这样可以节省内存和复制每个实例的值所花费的 GPU 周期数</li></ul><p>要求</p><ul><li>#pragma target 4.5 或更高<ul><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTkuNC9NYW51YWwvU0wtU2hhZGVyQ29tcGlsZVRhcmdldHMuaHRtbA==">着色器编译目标级别 - Unity 手册</span></li></ul></li><li>#pragma multi_compile _DOTS_INSTANCING_ON</li><li>声明 DOTS Instanced 属性块</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjIuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9kb3RzLWluc3RhbmNpbmctc2hhZGVycy5odG1s">Unity - Manual: DOTS Instancing shaders</span></li></ul><h1 id="光照"><a class="anchor" href="#光照">#</a> 光照</h1><h2 id="阴影"><a class="anchor" href="#阴影">#</a> 阴影</h2><p>阴影贴图本质上是从光源视角投射的纹理<br />注 1：URP 中，额外光源若选顶点光照则不能设置阴影<br />注 2：内置渲染管线未找到直接设置顶点光</p><h3 id="cascaded-shadow-mapscsm"><a class="anchor" href="#cascaded-shadow-mapscsm">#</a> Cascaded Shadow Maps(CSM)</h3><p>使用多张阴影贴图实现阴影的一种技术</p><ul><li>阴影贴图的缺点：空间中对象在阴影图比例太小，采样精度不够，产生锯齿 (增加阴影图分辨率可以改善，但治标不治本，同时也会增加内存消耗)<ul><li>而且一张阴影图会导致近处物体采样精度不够，远处物体采样精度浪费</li></ul></li><li>问题是阴影贴图分辨率低，级联阴影的关键就是生成和使用不同精细度的阴影贴图</li></ul><p>基础的阴影贴图方法对于大型场景渲染显得力不从心，由于阴影贴图分辨率问题，很容易出现阴影抖动和锯齿边缘现象<br /> Cascaded Shadow Maps (CSM) 方法根据对象到观察者的距离提供不同分辨率的深度纹理来解决上述问题</p><ul><li>在一张阴影贴图中捕捉所有对象需要阴影贴图具有非常高的分辨率</li><li>使用多张阴影贴图就可以解决这个问题，对于近处的场景使用较高分辨率的阴影贴图，对于远处的场景使用粗糙的阴影贴图，在两张阴影贴图过渡的地方选择其中一张使用</li></ul><p>注：实时阴影，仅适用于平行光 (大场景最好至少 2 个，默认是 1 个 - 即仅一张)<br /> 注：因为需要多张阴影，因此会增加 DrawCall<br /><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MzY4OTk4Nw==">Cascaded Shadow Maps (CSM) 实时阴影的原理与实现</span><br /><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMDU0NDIvYXJ0aWNsZS9kZXRhaWxzLzExNzQyNzM5NQ=="> Unity 实时阴影实现 ——Cascaded Shadow Mapping_unity 阴影</span></p><h3 id="bias"><a class="anchor" href="#bias">#</a> Bias</h3><p>阴影偏移，解决自遮挡阴影瑕疵 (Shadow acne) 而提出<br />因为 DepthMap 分辨率的关系，每个 Depth 像素对应地面上的一小块区域，而不是一个点</p><ul><li>这块区域中，如果都按照这个 Depth 值进行计算的话，就有的地方比 Depth 值大，有的地方比 Depth 值小，所以就会重现交错</li><li>（因此除 Bias 外也可以通过提升 DepthMap 的分辨率解决，但是...）<ul><li>当光源离得特别远的时候，你从光源角度看，整个场景可能都挤在几个像素里，特别的小，所以没办法只通过调整深度图的分辨率来控制 (MipMap？Cascade？)</li></ul></li></ul><p>因此在和 ShadowMap 中离散化的深度比较时，将这个深度加大一点点，这样只有当 ShadowMap 中的深度显著大于计算出来的深度时，才判断为产生阴影<br />注：若 Bias 值太大也会有副作用，例如会导致对象的底部与阴影有一定的距离，造成 &quot;浮空&quot; 的错觉<br /><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQ5MDkwMzIx">关于 Shadow Mapping 产生的 Shadow Acne，我的理解是不是有问题？ - 知乎</span></p><h1 id="渲染方式"><a class="anchor" href="#渲染方式">#</a> 渲染方式</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTc0NzUwMjg=">浅谈延迟渲染、移动 GPU 架构和 Metal</span></p><ul><li>前向渲染是一种非常直接的渲染方式，我们提交的 mesh，经过 vs、gs、fs 等 shader，直接绘制到 color buffer 等待输出到屏幕，很线性的 Per-Object/Per-Light 方式进行绘制。—— 光照对性能影响很大<ul><li>前向渲染渲染 n 个物体在 m 个光源下的着色，复杂度为 O (n*m) 次。</li></ul></li><li>延迟渲染 (Deferred Rendering)，即延迟着色（Deferred Shading），顾名思义，是将着色计算延后进行处理的一种渲染方法，可以将延迟渲染 ( Deferred Rendering) 理解为先将所有物体都先绘制到屏幕空间的缓冲（即 G-buffer，Geometric Buffer，几何缓冲区）中，再逐光源对该缓冲进行着色的过程，从而避免了因计算被深度测试丢弃的片元着色而产⽣的不必要的开销<ul><li>对应于前向渲染 O (m*n) 的复杂度，经典的延迟渲染复杂度为 O (n+m)</li><li>延迟管线下多了深度、法线、颜色等几张 G-Buffer。这些都是屏幕大小的尺寸的 Render Target，所带来的内存以及带宽压力很大</li><li>延迟渲染有以下特点：<ul><li>内存开销较大</li><li>读写 G-buffer 的内存带宽用量是性能瓶颈。</li><li>对透明物体的渲染存在问题。在这点上需要结合前向渲染进行渲染。</li><li>对多重采样抗锯齿（MultiSampling Anti-Aliasing, MSAA）的支持不友好，主要因为需开启 MRT。</li><li>由于 Deferred Shading 的 Deferred 阶段是在完全基于 G-Buffer 的屏幕空间进行，这也导致了物体材质信息的缺失，这样在处理多变的渲染风格时就需要额外的操作。</li></ul></li><li>针对上文的问题，业界有主流有两种优化方式：<ul><li>Light Pre-Pass 即 Deferred Lighting 延迟光照技术，通过减少经典延迟渲染所使用的 G-Buffer 数量来提高性能</li><li>分块延迟渲染，tile-based Deferred Rendering。该方法通过可以在一次绘制处理多个光源，以及来降低对 G-Buffer 的读写开销</li></ul></li></ul></li><li>影响功耗的最大因素是什么？带宽。</li></ul><h2 id="前向渲染forwardpass"><a class="anchor" href="#前向渲染forwardpass">#</a> 前向渲染 (ForwardPass)</h2><h3 id="渲染方式-2"><a class="anchor" href="#渲染方式-2">#</a> 渲染方式</h3><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTc0NzUwMjg=">浅谈延迟渲染、移动 GPU 架构和 Metal</span></p><ul><li>先渲染 ShadowMap</li><li>然后从近至远渲染不透明物体</li><li>最后从远至近渲染透明物体</li><li>因为有深度测试，因此先渲染近处物体可以提前剔除不可见像素，透明物体则相反，需要混合叠加，因此由远及近</li><li>unity 规定，2500 以下对象由近及远，以上由远及近</li><li>earlyz：几何阶段与片元着色器阶段之间（光栅化之后，片元着色器之前），不过最终还是会走一次正常的后置深度测试</li><li>若检测到在片元着色器存在抛弃片元和改写深度的操作，则 earlyz 优化将被弃用</li><li>例如使用了 alphatest 渲染物体（因为片元是在片元着色器丢弃的，丢弃后，它之后的片元就得显示，若进行了 earlyz 就会出问题）</li></ul><h3 id="前向实时剔除"><a class="anchor" href="#前向实时剔除">#</a> 前向实时剔除</h3><ul><li>前向渲染是逐对象渲染，若一个物体挡住了另一个物体，执行的渲染就无效了，为了解决这些问题，也提出了一些解决方法：如 Early-z 、Z-Prepass 、 Hi-Z</li><li>Early-z：在光栅化阶段，每个模型的深度就已经写入深度缓存了，先进行深度剔除再计算光照</li><li>Z-Prepass：首先把整个场景中的模型都渲染一遍，全部都写入 Z-Buffer ，这次渲染除了 Z-Buffer 其他的信息都不计算。然后再渲染一遍场景，这次渲染关闭深度写入，每个像素和 Z-Buffer 中已经存在的深度信息进行对比，只有通过测试的像素才会计算光照。这种方法虽然避免了无效的光照计算，但是却执行了两次顶点着色器，所以最好是在场景中物体的光照计算非常复杂但是顶点数量却不是很多的情况下使用。</li><li>Hi-Z ：上面两种方法都是在 GPU 段进行的，而 Hi-Z 这种方法是在 CPU 端进行的，在几何体被提交到 GPU 之前会进行遮挡测试，如果几何体被别的物体遮挡了就不会提交到 GPU</li></ul><h3 id="光照-2"><a class="anchor" href="#光照-2">#</a> 光照</h3><ul><li>多一个光源就会多一个 DrawCall，是因为重要光源的原因，在 ForwardPass 渲染路径中，默认最多支持 4 个 逐像素的重要光源 (可设置)，光源默认 Auto ，将光源设置为 Net Important 即可减少该消耗。(不重要的顶点光源同样是限制 4 个，Shader 中 unity_LightColor [4]--&gt; 仅 BasePass)</li><li>BasePass（LightMode=ForwardBase）：最重要逐像素平行光源 (_LightColor0)+ 不重要光源 (unity_LightColor [4])+LightMap + 环境光</li><li>AdditionalPass（LightMode=ForwardAdd）：其它逐像素重要光源 (_LightColor0) 在额外 Pass 渲染，与前者叠加，多一个就会导致多一份 DrawCall</li></ul><h3 id="阴影forward"><a class="anchor" href="#阴影forward">#</a> 阴影 (Forward)</h3><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVGZsNk1VUHRPVk5EQzJDeTNhWGpIQQ==">游戏中的动态阴影</span></p><ul><li>分为两部分，自己接收阴影以及投射阴影，MeshRender 上也可以单独设置</li><li>是否有阴影跟三个条件有关：(1) Shader 中的 接收投射阴影 Pass；(2) Render 上的接收投射开关；(3) 光源是否设置阴影</li><li>Shader 中阴影投射 Pass 必须：<ul><li>打 Tags {&quot;LightMode&quot;:&quot;ShadowCaster&quot;}，标记该 Pass 专用于阴影投射</li><li>增加预编译指令 #pragma multi_compile_shadowcaster</li><li>在顶点、片段中调用 Unity 提供的预定义进行处理：V2F_SHADOW_CASTER、TRANSFER_SHADOW_CASTER_NORMALOFFSET、SHADOW_CASTER_FRAGMENT<ul><li>V2F_SHADOW_CASTER：顶点到片段数据变量</li><li>TRANSFER_SHADOW_CASTER_NORMALOFFSET：在顶点 Shader 函数中计算了 物体顶点世界坐标 - 光源坐标，即当前顶点到光源向量，然后再转 clip 裁剪空间</li><li>SHADOW_CASTER_FRAGMENT：在片段 Shader 函数中将顶点到光源向量转长度，计算深度（光源设置的 shadowbias 就在这里用的：长度 + unity_Light_ShadowBias.x）</li></ul></li><li>Shader 中阴影接收 Pass 必须：<ul><li>打 Tags {&quot;LightMode&quot;:&quot;ForwardBase&quot;}，标记该 Pass 为向前渲染</li><li>增加预编译指令 #pragma multi_compile_fwdbase</li><li>在顶点、片段中调用 Unity 提供的预定义进行处理：SHADOWCOORDS (1)、<ul><li>SHADOWCOORDS (ID)：ID 是个数值，表示使用的 TEXCOORD+ID，保存顶点函数通过 ComputeScreenPos (o.pos) 计算的 showCoord</li><li>TRANFER_SHADOW (o)：通过顶点 clip 裁剪空间坐标计算屏幕空间阴影采样坐标 ComputeScrrenPos (o.pos)</li><li>SHADOW_ATTENUATION (i)：根据 showCoord 采样阴影颜色，返回叠加的阴影强度值。</li></ul></li></ul></li></ul></li><li>Forward：<ul><li>在光源位置渲染一张深度图，然后找物体 Shader 中的特殊的 阴影投射 Pass</li><li>在正常渲染时，判断当前深度是否大于阴影深度，叠加阴影颜色</li></ul></li><li>仅在使用像素光照的情况下才渲染法线贴图、光照剪影和实时阴影。此外，在像素模式下渲染时，聚光灯形状和点光源高光看起来要好得多。</li><li>CSM (Cascaded Shadows Map)：级联阴影，将摄像机前面空间分成多个层级，分别 (以不同分辨率) 绘制各个层级物体阴影深度，合成一张连续的 CSM 贴图</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTguNC9NYW51YWwvTGlnaHRQZXJmb3JtYW5jZS5odG1s">https://docs.unity.cn/cn/2018.4/Manual/LightPerformance.html</span></li></ul><h2 id="延迟渲染deferred"><a class="anchor" href="#延迟渲染deferred">#</a> 延迟渲染 (Deferred)</h2><ul><li>延迟渲染就是把光照计算延迟到深度测试之后的渲染方式，只渲染可见的像素，不会有无效的计算。</li><li>延迟渲染的思路就是先把几何体的信息都渲染到二维空间中（G-Buffer），然后把 G-Buffer 整体进行光照计算，G-Buffer 中存在的信息都是会最终呈现在屏幕上的，不会有无效计算。<ul><li>Z-prepass 也是先渲染出深度缓存进行深度测试后再计算光照的，和延迟渲染有什么不同？最大的不同点就在于 G-buffer ，Z-prepass 在深度测试后也还是按照一个几何体渲染完再进行下一个这种方式来渲染的 ，延迟渲染是几何体的信息传递到 G -buffer 之后就和几何体没多大关系了，接下来的操作都是对 G-buffer 进行的。</li></ul></li><li>G-Buffer：不同的引擎处理可能不一样，例如 PBR 会有深度、颜色、法线、世界空间坐标、模板、金属、粗糙、高光这些信息</li><li>缺点：<ul><li>前向渲染只需要深度缓冲和最终的颜色缓冲就够了，延迟渲染需要缓存的信息实在太多了，这造成了带宽的开销大幅增加。</li><li>对于半透明无能为力，所有半透明的物体都需要等待不透明物体以延迟渲染完成之后，在用前向渲染的方式渲染半透明物体。</li><li>无法记录通过半透明对象可见的对象和当前对象本身的深度和法线</li></ul></li><li><strong>分块延迟渲染</strong>：<ul><li>虽然延迟渲染已经把光照数量和三角形数量不再关联了，但是当场景中的光源数量不断上升之后，就算是延迟渲染也有点撑不住。</li><li>这时就需要分块延迟渲染，它的思路是把 G-Buffer 分成很多个小块，分析每个小块受到哪些光源的影响，然后逐个分块进行着色，那些受光源影响的数量少的小块就不需要那么多的光照计算了。这种渲染方式在光源数量少的情况下效果不明显，但是光源数量越多它优化的性能也就越多。</li></ul></li></ul><h3 id="前向与延迟渲染路径比较"><a class="anchor" href="#前向与延迟渲染路径比较">#</a> 前向与延迟渲染路径比较</h3><ul><li>后处理方式不同。需要深度信息进行后处理时：前向渲染需要单独渲染一张深度图；延迟渲染直接从 G-buffer 中的深度图进行计算。</li><li>着色计算不同（shader）。延迟渲染光照计算统一在 Lighting Pass 里计算，只能用一个光照模型，需要其它光照模型只能切换 Pass。</li><li>抗锯齿方式不同</li></ul><h2 id="forward-渲染"><a class="anchor" href="#forward-渲染">#</a> Forward+ 渲染</h2><p>思路是将屏幕划分为一个一个的块儿，控制每个块儿的影响灯光数量，从而减轻运算压力，让前向渲染也可以处理多光源的情况。</p><h1 id="后期处理"><a class="anchor" href="#后期处理">#</a> 后期处理</h1><h2 id="抗锯齿"><a class="anchor" href="#抗锯齿">#</a> 抗锯齿</h2><ul><li>MSAA (Multi Sample AA)：基于多边形抗锯齿，增加像素采样数 (增加额外显存及带宽开销)，只能用于 Forward，有 2X、4X<ul><li>对空间进行 4 倍采样，进行着色时，考虑 4 个子像素对同一个几何体的覆盖率；若三角形对这 4 个采样点的覆盖率是 100%，则仅进行一次着色，否则都需要着色，并根据每个三角形占据的采样比例计算该点平均值</li><li>现代的几何体密度较高，性能消耗也会比较高</li></ul></li><li>FXAA (Fast Approximately AA)：后处理抗锯齿，图形边缘进行柔化，速度很快但会糊。</li><li>SMAA (Subpixel Morphological)：后处理形态抗锯齿，改进了对模型边缘的判定算法，效果比 FXAA 更好，但是消耗比 FXAA 高一倍</li><li>TAA (Temporal AA)：时域抗锯齿，子像素采样点分布到多帧，需要运动矢量 (motion vectors)，原理是，通过 Motion Vector，找到上一帧的当前像素点的信息，然后混合，抖动投影矩阵的做法被称为 Jitter<ul><li>涉及两个 pass：渲染动态物体的运动矢量至速度缓存与 TAA</li></ul></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTkuNC9NYW51YWwvUG9zdFByb2Nlc3NpbmctQW50aWFsaWFzaW5nLmh0bWw=">抗锯齿 (Anti-aliasing) - Unity 手册</span><ul><li>Unity Quality 内置的就是 MSAA， 在 URP 中，渲染管线可以设置 MSAA，相机后处理可以选择 FXAA、SMAA，两者可以叠加。URP 不自带 TAA (缺少正确的 Motion Vectors)，【TAA 与 MSAA 不能叠加 -- 待定】</li><li>官方推荐：FXAA -- 移动端，SMAA、TAA-- 桌面和主机</li><li>Post Processing v2 倒是支持 TAA，但是 URP 集成的 PP 没有支持 (缺少 Motion Vectors 数据)，且内置的 Post Processing 替代了 PPv2 (<span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS51bml0eS5jb20vdGhyZWFkcy9wb3N0LXByb2Nlc3NpbmctYW5kLXVycC10aGUtcGxhbi43OTU0NTYv">post-processing-and-urp-the-plan</span>)</li><li>速度快慢：FXAA-&gt;SMAA-&gt;MSAA-&gt;TAA</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxlbWVudDNkcy5jb20vZm9ydW0ucGhwP21vZD12aWV3dGhyZWFkJmFtcDt0aWQ9MzkwMzEy">U3D 各种抗锯齿哪个好？各自特点是什么？性能如何？什么平台用什么合适？</span></li></ul></li></ul><h2 id="屏幕效果"><a class="anchor" href="#屏幕效果">#</a> 屏幕效果</h2><ul><li>Bloom 效果<ul><li>提取亮度、模糊处理、以及合并光晕</li><li>提取原图像，给定一个阈值，使用高斯模糊阈值范围上的图像。再与原图相加，获得 bloom 效果</li></ul></li><li>景深<ul><li>近距离模糊</li><li>焦点范围清晰</li><li>远距离模糊</li><li>注：可能需要用到深度，另外听说还有种物理景深算法</li></ul></li></ul><h1 id="性能优化"><a class="anchor" href="#性能优化">#</a> 性能优化</h1><ul><li>减少提交次数 DrawCall，减少数据交换量，带宽优化、也是显存优化、</li><li><strong>减少 CPU 与 GPU 的数据同步</strong>。减少 CPU 与 GPU 的数据同步也是一个方向，怪物尽可能由 GPU 绘制，最大可能减少数据同步，以达到最高异步效率</li><li>可变分辨率</li><li>Shader：避免不同数据类型混用或者叫避免不必要的精度转换，例如 half 和 float，精度转换也是有消耗的<ul><li>现在新型 GPU fixed 可能已经没了，等价于 Half</li><li>3D 贴图开启 Mipmap，以空间换时间</li><li>使用 Bilinear 代替 Trilinear 过滤</li><li>减少 Anisotropic 过滤采样数量</li></ul></li><li>使用 LightMap，如果实在要使用实时阴影，可以考虑 Subtractive + 低分辨率阴影配合正确的阴影级联 (cascade) 设置 (级联仅适用于方向光)</li><li>BVH</li></ul><h1 id="渲染调试"><a class="anchor" href="#渲染调试">#</a> 渲染调试</h1><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9GcmFtZURlYnVnZ2VyLmh0bWw=">FrameDebugger</span></p><h1 id="其它-2"><a class="anchor" href="#其它-2">#</a> 其它</h1><h2 id="模型"><a class="anchor" href="#模型">#</a> 模型</h2><ul><li>网格主要由：顶点、三角形索引数组、UV 三个基础数据组成</li></ul><h2 id="动画"><a class="anchor" href="#动画">#</a> 动画</h2><ul><li>分为两种：一种是用一种算法改变顶点位置，为顶点动画；另一种是用骨骼影响网格顶点，为骨骼动画。两种方式都是通过在每一帧偏移模型网格上的顶点，让模型变形从而实现动画，最终原理其实一样。</li><li>传统骨骼动画：每个顶点都有骨骼权重数据（被哪些骨骼影响，权重多少），在 unity 中可以设置每个顶点最多受四个骨骼权重影响 —— 传统骨骼动画由骨骼点与顶点权重数据计算得到，顶点与骨骼数量越多，有效权重数据越多，cpu 消耗也越大</li><li>skinmesh：bindposes 为旋转矩阵，是为了实现父节点旋转位移时更快计算出子节点的位移旋转的变化矩阵（父子节点有相对位置关系，相对位置，相对角度，相对比例不变）</li><li>传统骨骼动画计算：CPU 计算骨架 -&gt;GPU 顶点蒙皮</li><li>贴图骨骼动画：动画信息存储为图片，VertexShader 通过 tex2dlod 采样 (贴图模式采用 Point)<ul><li>通过 CPU 计算全单位 Mask 图：播放哪个动画，第几帧。一张贴图包含所欲单位实时状态信息，只有一次数据同步。</li></ul></li><li>大批量实例化绘制 (GPU Instancing)：DrawMeshInstanced，该函数一般用于加速静态物体，批量一次性绘制一个 Mesh 多次。由于动态物体有动画，难以完全一致 (当对象足够多的时候，当前帧动画可能一致就能用了)，形成动画对象大批量实例化技术。</li><li>批量化 GPU 阴影</li></ul><h2 id="urp"><a class="anchor" href="#urp">#</a> URP</h2><ul><li>URP 多相机使用：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTE2Mzg5NTk=">https://zhuanlan.zhihu.com/p/351638959</span></li><li>Depth Priming (Pre-Z Pass)：OverDraw 过度绘制可以启用，但是要避免在 Tile-Based GPUs (移动平台)，提高半透明物体效率？<ul><li>优化 OverDraw，会增加 DrawCall，需要判断是否是正优化。</li><li>只能用于 Forward，自定义 Shader 需要手动添加 DepthOnly Pass</li><li>手机上与 MSAA 同时开启会比 DrawCall 开销还要大</li><li>DrawCall 或其它图形 API 调用</li></ul></li><li>RenderingDebuger：URP 调试工具</li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTYzOTczMzQ=">URP 配置 — 保姆级新手指南</span></li></ul><p>光照</p><ul><li>注：额外光源若选顶点光照则不能设置阴影</li></ul><h1 id="参考文档"><a class="anchor" href="#参考文档">#</a> 参考文档</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvYngwOXNjbmExVDJkV0RSVmlKejBWQQ==">图形学基础篇</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNjM5NDQ1MzE=">(十)、图形渲染进阶知识</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9GcmFtZURlYnVnZ2VyLmh0bWw=">FrameDebugger</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NzQ1NDAzMjk=">URP 延迟渲染 + Native Renderpass 踩坑记录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9vcHRpbWl6aW5nLWRyYXctY2FsbHMuaHRtbA==">Unity - Manual: Optimizing draw calls</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9SZW5kZXJpbmdTdGF0aXN0aWNzLmh0bWw=">Unity - Manual: The Rendering Statistics window</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9PcHRpbWl6aW5nR3JhcGhpY3NQZXJmb3JtYW5jZS5odG1s">Unity - Manual: Graphics performance fundamentals</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9zdGF0aWMtYmF0Y2hpbmcuaHRtbA==">Unity - Manual: Static batching</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL1NjcmlwdFJlZmVyZW5jZS9HcmFwaGljcy5SZW5kZXJNZXNoSW5zdGFuY2VkLmh0bWw=">Unity - Scripting API: Graphics.RenderMeshInstanced</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL1NjcmlwdFJlZmVyZW5jZS9HcmFwaGljcy5SZW5kZXJNZXNoSW5kaXJlY3QuaHRtbA==">Unity - Scripting API: Graphics.RenderMeshIndirect</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9TUlBCYXRjaGVyLmh0bWw=">Unity - Manual: Scriptable Render Pipeline Batcher</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS51bml0eS5jb20vdGhyZWFkcy9uZXctYmF0Y2hyZW5kZXJlcmdyb3VwLWFwaS1mb3ItMjAyMi0xLjEyMzA2Njkv">https://forum.unity.com/threads/new-batchrenderergroup-api-for-2022-1.1230669/</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjIuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9iYXRjaC1yZW5kZXJlci1ncm91cC1jcmVhdGluZy1hLXJlbmRlcmVyLmh0bWw=">Unity - Manual: Creating a renderer with BatchRendererGroup</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTkuNC9NYW51YWwvU0wtU2hhZGVyQ29tcGlsZVRhcmdldHMuaHRtbA==">着色器编译目标级别 - Unity 手册</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjIuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9kb3RzLWluc3RhbmNpbmctc2hhZGVycy5odG1s">Unity - Manual: DOTS Instancing shaders</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MzY4OTk4Nw==">Cascaded Shadow Maps (CSM) 实时阴影的原理与实现</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMDU0NDIvYXJ0aWNsZS9kZXRhaWxzLzExNzQyNzM5NQ==">Unity 实时阴影实现 ——Cascaded Shadow Mapping_unity 阴影</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQ5MDkwMzIx">关于 Shadow Mapping 产生的 Shadow Acne，我的理解是不是有问题？ - 知乎</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTc0NzUwMjg=">浅谈延迟渲染、移动 GPU 架构和 Metal</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTc0NzUwMjg=">浅谈延迟渲染、移动 GPU 架构和 Metal</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVGZsNk1VUHRPVk5EQzJDeTNhWGpIQQ==">游戏中的动态阴影</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTguNC9NYW51YWwvTGlnaHRQZXJmb3JtYW5jZS5odG1s">https://docs.unity.cn/cn/2018.4/Manual/LightPerformance.html</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTkuNC9NYW51YWwvUG9zdFByb2Nlc3NpbmctQW50aWFsaWFzaW5nLmh0bWw=">抗锯齿 (Anti-aliasing) - Unity 手册</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS51bml0eS5jb20vdGhyZWFkcy9wb3N0LXByb2Nlc3NpbmctYW5kLXVycC10aGUtcGxhbi43OTU0NTYv">post-processing-and-urp-the-plan</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxlbWVudDNkcy5jb20vZm9ydW0ucGhwP21vZD12aWV3dGhyZWFkJmFtcDt0aWQ9MzkwMzEy">U3D 各种抗锯齿哪个好？各自特点是什么？性能如何？什么平台用什么合适？</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9GcmFtZURlYnVnZ2VyLmh0bWw=">FrameDebugger</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTE2Mzg5NTk=">https://zhuanlan.zhihu.com/p/351638959</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTYzOTczMzQ=">URP 配置 — 保姆级新手指南</span></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#前言&quot;&gt;#&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;部分来源于网络，并注明来源（已丢失除外），性能优化、批处理则主要整理自 Unity 官方文档&lt;br /&gt;
注 1：参考文档均在对应位置标注，文章末尾也贴了对应链接&lt;</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/categories/Unity3D/"/>
    
    
    <category term="Unity3D" scheme="https://wangjiaying.top/tags/Unity3D/"/>
    
    <category term="图形学" scheme="https://wangjiaying.top/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="性能优化" scheme="https://wangjiaying.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="笔记" scheme="https://wangjiaying.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
