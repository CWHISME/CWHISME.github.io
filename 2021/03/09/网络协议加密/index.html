<!DOCTYPE html><meta name="viewport" content="height=device-height,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=0"><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="cwhisme"><meta name="author" content="CWHISME"><meta property="og:title" content="网络协议加密"><meta property="og:description" content="cwhisme"><meta property="og:site_name" content="WangJiaYing"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><title>网络协议加密 - WangJiaYing</title><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/DateTimeAfeterCalc.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/particles-bg.js"></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/script.js"></script><link href="https://fastly.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/css/style.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tachyons@4.12.0/css/tachyons.min.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="WangJiaYing" type="application/atom+xml">
</head><body><canvas id="hackEffectCanvas" style="position:fixed;z-index:-1;pointer-events:none"></canvas><canvas class="fireworks" style="position:fixed;z-index:10;pointer-events:none"></canvas><div class="w-100 bg-1 ph5-ns ph3 text-light"><nav class="db dt-l w-100 mw8 center border-box pv3"><a class="db dtc-l v-mid link dim w-100 w-25-l tc tl-l mb2 mb0-l white" href="/" title="WangJiaYing"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/logo.svg" class="dib h3" alt="WangJiaYing"></a><div class="db dtc-l v-mid w-100 w-75-l tc tr-l"><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/" title="Home">Home </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/archives" title="Archives">Archives </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/tags" title="Tags">Tags </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/categories" title="Categories">Categories </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/bookmark" title="Bookmark">Bookmark </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/about" title="About">About</a></div></nav><div class="w-100 mw8 center vh-40 dt"><div class="dtc v-mid white"><h1 class="f1-l f2-m tc tc-m tl-ns">网络协议加密</h1><p class="f4 fw3 pab-100px tc tc-m tl-ns"><i class="fa fa-calendar-check-o" aria-hidden="true"></i> 2021-03-09&nbsp&nbsp <i class="fa fa-clock-o" aria-hidden="true"></i> <span id="dateTimeAfter">2021-03-09</span></p></div></div><div class="relative w-100 mw8 center white dn dn-m db-ns"><i class="header-icon fa fa-snowflake-o"></i></div></div><div class="w-100 ph2 ph4-m ph5-l mv5 mv6-l"><div class="content"><div class="mw8 center"><div class="cf"><div class="fl w-100 w-70-l mw7 left fw3 lh-copy pr4-ns pr0-m post-content"><p>众所周知，现在网络通信的时候，协议之间一般都会进行加密，以防第三方抓包等进行破解。再不济也会进行异或混淆。在这里我就记录一下自己的一个网络框架『CrySimpleNet』进行协议加密的结构。</p><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>CrySimpleNet开发的初衷，主要是当年接手公司项目维护之后，意图实现一套『远程打包』。</p><p>比如，在自己的机器上，使用一个客户端，点击对应选项，就可以自动在打包机上调用Unity3D进行相应操作：如自动合并SVN打热更、更新项目出包等等。</p><p>这个网络框架的目的是：使得打包者可以直接调用客户端，通知Windows打包机进行各项操作，Android打包就简单，直接全是Windows打包机操作就行了，最多不过在让Unity导出项目之后，需要再额外调用Android Studio进行最终打包。<br>不过IOS项目打包则需要在导出Xcode工程后，将工程数据传输到Mac打包机调用Xcode进行最终打包。此不多言。</p><p>不过后面在实现网络方面功能、然后测试了框架文件传输效果后，被告知打包机不能被直连：因为担心网络安全；因此这个计划就放弃了。<br>后期打包主要操作和工具还是做到了UnityEditor中。</p><p>还好这个框架在实现的时候，就考虑了重用性，核心库不管是放Unity，还是放WPF都可以用。现在用不上，以后说不准哪里还能用到。<br>毕竟自己实现的东西，跟网上随便找的框架，用起来可不一样。</p><p>放了这么些时日，想起当初对协议传输加密方面，只简单实现了 异或混淆、压缩等操作，加密性应该算是比较低的。包括数据包完整性校验也没做，于是花了点时间，将其补上了。</p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p><span>加密结构：异或加密【RSA加密标志(1)|RSA加密【MD5校验位+压缩位|实际数据|MD5校验数据(16位或者0)】】</span></p><p>由于协议结构是个人琢磨的，若有不足还请指正。</p><p>其操作顺序为：</p><ol><li>首先判断是否压缩：数据包大小超出压缩上限</li><li>若需要压缩，则将原数据压缩成一个新的比特数组</li><li>创建一个包括 MD5标志、压缩标志和目前数据包长度 大小的新数组</li><li>数组第0位写入MD5校验标志及压缩标志(之所以写入MD5标志位，是因为MD5校验做成了可通过配置进行开启或关闭)</li><li>写入实际数据</li><li>写入MD5校验数据(如果有的话)</li><li>RSA加密：写入RSA标志位，写入加密数据(同样可通过配置开启或关闭)</li><li>异或混淆</li></ol><p>解密顺序则通过相反顺序操作进行。</p><ol><li>异或混淆解密</li><li>判断是否RSA加密，并进行解密</li><li>取出MD5标志、取出压缩标志</li><li>取出老的MD5码</li><li>取出实际数据</li><li>判断是否进行MD5校验，若有则计算实际数据MD5，并与老的MD5码对比</li><li>判断是否压缩、解压缩</li></ol><p>代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 加密</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 加密结构：异或加密【RSA加密标志(1)|RSA加密【MD5校验位+压缩位|实际数据|MD5校验数据(16位或者0)】】</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;bytes&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;compress&quot;&gt;</span>是否压缩<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rsaEncrypt&quot;&gt;</span>是否rsa加密<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">ByteEncryption</span>(<span class="params"><span class="built_in">byte</span>[] bytes, <span class="built_in">bool</span> compress = <span class="literal">true</span>, <span class="built_in">bool</span> rsaEncrypt = <span class="literal">false</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">byte</span>[] compressBytes = bytes;</span><br><span class="line">    <span class="comment">//压缩</span></span><br><span class="line">    <span class="keyword">if</span> (compress)</span><br><span class="line">        compressBytes = Compress(compressBytes);</span><br><span class="line">    <span class="comment">//写入标志</span></span><br><span class="line">    <span class="comment">//注：MD5加密，则位数为16位MD5+MD5标志位@压缩标志位</span></span><br><span class="line">    <span class="comment">//      否则为 MD5标志位@压缩标志位</span></span><br><span class="line">    <span class="built_in">byte</span>[] tempBytes = <span class="keyword">new</span> <span class="built_in">byte</span>[(Config.IsProtoMD5Verification ? compressBytes.Length + <span class="number">16</span> : compressBytes.Length) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//byte类型标志位最大支持7个：byte b = 1 &lt;&lt; 1 | 1 &lt;&lt; 2 | 1 &lt;&lt; 3 | 1 &lt;&lt; 4 | 1 &lt;&lt; 5 | 1 &lt;&lt; 6 | 1 &lt;&lt; 7=254;</span></span><br><span class="line">    <span class="built_in">int</span> flagByte = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//写入MD5校验位</span></span><br><span class="line">    flagByte |= (Config.IsProtoMD5Verification ? <span class="number">1</span> : <span class="number">0</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//写入压缩位</span></span><br><span class="line">    flagByte |= (compress ? <span class="number">1</span> : <span class="number">0</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    tempBytes[index++] = (<span class="built_in">byte</span>)flagByte;</span><br><span class="line">    <span class="comment">//写入实际数据</span></span><br><span class="line">    compressBytes.CopyTo(tempBytes, index);</span><br><span class="line">    index += compressBytes.Length;</span><br><span class="line">    <span class="comment">//写入MD5校验数据</span></span><br><span class="line">    <span class="keyword">if</span> (Config.IsProtoMD5Verification)</span><br><span class="line">    &#123;</span><br><span class="line">        CalcMD5(compressBytes).CopyTo(tempBytes, index);</span><br><span class="line">        index += <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内容 加密</span></span><br><span class="line">    tempBytes = EncryptRawContent(tempBytes, rsaEncrypt);</span><br><span class="line">    <span class="comment">//混淆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tempBytes.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tempBytes[i] ^= Config.XorKey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tempBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 解密</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;bytes&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">ByteDecrypt</span>(<span class="params"><span class="built_in">byte</span>[] bytes</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//解混</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bytes.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes[i] ^= Config.XorKey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内容解密</span></span><br><span class="line">    bytes = DecryptRawContent(bytes);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//读取标志位信息</span></span><br><span class="line">    <span class="built_in">byte</span> flagByte = bytes[index++];</span><br><span class="line">    <span class="comment">//读取MD5校验标志</span></span><br><span class="line">    <span class="built_in">bool</span> isMd5Verify = (flagByte &amp; <span class="number">1</span> &lt;&lt; <span class="number">1</span>) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//读取压缩标志</span></span><br><span class="line">    <span class="built_in">bool</span> isCompress = (flagByte &amp; <span class="number">1</span> &lt;&lt; <span class="number">2</span>) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//MD5校验数据保存在最后，这里如果有的话就要删掉</span></span><br><span class="line">    <span class="built_in">int</span> contentLength = bytes.Length - index;</span><br><span class="line">    contentLength = isMd5Verify ? contentLength - <span class="number">16</span> : contentLength;</span><br><span class="line">    <span class="built_in">byte</span>[] rawBytes = <span class="keyword">new</span> <span class="built_in">byte</span>[contentLength];</span><br><span class="line">    Array.Copy(bytes, index, rawBytes, <span class="number">0</span>, contentLength);</span><br><span class="line">    index += contentLength;</span><br><span class="line">    <span class="keyword">if</span> (isMd5Verify)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] md5Bytes = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">16</span>];</span><br><span class="line">        Array.Copy(bytes, index, md5Bytes, <span class="number">0</span>, md5Bytes.Length);</span><br><span class="line">        <span class="built_in">byte</span>[] nowMd5 = CalcMD5(rawBytes);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; md5Bytes.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (md5Bytes[i] != nowMd5[i])</span><br><span class="line">            &#123;</span><br><span class="line">                Log.Error(<span class="string">$&quot;MD5校验失败！原：<span class="subst">&#123;md5Bytes.ToString()&#125;</span> ==&gt; 现<span class="subst">&#123;nowMd5&#125;</span>&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        index += <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">byte</span>[] oringinByte = rawBytes;</span><br><span class="line">    <span class="comment">//解压缩</span></span><br><span class="line">    <span class="keyword">if</span> (isCompress)</span><br><span class="line">        oringinByte = Decompress(oringinByte);</span><br><span class="line">    <span class="keyword">return</span> oringinByte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上便是整个加密结构。</p><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>加密结构中，加解密顺序操作即可，并无难点。需要注意的是RSA加密的问题，这里我是单独抽出了一个方法，方便排版和处理。</p><p>因为RSA加密需要秘钥，一般来说，加密者使用公钥，接收者使用私钥，成对进行。<br>因此在个人的设计中，需要有两组秘钥：</p><ul><li>服务器公钥-客户端私钥</li><li>服务器私钥-客户端公钥</li></ul><p>分别用于客户端与服务器相对发送、接收的加密、解密。</p><p>但是，RSA加密明文长度是有限制的：根据资料显示，一个公钥加密的明文长度，等于秘钥长度减11字节。<br>其中11字节是RSA算法需要占用的空间。<br>即，若秘钥长度为1024位，则明文长度最大支持 1024/8-11=117字节(1字节=8位，秘钥单位是位)<br>同时，明文加密后的长度，一定会等于秘钥长度。</p><p>因此采取了分块解密的方式。<br>假设秘钥长度为1024位，则</p><ul><li>数据块一块最多占用 maxSzie=1024/8=128Byte</li><li>明文一块最多占用 maxCap=maxSzie-11=117Byte</li></ul><p>主要操作是：</p><ol><li>判断需要加密的内容，字节数是否大于117Byte，如果小于，直接加密返回即可。</li><li>若数据大于117Byte，则根据 总量/117 并向上取整，获取分块数量。<br>之所以向上取整，是因为如果有余数，那么代表按照117Byte进行分割会有剩余字节，最后一个数据块必然是小于117Byte的。</li><li>根据得出需要分块的数量N，创建加密后总数据数组(size=N*maxSzie)容器。</li><li>进行for循环，不断加密不断填充，完成加密。</li></ol><p>代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> RSA 加密</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;val&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">EncryptRSA</span>(<span class="params"><span class="built_in">byte</span>[] val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_rsaEncrypt == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _rsaEncrypt = <span class="keyword">new</span> RSACryptoServiceProvider();</span><br><span class="line">        _rsaEncrypt.FromXmlString(Config.RSAPublicKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Rsa加密最大允许秘钥长度-11的加密内容</span></span><br><span class="line">    <span class="comment">//例如1024/8=128个字节-11=117字节</span></span><br><span class="line">    <span class="comment">//因此需要分割加密</span></span><br><span class="line">    <span class="built_in">int</span> maxSize = _rsaEncrypt.KeySize / <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">int</span> maxCap = maxSize - <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">if</span> (val.Length &gt; maxCap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> num = (<span class="built_in">int</span>)Math.Ceiling(val.Length / (<span class="built_in">float</span>)maxCap);</span><br><span class="line">        <span class="comment">//最终数据</span></span><br><span class="line">        <span class="built_in">byte</span>[] finalBytes = <span class="keyword">new</span> <span class="built_in">byte</span>[num * maxSize];</span><br><span class="line">        <span class="comment">//每一片的实际数据</span></span><br><span class="line">        <span class="built_in">byte</span>[] piceRawBytes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> index = i * maxCap;</span><br><span class="line">            piceRawBytes = <span class="keyword">new</span> <span class="built_in">byte</span>[val.Length - index &gt; maxCap ? maxCap : val.Length - index];</span><br><span class="line">            Array.Copy(val, index, piceRawBytes, <span class="number">0</span>, piceRawBytes.Length);</span><br><span class="line">            <span class="built_in">byte</span>[] bytes = _rsaEncrypt.Encrypt(piceRawBytes, <span class="literal">false</span>);</span><br><span class="line">            bytes.CopyTo(finalBytes, i * maxSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _rsaEncrypt.Encrypt(val, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于分块之后，最后一块的数据内容不规则，因此需要特殊处理一下最后一块的数据。</p><p>解密方式则通过类似操作进行，分块解密，然后统一合并，形成最终明文数据：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> RSA 解密</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;val&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">DecryptRSA</span>(<span class="params"><span class="built_in">byte</span>[] val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_rsaDecrypt == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _rsaDecrypt = <span class="keyword">new</span> RSACryptoServiceProvider();</span><br><span class="line">        _rsaDecrypt.FromXmlString(Config.RSAPrivateKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Rsa加密最大允许秘钥长度-11的加密内容</span></span><br><span class="line">    <span class="comment">//例如1024/8=128个字节-11=117字节</span></span><br><span class="line">    <span class="comment">//因此需要分割解密</span></span><br><span class="line">    <span class="built_in">int</span> maxSize = _rsaDecrypt.KeySize / <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">int</span> maxCap = maxSize - <span class="number">11</span>;</span><br><span class="line">    <span class="comment">//大于秘钥最大支持长度，估计是分割过的内容</span></span><br><span class="line">    <span class="keyword">if</span> (val.Length &gt; maxSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> num = val.Length / maxSize;</span><br><span class="line">        <span class="keyword">using</span> (MemoryStream stream = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">byte</span>[] lockBytes = <span class="keyword">new</span> <span class="built_in">byte</span>[maxSize];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Array.Copy(val, i * maxSize, lockBytes, <span class="number">0</span>, lockBytes.Length);</span><br><span class="line">                <span class="built_in">byte</span>[] unlockBytes = _rsaDecrypt.Decrypt(lockBytes, <span class="literal">false</span>);</span><br><span class="line">                stream.Write(unlockBytes, <span class="number">0</span>, unlockBytes.Length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stream.ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _rsaDecrypt.Decrypt(val, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不可否认的是，RSA加密及分块加解密这种方式肯定也会给性能带来影响。<br>不过现在还是以安全为准，而且结构在这儿，就算更换加密方式也是很简单的。</p><p>增加数据MD5校验及RSA加密后，调用GenerateRsaKey方法生成一对公钥及私钥，进行简单的通信测试<br>(正常情况应该生成两对，服务器及客户端相对配置，这里为了方便就直接用一对进行测试了，双方都使用同一对公钥私钥进行加解密)</p><p>内容能够正常传输，未发现问题，说明加解密正常。</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-03-09-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%AF%86_1.png" alt="效果"></p><br><br><hr><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><div id="vcomments"></div><script>new Valine({el:"#vcomments",appId:"MsaVbSzIr9cIfikihDExdun9-gzGzoHsz",appKey:"Bj6SEFUBomrLOTWx9B8S6zQH",placeholder:"请输入评论内容~",avatar:"mp",visitor:!1})</script></div><div class="fl w-100 w-30-l center fw3 lh-copy pl4-ns tl black-50"><hr class="dn-l mw4 black-50 mt5"><div class="mt5 mt0-l site-author"><article class="dt db-l mw8 mw8-m mw5-ns center ml0-l bg-white mv3"><div class="dn dtc-m db-l v-mid tc pr4 pr0-l" style="min-width:6rem"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/photo.jpg" class="mb4-l br-100 h3 w3 h4-l w4-l dib" title="CWHISME"></div><div class="dtc db-l v-mid lh-copy measure center f6 black-50 tj">悲观主义的末日</div></article></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>分类</h3><p><a href="/categories/网络开发/">网络开发</a></p></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>近期文章</h3><p><a href="/2022/12/10/%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/">协变和逆变</a></p><p><a href="/2022/12/06/Unity%E7%9A%84%E9%98%B4%E5%BD%B1%E4%B8%8E%E5%85%89%E7%85%A7%E7%83%98%E7%84%99/">Unity 的阴影与光照烘焙</a></p><p><a href="/2022/11/23/%E6%89%93%E5%8C%85AssetBundle%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86/">打包 AssetBundle 的基础规则整理</a></p><p><a href="/2022/11/18/StringBuilder%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E7%A0%94%E7%A9%B6/">StringBuilder 扩容规则研究</a></p><p><a href="/2022/11/17/%E6%B5%8B%E8%AF%95%E6%89%8B%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">简单测试手动垃圾回收</a></p></div></div></div></div></div></div><div class="bg-1 ph2 ph5-ns pv5"><div class="mv8"><div class="center tc"><div class="dib mh3"><a class="f3 f2-ns white dim" href="https://github.com/CWHISME" target="_blank"><i class="fa fa-github"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="mailto:cwhisme@126.com" target="_blank"><i class="fa fa-envelope"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div></div><div class="f6 f5-ns center tc white pt5 fw3">Copyright © 2021 | Design & Hexo <a class="link dim white" target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-anodyne/">Jonathan Klughertz</a> | Modify By CWHISME</div></div></div></body></html>