<!DOCTYPE html><meta name="viewport" content="height=device-height,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=0"><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="cwhisme"><meta name="author" content="CWHISME"><meta property="og:title" content="关于SynchronizationContext的使用"><meta property="og:description" content="cwhisme"><meta property="og:site_name" content="WangJiaYing"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><title>关于SynchronizationContext的使用 - WangJiaYing</title><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/DateTimeAfeterCalc.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/particles-bg.js"></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/script.js"></script><link href="https://fastly.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/css/style.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tachyons@4.12.0/css/tachyons.min.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="WangJiaYing" type="application/atom+xml">
</head><body><canvas id="hackEffectCanvas" style="position:fixed;z-index:-1;pointer-events:none"></canvas><canvas class="fireworks" style="position:fixed;z-index:10;pointer-events:none"></canvas><div class="w-100 bg-1 ph5-ns ph3 text-light"><nav class="db dt-l w-100 mw8 center border-box pv3"><a class="db dtc-l v-mid link dim w-100 w-25-l tc tl-l mb2 mb0-l white" href="/" title="WangJiaYing"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/logo.svg" class="dib h3" alt="WangJiaYing"></a><div class="db dtc-l v-mid w-100 w-75-l tc tr-l"><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/" title="Home">Home </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/archives" title="Archives">Archives </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/tags" title="Tags">Tags </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/categories" title="Categories">Categories </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/bookmark" title="Bookmark">Bookmark </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/about" title="About">About</a></div></nav><div class="w-100 mw8 center vh-40 dt"><div class="dtc v-mid white"><h1 class="f1-l f2-m tc tc-m tl-ns">关于SynchronizationContext的使用</h1><p class="f4 fw3 pab-100px tc tc-m tl-ns"><i class="fa fa-calendar-check-o" aria-hidden="true"></i> 2021-03-25&nbsp&nbsp <i class="fa fa-clock-o" aria-hidden="true"></i> <span id="dateTimeAfter">2021-03-25</span></p></div></div><div class="relative w-100 mw8 center white dn dn-m db-ns"><i class="header-icon fa fa-snowflake-o"></i></div></div><div class="w-100 ph2 ph4-m ph5-l mv5 mv6-l"><div class="content"><div class="mw8 center"><div class="cf"><div class="fl w-100 w-70-l mw7 left fw3 lh-copy pr4-ns pr0-m post-content"><p>SynchronizationContext是C#内置跨线程同步上下文的基类，可以实现线程间的同步。<br>例如，一般情况下子线程无法修改主线程的UI，通常比较麻烦的做法就是自己采用轮询机制实现同步。<br>而该类则可很方便地处理该类型问题。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>官方文档地址：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext?view=net-5.0">地址</a></p><p>说实话，官方文档的描述极少，大概就是说这个类是个基类，提供了一个通用的线程上下文的传递模型，有需要可以直接继承该类，并重载需要的方法，简化了多线程工作单元传递所需的工作。<br>不过在该文档中，还额外提供了一份 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2011/february/msdn-magazine-parallel-computing-it-s-all-about-the-synchronizationcontext">MSDN的文章</a> 。<br>MSDN文章就比较详细些了。</p><p>原理就不多说了，上面MSDN文章有详细介绍，这种系统层级的东西，用就好了。<br>另外虽说称为基类，但是直接使用也是没问题的。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在SynchronizationContext中，有静态的Current变量，在主UI线程调用将返回一个SynchronizationContext类型的实例。<br>同时也提供了SetSynchronizationContext(SynchronizationContext syncContext)方法可覆盖该返回值，一般用于继承了SynchronizationContext并有自己额外处理的方式的派生类使用。</p><p>可以将Current当做一个单例，但是注意的是它属于每个线程独有，在UI主线程可以直接通过SynchronizationContext.Current获取到默认的实例，但新开的子线程默认始终为Null。<br><font color="red">注：即便使用SetSynchronizationContext在主线程设置之后，新开的子线程若不进行设置，依然会保持为Null。</font></p><hr><p>SynchronizationContext类中，主要提供Post、Send两个方法进行线程回调使用：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">SendOrPostCallback d, <span class="built_in">object</span> state</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Send</span>(<span class="params">SendOrPostCallback d, <span class="built_in">object</span> state</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中调用Post将会异步执行，调用Send则同步执行。<code>object state</code>为调用回调时，传入的参数。</p><ul><li>Post：在调用之后，立即执行当前线程后续代码。</li><li>Send：在调用之后，等待回调执行完毕，才会继续执行当前线程后续代码。</li></ul><p>测试如下：</p><p><strong>Send</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    SynchronizationContext.SetSynchronizationContext(context);</span><br><span class="line">    SynchronizationContext.Current.Send((args) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;子线程调用UI！args:<span class="subst">&#123;args&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;参数X&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用结束！&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在该方法中，调用Send，并在回调内休眠1000毫秒。<br>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子线程调用UI！args:参数X</span><br><span class="line">调用结束！</span><br></pre></td></tr></table></figure><p>按照顺序执行，当子线程休眠时，后续代码也阻塞未执行，直到Send回调执行完毕。</p><p><strong>Post</strong></p><p>直接将上述代码中的Send改为Post，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用结束！</span><br><span class="line">子线程调用UI！args:参数X</span><br></pre></td></tr></table></figure><p>即使去掉回调中的1000毫秒休眠，调用Post，依然会是该结果。</p><p>因此可以表明：Post可用于异步回调，Send可用于等待回调执行，需要阻塞后续代码的情况。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h3><p>直接使用的方法很简单，这里先来看WPF中的效果。</p><p>正常情况下，子线程无法操作UI，若直接调用，会得到异常报错，例如如下代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    TestBtn.Content = <span class="string">&quot;子线程调用UI！&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>会得到如下报错：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-03-25-%E5%85%B3%E4%BA%8ESynchronizationContext_1.png" alt="错误"></p><p>在WPF中，虽然有其它方式可以避免报错并让其正常工作，例如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    TestBtn.Dispatcher.Invoke(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        TestBtn.Content = <span class="string">&quot;子线程调用UI！&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不过这种方式是WPF自己的特性，如果想在其它地方使用，比如Unity，可就没这种东西了。</p><p>此时便可使用SynchronizationContext：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SynchronizationContext context = SynchronizationContext.Current;</span><br><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    SynchronizationContext.SetSynchronizationContext(context);</span><br><span class="line">    SynchronizationContext.Current.Send((args) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;子线程调用UI！&quot;</span>);</span><br><span class="line">        TestBtn.Content = <span class="string">&quot;子线程调用UI！&quot;</span>;</span><br><span class="line">    &#125;, <span class="literal">null</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用结束！&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>该份代码复制至Unity，且调用UI替换为Unity的函数，亦可正常工作：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SynchronizationContext context = SynchronizationContext.Current;</span><br><span class="line">    Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        SynchronizationContext.SetSynchronizationContext(context);</span><br><span class="line">        Console.WriteLine(SynchronizationContext.Current.GetHashCode());</span><br><span class="line">        SynchronizationContext.Current.Send((args) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;子线程调用UI！&quot;</span>);</span><br><span class="line">            UnityEditor.EditorUtility.DisplayDialog(<span class="string">&quot;提示&quot;</span>, <span class="string">&quot;子线程的调用！&quot;</span>, <span class="string">&quot;OK&quot;</span>);</span><br><span class="line">        &#125;, <span class="literal">null</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;调用结束！&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-03-25-%E5%85%B3%E4%BA%8ESynchronizationContext_2.png"></p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>一般在项目中，代码结构都不会如此简单，如果在开启子线程时，处处考虑SynchronizationContext实例线程传递的话，也比较麻烦。因此可以使用单例。</p><p>这里主要有两种方式实现：</p><ul><li>普通单例缓存SynchronizationContext实例</li><li>继承自SynchronizationContext的单例实现</li></ul><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>第一种比较好说，直接新建一个单例类，并将SynchronizationContext封装即可。<br>代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MySynchronizationContextHolder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySynchronizationContextHolder Instance &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> MySynchronizationContextHolder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SynchronizationContext _context = SynchronizationContext.Current;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> _mainThreadId = Thread.CurrentThread.ManagedThreadId;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 子线程执行一个回调时调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;action&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;state&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">Action action, <span class="built_in">object</span> state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Post(<span class="keyword">new</span> SendOrPostCallback((x) =&gt; action.Invoke()), state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 子线程执行一个回调时调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;callback&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;state&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">SendOrPostCallback callback, <span class="built_in">object</span> state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.CurrentThread.ManagedThreadId == _mainThreadId)</span><br><span class="line">        &#123;</span><br><span class="line">            callback.Invoke(state);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _context.Post(callback, state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此种方式唯一需要注意的是：子线程调用实例之前，主线程必须先调用一次，确保单例初始化于主线程，否则初始化于子线程的单例会造成错误的结果。<br>(例如上述方式，若第一次由子线程初始化调用，会导致_context实例为Null，而且由于处于子线程甚至无法捕获错误。)</p><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>第二种方式，由于继承了SynchronizationContext，就不能简单地通过调用<code>base.Post(callback,state);</code>这种方法来实现传递了。<br>因为那样的话，这个单例就会变成跟子线程调用一样的性质了：<br>直接调用的情况就如同子线程直接创建了一个新实例，然后调用造成的结果，跟子线程直接调用无所区别。</p><p>因此这里就需要额外做点工作，比如重写方法，缓存回调，然后在主线程Update中统一更新：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MySynchronizationContext</span> : <span class="title">SynchronizationContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySynchronizationContext Instance &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> MySynchronizationContext();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ConcurrentQueue</span>&lt;<span class="title">Action</span>&gt; _queue</span> = <span class="keyword">new</span> ConcurrentQueue&lt;Action&gt;();</span><br><span class="line">    <span class="keyword">private</span> Action _callback;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_queue.Count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_queue.TryDequeue(<span class="keyword">out</span> _callback))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            _callback.Invoke();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 子线程执行一个回调时调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;action&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;state&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">Action action, <span class="built_in">object</span> state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Post(<span class="keyword">new</span> SendOrPostCallback((x) =&gt; action.Invoke()), state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 子线程执行一个回调时调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;callback&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;state&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">SendOrPostCallback callback, <span class="built_in">object</span> state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _queue.Enqueue(() =&gt; callback.Invoke(state));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是两个可以将SynchronizationContext封装为单例的实现方式。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>个人感觉，这种一般在多线程使用中还是挺有用的——比自己去循环查询结果来得方便。</p><p>此前个人就经常使用那种笨办法，比如制作Unity工具，在子线程回调中需要表现的时候：弹窗或者显示进度条，就是在使用回调修改值，然后在界面中再根据回调修改后的值判断是否进行显示，<br>中间转化及其麻烦，有时候甚至直接就因此放弃做什么表现了，直接一个子线程搞完了再统一给个回复。</p><p>后续就会考虑实际应用，或许修改下以前的代码了。<br>如Github上一些小工具，后续应该会考虑更新一波。</p><br><br><hr><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><div id="vcomments"></div><script>new Valine({el:"#vcomments",appId:"MsaVbSzIr9cIfikihDExdun9-gzGzoHsz",appKey:"Bj6SEFUBomrLOTWx9B8S6zQH",placeholder:"请输入评论内容~",avatar:"mp",visitor:!1})</script></div><div class="fl w-100 w-30-l center fw3 lh-copy pl4-ns tl black-50"><hr class="dn-l mw4 black-50 mt5"><div class="mt5 mt0-l site-author"><article class="dt db-l mw8 mw8-m mw5-ns center ml0-l bg-white mv3"><div class="dn dtc-m db-l v-mid tc pr4 pr0-l" style="min-width:6rem"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/photo.jpg" class="mb4-l br-100 h3 w3 h4-l w4-l dib" title="CWHISME"></div><div class="dtc db-l v-mid lh-copy measure center f6 black-50 tj">悲观主义的末日</div></article></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>分类</h3><p><a href="/categories/技术研究/">技术研究</a></p></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>近期文章</h3><p><a href="/2022/12/10/%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/">协变和逆变</a></p><p><a href="/2022/12/06/Unity%E7%9A%84%E9%98%B4%E5%BD%B1%E4%B8%8E%E5%85%89%E7%85%A7%E7%83%98%E7%84%99/">Unity 的阴影与光照烘焙</a></p><p><a href="/2022/11/23/%E6%89%93%E5%8C%85AssetBundle%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86/">打包 AssetBundle 的基础规则整理</a></p><p><a href="/2022/11/18/StringBuilder%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E7%A0%94%E7%A9%B6/">StringBuilder 扩容规则研究</a></p><p><a href="/2022/11/17/%E6%B5%8B%E8%AF%95%E6%89%8B%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">简单测试手动垃圾回收</a></p></div></div></div></div></div></div><div class="bg-1 ph2 ph5-ns pv5"><div class="mv8"><div class="center tc"><div class="dib mh3"><a class="f3 f2-ns white dim" href="https://github.com/CWHISME" target="_blank"><i class="fa fa-github"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="mailto:cwhisme@126.com" target="_blank"><i class="fa fa-envelope"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div></div><div class="f6 f5-ns center tc white pt5 fw3">Copyright © 2021 | Design & Hexo <a class="link dim white" target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-anodyne/">Jonathan Klughertz</a> | Modify By CWHISME</div></div></div></body></html>