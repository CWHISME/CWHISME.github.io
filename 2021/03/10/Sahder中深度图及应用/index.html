<!DOCTYPE html><meta name="viewport" content="height=device-height,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=0"><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="cwhisme"><meta name="author" content="CWHISME"><meta property="og:title" content="Unity3D中Sahder深度图及应用"><meta property="og:description" content="cwhisme"><meta property="og:site_name" content="WangJiaYing"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><title>Unity3D中Sahder深度图及应用 - WangJiaYing</title><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/DateTimeAfeterCalc.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/particles-bg.js"></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/script.js"></script><link href="https://fastly.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/css/style.css"><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script id="MathJax-script" src="https://fastly.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tachyons@4.12.0/css/tachyons.min.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="WangJiaYing" type="application/atom+xml">
</head><body><canvas id="hackEffectCanvas" style="position:fixed;z-index:-1;pointer-events:none"></canvas><canvas class="fireworks" style="position:fixed;z-index:10;pointer-events:none"></canvas><div class="w-100 bg-1 ph5-ns ph3 text-light"><nav class="db dt-l w-100 mw8 center border-box pv3"><a class="db dtc-l v-mid link dim w-100 w-25-l tc tl-l mb2 mb0-l white" href="/" title="WangJiaYing"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/logo.svg" class="dib h3" alt="WangJiaYing"></a><div class="db dtc-l v-mid w-100 w-75-l tc tr-l"><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/" title="Home">Home </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/archives" title="Archives">Archives </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/tags" title="Tags">Tags </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/categories" title="Categories">Categories </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/bookmark" title="Bookmark">Bookmark </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/about" title="About">About</a></div></nav><div class="w-100 mw8 center vh-40 dt"><div class="dtc v-mid white"><h1 class="f1-l f2-m tc tc-m tl-ns">Unity3D中Sahder深度图及应用</h1><p class="f4 fw3 pab-100px tc tc-m tl-ns"><i class="fa fa-calendar-check-o" aria-hidden="true"></i> 2021-03-10&nbsp&nbsp <i class="fa fa-clock-o" aria-hidden="true"></i> <span id="dateTimeAfter">2021-03-10</span></p></div></div><div class="relative w-100 mw8 center white dn dn-m db-ns"><i class="header-icon fa fa-snowflake-o"></i></div></div><div class="w-100 ph2 ph4-m ph5-l mv5 mv6-l"><div class="content"><div class="mw8 center"><div class="cf"><div class="fl w-100 w-70-l mw7 left fw3 lh-copy pr4-ns pr0-m post-content"><div class="tags-container-vertical"><div class="tags-sub-container"><a class="fw3 ph1 dib" href="/tags/Shader/">#Shader</a></div></div><p>关于Sahder中的深度图，其应用方式有很多，最常见的例如 科幻游戏中扫描线、水的Shader、透明物体相交、屏幕后期处理的描边等。<br>主要就是因为在能够获得场景深度值之后，可以有许多操作空间。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章，其实在之前整理『Unity3DSahder关键字』及『Sahder内置函数』的时候就在想写一下了。<br>不过在那之后，有几个原因导致一直没有动手：</p><ul><li>感觉只是个小东西，复杂之处在于用它来实现的各种后期效果；</li><li>虽然知道原理，但自己动手搞了搞之后，感觉理解起来有点困惑，这样就更不好说写什么了；</li><li>网上相关文章也挺多；<br>另外也有点其他事情耽搁了。</li></ul><p>不过后面考虑了下，不写写加深理解，总结实践下，那后面再遗忘可就真没收获了。<br>因此在这里，我会简单总结一下深度图分别在屏幕后期处理及单个物体Shader中的用法及作用。</p><h2 id="获取深度图"><a href="#获取深度图" class="headerlink" title="获取深度图"></a>获取深度图</h2><p>在获取深度值方面，主要有两种方式：</p><ol><li>通过获取整个屏幕深度图</li><li>在单个物体特殊应用时，获取自身深度值</li></ol><p>在Unity中，引擎是直接提供了屏幕深度图的，使用方式也很简单：在Shader中声明 <code>sampler2D _CameraDepthTexture;</code>变量即可，运行时Unity会自动为其赋值。<br>然后通过纹理采样函数，即可获取到指定 屏幕坐标 的深度值信息。<br>注意采样到的深度值，并非线性[0,1]深度值，可使用Unity提供的函数Linear01Depth转化。</p><p><font color="red">注：仅“不透明”对象（这些对象的材质和着色器设置为使用小于等于 2500 的渲染队列）会自动被渲染到深度纹理中</font></p><p>另外在这里还需要注意两点：屏幕后期处理Shader与物体自身Sahder采样的差异。</p><h3 id="屏幕后处理对深度图采样"><a href="#屏幕后处理对深度图采样" class="headerlink" title="屏幕后处理对深度图采样"></a>屏幕后处理对深度图采样</h3><p>屏幕后期处理Sahder采样方式比较简单，直接将i.uv传入采样函数，返回的即是屏幕对应位置的深度值。</p><p>片元处理函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float depth = Linear01Depth(tex2D(_CameraDepthTexture, i.uv).x);</span><br></pre></td></tr></table></figure><h3 id="物体对屏幕深度值采样"><a href="#物体对屏幕深度值采样" class="headerlink" title="物体对屏幕深度值采样"></a>物体对屏幕深度值采样</h3><p>不过若使用者是某个物体的Sahder，那么就不能直接通过uv去采用深度了；这也是理所当然，物体uv跟屏幕坐标可没有半分关系。<br>因此需要计算出顶点所在的屏幕空间坐标，然后将屏幕空间坐标当做uv对深度图进行采样。</p><p>Unity同样提供了对应函数<code>ComputeScreenPos(x)</code>，其中x是投影空间坐标。<br>在顶点处理函数传入片元数据结构体中，定义一个四维变量，调用该方法即可获取屏幕坐标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.screenPos=ComputeScreenPos(o.vertex);</span><br></pre></td></tr></table></figure><p>然后在片元处理函数中，进行纹理采样。<br>注意此处是使用tex2Dproj采样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float sceneZ = tex2Dproj(_CameraDepthTexture,i.screenPos).x;</span><br></pre></td></tr></table></figure><p>或者使用tex2D，手动除以w分量亦可：<br>(注：原因是uv采样值范围是[0,1]，因此计算出来的屏幕坐标需除以w分量映射至[0,1]区间)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float sceneZ = tex2D(_CameraDepthTexture,i.screenPos.xy/i.screenPos.w).x;</span><br></pre></td></tr></table></figure><p>直接将采样的深度值作为颜色输出效果：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-03-10-Sahder%E4%B8%AD%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%8F%8A%E5%BA%94%E7%94%A8_1.png" alt="物体采样(左)后处理屏幕采样(右)"><br>(物体采样(左)后处理屏幕采样(右))</p><h2 id="屏幕后处理对深度值的应用"><a href="#屏幕后处理对深度值的应用" class="headerlink" title="屏幕后处理对深度值的应用"></a>屏幕后处理对深度值的应用</h2><p>关于屏幕后处理对深度图的应用，最简单的，大约要数“扫描线”这种了。<br>单纯地对比当前深度值及距离，就可以做出一个效果，网络上大多数关于深度图的文章，似乎也是第一个就在讲这个。</p><p>因此，秉着从简单开始原则，我也来一份。</p><p>首先，为了简单起见，这里就不使用其它什么额外效果，直接定义两个所需的基础变量：</p><ul><li>_Depth 作为当前深度距离</li><li>_Width 作为扫描线的宽度</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_Width(&quot;Width&quot;,Float) = 0.1</span><br><span class="line">_Depth(&quot;Depth&quot;,Range(0,1)) = 0.1</span><br></pre></td></tr></table></figure><p>然后，在片元处理函数中，分别采样屏幕原图和深度图。<br>这时候就可以通过 _Depth参数 和深度图中的数值进行对比，计算结果。</p><p>判断标准是什么？</p><ul><li>深度值小于 _Depth</li><li>深度值大于 _Depth-_Width 形成宽度<br>在这个区间内，可以形成一条宽度 _Width 的横线</li></ul><p>如下代码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//采样屏幕原图</span><br><span class="line">float4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">//采样深度图</span><br><span class="line">float depth = Linear01Depth(tex2D(_CameraDepthTexture, i.uv).x);</span><br><span class="line">float distance = _Depth;</span><br><span class="line">//判断深度值是否处于当前设置的区间内</span><br><span class="line">if (depth &lt; distance &amp;&amp; depth&gt; distance - _Width) &#123;</span><br><span class="line">	return float4(1, 0, 0, 1)+col;</span><br><span class="line">&#125;</span><br><span class="line">return col;</span><br></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-03-10-Sahder%E4%B8%AD%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%8F%8A%E5%BA%94%E7%94%A8_2.gif" alt="最基础的效果"><br>(最基础的效果)</p><p>在这块代码中，判断当深度值处于当前设置区间内，则直接将红色与当前颜色融合，否则返回当前颜色。很简单的一个逻辑。</p><p>如果觉得这条横线的边太硬，想稍微加点效果的话，还可以根据当前颜色深度所处宽度比例，作边缘柔化处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float diff = 1 - (distance - depth) / _Width;</span><br><span class="line">return float4(1, 0, 0, 1)*diff+col;</span><br></pre></td></tr></table></figure><p>由于上面是深度位于 distance - _Width 区间才会进来，所以 distance - depth 取值范围为 [0,_Width]。<br>因此 distance - depth 便是当前所处区间的位置，除以宽度，得出当前所处位置的比例。根据比例逐步提高线条颜色值，可以形成一个简易的柔化效果。</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-03-10-Sahder%E4%B8%AD%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%8F%8A%E5%BA%94%E7%94%A8_3.png" alt="加柔边效果"><br>(加柔边效果)</p><p>屏幕后期处理中，上述只是最简单和基础的一个应用，深度图的作用还有做屏幕描边啊、模糊，做雾效等等，在此就不多说了。</p><h2 id="物体Shader对深度值的应用"><a href="#物体Shader对深度值的应用" class="headerlink" title="物体Shader对深度值的应用"></a>物体Shader对深度值的应用</h2><p>在物体Sahder中，如果需要获取深度图，那么一般来说，自身深度都是不写入深度图的，ZWrite通常为<code>ZWrite Off</code>。</p><p>因此主要有两个操作：</p><ul><li>计算自身深度值</li><li>采样自身位置原本深度值</li></ul><p>然后通过两者相差，进行深度比较执行其它逻辑。<br>最常见的例如水的Shader，在靠近岸边的时候波浪、渐变效果，物体相交检测等。应用方面，这里主要就说一下物体相交检测的效果。</p><p>为了计算自身深度，可以直接使用Unity提供函数COMPUTE_EYEDEPTH(x)，需要在顶点处理函数中调用，返回当前顶点深度值。</p><p>为了采样自身原本位置深度值，需要计算出当前顶点对应屏幕坐标，然后对深度图进行采样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v2f:</span><br><span class="line">	float4 screenPos: TEXCOORD3;</span><br><span class="line"></span><br><span class="line">vert:</span><br><span class="line">	o.screenPos = ComputeScreenPos(o.vertex);</span><br><span class="line">	COMPUTE_EYEDEPTH(o.screenPos.z);</span><br></pre></td></tr></table></figure><p>由于计算出来的屏幕坐标，z值实际上是没用的(投影纹理查询只用到xy/w)，因此可以直接将自己的深度值存放至screenPos的z值中，传入片元处理函数。</p><p>来到片元处理函数后，采样深度图中的深度值，并将其与物体当前深度值进行对比，直接输出，可得到如下效果：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-03-10-Sahder%E4%B8%AD%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%8F%8A%E5%BA%94%E7%94%A8_4.png" alt="效果"></p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//场景深度</span><br><span class="line">float sceneZ = LinearEyeDepth(tex2Dproj(_CameraDepthTexture,i.screenPos).x);</span><br><span class="line">//自身深度</span><br><span class="line">float selfZ = (i.screenPos.z);</span><br><span class="line">//取得差值</span><br><span class="line">float diff =  (sceneZ-selfZ );</span><br><span class="line">//输出差值</span><br><span class="line">return float4(diff, diff, diff,1);</span><br></pre></td></tr></table></figure><p>我们需要实现一个 相交描边 的效果，那么可以定义一个描边强度值<code>_OutLineValue(&quot;RimValue&quot;, Range(0,1)) = 0.1</code><br>大于该值输出描边颜色，否则可以输出黑色。<br>将直接返回深度差值修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return float4(step(diff, _OutLineValue) , 0, 0, 0.5);</span><br></pre></td></tr></table></figure><p>step为shder内置函数，step(diff, _OutLineValue)表示，当diff小于_OutLineValue时，返回1，diff大于_OutLineValue时，返回0。<br>直接当做R通道颜色放进去，可以方便低实现：深度值低于_OutLineValue显示红色描边 的需求。</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-03-10-Sahder%E4%B8%AD%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%8F%8A%E5%BA%94%E7%94%A8_5.png" alt="效果"></p><p>如此，最简单的一个 相交描边 效果就实现了，代码很简单，所以效果也很简陋。</p><p>为了优化点显示的话，可以加一点其它效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//场景深度</span><br><span class="line">float sceneZ = LinearEyeDepth(tex2Dproj(_CameraDepthTexture,i.screenPos).x);</span><br><span class="line">//自身深度</span><br><span class="line">float selfZ = (i.screenPos.z);</span><br><span class="line">//取得差值</span><br><span class="line">float diff =  (sceneZ-selfZ);</span><br><span class="line">//计算相交的描边强度</span><br><span class="line">float outLineStrenth =1- saturate(diff / _OutLineValue);</span><br><span class="line">//计算视线夹角，实现轮廓高亮</span><br><span class="line">float rimStrenth=1-abs(dot(i.normal, i.viewDir))*_RimValue;</span><br><span class="line">return float4(0,0,0,0.5)+float4(1,0,0,0)*max(outLineStrenth, rimStrenth);</span><br></pre></td></tr></table></figure><p>因为这里的物体是透明且双面显示，因此需要处理法线与视线为负的情况，这里直接将点乘结果转化为绝对值的正数。<br>最终返回值为半透明黑色叠加相交描边或轮廓颜色：在这里取两者最大值，可以保证相交和轮廓因为视角原因叠在一块的时候，可以优先展示程度更深的一方，效果更好。</p><p>另外外边缘轮廓还可以直接使用菲涅尔效果展示(比上面单纯视线和法线夹角好用，当然计算也稍微多一点)。</p><p>一般游戏中，使用的简化版菲涅尔公式为：</p><p>$$<br>fresnel=(1-(N \cdot V))^5*强度<br>$$</p><p>代码可修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float rim=pow(1-abs(dot(i.normal, i.viewDir)), 5)*_RimValue;</span><br></pre></td></tr></table></figure><p>当然，其中5这个定量也可以修改为变量，已进行更细致的效果调整。</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-03-10-Sahder%E4%B8%AD%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%8F%8A%E5%BA%94%E7%94%A8_6.png" alt="效果 直接轮廓高亮(左) 菲涅尔(右)"><br>(效果 直接轮廓高亮(左) 菲涅尔(右))</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是深度图最简答的两个不同应用。<br>这次也是一边实践一边Bing一边写，花了两天多时间，总算收尾了。<br>怎么说呢，这一趟下来，还是有收获的。之前虽然知道大概怎么做，但实际理解起来还是有点糊的，因为自己不理解的也不敢直接写，所以从易到难一遍想一边慢慢再实现一遍，至少很多之前不太理解的地方也算想通了。</p><p>后边除非许久不再研究这一块，就算忘了，看看自己写的文章，应该也能很快拾起来吧。</p><div class="tags-container-bottom"><i class="fa fa-tag pr3 text-main-color"></i><a class="fw3 ph1 dib" href="/tags/Shader/">#Shader</a></div><br><br><hr><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><div id="vcomments"></div><script>new Valine({el:"#vcomments",appId:"MsaVbSzIr9cIfikihDExdun9-gzGzoHsz",appKey:"Bj6SEFUBomrLOTWx9B8S6zQH",placeholder:"请输入评论内容~",avatar:"mp",visitor:!1})</script></div><div class="fl w-100 w-30-l center fw3 lh-copy pl4-ns tl black-50"><hr class="dn-l mw4 black-50 mt5"><div class="mt5 mt0-l site-author"><article class="dt db-l mw8 mw8-m mw5-ns center ml0-l bg-white mv3"><div class="dn dtc-m db-l v-mid tc pr4 pr0-l" style="min-width:6rem"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/photo.jpg" class="mb4-l br-100 h3 w3 h4-l w4-l dib" title="CWHISME"></div><div class="dtc db-l v-mid lh-copy measure center f6 black-50 tj">悲观主义的末日</div></article></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>分类</h3><p><a href="/categories/Unity3D/">Unity3D</a></p></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>近期文章</h3><p><a href="/2022/12/10/%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/">协变和逆变</a></p><p><a href="/2022/12/06/Unity%E7%9A%84%E9%98%B4%E5%BD%B1%E4%B8%8E%E5%85%89%E7%85%A7%E7%83%98%E7%84%99/">Unity 的阴影与光照烘焙</a></p><p><a href="/2022/11/23/%E6%89%93%E5%8C%85AssetBundle%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86/">打包 AssetBundle 的基础规则整理</a></p><p><a href="/2022/11/18/StringBuilder%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E7%A0%94%E7%A9%B6/">StringBuilder 扩容规则研究</a></p><p><a href="/2022/11/17/%E6%B5%8B%E8%AF%95%E6%89%8B%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">简单测试手动垃圾回收</a></p></div></div></div></div></div></div><div class="bg-1 ph2 ph5-ns pv5"><div class="mv8"><div class="center tc"><div class="dib mh3"><a class="f3 f2-ns white dim" href="https://github.com/CWHISME" target="_blank"><i class="fa fa-github"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="mailto:cwhisme@126.com" target="_blank"><i class="fa fa-envelope"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div></div><div class="f6 f5-ns center tc white pt5 fw3">Copyright © 2021 | Design & Hexo <a class="link dim white" target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-anodyne/">Jonathan Klughertz</a> | Modify By CWHISME</div></div></div></body></html>