<!DOCTYPE html><meta name="viewport" content="height=device-height,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=0"><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="cwhisme"><meta name="author" content="CWHISME"><meta property="og:title" content="代码调用TexturePacker打图集并生成动画"><meta property="og:description" content="cwhisme"><meta property="og:site_name" content="WangJiaYing"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><title>代码调用TexturePacker打图集并生成动画 - WangJiaYing</title><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/DateTimeAfeterCalc.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/particles-bg.js"></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/script.js"></script><link href="https://fastly.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/css/style.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tachyons@4.12.0/css/tachyons.min.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="WangJiaYing" type="application/atom+xml">
</head><body><canvas id="hackEffectCanvas" style="position:fixed;z-index:-1;pointer-events:none"></canvas><canvas class="fireworks" style="position:fixed;z-index:10;pointer-events:none"></canvas><div class="w-100 bg-1 ph5-ns ph3 text-light"><nav class="db dt-l w-100 mw8 center border-box pv3"><a class="db dtc-l v-mid link dim w-100 w-25-l tc tl-l mb2 mb0-l white" href="/" title="WangJiaYing"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/logo.svg" class="dib h3" alt="WangJiaYing"></a><div class="db dtc-l v-mid w-100 w-75-l tc tr-l"><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/" title="Home">Home </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/archives" title="Archives">Archives </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/tags" title="Tags">Tags </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/categories" title="Categories">Categories </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/bookmark" title="Bookmark">Bookmark </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/about" title="About">About</a></div></nav><div class="w-100 mw8 center vh-40 dt"><div class="dtc v-mid white"><h1 class="f1-l f2-m tc tc-m tl-ns">代码调用TexturePacker打图集并生成动画</h1><p class="f4 fw3 pab-100px tc tc-m tl-ns"><i class="fa fa-calendar-check-o" aria-hidden="true"></i> 2021-08-06&nbsp&nbsp <i class="fa fa-clock-o" aria-hidden="true"></i> <span id="dateTimeAfter">2021-08-06</span></p></div></div><div class="relative w-100 mw8 center white dn dn-m db-ns"><i class="header-icon fa fa-snowflake-o"></i></div></div><div class="w-100 ph2 ph4-m ph5-l mv5 mv6-l"><div class="content"><div class="mw8 center"><div class="cf"><div class="fl w-100 w-70-l mw7 left fw3 lh-copy pr4-ns pr0-m post-content"><div class="tags-container-vertical"><div class="tags-sub-container"><a class="fw3 ph1 dib" href="/tags/工具/">#工具</a></div></div><p>这几天给项目做了一个自动创建新兵种的工具，只需要提供符合规则格式的图片，即可一键自动生成新兵种战斗模型、布阵模型动画。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工具：</p><ul><li>Unity3D 2017.4.28f1</li><li>TexturePacker 3.0.9</li></ul><h3 id="战斗模型"><a href="#战斗模型" class="headerlink" title="战斗模型"></a>战斗模型</h3><p>我们项目这个版本(2.2.0)策划加了新兵种需求，根据兵种的进化情况，战斗中的兵种模型也是需要进行更换的。</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-08-06/1.png" alt="图片"></p><p>之前项目整个旧兵种也就固定的那几个，在拿到第一版的资源后，查了下并尝试了手动创建方式，还是有点麻烦。</p><p>手动操作步骤如下：</p><ul><li>复制一份老兵种</li><li>复制对应美术路径兵种图片到新目录</li><li>用 Texturepacker 打开，改生成图片、Json描述名字</li><li>手动打图集</li><li>手动改名</li><li>手动重新修改材质的图片引用</li><li>手动将json转化为二进制文件</li><li>手动修改兵种 Prefab 上的材质、二进制引用</li><li>等…</li></ul><h3 id="布阵动画模型"><a href="#布阵动画模型" class="headerlink" title="布阵动画模型"></a>布阵动画模型</h3><p>另外，除战斗中兵种模型外，还有外部布阵界面的展示模型：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-08-06/2.png" alt="图片"></p><p>布阵界面的动画模型，说是模型，实际上是5张不同动画的图片组成的帧动画，此处已有的功能结构使用了 Unity 自带的 Animation 创建动画，然后引用至 AnimatorController 进行播放使用。</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-08-06/3.png" alt="图片"></p><p>手动操作方式同样繁琐，手动机械化操作非常多。<br>其创建过程包括：</p><ul><li>放入新兵种图片</li><li>打图集</li><li>使用指定工具选定新图片及Json文本创建 Sprite 图集</li><li>拖出布阵模型 Prefab，打开Animation界面创建对应名字动画</li><li>动画设置为10帧，并选中之前打好的图集，每0.1秒手动拖拽一张图片形成动画<br><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-08-06/4.png" alt="图片"></li><li>保存动画，并将动画拖拽到AnimatorController中</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>开始策划只给了几个兵种，就感觉手累，特别是新需求一下增加了数以十计的模型需求，后续版本还会继续增加：<br><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-08-06/5.png" alt="图片"></p><p>手动处理了几个，就感觉不能这样下去了！太过于机械化且浪费时间，何况第一波是18个，根据功能计划，下个版本第二波可能就是36个了！</p><p>于是就想整个自动化工具，最好是一键选择资源目录，可以一条龙处理的，以做到不管后面是36个还是72个，都可以自动化完成，避免手动重复操作。因此有了这个工具的开发。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="战斗模型-1"><a href="#战斗模型-1" class="headerlink" title="战斗模型"></a>战斗模型</h3><p>对于战斗模型，原理很简单：拿了一份兵种当做『源』，类似于 Prefab，然后添加新兵种时，复制一份，然后自动处理机械化相关操作。</p><p>主要需要处理的是复制后，所属为『新兵种』模型的各个文件引用关系。</p><p>其创建一个兵种的代码被封装为一个方法，批量创建时只需要获取路径，循环调用即可。</p><hr><hr><p>代码主要就是将上述手动步骤修改为自动步骤，Copy 文件，改名、该引用之类的代码就不贴了，以下是调用 TexturePacker 打新图集的方式：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoCmd</span>(<span class="params"><span class="built_in">string</span> workingPath, <span class="built_in">string</span> cmd, <span class="built_in">float</span> defaulScale = <span class="number">0.6f</span>, <span class="built_in">float</span> reduceScale = <span class="number">0.05f</span>, <span class="built_in">int</span> retryCount = <span class="number">5</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> scale = defaulScale;</span><br><span class="line">    <span class="built_in">int</span> maxRetry = retryCount;</span><br><span class="line">    <span class="keyword">while</span> (DoCmd(_texturePackerCmdPath, workingPath, cmd + <span class="string">&quot; --scale &quot;</span> + scale) != <span class="number">0</span> &amp;&amp; maxRetry &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        maxRetry--;</span><br><span class="line">        scale -= reduceScale;</span><br><span class="line">    &#125;</span><br><span class="line">    UnityEngine.Debug.Log(cmd + <span class="string">&quot;  Scale:&quot;</span> + scale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">DoCmd</span>(<span class="params"><span class="built_in">string</span> fileName, <span class="built_in">string</span> workingPath, <span class="built_in">string</span> cmd</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Process process = <span class="keyword">new</span> Process();</span><br><span class="line">    process.StartInfo.FileName = fileName;</span><br><span class="line">    process.StartInfo.WorkingDirectory = workingPath;</span><br><span class="line">    process.StartInfo.Arguments = cmd;</span><br><span class="line">    <span class="comment">//process.StartInfo.RedirectStandardInput = true;</span></span><br><span class="line">    process.Start();</span><br><span class="line">    <span class="comment">//process.StandardInput.WriteLine(cmd);</span></span><br><span class="line">    process.WaitForExit();</span><br><span class="line">    <span class="keyword">return</span> process.ExitCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码通过每次调用 Texturepacker 进程结束标识，确定打出来的图集有没有问题？<br>这里的问题，主要是指图中要素过多，当前分辨率(1024x1024)装不下。<br>装不下怎么办呢？</p><p>看了下之前老的图集，是直接通过对图集进行部分缩放解决。</p><p>在此处自动化操作时，TexturePacker 打出来图集若出现此种情况，将会返回 10，若成功，则返回 0。</p><p>因此这里就可以针对 TexturePacker 进程结束的返回值进行额外判断，若返回非 0 ，则减少 Scale 参数并重试。</p><h3 id="布阵模型动画创建"><a href="#布阵模型动画创建" class="headerlink" title="布阵模型动画创建"></a>布阵模型动画创建</h3><p>布阵相关处理，每次都是创建新的动画文件，并添加至 AnimatorController 引用。<br>那些 Copy 原图、打图集、改引用的代码就不说，都是常规操作。</p><p>主要创建动画相关代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateFormationAnimationClip</span>(<span class="params"><span class="built_in">string</span> fileName, <span class="built_in">string</span> formationBlueTex</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> shortName = fileName.Replace(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> animPath = FileUtil.GetProjectRelativePath(Path.Combine(_troopformationPath, <span class="string">&quot;an/&quot;</span> + shortName + <span class="string">&quot;.anim&quot;</span>));</span><br><span class="line">    <span class="built_in">string</span> animControllerPath = FileUtil.GetProjectRelativePath(Path.Combine(_troopformationPath, <span class="string">&quot;buzhen_ctr.controller&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (File.Exists(animPath))</span><br><span class="line">        File.Delete(animPath);</span><br><span class="line">    <span class="comment">//创建动画片段</span></span><br><span class="line">    AnimationClip clip = <span class="keyword">new</span> AnimationClip();</span><br><span class="line"></span><br><span class="line">    List&lt;Sprite&gt; sprites = LoadFormationSprite(formationBlueTex, <span class="string">&quot;_&quot;</span> + fileName + <span class="string">&quot;_idle_&quot;</span>);</span><br><span class="line">    EditorCurveBinding curveBinding = <span class="keyword">new</span> EditorCurveBinding();</span><br><span class="line">    curveBinding.type = <span class="keyword">typeof</span>(UnityEngine.UI.Image);</span><br><span class="line">    curveBinding.path = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    curveBinding.propertyName = <span class="string">&quot;m_Sprite&quot;</span>;</span><br><span class="line">    ObjectReferenceKeyframe[] keyframes = <span class="keyword">new</span> ObjectReferenceKeyframe[sprites.Count];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; keyframes.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        keyframes[i] = <span class="keyword">new</span> ObjectReferenceKeyframe();</span><br><span class="line">        keyframes[i].time = i / <span class="number">10f</span>;</span><br><span class="line">        keyframes[i].<span class="keyword">value</span> = sprites[i];</span><br><span class="line">    &#125;</span><br><span class="line">    clip.frameRate = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    AnimationClipSettings clipSettings = AnimationUtility.GetAnimationClipSettings(clip);</span><br><span class="line">    clipSettings.loopTime = <span class="literal">true</span>;</span><br><span class="line">    AnimationUtility.SetAnimationClipSettings(clip, clipSettings);</span><br><span class="line">    AnimationUtility.SetObjectReferenceCurve(clip, curveBinding, keyframes);</span><br><span class="line">    AssetDatabase.CreateAsset(clip, animPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加至动画控制器</span></span><br><span class="line">    AnimatorController animatorController = AssetDatabase.LoadAssetAtPath&lt;AnimatorController&gt;(animControllerPath);</span><br><span class="line">    List&lt;AnimatorState&gt; stateRemoveTmp = <span class="keyword">new</span> List&lt;AnimatorState&gt;();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> animatorController.layers[<span class="number">0</span>].stateMachine.states)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.state.name == shortName) stateRemoveTmp.Add(item.state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> stateRemoveTmp)</span><br><span class="line">    &#123;</span><br><span class="line">        animatorController.layers[<span class="number">0</span>].stateMachine.RemoveState(item);</span><br><span class="line">    &#125;</span><br><span class="line">    AnimatorState state = animatorController.AddMotion(clip, <span class="number">0</span>);</span><br><span class="line">    state.name = shortName;</span><br><span class="line">    state.motion = clip;</span><br><span class="line">    state.speed = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//animatorController.layers[0].stateMachine.AddState(state, Vector3.up * animatorController.layers[0].stateMachine.states.Length * 50);</span></span><br><span class="line">    <span class="comment">//animatorController.layers[0].stateMachine.AddEntryTransition(state);</span></span><br><span class="line">    AssetDatabase.SaveAssets();</span><br><span class="line">    <span class="comment">//AssetDatabase.Refresh();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终生成效果如下：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-08-06/6.png" alt="图片"></p><h3 id="代码为-AnimatorController-添加动画的注意点"><a href="#代码为-AnimatorController-添加动画的注意点" class="headerlink" title="代码为 AnimatorController 添加动画的注意点"></a>代码为 AnimatorController 添加动画的注意点</h3><p>在使用编辑器对 AnimatorController 进行操作，添加新动画状态时，需要调用 AnimatorController 内置函数 AddMotion，直接传入 AnimationClip，该方法会自动创建一个 AnimatorState 并返回其示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnimatorState state = animatorController.AddMotion(clip, <span class="number">0</span>);</span><br><span class="line">state.name = shortName;</span><br><span class="line">state.motion = clip;</span><br><span class="line">state.speed = <span class="number">0.5f</span>;</span><br></pre></td></tr></table></figure><p>该方法创建的动画状态才能被正确保存至文件。</p><p>不能使用 New 的方式去创建，如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AnimatorState state = <span class="keyword">new</span> AnimatorState();</span><br><span class="line">state.name = shortName;</span><br><span class="line">state.motion = clip;</span><br><span class="line">state.speed = <span class="number">0.5f</span>;</span><br><span class="line">animatorController.layers[<span class="number">0</span>].stateMachine.AddState(state, Vector3.up * animatorController.layers[<span class="number">0</span>].stateMachine.states.Length * <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>这种方式看起来确实也能添加，但是仅限于『当前』，因为它不会改动到 AnimatorController 文件(至少经过个人尝试，Unity2017.4.28f1中是如此)，相当于在缓存中生成了一样，当重启Unity后，所做修改都会失效。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="最终界面"><a href="#最终界面" class="headerlink" title="最终界面"></a>最终界面</h3><p>所有功能完成后，再加上发现 Bug 进行修复并添加一些子单位功能后，最终界面如下：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-08-06/7.png" alt="图片"></p><ul><li>创建一个：选中一个目录，该目录下存在『红』、『蓝』文件夹，若同时存在『布阵』文件夹，则同时会创建布阵动画(可通过勾选 不生成布阵模型 取消)。</li><li>批量创建：选中一个目录，该目录下存在一系列子目录，子目录格式与上述 『创建一个』 格式一致，该选项会自动批量执行。</li><li>创建一个(布阵动画)：选中一个目录，该目录下存在『布阵』文件夹，程序根据其内图片生成布阵动画。</li><li>批量创建(布阵动画)：格式与 『批量创建』 一致，批量创建布阵动画</li><li>重打图集(布阵)：直接重打图集，不会生成动画</li><li>图集修复(布阵)：若最终图集出现错误(如精灵分割错误)，可以点击重新生成</li><li>重定向动画引用：这是在打完新图集，生成新动画后发现老动画出现问题而增加的选项——当时是由于图集使用图片进行额外优化了分辨率大小导致。该选项可以根据目录下的动画文件名字，重新去图集中获取对应图片生成新的动画及引用，一般没有使用需求。</li></ul><div class="tags-container-bottom"><i class="fa fa-tag pr3 text-main-color"></i><a class="fw3 ph1 dib" href="/tags/工具/">#工具</a></div><br><br><hr><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><div id="vcomments"></div><script>new Valine({el:"#vcomments",appId:"MsaVbSzIr9cIfikihDExdun9-gzGzoHsz",appKey:"Bj6SEFUBomrLOTWx9B8S6zQH",placeholder:"请输入评论内容~",avatar:"mp",visitor:!1})</script></div><div class="fl w-100 w-30-l center fw3 lh-copy pl4-ns tl black-50"><hr class="dn-l mw4 black-50 mt5"><div class="mt5 mt0-l site-author"><article class="dt db-l mw8 mw8-m mw5-ns center ml0-l bg-white mv3"><div class="dn dtc-m db-l v-mid tc pr4 pr0-l" style="min-width:6rem"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/photo.jpg" class="mb4-l br-100 h3 w3 h4-l w4-l dib" title="CWHISME"></div><div class="dtc db-l v-mid lh-copy measure center f6 black-50 tj">悲观主义的末日</div></article></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>分类</h3><p><a href="/categories/Unity3D/">Unity3D</a></p></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>近期文章</h3><p><a href="/2022/12/10/%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/">协变和逆变</a></p><p><a href="/2022/12/06/Unity%E7%9A%84%E9%98%B4%E5%BD%B1%E4%B8%8E%E5%85%89%E7%85%A7%E7%83%98%E7%84%99/">Unity 的阴影与光照烘焙</a></p><p><a href="/2022/11/23/%E6%89%93%E5%8C%85AssetBundle%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86/">打包 AssetBundle 的基础规则整理</a></p><p><a href="/2022/11/18/StringBuilder%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E7%A0%94%E7%A9%B6/">StringBuilder 扩容规则研究</a></p><p><a href="/2022/11/17/%E6%B5%8B%E8%AF%95%E6%89%8B%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">简单测试手动垃圾回收</a></p></div></div></div></div></div></div><div class="bg-1 ph2 ph5-ns pv5"><div class="mv8"><div class="center tc"><div class="dib mh3"><a class="f3 f2-ns white dim" href="https://github.com/CWHISME" target="_blank"><i class="fa fa-github"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="mailto:cwhisme@126.com" target="_blank"><i class="fa fa-envelope"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div></div><div class="f6 f5-ns center tc white pt5 fw3">Copyright © 2021 | Design & Hexo <a class="link dim white" target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-anodyne/">Jonathan Klughertz</a> | Modify By CWHISME</div></div></div></body></html>