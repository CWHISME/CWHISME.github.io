<!DOCTYPE html><meta name="viewport" content="height=device-height,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=0"><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="cwhisme"><meta name="author" content="CWHISME"><meta property="og:title" content="C#中的UDP与KCP的使用"><meta property="og:description" content="cwhisme"><meta property="og:site_name" content="WangJiaYing"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><title>C#中的UDP与KCP的使用 - WangJiaYing</title><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/DateTimeAfeterCalc.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/particles-bg.js"></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/script.js"></script><link href="https://fastly.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/css/style.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tachyons@4.12.0/css/tachyons.min.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="WangJiaYing" type="application/atom+xml">
</head><body><canvas id="hackEffectCanvas" style="position:fixed;z-index:-1;pointer-events:none"></canvas><canvas class="fireworks" style="position:fixed;z-index:10;pointer-events:none"></canvas><div class="w-100 bg-1 ph5-ns ph3 text-light"><nav class="db dt-l w-100 mw8 center border-box pv3"><a class="db dtc-l v-mid link dim w-100 w-25-l tc tl-l mb2 mb0-l white" href="/" title="WangJiaYing"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/logo.svg" class="dib h3" alt="WangJiaYing"></a><div class="db dtc-l v-mid w-100 w-75-l tc tr-l"><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/" title="Home">Home </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/archives" title="Archives">Archives </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/tags" title="Tags">Tags </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/categories" title="Categories">Categories </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/bookmark" title="Bookmark">Bookmark </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/about" title="About">About</a></div></nav><div class="w-100 mw8 center vh-40 dt"><div class="dtc v-mid white"><h1 class="f1-l f2-m tc tc-m tl-ns">C#中的UDP与KCP的使用</h1><p class="f4 fw3 pab-100px tc tc-m tl-ns"><i class="fa fa-calendar-check-o" aria-hidden="true"></i> 2021-06-26&nbsp&nbsp <i class="fa fa-clock-o" aria-hidden="true"></i> <span id="dateTimeAfter">2021-06-26</span></p></div></div><div class="relative w-100 mw8 center white dn dn-m db-ns"><i class="header-icon fa fa fa-globe"></i></div></div><div class="w-100 ph2 ph4-m ph5-l mv5 mv6-l"><div class="content"><div class="mw8 center"><div class="cf"><div class="fl w-100 w-70-l mw7 left fw3 lh-copy pr4-ns pr0-m post-content"><p>本文主要介绍 UDP 及 KCP 通讯的一个简单使用，目的是为『帧同步』战斗的实现作一个前置准备。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前不是提到了帧同步么，在那之后，或者说那时候就有想自己实现一个完整的帧同步战斗。不过后边又忙了忙项目任务，加上其它一些事情，也就搁置下来了。这两天项目 2.1.0 版本任务差不多，并且也开始出包了。今天周六，加班主要是给测试出出包，于是就想利用空余时间整理下，顺便写写东西。</p><p>帧同步战斗对网络性能要求一般会比较高，因为很『怕』延迟，所以一般都会采用 UDP 协议进行数据传输，后面有了 KCP 之后多了个选择(听说)。当然，不排除也有的游戏直接用 TCP 作为通讯协议，因为 TCP 虽然没前两者快，延迟可能更高，不过因为 TCP 必然会作为游戏通信基础协议，战斗也直接用 TCP 确实更简单一点。</p><p>由于 KCP 其实也是从 UDP 之上搭建的一个协议框架，因此这里先从 UDP 开始介绍吧。</p><p>注：虽然本文描述内容个人都进行过编码试验，不过限于个人水平，若有错漏，还请指正。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>众所周知，UDP 作为一个无连接协议，是只管发，不管接没接收到的。</p><p>不像 TCP，服务端必须监听客户端连接，然后建立连接才能相互通信。<br>作为 UDP，只需要监听指定端口，就能直接获取所有从该端口传入的数据。</p><p>因此性能上 UDP 会更好，但若是不管不顾的话，问题就是会出现数据包丢失。除非是视频流之类对丢包不敏感的东西，不然使用 UDP 的话，丢包问题都是需要自己解决的。</p><p>其使用方式主要有两种：</p><ol><li>直接使用 C# 提供的 UdpClient</li><li>采用Socket连接方式</li></ol><p>使用 UdpClient 的方式相对比较简单，因为其本身就是对 Socket 的一个封装，使得 UDP更好用一点。所单纯使用 UDP，采用该方式也是可以的。</p><h3 id="UdpClient"><a href="#UdpClient" class="headerlink" title="UdpClient"></a>UdpClient</h3><p>UdpClient 使用方式很简单，创建一个 UdpClient，然后调用 Connect 连接至需要发送的对象即可：</p><p>发送端：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Send Client</span></span><br><span class="line"><span class="keyword">using</span> (UdpClient udp = <span class="keyword">new</span> UdpClient())</span><br><span class="line">&#123;</span><br><span class="line">	udp.Connect(System.Net.IPAddress.Parse(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">4444</span>);</span><br><span class="line">	<span class="built_in">byte</span>[] sendBytes = Encoding.UTF8.GetBytes(<span class="string">&quot;Hello UdpClient!&quot;</span>);</span><br><span class="line">	udp.Send(sendBytes, sendBytes.Length);</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;已发送&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，UdpClient 的构造函数可以接收 IPEndPoint 或 端口号，代表的本地IP或端口号。<br>(关于构造函数参数，更多可参考<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.udpclient.-ctor?view=net-5.0">官方文档</a>)</p><p>经个人尝试，有以下规则：</p><ul><li>若构造函数指定了端口号(或IP)，UdpClient 本地地址将初始化为指定端口(IP)</li><li>若构造函数未指定端口号，则会在调用 Connect 时，自动将本地端口号初始化为一个随机值，IP初始化为本地IP<br><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-06-26/1.png"></li><li>仅作为发送端，可以不用指定初始化值</li><li>作为接收端，需要先指定过本地端口，或调用过会自动初始化本地地址的方法(如Connect)</li></ul><p>一般 IPEndPoint 倒不用特别注意，若仅仅只是发送数据，倒可以视情况而定，不过若作为数据接收者『接收端』则一般来说是需要指定的，或后续或调用过 Connect 方法，否则直接调用 Receive 方法将会抛出异常：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-06-26/2.png"></p><p>当然相互之间的通讯，除非能够有告诉另外的发送者，否则可能就没法准确接收数据了，这里特指 UdpClient 的方式，<br>除非另外一方使用 Socket 方式接收 UDP 数据，不过动态端口号中间也有操作余地的。</p><p>上面发送端并未指明本地端口，这里接收端则直接指定 4444 为接收端。</p><p>接收端：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Receve Server</span></span><br><span class="line"><span class="keyword">using</span> (UdpClient udp = <span class="keyword">new</span> UdpClient())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//udp.Connect(System.Net.IPAddress.Parse(&quot;127.0.0.1&quot;), 4444);</span></span><br><span class="line">	<span class="comment">//远程IP缓存，收到谁的信息，这个IP就会是谁的地址</span></span><br><span class="line">	System.Net.IPEndPoint ipRemote = <span class="keyword">new</span> System.Net.IPEndPoint(System.Net.IPAddress.Any, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">byte</span>[] receiveBytes = udp.Receive(<span class="keyword">ref</span> ipRemote);</span><br><span class="line">	Console.WriteLine(<span class="string">$&quot;收到来自 <span class="subst">&#123;ipRemote&#125;</span> 的信息：<span class="subst">&#123;Encoding.UTF8.GetString(receiveBytes)&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure><p>测试效果：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-06-26/3.png"></p><p>可以看见，发送端的端口被打印出来，也是属于一个随机端口。</p><p>另外可以注意到，接收端在打印接收信息之前，也打印了一个“已发送”的信息</p><p>这是因为方便测试，上述接收和发送代码放在了一块用：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Send Client</span></span><br><span class="line"><span class="keyword">using</span> (UdpClient udp = <span class="keyword">new</span> UdpClient())</span><br><span class="line">&#123;</span><br><span class="line">	udp.Connect(System.Net.IPAddress.Parse(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">4444</span>);</span><br><span class="line">	<span class="built_in">byte</span>[] sendBytes = Encoding.UTF8.GetBytes(<span class="string">&quot;Hello UdpClient!&quot;</span>);</span><br><span class="line">	udp.Send(sendBytes, sendBytes.Length);</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;已发送&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Receve Server</span></span><br><span class="line"><span class="keyword">using</span> (UdpClient udp = <span class="keyword">new</span> UdpClient(<span class="number">4444</span>))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//远程IP缓存，收到谁的信息，这个IP就会是谁的地址</span></span><br><span class="line">	System.Net.IPEndPoint ipRemote = <span class="keyword">new</span> System.Net.IPEndPoint(System.Net.IPAddress.Any, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">byte</span>[] receiveBytes = udp.Receive(<span class="keyword">ref</span> ipRemote);</span><br><span class="line">	Console.WriteLine(<span class="string">$&quot;收到来自 <span class="subst">&#123;ipRemote&#125;</span> 的信息：<span class="subst">&#123;Encoding.UTF8.GetString(receiveBytes)&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure><p>因为接收端收到信息就会释放掉当前端口占用，因此通信完成后新的发送端又会成为接收端。(虽然并没有什么用，不过方便测试，测试时，双击两次执行文件就可以得出运行结果了)</p><h3 id="Socket方式"><a href="#Socket方式" class="headerlink" title="Socket方式"></a>Socket方式</h3><p>Socket 方式是比 UdpClient 更底层的使用方式，相比 UdpClient 来说，相对来说会自由一点。</p><p>向指定地址及指定端口(本机4444端口)发送数据：</p><p>···cs<br>using (Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp))<br>{<br>socket.Connect(“127.0.0.1”, 4444);<br>socket.Send(Encoding.UTF8.GetBytes(Console.ReadLine()));<br>}<br>···</p><p>监听本机指定端口(本机4444端口)数据：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (Socket socket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp))</span><br><span class="line">&#123;</span><br><span class="line">    socket.Bind(<span class="keyword">new</span> System.Net.IPEndPoint(System.Net.IPAddress.Any, <span class="number">4444</span>));</span><br><span class="line">    <span class="built_in">byte</span>[] buff = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">int</span> num = socket.Receive(buff);</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Encoding.UTF8.GetString(buff, <span class="number">0</span>, num));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;接收完毕！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处发送跟 UdpClient 没有太大差异，都很简单，需要注意的是接收端，Socket 方式需要像 TCP 一样指定接收的缓存字节数组，而且位于接收缓存中的内容也需要自己判断读取，若缓存不够，一次不一定能读取完。关于这点后续再谈，这里直接简单地设置一个1024byte大小的缓冲数组用于接受数据。</p><hr><p>另外为了方便起见，个人直接写了个简单的测试代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Start:</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;输入1初始化为服务端，2初始化为发送端&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> key = Console.ReadKey();</span><br><span class="line">    <span class="comment">//服务器</span></span><br><span class="line">    <span class="keyword">if</span> (key.Key == ConsoleKey.D1)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;已初始化为服务端&quot;</span>);</span><br><span class="line">        <span class="keyword">using</span> (Socket socket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp))</span><br><span class="line">        &#123;</span><br><span class="line">            socket.Bind(<span class="keyword">new</span> System.Net.IPEndPoint(System.Net.IPAddress.Any, <span class="number">4444</span>));</span><br><span class="line">        Server:</span><br><span class="line">            <span class="built_in">byte</span>[] buff = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="built_in">int</span> num = socket.Receive(buff);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(Encoding.UTF8.GetString(buff, <span class="number">0</span>, num));</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;接收完毕！\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> Server;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送端</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key.Key == ConsoleKey.D2)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;已初始化为发送端&quot;</span>);</span><br><span class="line">        <span class="keyword">using</span> (Socket socket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp))</span><br><span class="line">        &#123;</span><br><span class="line">            socket.Connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">4444</span>);</span><br><span class="line">        Sender:</span><br><span class="line">            socket.Send(Encoding.UTF8.GetBytes(Console.ReadLine()));</span><br><span class="line">            <span class="keyword">goto</span> Sender;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;输入错误!&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> Start;</span><br></pre></td></tr></table></figure><p>(方便测试，这里就不要在意使用Goto了)<br>效果如下：<br><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-06-26/4.png"></p><p>最基础的发送和接收就是如此，不过如果单纯使用 UDP ，过程中还需要自己另外处理丢包，重发等处理。<br>后续介绍的 KCP ，则相当于在此基础上，实现了这一类功能。</p><p>另外 KCP 的 Socket 使用方式，还有直接调用 『SendTo』 或 『ReceiveFrom』 方法，不过一般不建议那种使用方式。</p><h2 id="KCP"><a href="#KCP" class="headerlink" title="KCP"></a>KCP</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>根据说明：</p><blockquote><p>KCP是一个快速可靠协议，能以比 TCP 浪费 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，以 callback的方式提供给 KCP。 连时钟都需要外部传递进来，内部不会有任何一次系统调用。</p></blockquote><p>更多介绍可参考 KCP的 <a target="_blank" rel="noopener" href="https://github.com/skywind3000/kcp">Git地址</a><br>（注：这是C语言版本）</p><p>根据描述来看，感觉 KCP 有点类似于空间换时间，流量换效率的模式。</p><p>C# 如果使用C语言版本用就有点麻烦了，这里就直接使用其C#移植版。在 readme 中也有好几个实现的项目链接，这里个人选择了 <a target="_blank" rel="noopener" href="https://github.com/limpo1989/kcp-csharp">KCPSharp</a></p><h3 id="KCPSharp-UDPSession-的问题"><a href="#KCPSharp-UDPSession-的问题" class="headerlink" title="KCPSharp UDPSession 的问题"></a>KCPSharp UDPSession 的问题</h3><p>注：这个KCPSharp虽然提供的 UDPSession 但是稍微有点坑，直接是没法开箱即用的。<br>因此还有个问题就是项目提供的示例 Demo 也没法正常使用(虽然不知道作者知不知道)。</p><p>UDPSession 中问题主要有以下几点：</p><ul><li>Connect 使用 Dns.GetHostEntry(host) 获取本地地址，实测传入127.0.0.1获取到的将会是IPV6地址</li><li>会话标识(conv)是直接传入一个随机数，，导致两个 UDPSession 之间都没法正常通信</li><li>仅提供发送者 Connect 初始化方法，建立的Socket本地端口随机，没有初始作为监听者方法</li></ul><h4 id="默认提供的连接方法"><a href="#默认提供的连接方法" class="headerlink" title="默认提供的连接方法"></a>默认提供的连接方法</h4><p>看连接结构(KCPSharp提供的UDPSession)：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Connect</span>(<span class="params"><span class="built_in">string</span> host, <span class="built_in">int</span> port</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IPHostEntry hostEntry = Dns.GetHostEntry(host);</span><br><span class="line">    <span class="keyword">if</span> (hostEntry.AddressList.Length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Unable to resolve host: &quot;</span> + host);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> endpoint = hostEntry.AddressList[<span class="number">0</span>];</span><br><span class="line">    mSocket = <span class="keyword">new</span> Socket(endpoint.AddressFamily, SocketType.Dgram, ProtocolType.Udp);</span><br><span class="line">    mSocket.Connect(endpoint, port);</span><br><span class="line">    RemoteAddress = (IPEndPoint)mSocket.RemoteEndPoint;</span><br><span class="line">    LocalAddress = (IPEndPoint)mSocket.LocalEndPoint;</span><br><span class="line">    mKCP = <span class="keyword">new</span> KCP((<span class="built_in">uint</span>)(<span class="keyword">new</span> Random().Next(<span class="number">1</span>, Int32.MaxValue)), rawSend);</span><br><span class="line">    <span class="comment">// normal:  0, 40, 2, 1</span></span><br><span class="line">    <span class="comment">// fast:    0, 30, 2, 1</span></span><br><span class="line">    <span class="comment">// fast2:   1, 20, 2, 1</span></span><br><span class="line">    <span class="comment">// fast3:   1, 10, 2, 1</span></span><br><span class="line">    mKCP.NoDelay(<span class="number">0</span>, <span class="number">30</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    mKCP.SetStreamMode(<span class="literal">true</span>);</span><br><span class="line">    mRecvBuffer.Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果自己添加一个监听者直接使用，在KCP接收层，Input方法中，ikcp_decode32u 解析的时候判断会话标识不一致，都会直接返回-1(不信<code>Random().Next(1, Int32.MaxValue)</code>这种方法还能让标识一致的？)</p><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>这里先修改一下这个连接方法，使其可以接受一个 conv 的外部参数，修正即便是两个同一个类创建的 UDPSession 都无法正确通信问题：<br>(顺便将字符串IP和端口换成了 IPEndPoint)</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Connect</span>(<span class="params">IPEndPoint remoteIP, <span class="built_in">uint</span> conv = <span class="number">1</span></span>)</span></span><br></pre></td></tr></table></figure><p>由于 KCP 在正确收到消息后，默认会有一个回复数据包消息发回发送端。<br>因此如果像上文 UDP 那般，仅绑定本地接收端口来接收数据，数据确实能够接收到，但是由于没有 remoteEP,后续发送回复数据包时就会报错了(后续修改的时候把代码改)。</p><p>而且，还有一个问题：</p><p><strong>此时仅有可以发送的连接端，由于调用该接口仅绑定远程主机，本机地址端口号将会随机生成，根本没法正确确定接收信息端口。</strong></p><p>为此，可以仿照上文 UdpClient 使用方法，给 UDPSession 增加一个构造函数，使其可以初始化本地地址或端口号：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UDPSession</span>(<span class="params">IPEndPoint localIP</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mSocket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);</span><br><span class="line">    mSocket.Bind(localIP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UDPSession</span>(<span class="params"><span class="built_in">int</span> port</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mSocket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);</span><br><span class="line">    mSocket.Bind(<span class="keyword">new</span> IPEndPoint(IPAddress.Any, port));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Connect</span>(<span class="params">IPEndPoint remoteIP, <span class="built_in">uint</span> conv = <span class="number">1</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mSocket.Connect(remoteIP);</span><br><span class="line">    InitKcp(conv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，使用如下测试代码即可进行本机同一客户端自我通信：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    UDPSession session = <span class="keyword">new</span> UDPSession(<span class="number">4444</span>);</span><br><span class="line">    session.Connect(<span class="keyword">new</span> System.Net.IPEndPoint(System.Net.IPAddress.Parse(<span class="string">&quot;192.168.9.76&quot;</span>), <span class="number">4444</span>));</span><br><span class="line">    <span class="built_in">byte</span>[] bytes = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line">Server:</span><br><span class="line">    session.Update();</span><br><span class="line">    <span class="built_in">int</span> num = session.Recv(bytes, <span class="number">0</span>, bytes.Length);</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span>)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;收到信息：&quot;</span> + Encoding.UTF8.GetString(bytes, <span class="number">0</span>, num));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">-1</span>) Console.WriteLine(<span class="string">&quot;监听错误！&quot;</span>);</span><br><span class="line">    session.Send(Encoding.UTF8.GetBytes(Console.ReadLine()));</span><br><span class="line">    <span class="keyword">goto</span> Server;</span><br></pre></td></tr></table></figure><p>其中需要注意的是 Update 调用，KCP 需要这个更新内部时钟，缓存列表数据的发送处理等等。<br>虽然在 KCPSharp 提供的 UDPSession 发送接口中，默认处理了等待发送缓存数据及 NoDelay 的判断，通过即会立即发送数据，不过 Update 在其它处理还是必要的。</p><p>例如将 <code>session.WriteDelay = true</code> 设置为true，那么不调用 update 就无法正常发送数据。</p><p>效果：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-06-26/5.png"></p><p>这个程序拿到同一局域网其它电脑上，也是可以连上并通信的，不过需要注意的是：此处虽然接收数据做了处理，一般不会导致线程阻塞，不过在调用 Console.ReadLine 会由于需求用户输入而导致阻塞。另外还有同一台主机开不了两个实例(端口被占用)。</p><p>不同主机之间，就得按下回车，才能正确读取到接收信息了。可以优化一下，放在另外线程即可。</p><h5 id="关于同时-Bind-与-Connect-的问题"><a href="#关于同时-Bind-与-Connect-的问题" class="headerlink" title="关于同时 Bind 与 Connect 的问题"></a>关于同时 Bind 与 Connect 的问题</h5><p><font color="red">注：如果同时调用 Bind() 与 Connect()，则代表仅接收 Connect 对象的数据，其它任何数据，都将直接丢弃！</font><br>参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9741392/can-you-bind-and-connect-both-ends-of-a-udp-connection">StackOverflow: Can you bind() and connect() both ends of a UDP connection</a></p><p>由于 KCP 需求回复数据包，相当于说就是点对点类型的意思了。</p><p>因此默认除非真的写死点对点，否则都是需要另外传入参数，例如采用 TCP 传入端口号进行初始化连接。</p><p>可以看到，直接的使用方式，KCP 与 UDP 差异不是很大，主要原因在于 UDPSession 可以说是把更新方法、发送判断又封装了一层，KCP 核心其实就 KCP.cs、ByteBuffer.cs 这两个类。虽然封装的 UDPSession 用起来也有点问题，不过改了下就跟上文的 UDPClient 使用方式差不多了。</p><p>不过，由于 回复包存在的缘故，KCP必须在发送消息前相互都『知道』对方的IP和端口，这就导致其无法完全独立运行<br>例如：同一台主机只能存在一个实例，因为在一个实例 Bind 占用了端口号之后另一个实例就无法绑定同一端口号了。此时应当需要额外作处理区分，例如像 UdpClient 一样，使其可以接收不同连接而来的数据，而非一个连接。猜测 UdpClient 可能就用了ReceiveFrom 一类的方法，当然，此种情况就后续再说了。</p><hr><p>后来想起来，C#是可以反编的，于是用 dnSpy 查看了一下，还真是如此：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token: 0x060021EF RID: 8687 RVA: 0x000A24B0 File Offset: 0x000A06B0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">byte</span>[] <span class="title">Receive</span>(<span class="params"><span class="keyword">ref</span> IPEndPoint remoteEP</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.m_CleanedUp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ObjectDisposedException(<span class="keyword">base</span>.GetType().FullName);</span><br><span class="line">	&#125;</span><br><span class="line">	EndPoint endPoint;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.m_Family == AddressFamily.InterNetwork)</span><br><span class="line">	&#123;</span><br><span class="line">		endPoint = IPEndPoint.Any;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		endPoint = IPEndPoint.IPv6Any;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">int</span> num = <span class="keyword">this</span>.Client.ReceiveFrom(<span class="keyword">this</span>.m_Buffer, <span class="number">65536</span>, SocketFlags.None, <span class="keyword">ref</span> endPoint);</span><br><span class="line">	remoteEP = (IPEndPoint)endPoint;</span><br><span class="line">	<span class="built_in">byte</span>[] array = <span class="keyword">new</span> <span class="built_in">byte</span>[num];</span><br><span class="line">	Buffer.BlockCopy(<span class="keyword">this</span>.m_Buffer, <span class="number">0</span>, array, <span class="number">0</span>, num);</span><br><span class="line">	<span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文只是对 UDP 和 KCP 使用的一个最基础的介绍，后续的修改和使用或许也会写一写。</p><p>今天已经29号周二了，还是挺费时间，主要是一边写，还得一边尝试，不确定的地方也不敢直接下结论，查资料和实验起来比较麻烦。</p><p>写这篇文章的主要原因，其实是因为为我在将 KCPSharp 嵌入自己之前提到的自己搞的一个网络通信结构(就之前考虑做项目远程打包模式时候弄的那个)的时候出了点问题，出现了发送/接收失败的问题(其实就是上文提到的一些坑的问题：conv为随机值，接收数据返回-1等)。</p><p>由于结构已经有点复杂，所以不好找问题，因此就就想新开一个项目，然后完全重新尝试。于是就有了本文以及本文的操作。</p><p>下一步就是将这修改后的代码，放进我自己的那个框架，使其能够正常使用。然后搞一个简单的帧同步战斗。</p><p>再然后，是利用 <a target="_blank" rel="noopener" href="https://github.com/egametang/ET">ET</a> 框架，做一个比较完整的游戏流程。毕竟自己的这个小东西，就单纯只是一个玩具而已，特别是最近从基础开始在复习了一下编程理念，感觉以后还是要重构一下。不过这个还是等那些过完了再说。</p><hr><p>参考文章：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.net.sockets.udpclient?view=net-5.0">C#官方文档</a></li><li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9741392/can-you-bind-and-connect-both-ends-of-a-udp-connection">StackOverflow: Can you bind() and connect() both ends of a UDP connection</a></li><li><a target="_blank" rel="noopener" href="http://www.skywind.me/blog/archives/1048">快速可靠协议-KCP</a></li><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56561293">KCP 源码阅读</a></li><li><a target="_blank" rel="noopener" href="https://chenqinghe.com/?p=25">KCP 协议详解</a></li><li><a target="_blank" rel="noopener" href="https://github.com/szhnet/kcp-netty/issues/6">咨询关于conv值和stream模式的问题</a></li><li><a target="_blank" rel="noopener" href="https://github.com/skywind3000/kcp/issues/100">https://github.com/skywind3000/kcp/issues/100</a></li><li><a target="_blank" rel="noopener" href="https://github.com/skywind3000/kcp/blob/master/README.md">KCP Readme</a></li></ul><br><br><hr><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><div id="vcomments"></div><script>new Valine({el:"#vcomments",appId:"MsaVbSzIr9cIfikihDExdun9-gzGzoHsz",appKey:"Bj6SEFUBomrLOTWx9B8S6zQH",placeholder:"请输入评论内容~",avatar:"mp",visitor:!1})</script></div><div class="fl w-100 w-30-l center fw3 lh-copy pl4-ns tl black-50"><hr class="dn-l mw4 black-50 mt5"><div class="mt5 mt0-l site-author"><article class="dt db-l mw8 mw8-m mw5-ns center ml0-l bg-white mv3"><div class="dn dtc-m db-l v-mid tc pr4 pr0-l" style="min-width:6rem"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/photo.jpg" class="mb4-l br-100 h3 w3 h4-l w4-l dib" title="CWHISME"></div><div class="dtc db-l v-mid lh-copy measure center f6 black-50 tj">悲观主义的末日</div></article></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>分类</h3><p><a href="/categories/网络开发/">网络开发</a></p></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>近期文章</h3><p><a href="/2022/12/10/%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/">协变和逆变</a></p><p><a href="/2022/12/06/Unity%E7%9A%84%E9%98%B4%E5%BD%B1%E4%B8%8E%E5%85%89%E7%85%A7%E7%83%98%E7%84%99/">Unity 的阴影与光照烘焙</a></p><p><a href="/2022/11/23/%E6%89%93%E5%8C%85AssetBundle%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86/">打包 AssetBundle 的基础规则整理</a></p><p><a href="/2022/11/18/StringBuilder%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E7%A0%94%E7%A9%B6/">StringBuilder 扩容规则研究</a></p><p><a href="/2022/11/17/%E6%B5%8B%E8%AF%95%E6%89%8B%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">简单测试手动垃圾回收</a></p></div></div></div></div></div></div><div class="bg-1 ph2 ph5-ns pv5"><div class="mv8"><div class="center tc"><div class="dib mh3"><a class="f3 f2-ns white dim" href="https://github.com/CWHISME" target="_blank"><i class="fa fa-github"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="mailto:cwhisme@126.com" target="_blank"><i class="fa fa-envelope"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div></div><div class="f6 f5-ns center tc white pt5 fw3">Copyright © 2021 | Design & Hexo <a class="link dim white" target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-anodyne/">Jonathan Klughertz</a> | Modify By CWHISME</div></div></div></body></html>