<!DOCTYPE html><meta name="viewport" content="height=device-height,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=0"><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="cwhisme"><meta name="author" content="CWHISME"><meta property="og:title" content="Unity3D Sahder 关键字"><meta property="og:description" content="cwhisme"><meta property="og:site_name" content="WangJiaYing"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><title>Unity3D Sahder 关键字 - WangJiaYing</title><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/DateTimeAfeterCalc.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/particles-bg.js"></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/script.js"></script><link href="https://fastly.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/css/style.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tachyons@4.12.0/css/tachyons.min.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="WangJiaYing" type="application/atom+xml">
</head><body><canvas id="hackEffectCanvas" style="position:fixed;z-index:-1;pointer-events:none"></canvas><canvas class="fireworks" style="position:fixed;z-index:10;pointer-events:none"></canvas><div class="w-100 bg-1 ph5-ns ph3 text-light"><nav class="db dt-l w-100 mw8 center border-box pv3"><a class="db dtc-l v-mid link dim w-100 w-25-l tc tl-l mb2 mb0-l white" href="/" title="WangJiaYing"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/logo.svg" class="dib h3" alt="WangJiaYing"></a><div class="db dtc-l v-mid w-100 w-75-l tc tr-l"><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/" title="Home">Home </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/archives" title="Archives">Archives </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/tags" title="Tags">Tags </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/categories" title="Categories">Categories </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/bookmark" title="Bookmark">Bookmark </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/about" title="About">About</a></div></nav><div class="w-100 mw8 center vh-40 dt"><div class="dtc v-mid white"><h1 class="f1-l f2-m tc tc-m tl-ns">Unity3D Sahder 关键字</h1><p class="f4 fw3 pab-100px tc tc-m tl-ns"><i class="fa fa-calendar-check-o" aria-hidden="true"></i> 2021-01-26&nbsp&nbsp <i class="fa fa-clock-o" aria-hidden="true"></i> <span id="dateTimeAfter">2021-01-26</span></p></div></div><div class="relative w-100 mw8 center white dn dn-m db-ns"><i class="header-icon fa fa-snowflake-o"></i></div></div><div class="w-100 ph2 ph4-m ph5-l mv5 mv6-l"><div class="content"><div class="mw8 center"><div class="cf"><div class="fl w-100 w-70-l mw7 left fw3 lh-copy pr4-ns pr0-m post-content"><div class="tags-container-vertical"><div class="tags-sub-container"><a class="fw3 ph1 dib" href="/tags/Shader/">#Shader</a></div></div><p>用于记录Unity3D的Shader关键字、或内置函数、变量等，便于查询，视情况修改。</p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>[Attribute]_Name (“Display Name”,Type) = Default Value</p><h3 id="类型-Type"><a href="#类型-Type" class="headerlink" title="类型(Type)"></a>类型(Type)</h3><ul><li>Color 颜色</li><li>Int 整数</li><li>Float、[Range(Min,Max)] 浮点数</li><li>Vector 四维向量</li><li>2D 纹理（默认值：white、black、grey、bump）</li><li>3D 纹理</li><li>Cube 立方体纹理</li></ul><h3 id="属性-Attribute）"><a href="#属性-Attribute）" class="headerlink" title="属性(Attribute）"></a>属性(Attribute）</h3><ul><li>HDR：用于Color类型，将颜色取色器设置为支持HDR类型</li><li>PowerSlider(Value)：用于Int或Float类型，调整材质面板上滑杆拉动效果，对拉动值区间微调</li><li>IntRange：当标记给Range(Min,Max)类型时，会导致材质面板只能拖动整数值</li><li>Toggle：开关，用于Int或Float类型，0代表关，1代表开</li><li>Enum(C#中的枚举类型)：枚举，用于Int或Float类型</li><li>NoScaleOffset：用于纹理类型，取消面板Tiling 、Offset 的设置选项</li><li>Normal：用于2D纹理类型，标记图片必须为法线贴图</li><li>HideInInspector：在面板隐藏</li><li>MainTexture： 表示一个属性 (property) 是材质的主纹理。默认情况下，Unity 将属性 (property) 名称为 _MainTex 的纹理视为主纹理。</li><li>MainColor：表示一个属性 (property) 是材质的主色。默认情况下，Unity 将属性 (property) 名称为 _Color 的颜色视为主色。</li><li>Gamma：用于Float 或 Vector，因为：如果是普通的 Color 属性，使用线性颜色空间时，所有材质颜色属性均以 sRGB 颜色提供，但在传递到着色器时会转换为线性值，该标记会使得Float 或 Vector也进行颜色空间转换。</li></ul><h3 id="纹理特殊说明"><a href="#纹理特殊说明" class="headerlink" title="纹理特殊说明"></a>纹理特殊说明</h3><h4 id="纹理平铺和偏移"><a href="#纹理平铺和偏移" class="headerlink" title="纹理平铺和偏移"></a>纹理平铺和偏移</h4><p>材质通常具有其纹理属性的 Tiling 和 Offset 字段。此信息将传递到着色器中的 float4 {TextureName}_ST 属性：</p><ul><li>x 包含 X 平铺值</li><li>y 包含 Y 平铺值</li><li>z 包含 X 偏移值</li><li>w 包含 Y 偏移值</li></ul><p>例如，如果着色器包含名为 _MainTex 的纹理，则平铺信息将位于 _MainTex_ST 矢量中。</p><h4 id="纹理大小"><a href="#纹理大小" class="headerlink" title="纹理大小"></a>纹理大小</h4><p>{TextureName}_TexelSize - float4 属性包含纹理大小信息：</p><ul><li>x 包含 1.0/宽度</li><li>y 包含 1.0/高度</li><li>z 包含宽度</li><li>w 包含高度</li></ul><h4 id="纹理-HDR-参数"><a href="#纹理-HDR-参数" class="headerlink" title="纹理 HDR 参数"></a>纹理 HDR 参数</h4><p>{TextureName}_HDR - 一个 float4 属性，其中包含有关如何根据所使用的颜色空间解码潜在 HDR（例如 RGBM 编码）纹理的信息。</p><h4 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;TA/NewUnlitShader&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">	Properties</span><br><span class="line">	&#123;</span><br><span class="line">		[HDR]_Color(<span class="string">&quot;Color&quot;</span>,COLOR) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">		[IntRange]_Int(<span class="string">&quot;It&#x27;s Int&quot;</span>,Range(<span class="number">0</span>,<span class="number">5</span>)) = <span class="number">1</span></span><br><span class="line">		_Float(<span class="string">&quot;It&#x27;s Float&quot;</span>,Float) = <span class="number">1</span></span><br><span class="line">		_Vector(<span class="string">&quot;It&#x27;s Vector&quot;</span>,Vector)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">		[NoScaleOffset]_Texture2D(<span class="string">&quot;2D Texture&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">		[NoScaleOffset]_Texture3D(<span class="string">&quot;3D Texture&quot;</span>,<span class="number">3</span>D) = <span class="string">&quot;&quot;</span>&#123;&#125;</span><br><span class="line">		[NoScaleOffset]_TextureCube(<span class="string">&quot;Cube Texture&quot;</span>,Cube) = <span class="string">&quot;&quot;</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">		Pass&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    Fallback <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">    CustomEditor <span class="string">&quot;EditorName&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="Shader变量"><a href="#Shader变量" class="headerlink" title="Shader变量"></a>Shader变量</h3><ul><li><p>float：32位浮点数，完整的 float 精度通常用于世界空间位置、纹理坐标或涉及复杂函数（如三角函数或幂/取幂）的标量计算。</p></li><li><p>half：16位浮点数，范围为 –60000 至 +60000，精度约为 3 位小数；一般用于短矢量、方向、对象空间位置、高动态范围颜色。</p></li><li><p>fixed：11位定点数，范围从 –2.0 到 +2.0，精度为 1/256；一般用于常规颜色（通常存储在常规纹理中）以及对它们执行简单运算。</p></li><li><p>int：32位整型；通常用作循环计数器或数组索引。</p></li><li><p>float4、float4x4：复合矢量/矩阵类型(half亦同)</p></li><li><p>sampler2D、sampler3D、samplerCUBE：纹理使用(亦有 sampler2D_half、sampler2D_float)<br>若使用默认纹理，在移动平台纹理会被自动转换成低精度的纹理类型，如果需要半精度的或者高精度的便需要用以下方式来声明：</p><p>sampler2D_half、<br>sampler2D_float、<br>sampler3D_half、<br>sampler3D_float、<br>samplerCUBE_halft、<br>samplerCUBE_float</p></li></ul><p>一般的经验法则是全部都从半精度开始（但位置和纹理坐标除外）。仅当半精度对于计算的某些部分不足时，才增加精度。</p><h3 id="向顶点程序提供的顶点数据"><a href="#向顶点程序提供的顶点数据" class="headerlink" title="向顶点程序提供的顶点数据"></a>向顶点程序提供的顶点数据</h3><ul><li>POSITION 是顶点位置，通常为 float3 或 float4。</li><li>NORMAL 是顶点法线，通常为 float3。</li><li>TEXCOORD0 是第一个 UV 坐标，通常为 float2、float3 或 float4。</li><li>TEXCOORD1、TEXCOORD2 和 TEXCOORD3 分别是第 2、第 3 和第 4 个 UV 坐标。</li><li>TANGENT 是切线矢量（用于法线贴图），通常为 float4。</li><li>COLOR 顶点颜色，通常为 float4。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">appdata_full</span> &#123;</span></span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float4 tangent : TANGENT;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">    float4 texcoord : TEXCOORD0;</span><br><span class="line">    float4 texcoord1 : TEXCOORD1;</span><br><span class="line">    float4 texcoord2 : TEXCOORD2;</span><br><span class="line">    float4 texcoord3 : TEXCOORD3;</span><br><span class="line">    fixed4 color : COLOR;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>若如下所示 引用 了UnityCG.cginc，则具有四个Unity3D预定义的结构体：</p><ul><li>appdata_base： vertex, normal, texcoord.</li><li>appdata_tan： vertex, tangent, normal, texcoord.</li><li>appdata_full： vertex, tangent, normal, texcoord, texcoord1, texcoord2, texcoord3, color.</li><li>appdata_img: vertex, texcoord.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGPROGRAM</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">ENDCG</span><br></pre></td></tr></table></figure><h3 id="标签（SubShader-Tags）"><a href="#标签（SubShader-Tags）" class="headerlink" title="标签（SubShader Tags）"></a>标签（SubShader Tags）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ex: Tags &#123; &quot;TagName1&quot; = &quot;Value1&quot; &quot;TagName2&quot; = &quot;Value2&quot; &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>标签</th><th>参数</th></tr></thead><tbody><tr><td>Queue</td><td>预定义:Background(1000)、Geometry(2000)、AlphaTest(2450)、Transparent(3000)、Overlay(4000)；亦可选择直接填写数值，或类似 『Geometry+500』</td></tr><tr><td>RenderType</td><td>使用替换的着色器进行渲染，脚本可使用函数 Camera.RenderWithShader 或 Camera.SetReplacementShader 来实现着色器替换(ResetReplacementShader重置，有同标签shader物体则替换渲染，无的物体则不再被渲染)。</td></tr><tr><td>DisableBatching</td><td>“true” or “false” ，是否禁用批处理；or “LODFading”(当 LOD 淡化处于激活状态时禁用批处理；主要用于树)</td></tr><tr><td>ForceNoShadowCasting</td><td>“true” or “false”，该子着色器渲染的对象是否投射阴影</td></tr><tr><td>IgnoreProjector</td><td>若值为“True”，则使用此着色器的对象不会受到投影器(Projector[Unity组件])的影响。</td></tr><tr><td>PreviewType</td><td>指示材质检视面板预览应如何显示材质。默认情况下，材质显示为球体，但也可以将 PreviewType 设置为“Plane”（将显示为 2D）或“Skybox”（将显示为天空盒）。</td></tr><tr><td>CanUseSpriteAtlas</td><td>如果着色器用于精灵，请将 CanUseSpriteAtlas 标签设置为“False”，这样在精灵打包到图集内时，该标签将不起作用。</td></tr></tbody></table><h3 id="渲染状态设置"><a href="#渲染状态设置" class="headerlink" title="渲染状态设置"></a>渲染状态设置</h3><h4 id="Cull"><a href="#Cull" class="headerlink" title="Cull"></a>Cull</h4><p><code>Cull Back | Front | Off</code> 设置多边形剔除模式。</p><h4 id="ZTest"><a href="#ZTest" class="headerlink" title="ZTest"></a>ZTest</h4><p><code>ZTest (Less | Greater | LEqual | GEqual | Equal | NotEqual | Always)</code> 设置深度缓冲区测试模式。默认值为 _LEqual_（将前方或远处的对象作为现有对象绘制；隐藏其后面的对象）。</p><h4 id="ZWrite"><a href="#ZWrite" class="headerlink" title="ZWrite"></a>ZWrite</h4><p><code>ZWrite On | Off</code> 设置深度缓冲区写入模式（默认值为 _On_）。</p><h4 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h4><p><code>Offset Factor, Units</code> 设置 Z 缓冲区深度偏移。允许使用两个参数指定深度偏移：<em>factor</em> 和 units。Factor 相对于多边形的 X 或 Y 缩放最大 Z 斜率，而 units 缩放最小可分辨深度缓冲区值。因此可强制将一个多边形绘制在另一个多边形上，尽管它们实际上位于相同位置。例如，Offset 0, -1 将多边形拉近摄像机并忽略多边形的斜率，而 Offset -1, -1 在观察掠射角时进一步拉近多边形。</p><h4 id="ColorMask"><a href="#ColorMask" class="headerlink" title="ColorMask"></a>ColorMask</h4><p><code>ColorMask RGB | A | 0 | R、G、B、A 的任意组合</code> 设置颜色通道写入遮罩。</p><h4 id="混合（Blend）"><a href="#混合（Blend）" class="headerlink" title="混合（Blend）"></a>混合（Blend）</h4><p>设置 Alpha 混合、Alpha 操作和 alpha-to-coverage 模式。</p><h5 id="混合运算"><a href="#混合运算" class="headerlink" title="混合运算"></a>混合运算</h5><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>Add</td><td>将源和目标相加。</td></tr><tr><td>Sub</td><td>从源减去目标。</td></tr><tr><td>RevSub</td><td>从目标减去源。</td></tr><tr><td>Min</td><td>使用源和目标中的较小者。</td></tr><tr><td>Max</td><td>使用源和目标中的较大者。</td></tr></tbody></table><h5 id="混合系数"><a href="#混合系数" class="headerlink" title="混合系数"></a>混合系数</h5><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>One</td><td>值为 1 - 让源或目标颜色通过。</td></tr><tr><td>Zero</td><td>值为 0 - 删除源或目标值。</td></tr><tr><td>SrcColor</td><td>此阶段的值乘以源颜色值。</td></tr><tr><td>SrcAlpha</td><td>此阶段的值乘以源 Alpha 值。</td></tr><tr><td>DstColor</td><td>此阶段的值乘以帧缓冲区源颜色值。</td></tr><tr><td>DstAlpha</td><td>此阶段的值乘以帧缓冲区源 Alpha 值。</td></tr><tr><td>OneMinusSrcColor</td><td>此阶段的值乘以（1 - 源颜色）。</td></tr><tr><td>OneMinusSrcAlpha</td><td>此阶段的值乘以（1 - 源 Alpha）。</td></tr><tr><td>OneMinusDstColor</td><td>此阶段的值乘以（1 - 目标颜色）。</td></tr><tr><td>OneMinusDstAlpha</td><td>此阶段的值乘以（1 - 目标 Alpha）。</td></tr></tbody></table><h5 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Blend SrcAlpha OneMinusSrcAlpha // 传统透明度</span><br><span class="line">Blend One OneMinusSrcAlpha // 预乘透明度</span><br><span class="line">Blend One One // 加法</span><br><span class="line">Blend OneMinusDstColor One // 软加法</span><br><span class="line">Blend DstColor Zero // 乘法</span><br><span class="line">Blend DstColor SrcColor // 2x 乘法</span><br></pre></td></tr></table></figure><h3 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h3><ul><li>SV_POSITION：顶点着色器输出顶点的最终裁剪空间位置</li><li>SV_Target：片段着色器输出语义（SV_TargetN[SV_Target1、SV_Target2等]）</li><li>SV_Depth：片段着色器深度输出</li><li>VPOS：(UNITY_VPOS_TYPE)屏幕空间像素位置。[需求#pragma target 3.0]</li><li>VFACE：正面的 VFACE 输入为正，背面的为负。[需求#pragma target 3.0]</li><li>SV_VertexID：(uint)顶点 ID [需求#pragma target 3.5]</li></ul><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><h3 id="UnityCG-cginc"><a href="#UnityCG-cginc" class="headerlink" title="UnityCG.cginc"></a>UnityCG.cginc</h3><h4 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>float4 UnityObjectToClipPos(float3 pos)</td><td>将对象空间中的点变换到齐次坐标中的摄像机裁剪空间。这等效于 mul(UNITY_MATRIX_MVP, float4(pos, 1.0))，应该在适当的位置使用</td></tr><tr><td>float3 UnityObjectToViewPos(float3 pos)</td><td>将对象空间中的点变换到视图空间。这等效于 __mul(UNITY_MATRIX_MV, float4(pos, 1.0)).xyz__，应该在适当的位置使用</td></tr><tr><td>float3 WorldSpaceViewDir(float4 v)</td><td>返回从给定对象空间顶点位置朝向摄像机的世界空间方向（未标准化）</td></tr><tr><td>float3 ObjSpaceViewDir(float4 v)</td><td>返回从给定对象空间顶点位置朝向摄像机的对象空间方向（未标准化）</td></tr><tr><td>float2 ParallaxOffset(half h, half height, half3 viewDir)</td><td>计算视差法线贴图的 UV 偏移</td></tr><tr><td>fixed Luminance(fixed3 c)</td><td>将颜色转换为亮度（灰阶）</td></tr><tr><td>fixed3 DecodeLightmap(fixed4 color)</td><td>从 Unity 光照贴图（RGBM 或 dLDR，具体取决于平台）解码颜色</td></tr><tr><td>float4 EncodeFloatRGBA(float v)</td><td>将 [0..1) 范围浮点数编码为 RGBA 颜色，用于存储在低精度渲染目标中</td></tr><tr><td>float DecodeFloatRGBA(float4 enc)</td><td>将 RGBA 颜色解码为浮点数</td></tr><tr><td>float2 EncodeFloatRG(float v)</td><td>将 [0..1) 范围浮点数编码为 float2</td></tr><tr><td>float DecodeFloatRG(float2 enc)</td><td>解码先前编码的 RG 浮点数</td></tr><tr><td>float2 EncodeViewNormalStereo(float3 n)</td><td>将视图空间法线编码为 0 到 1 范围内的两个数字</td></tr><tr><td>float3 DecodeViewNormalStereo(float4 enc4)</td><td>从 enc4.xy 解码视图空间法线</td></tr><tr><td>float4 ComputeScreenPos(float4 clipPos)</td><td>计算用于执行屏幕空间贴图纹理采样的纹理坐标。输入是裁剪空间位置</td></tr><tr><td>float4 ComputeGrabScreenPos(float4 clipPos)</td><td>计算用于 GrabPass 纹理采样的纹理坐标。输入是裁剪空间位置</td></tr><tr><td>float3 UnityWorldSpaceViewDir(float3 worldPos)</td><td>给定世界坐标，计算视线方向向量，返回值并未归一化</td></tr><tr><td>float3 WorldSpaceViewDir(float4 localPos)</td><td>给定物体空间坐标，计算视线方向向量，返回值并未归一化</td></tr><tr><td>float3 UnityObjectToWorldNormal(float3 norm)</td><td>将法线从物体空间变换至世界空间</td></tr></tbody></table><h4 id="特定渲染下的辅助函数"><a href="#特定渲染下的辅助函数" class="headerlink" title="特定渲染下的辅助函数"></a>特定渲染下的辅助函数</h4><p>仅当使用前向渲染（ForwardBase 或 ForwardAdd 通道类型）时，这些函数才有用。</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>float3 WorldSpaceLightDir(float4 v)</td><td>根据给定的对象空间顶点位置计算朝向光源的世界空间方向（未标准化）。</td></tr><tr><td>float3 ObjSpaceLightDir(float4 v)</td><td>根据给定对象空间顶点位置计算朝向光源的对象空间方向（未标准化）。</td></tr><tr><td>float3 Shade4PointLights(…)</td><td>计算四个点光源的光照，将光源数据紧密打包到矢量中。前向渲染使用它来计算每顶点光照。</td></tr></tbody></table><p>仅当使用每顶点光照着色器（“Vertex”通道类型）时，这些函数才有用。</p><p>|函数|说明|<br>float3 ShadeVertexLights(float4 vertex, float3 normal)|根据给定的对象空间位置和法线计算四个每顶点光源和环境光的光照。</p><h2 id="内置着色器变量"><a href="#内置着色器变量" class="headerlink" title="内置着色器变量"></a>内置着色器变量</h2><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>UNITY_MATRIX_MVP</td><td>当前模型 * 视图 * 投影矩阵。</td></tr><tr><td>UNITY_MATRIX_MV</td><td>当前模型 * 视图矩阵。</td></tr><tr><td>UNITY_MATRIX_V</td><td>当前视图矩阵。</td></tr><tr><td>UNITY_MATRIX_P</td><td>当前投影矩阵。</td></tr><tr><td>UNITY_MATRIX_VP</td><td>当前视图 * 投影矩阵。</td></tr><tr><td>UNITY_MATRIX_T_MV</td><td>模型转置 * 视图矩阵。</td></tr><tr><td>UNITY_MATRIX_IT_MV</td><td>模型逆转置 * 视图矩阵。用于将法线从模型转换至相机空间。</td></tr><tr><td>unity_ObjectToWorld</td><td>当前模型矩阵。</td></tr><tr><td>unity_WorldToObject</td><td>当前世界矩阵的逆矩阵。</td></tr></tbody></table><h3 id="摄像机和屏幕"><a href="#摄像机和屏幕" class="headerlink" title="摄像机和屏幕"></a>摄像机和屏幕</h3><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>_WorldSpaceCameraPos</td><td>float3</td><td>摄像机的世界空间位置。</td></tr><tr><td>_ProjectionParams</td><td>float4</td><td>x 是 1.0（如果当前使用翻转投影矩阵进行渲染，则为 –1.0），y 是摄像机的近平面，z 是摄像机的远平面，w 是远平面的倒数。</td></tr><tr><td>_ScreenParams</td><td>float4</td><td>x 是摄像机目标纹理的宽度（以像素为单位），y 是摄像机目标纹理的高度（以像素为单位），z 是 1.0 + 1.0/宽度，w 为 1.0 + 1.0/高度。</td></tr><tr><td>_ZBufferParams</td><td>float4</td><td>用于线性化 Z 缓冲区值。x 是 (1-远/近)，y 是 (远/近)，z 是 (x/远)，w 是 (y/远)。</td></tr><tr><td>unity_OrthoParams</td><td>float4</td><td>x 是正交摄像机的宽度，y 是正交摄像机的高度，z 未使用，w 在摄像机为正交模式时是 1.0，而在摄像机为透视模式时是 0.0。</td></tr><tr><td>unity_CameraProjection</td><td>float4x4</td><td>摄像机的投影矩阵。</td></tr><tr><td>unity_CameraInvProjection</td><td>float4x4</td><td>摄像机投影矩阵的逆矩阵。</td></tr><tr><td>unity_CameraWorldClipPlanes[6]</td><td>float4</td><td>摄像机视锥体平面世界空间方程，按以下顺序：左、右、底、顶、近、远。</td></tr></tbody></table><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>_Time</td><td>float4</td><td>自关卡加载以来的时间 (t/20, t, t<em>2, t</em>3)，用于将着色器中的内容动画化。</td></tr><tr><td>_SinTime</td><td>float4</td><td>时间正弦：(t/8, t/4, t/2, t)。</td></tr><tr><td>_CosTime</td><td>float4</td><td>时间余弦：(t/8, t/4, t/2, t)。</td></tr><tr><td>unity_DeltaTime</td><td>float4</td><td>增量时间：(dt, 1/dt, smoothDt, 1/smoothDt)。</td></tr></tbody></table><h3 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h3><p>前向渲染（ForwardBase 和 ForwardAdd 通道类型）：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>_LightColor0</td><td>fixed4</td><td>光源颜色（在 UnityLightingCommon.cginc 中声明）。</td></tr><tr><td>_WorldSpaceLightPos0</td><td>float4</td><td>方向光：（世界空间方向，0）。其他光源：（世界空间位置，1）。</td></tr><tr><td>unity_WorldToLight</td><td>float4x4</td><td>世界/光源矩阵。用于对剪影和衰减纹理进行采样（在 AutoLight.cginc 中声明）。</td></tr><tr><td>unity_4LightPosX0、unity_4LightPosY0、unity_4LightPosZ0</td><td>float4</td><td>（仅限 ForwardBase 通道）前四个非重要点光源的世界空间位置。</td></tr><tr><td>unity_4LightAtten0</td><td>float4</td><td>（仅限 ForwardBase 通道）前四个非重要点光源的衰减因子。</td></tr><tr><td>unity_LightColor</td><td>half4[4]</td><td>（仅限 ForwardBase 通道）前四个非重要点光源的颜色。</td></tr><tr><td>unity_WorldToShadow</td><td>float4x4[4]</td><td>世界/阴影矩阵。聚光灯的一个矩阵，方向光级联最多有四个矩阵。</td></tr></tbody></table><h3 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h3><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>unity_Lightmap</td><td>Texture2D</td><td>包含光照贴图信息。</td></tr><tr><td>unity_LightmapST</td><td>float4[8]</td><td>缩放 UV 信息并转换到正确的范围以对光照贴图纹理进行采样。</td></tr></tbody></table><h3 id="雾效和环境光"><a href="#雾效和环境光" class="headerlink" title="雾效和环境光"></a>雾效和环境光</h3><p>unity_AmbientSky| fixed4| 梯度环境光照情况下的天空环境光照颜色。<br>unity_AmbientEquator| fixed4| 梯度环境光照情况下的赤道环境光照颜色。<br>unity_AmbientGround| fixed4| 梯度环境光照情况下的地面环境光照颜色。<br>UNITY_LIGHTMODEL_AMBIENT| fixed4| 环境光照颜色（梯度环境情况下的天空颜色）。旧版变量。<br>unity_FogColor| fixed4| 雾效颜色。<br>unity_FogParams| float4| 用于雾效计算的参数：(density / sqrt(ln(2))、density / ln(2)、–1/(end-start) 和 end/(end-start))。x 对于 Exp2 雾模式很有用；<em>y</em> 对于 Exp 模式很有用，<em>z</em> 和 w 对于 Linear 模式很有用。</p><h2 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h2><h3 id="GrabPass"><a href="#GrabPass" class="headerlink" title="GrabPass"></a>GrabPass</h3><p>一般以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GrabPass &#123; &quot;TextureName&quot; &#125; </span><br><span class="line">sampler2D TextureName</span><br></pre></td></tr></table></figure><h3 id="摄像机的深度纹理"><a href="#摄像机的深度纹理" class="headerlink" title="摄像机的深度纹理"></a>摄像机的深度纹理</h3><p>通过声明 sampler2D _CameraDepthTexture 可直接引用；非线性值，存在x中，范围 [0,1]</p><p>(注：另外还有 _LastCameraDepthTexture 纹理)</p><p>可使用帮助函数：</p><p>名|说明<br>Linear01Depth(i)|通过深度纹理 i 给出高精度值时，返回相应的线性深度，范围在 0 到 1 之间<br>LinearEyeDepth(i)|通过深度纹理 i 计算，返回相应的视空间线性深度<br>COMPUTE_EYEDEPTH(float3 o)|顶点函数中使用，返回当前顶点视空间深度，一般用于不会被记录深度值的透明物体自身</p><ul><li>获取当前物体当前深度：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vert：COMPUTE_EYEDEPTH(o.screenPos.z);<span class="comment">//返回的为该物体处于视空间的深度值</span></span><br><span class="line">frag：fixed depth=LinearEyeDepth(tex2Dproj(_CameraDepthTexture,i.screenPos))<span class="comment">//获取该片元之前位于视空间的深度值，并将其转化为线性值</span></span><br></pre></td></tr></table></figure><p>若通过 <code>depth.x-(i.screenPos.z)</code> 直接返回为颜色值，则会有如图结果：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2021/2021-01-26-Unity3DSahder%E5%85%B3%E9%94%AE%E5%AD%97.png" alt="地形混合贴图"></p><p><font color="red">注：仅“不透明”对象（这些对象的材质和着色器设置为使用小于等于 2500 的渲染队列）会自动被渲染到深度纹理中</font></p><h3 id="透明物体"><a href="#透明物体" class="headerlink" title="透明物体"></a>透明物体</h3><p>分为 透明度测试(无效像素直接丢弃)、 透明度混合两类。<br>需要着重注意渲染顺序问题，Queue 标签对队列进行标识</p><p>若使用透明度混合，为解决透明物体渲染问题，可使用一个Pass开启深度测试，第二个Pass进行正常处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">Pass&#123;</span><br><span class="line">	ZWrite On</span><br><span class="line">	ColorMask 0</span><br><span class="line">&#125;</span><br><span class="line">Pass&#123;</span><br><span class="line">	ZWrite Off</span><br><span class="line">	Cull Off</span><br><span class="line">	Blend XXX XXX</span><br><span class="line">	//TODO:...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于此详细可参考 <a target="_blank" rel="noopener" href="https://dragon_boy.gitee.io/2020/06/20/UnityShaderAlpha/">Dragons blog：Unity Shader:透明效果</a></p><h3 id="UsePass"><a href="#UsePass" class="headerlink" title="UsePass"></a>UsePass</h3><p>复用指定Shader的Pass：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UsePass &quot;Shader/NAME&quot;</span><br></pre></td></tr></table></figure><blockquote><p>注：指定Shader的Pass需使用 <code>Name &quot;MyPassName&quot;</code> 命名，且在内部，所有通道名称均大写，因此 UsePass 必须引用大写名称。</p></blockquote><hr><blockquote><p>注:测试环境为Unity3D 2019.2.4f1<br>参考:</p><ul><li><a target="_blank" rel="noopener" href="https://www.zhihu.com/column/unityTA">知乎专栏</a></li><li><a target="_blank" rel="noopener" href="https://docs.unity.cn/2019.4/Documentation/Manual/SL-DataTypesAndPrecision.html">Unity3D官方文档</a></li></ul></blockquote><div class="tags-container-bottom"><i class="fa fa-tag pr3 text-main-color"></i><a class="fw3 ph1 dib" href="/tags/Shader/">#Shader</a></div><br><br><hr><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><div id="vcomments"></div><script>new Valine({el:"#vcomments",appId:"MsaVbSzIr9cIfikihDExdun9-gzGzoHsz",appKey:"Bj6SEFUBomrLOTWx9B8S6zQH",placeholder:"请输入评论内容~",avatar:"mp",visitor:!1})</script></div><div class="fl w-100 w-30-l center fw3 lh-copy pl4-ns tl black-50"><hr class="dn-l mw4 black-50 mt5"><div class="mt5 mt0-l site-author"><article class="dt db-l mw8 mw8-m mw5-ns center ml0-l bg-white mv3"><div class="dn dtc-m db-l v-mid tc pr4 pr0-l" style="min-width:6rem"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/photo.jpg" class="mb4-l br-100 h3 w3 h4-l w4-l dib" title="CWHISME"></div><div class="dtc db-l v-mid lh-copy measure center f6 black-50 tj">悲观主义的末日</div></article></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>分类</h3><p><a href="/categories/Unity3D/">Unity3D</a></p></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>近期文章</h3><p><a href="/2022/12/10/%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/">协变和逆变</a></p><p><a href="/2022/12/06/Unity%E7%9A%84%E9%98%B4%E5%BD%B1%E4%B8%8E%E5%85%89%E7%85%A7%E7%83%98%E7%84%99/">Unity 的阴影与光照烘焙</a></p><p><a href="/2022/11/23/%E6%89%93%E5%8C%85AssetBundle%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86/">打包 AssetBundle 的基础规则整理</a></p><p><a href="/2022/11/18/StringBuilder%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E7%A0%94%E7%A9%B6/">StringBuilder 扩容规则研究</a></p><p><a href="/2022/11/17/%E6%B5%8B%E8%AF%95%E6%89%8B%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">简单测试手动垃圾回收</a></p></div></div></div></div></div></div><div class="bg-1 ph2 ph5-ns pv5"><div class="mv8"><div class="center tc"><div class="dib mh3"><a class="f3 f2-ns white dim" href="https://github.com/CWHISME" target="_blank"><i class="fa fa-github"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="mailto:cwhisme@126.com" target="_blank"><i class="fa fa-envelope"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div></div><div class="f6 f5-ns center tc white pt5 fw3">Copyright © 2021 | Design & Hexo <a class="link dim white" target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-anodyne/">Jonathan Klughertz</a> | Modify By CWHISME</div></div></div></body></html>