<!DOCTYPE html><meta name="viewport" content="height=device-height,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=0"><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="cwhisme"><meta name="author" content="CWHISME"><meta property="og:title" content="关于对项目字符串拼接的优化研究"><meta property="og:description" content="cwhisme"><meta property="og:site_name" content="WangJiaYing"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><title>关于对项目字符串拼接的优化研究 - WangJiaYing</title><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/DateTimeAfeterCalc.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/particles-bg.js"></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/script.js"></script><link href="https://fastly.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/css/style.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tachyons@4.12.0/css/tachyons.min.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="WangJiaYing" type="application/atom+xml">
</head><body><canvas id="hackEffectCanvas" style="position:fixed;z-index:-1;pointer-events:none"></canvas><canvas class="fireworks" style="position:fixed;z-index:10;pointer-events:none"></canvas><div class="w-100 bg-1 ph5-ns ph3 text-light"><nav class="db dt-l w-100 mw8 center border-box pv3"><a class="db dtc-l v-mid link dim w-100 w-25-l tc tl-l mb2 mb0-l white" href="/" title="WangJiaYing"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/logo.svg" class="dib h3" alt="WangJiaYing"></a><div class="db dtc-l v-mid w-100 w-75-l tc tr-l"><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/" title="Home">Home </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/archives" title="Archives">Archives </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/tags" title="Tags">Tags </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/categories" title="Categories">Categories </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/bookmark" title="Bookmark">Bookmark </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/about" title="About">About</a></div></nav><div class="w-100 mw8 center vh-40 dt"><div class="dtc v-mid white"><h1 class="f1-l f2-m tc tc-m tl-ns">关于对项目字符串拼接的优化研究</h1><p class="f4 fw3 pab-100px tc tc-m tl-ns"><i class="fa fa-calendar-check-o" aria-hidden="true"></i> 2022-10-31&nbsp&nbsp <i class="fa fa-clock-o" aria-hidden="true"></i> <span id="dateTimeAfter">2022-10-31</span></p></div></div><div class="relative w-100 mw8 center white dn dn-m db-ns"><i class="header-icon fa fa-snowflake-o"></i></div></div><div class="w-100 ph2 ph4-m ph5-l mv5 mv6-l"><div class="content"><div class="mw8 center"><div class="cf"><div class="fl w-100 w-70-l mw7 left fw3 lh-copy pr4-ns pr0-m post-content"><div class="tags-container-vertical"><div class="tags-sub-container"><a class="fw3 ph1 dib" href="/tags/性能优化/">#性能优化</a></div></div><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在对组员代码进行审查时，经常碰到看着很不合理的字符串拼接操作，特别是对数组数据操作，也直接一个 for 循环，使用 + 号进行。</p><p>甚至有时候还是直接以 Text 作为主体，例如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; soldierData.Skills.Count; i++)</span><br><span class="line">&#123;</span><br><span class="line">	m_soldiersDesc.text += soldierData.Skills[i].GetLvDesc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个地方，首先 m_soldiersDesc.text 是一个主体，『+=』操作相当于 取值+字符串拼接+赋值+重构Text数据，还是在循环中进行——有多费就不用多说了。</p><p>再次对组员进行强调：使用对应指定方式拼接字符串。</p><p>项目中其实已有公共的采取 StringBuilder 拼接相关方法，例如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 組合数组</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toString</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> List&lt;T&gt; list, <span class="built_in">string</span> split = <span class="string">&quot;,&quot;</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!list.valid()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	StringBuilder sbd = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Count; i++) sbd.Append(list[i] + (i &lt; list.Count - <span class="number">1</span> ? split : <span class="string">&quot;&quot;</span>));</span><br><span class="line">	<span class="keyword">return</span> sbd.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：虽然该方法是已有的，但是使用的不多(而且该方法使用 StringBuilder 方式也不大好，例如调用了 StringBuilder Append 还在用+号拼接小的)，大多都是在搞自我拼接。</p><p>所以虽然要求大家使用项目自定义的字符串拼接相关扩展方法，不过这边这块恐怕需要进行优化一下。</p><h2 id="2-第一版优化"><a href="#2-第一版优化" class="headerlink" title="2. 第一版优化"></a>2. 第一版优化</h2><p>为此我在这个基础上增加了一份扩展，优化主要有两点：使用 StringBuilder 拼接，且对其进行缓存，每次回收利用。</p><p>主要代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> StringBuilder _stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">32</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> _stringCacheLength;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> _stringCacheTopIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将数组组合为字符串</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toString</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> List&lt;T&gt; list, <span class="built_in">string</span> split = <span class="string">&quot;,&quot;</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!list.valid()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    _stringBuilder.Length = <span class="number">0</span>;</span><br><span class="line">    _stringCacheLength = list.Count;</span><br><span class="line">    _stringCacheTopIndex = _stringCacheLength - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _stringCacheLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _stringBuilder.Append(list[i]);</span><br><span class="line">        <span class="keyword">if</span> (i != _stringCacheTopIndex) _stringBuilder.Append(split);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _stringBuilder.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将列表组合为字符串</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toString</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> List&lt;T&gt; list, RCallback&lt;<span class="built_in">string</span>, T&gt; getStr, <span class="built_in">string</span> split = <span class="string">&quot;,&quot;</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!list.valid()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    _stringBuilder.Length = <span class="number">0</span>;</span><br><span class="line">    _stringCacheLength = list.Count;</span><br><span class="line">    _stringCacheTopIndex = _stringCacheLength - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _stringCacheLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _stringBuilder.Append(getStr(list[i]));</span><br><span class="line">        <span class="keyword">if</span> (i != _stringCacheTopIndex) _stringBuilder.Append(split);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _stringBuilder.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将字典组合为字符串</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toString</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;(<span class="params"><span class="keyword">this</span> Dictionary&lt;K, V&gt; dic, <span class="built_in">string</span> split = <span class="string">&quot;,&quot;</span>, Func&lt;K, V, <span class="built_in">string</span>&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dic.Count &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    _stringBuilder.Length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> dic)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (getStrCallback == <span class="literal">null</span>)</span><br><span class="line">            _stringBuilder.Append(item.Value);</span><br><span class="line">        <span class="keyword">else</span> _stringBuilder.Append(getStrCallback(item.Key, item.Value));</span><br><span class="line">        _stringBuilder.Append(split);</span><br><span class="line">    &#125;</span><br><span class="line">    _stringBuilder.Remove(_stringBuilder.Length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> _stringBuilder.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将数组组合为字符串，换行分割</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toStringLine</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> T[] arr, RCallback&lt;<span class="built_in">string</span>, T&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.toString(Environment.NewLine, getStrCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将列表组合为字符串，换行分割</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toStringLine</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> List&lt;T&gt; list, RCallback&lt;<span class="built_in">string</span>, T&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> list.toString(Environment.NewLine, getStrCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将字典组合为字符串，换行分割</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toStringLine</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;(<span class="params"><span class="keyword">this</span> Dictionary&lt;K, V&gt; dic, Func&lt;K, V, <span class="built_in">string</span>&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dic.toString(Environment.NewLine, getStrCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要提供有两种处理方式：一种直接将数组每个数据拼接，另一种会经过回调处理后再拼接。<br>并支持数组、列表、字典三个常用数据结构内容的拼接。</p><p>这里只使用一份 StringBuilder 缓存，是因为考虑到游戏中单线程模式即用就即时返回结果了，没有必要采用对象池模式去缓存多个。</p><h2 id="3-性能测试与优化"><a href="#3-性能测试与优化" class="headerlink" title="3. 性能测试与优化"></a>3. 性能测试与优化</h2><h3 id="四种拼接方式性能测试"><a href="#四种拼接方式性能测试" class="headerlink" title="四种拼接方式性能测试"></a>四种拼接方式性能测试</h3><p>对于性能测试，这里首先以 100000 个放置于一个数组中的随机字符串的拼接为例，分别采用 +号拼接、string.Join、自定义StringBuilder、带回调自定义StringBuilder 四种方式，测试其消耗时长：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> TestCount = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//纯字符串数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span>[] _strArray;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化测试数据</span></span><br><span class="line">    _strArray = <span class="keyword">new</span> <span class="built_in">string</span>[TestCount];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _strArray[i] = GetRandomStr();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试数据填充完毕</span></span><br><span class="line">    <span class="comment">//==========</span></span><br><span class="line"></span><br><span class="line">    Stopwatch stopwatch = Stopwatch.StartNew();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 测试直接拼接数组</span></span><br><span class="line">    stopwatch.Start();</span><br><span class="line">    <span class="built_in">string</span> finalStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _strArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        finalStr += <span class="string">&quot;,&quot;</span> + _strArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">    stopwatch.Stop();</span><br><span class="line">    UnityEngine.Debug.Log(finalStr);</span><br><span class="line">    UnityEngine.Debug.LogWarning(<span class="built_in">string</span>.Format(<span class="string">&quot;直接拼接数组：&#123;0&#125;&quot;</span>, stopwatch.Elapsed.ToString()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 测试内部函数 join 拼接数组</span></span><br><span class="line">    stopwatch.Reset();</span><br><span class="line">    stopwatch.Start();</span><br><span class="line">    finalStr = <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, _strArray);</span><br><span class="line">    stopwatch.Stop();</span><br><span class="line">    UnityEngine.Debug.Log(finalStr);</span><br><span class="line">    UnityEngine.Debug.LogWarning(<span class="built_in">string</span>.Format(<span class="string">&quot;string.Join 拼接数组：&#123;0&#125;&quot;</span>, stopwatch.Elapsed.ToString()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 测试自定义函数拼接数组</span></span><br><span class="line">    stopwatch.Reset();</span><br><span class="line">    stopwatch.Start();</span><br><span class="line">    finalStr = _strArray.toString();</span><br><span class="line">    stopwatch.Stop();</span><br><span class="line">    UnityEngine.Debug.Log(finalStr);</span><br><span class="line">    UnityEngine.Debug.LogWarning(<span class="built_in">string</span>.Format(<span class="string">&quot;自定义函数拼接数组：&#123;0&#125;&quot;</span>, stopwatch.Elapsed.ToString()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 测试带回调自定义函数拼接数组</span></span><br><span class="line">    stopwatch.Reset();</span><br><span class="line">    stopwatch.Start();</span><br><span class="line">    finalStr = _strArray.toString(<span class="string">&quot;,&quot;</span>, str =&gt; str);</span><br><span class="line">    stopwatch.Stop();</span><br><span class="line">    UnityEngine.Debug.Log(finalStr);</span><br><span class="line">    UnityEngine.Debug.LogWarning(<span class="built_in">string</span>.Format(<span class="string">&quot;带回调自定义函数拼接数组：&#123;0&#125;&quot;</span>, stopwatch.Elapsed.ToString()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回一个随机值字符串</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">GetRandomStr</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Intern(Random.Range(<span class="number">0</span>, <span class="number">1000000</span>).ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2022/2022-10-31/m_58a128e53038c421467e1deabe1943b5_r.png"></p><p>如上图所示，可以看见直接使用 + 号进行拼接的方式，相比另外几种方式其消耗时间可以说是一骑绝尘：可以确定内部基本上没有什么优化的。</p><p>严格来说，上述测试方式并不准确，不过这里主要是因为 + 号拼接太过于消耗时间，数据大了电脑跑不动。因此我就仅执行一次大批量测试了——确定这方式真可以丢一边了。</p><h3 id="平均性能测试"><a href="#平均性能测试" class="headerlink" title="平均性能测试"></a>平均性能测试</h3><p>接下来，剔除 + 号拼接方式，对比余下方式去取平均消耗时间。</p><p>join、concat、自定义函数、带回调自定义函数分别执行 100 次，取平均时间。<br>除此之外，增加对 列表、字典、类类型结构测试。</p><p>测试代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">StrClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _desStr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StrClass</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _desStr = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetDes</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> GetHashCode() + _desStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> TestValueCount = <span class="number">100000</span>;</span><br><span class="line"><span class="comment">//每一轮测试次数，取平均消耗时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> TestNum = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//保存一下结果</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> _logPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">//纯字符串数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span>[] _strArray;</span><br><span class="line"><span class="comment">//纯字符串列表</span></span><br><span class="line"><span class="keyword">private</span> List&lt;<span class="built_in">string</span>&gt; _strList;</span><br><span class="line"><span class="comment">//字典</span></span><br><span class="line"><span class="keyword">private</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; _strDic;</span><br><span class="line"><span class="comment">//返回字符串的类结构</span></span><br><span class="line"><span class="keyword">private</span> StrClass[] _strClassArray;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化测试数据</span></span><br><span class="line">    _strArray = <span class="keyword">new</span> <span class="built_in">string</span>[TestValueCount];</span><br><span class="line">    _strList = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;(TestValueCount);</span><br><span class="line">    _strClassArray = <span class="keyword">new</span> StrClass[TestValueCount];</span><br><span class="line">    _strDic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;(TestValueCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestValueCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _strArray[i] = GetRandomStr();</span><br><span class="line">        _strList.Add(GetRandomStr());</span><br><span class="line">        _strClassArray[i] = <span class="keyword">new</span> StrClass(GetRandomStr());</span><br><span class="line">        _strDic[i] = GetRandomStr();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试数据填充完毕</span></span><br><span class="line">    <span class="comment">//==========</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Stopwatch stopwatch = Stopwatch.StartNew();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 测试直接拼接数组</span></span><br><span class="line">    <span class="comment">//stopwatch.Start();</span></span><br><span class="line">    <span class="comment">//string finalStr = &quot;&quot;;</span></span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt; _strArray.Length; i++)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    finalStr += &quot;,&quot; + _strArray[i];</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//stopwatch.Stop();</span></span><br><span class="line">    <span class="comment">//UnityEngine.Debug.Log(finalStr);</span></span><br><span class="line">    <span class="comment">//UnityEngine.Debug.LogWarning(string.Format(&quot;直接拼接数组：&#123;0&#125;&quot;, stopwatch.Elapsed.ToString()));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空日志</span></span><br><span class="line">    _logPath = Path.Combine(Application.dataPath, <span class="string">&quot;TestLog.txt&quot;</span>);</span><br><span class="line">    File.WriteAllText(_logPath, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试内部函数 concat 拼接数组</span></span><br><span class="line">    DoTest(<span class="string">&quot;string.concat 拼接数组&quot;</span>, () =&gt; <span class="built_in">string</span>.Concat(_strArray));</span><br><span class="line">    <span class="comment">//2. 测试内部函数 join 拼接数组</span></span><br><span class="line">    DoTest(<span class="string">&quot;string.Join 拼接数组&quot;</span>, () =&gt; <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, _strArray));</span><br><span class="line">    <span class="comment">//3. 测试自定义函数拼接数组</span></span><br><span class="line">    DoTest(<span class="string">&quot;自定义函数拼接数组&quot;</span>, () =&gt; _strArray.toString());</span><br><span class="line">    <span class="comment">//4. 测试带回调自定义函数拼接数组</span></span><br><span class="line">    DoTest(<span class="string">&quot;带回调自定义函数拼接数组&quot;</span>, () =&gt; _strArray.toString(<span class="string">&quot;,&quot;</span>, str =&gt; str));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 测试 join 函数拼接列表</span></span><br><span class="line">    DoTest(<span class="string">&quot;string.Join 拼接列表&quot;</span>, () =&gt; _strList.toString());</span><br><span class="line">    <span class="comment">//6. 测试自定义函数拼接列表</span></span><br><span class="line">    DoTest(<span class="string">&quot;自定义函数拼接列表&quot;</span>, () =&gt; _strList.toString());</span><br><span class="line">    <span class="comment">//7. 测试带回调自定义函数拼接列表</span></span><br><span class="line">    DoTest(<span class="string">&quot;带回调自定义函数拼接列表&quot;</span>, () =&gt; _strList.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8. 测试自定义函数拼接类类型</span></span><br><span class="line">    DoTest(<span class="string">&quot;自定义函数拼接类类型&quot;</span>, () =&gt; _strClassArray.toString(<span class="string">&quot;,&quot;</span>, data =&gt; data.GetDes()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//9. 测试自定义函数拼接字典</span></span><br><span class="line">    DoTest(<span class="string">&quot;自定义函数拼接字典&quot;</span>, () =&gt; _strDic.toString());</span><br><span class="line">    <span class="comment">//10. 测试自定义函数拼接字典</span></span><br><span class="line">    DoTest(<span class="string">&quot;自定义函数拼接字典(带回调操作)&quot;</span>, () =&gt; _strDic.toString(<span class="string">&quot;,&quot;</span>, (k, v) =&gt; k + v));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 执行一轮对 callback 运行测试</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoTest</span>(<span class="params"><span class="built_in">string</span> title, Action callback</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stopwatch stopwatch = Stopwatch.StartNew();</span><br><span class="line">    <span class="built_in">long</span> totalTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        stopwatch.Reset();</span><br><span class="line">        stopwatch.Start();</span><br><span class="line">        callback();</span><br><span class="line">        stopwatch.Stop();</span><br><span class="line">        totalTime += stopwatch.ElapsedTicks;</span><br><span class="line">    &#125;</span><br><span class="line">    TimeSpan span = <span class="keyword">new</span> TimeSpan(totalTime);</span><br><span class="line">    <span class="built_in">string</span> log = <span class="built_in">string</span>.Format(<span class="string">&quot;* &#123;0&#125;：&#123;1&#125;秒&#123;2&#125;毫秒\n&quot;</span>, title, span.Seconds, span.Milliseconds);</span><br><span class="line">    File.AppendAllText(_logPath, log);</span><br><span class="line">    UnityEngine.Debug.LogWarning(log);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回一个随机值字符串</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">GetRandomStr</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Intern(UnityEngine.Random.Range(<span class="number">0</span>, <span class="number">1000000</span>).ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><ul><li>string.concat 拼接数组：00:00:00.0099083</li><li>string.Join 拼接数组：00:00:00.0132115</li><li>自定义函数拼接数组：00:00:00.0179701</li><li>带回调自定义函数拼接数组：00:00:00.0175816</li><li>string.Join 拼接列表：00:00:00.0184016</li><li>自定义函数拼接列表：00:00:00.0185559</li><li>带回调自定义函数拼接列表：00:00:00.0180418</li><li>自定义函数拼接类类型：00:00:00.1013892</li><li>自定义函数拼接字典：00:00:00.0224806</li><li>自定义函数拼接字典(带回调操作)：00:00:00.0983786</li></ul><p>有点奇怪的是，在数组结构上，带回调自定义函数时间消耗反而比不带回调的低一点？</p><p>所以可以确定一下性能排序分别为：</p><blockquote><p>string.concat-&gt;string.Join-&gt;StringBuilder自定义拼接-&gt;+号拼接</p></blockquote><p>(其中 concat 之所以性能更高，除了因为少了一位『分隔符』的插入，看源码似乎还利用了创建一个最终大小字符串，通过内存拷贝方式复制进去实现)</p><p>这么看起来，还是内置拼接函数性能比较高。</p><p>不过 concat、Join 的局限性在于：只能用于数组类型，且只处理字符串——如果对象不是字符串，则直接通过 ToString 强转为字符串进行拼接。(要是有某个非字符串数组类型对象重载过 ToString 输出正确值也不是不能用)</p><h2 id="4-第二版优化"><a href="#4-第二版优化" class="headerlink" title="4. 第二版优化"></a>4. 第二版优化</h2><p>经过测试之后，大概性能也有点数了。</p><p>于是就有一些新的想法：例如无回调需求时使用 join 拼接、分隔符为空则采用 concat 拼接——虽然会增加一点判断，但是性能该是可以提升一点的。</p><p>另外在目前自定义扩展函数的使用方式上，感觉也还有点缺点：比如字典类型，如果别人想把 k、v 结构也拼接在一块，那么这里就不大好办了，让调用者在回调方法用 + 号拼接一次？这样可就又冗余了。所以最好也提供一个重载使其作为可选项。</p><p>最终形成以下方法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> StringBuilder _stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">32</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> _stringCacheLength;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> _stringCacheTopIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将数组组合为字符串</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toString</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> T[] arr, <span class="built_in">string</span> separator = <span class="string">&quot;,&quot;</span>, Func&lt;T, <span class="built_in">string</span>&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(separator) &amp;&amp; getStrCallback == <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">string</span>.Concat(arr);</span><br><span class="line">    <span class="comment">//if (getStrCallback == null) return string.Join(separator, arr);</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.Length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    _stringBuilder.Length = <span class="number">0</span>;</span><br><span class="line">    _stringCacheLength = arr.Length;</span><br><span class="line">    _stringCacheTopIndex = _stringCacheLength - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _stringCacheLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _stringBuilder.Append(CheckDeliverValue(arr[i], getStrCallback));</span><br><span class="line">        <span class="keyword">if</span> (i != _stringCacheTopIndex) _stringBuilder.Append(separator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _stringBuilder.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将列表组合为字符串</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toString</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> List&lt;T&gt; list, <span class="built_in">string</span> separator = <span class="string">&quot;,&quot;</span>, Func&lt;T, <span class="built_in">string</span>&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(separator) &amp;&amp; getStrCallback == <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">string</span>.Concat(list);</span><br><span class="line">    <span class="comment">//if (getStrCallback == null) return string.Join(separator, list);</span></span><br><span class="line">    <span class="keyword">if</span> (list == <span class="literal">null</span> || list.Count == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    _stringBuilder.Length = <span class="number">0</span>;</span><br><span class="line">    _stringCacheLength = list.Count;</span><br><span class="line">    _stringCacheTopIndex = _stringCacheLength - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _stringCacheLength; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _stringBuilder.Append(CheckDeliverValue(list[i], getStrCallback));</span><br><span class="line">        <span class="keyword">if</span> (i != _stringCacheTopIndex) _stringBuilder.Append(separator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _stringBuilder.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将字典的所有 value 组合为字符串，忽略字典的Key值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;separator&quot;&gt;</span>分隔符<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;getValueStrCallback&quot;&gt;</span>如果value转化为字符串需要其它接口，可使用回调返回调用后的值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>value,value,value,value,value......<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toString</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;(<span class="params"><span class="keyword">this</span> Dictionary&lt;K, V&gt; dic, <span class="built_in">string</span> separator = <span class="string">&quot;,&quot;</span>, Func&lt;V, <span class="built_in">string</span>&gt; getValueStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> toString(dic, separator, <span class="literal">null</span>, <span class="literal">null</span>, getValueStrCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将字典 key 和 value 成对组合为字符串，需要传入对应的分隔符</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;separator&quot;&gt;</span>每个对象之间分割符<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;separatorKV&quot;&gt;</span>key和value分隔符，传入空值拼接时将忽略key值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;getKeyStrCallback&quot;&gt;</span>如果key转化为字符串需要其它接口，可使用回调返回调用后的值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;getValueStrCallback&quot;&gt;</span>如果value转化为字符串需要其它接口，可使用回调返回调用后的值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>默认：key:value,key:value,key:value......<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toString</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;(<span class="params"><span class="keyword">this</span> Dictionary&lt;K, V&gt; dic, <span class="built_in">string</span> separator, <span class="built_in">string</span> separatorKV, Func&lt;K, <span class="built_in">string</span>&gt; getKeyStrCallback = <span class="literal">null</span>, Func&lt;V, <span class="built_in">string</span>&gt; getValueStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dic == <span class="literal">null</span> || dic.Count == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    _stringBuilder.Length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//kv分隔符为空，则当做表示不拼接key</span></span><br><span class="line">    <span class="built_in">bool</span> appendKey = !<span class="built_in">string</span>.IsNullOrEmpty(separatorKV);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> dic)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//附加字典key</span></span><br><span class="line">        <span class="keyword">if</span> (appendKey)</span><br><span class="line">        &#123;</span><br><span class="line">            _stringBuilder.Append(CheckDeliverValue(item.Key, getKeyStrCallback));</span><br><span class="line">            _stringBuilder.Append(separatorKV);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//附加字典值</span></span><br><span class="line">        _stringBuilder.Append(CheckDeliverValue(item.Value, getValueStrCallback));</span><br><span class="line">        <span class="comment">//分隔符</span></span><br><span class="line">        _stringBuilder.Append(separator);</span><br><span class="line">    &#125;</span><br><span class="line">    _stringBuilder.Remove(_stringBuilder.Length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> _stringBuilder.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将数组组合为字符串，换行分割</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toStringLine</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> T[] arr, Func&lt;T, <span class="built_in">string</span>&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.toString(Environment.NewLine, getStrCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将列表组合为字符串，换行分割</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toStringLine</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> List&lt;T&gt; list, Func&lt;T, <span class="built_in">string</span>&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> list.toString(Environment.NewLine, getStrCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将字典组合为字符串，换行分割(忽略key值)</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">toStringLine</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;(<span class="params"><span class="keyword">this</span> Dictionary&lt;K, V&gt; dic, Func&lt;V, <span class="built_in">string</span>&gt; getStrCallback = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dic.toString(Environment.NewLine, getStrCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 检查是否对值进行回调处理（若 getValueStrCallback 不为空则返回调用后结果，参数为 value）</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">CheckDeliverValue</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span>, Func&lt;T, <span class="built_in">string</span>&gt; getValueStrCallback</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (getValueStrCallback == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">value</span>.ToString();</span><br><span class="line">    <span class="keyword">return</span> getValueStrCallback(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性能测试："><a href="#性能测试：" class="headerlink" title="性能测试："></a>性能测试：</h4><p>依然是 100000 个随机字符串，循环一百次拼接。</p><p>测试代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试内部函数 concat 拼接数组</span></span><br><span class="line">DoTest(<span class="string">&quot;string.concat 拼接数组&quot;</span>, () =&gt; <span class="built_in">string</span>.Concat(_strArray));</span><br><span class="line"><span class="comment">//2. 测试内部函数 join 拼接数组</span></span><br><span class="line">DoTest(<span class="string">&quot;string.Join 拼接数组&quot;</span>, () =&gt; <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, _strArray));</span><br><span class="line"><span class="comment">//3. 测试自定义函数拼接数组</span></span><br><span class="line">DoTest(<span class="string">&quot;自定义函数拼接数组&quot;</span>, () =&gt; _strArray.toString());</span><br><span class="line"><span class="comment">//4. 测试带回调自定义函数拼接数组</span></span><br><span class="line">DoTest(<span class="string">&quot;带回调自定义函数拼接数组&quot;</span>, () =&gt; _strArray.toString(<span class="string">&quot;,&quot;</span>, str =&gt; str));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 测试 join 函数拼接列表</span></span><br><span class="line">DoTest(<span class="string">&quot;string.Join 拼接列表&quot;</span>, () =&gt; _strList.toString());</span><br><span class="line"><span class="comment">//6. 测试自定义函数拼接列表</span></span><br><span class="line">DoTest(<span class="string">&quot;自定义函数拼接列表&quot;</span>, () =&gt; _strList.toString());</span><br><span class="line"><span class="comment">//7. 测试带回调自定义函数拼接列表</span></span><br><span class="line">DoTest(<span class="string">&quot;带回调自定义函数拼接列表&quot;</span>, () =&gt; _strList.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//8. 测试自定义函数拼接类类型</span></span><br><span class="line">DoTest(<span class="string">&quot;自定义函数拼接类类型&quot;</span>, () =&gt; _strClassArray.toString(<span class="string">&quot;,&quot;</span>, data =&gt; data.GetDes()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//9. 测试自定义函数拼接字典</span></span><br><span class="line">DoTest(<span class="string">&quot;自定义函数拼接字典&quot;</span>, () =&gt; _strDic.toString());</span><br><span class="line"><span class="comment">//10. 测试自定义函数拼接字典</span></span><br><span class="line"><span class="comment">//DoTest(&quot;自定义函数拼接字典(带回调操作)&quot;, () =&gt; _strDic.toString(&quot;,&quot;);</span></span><br><span class="line"></span><br><span class="line">DoTest(<span class="string">&quot;string.concat 拼接数组&quot;</span>, () =&gt; <span class="built_in">string</span>.Concat(_strArray));</span><br><span class="line">DoTest(<span class="string">&quot;string.join 拼接数组&quot;</span>, () =&gt; <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, _strArray));</span><br><span class="line"></span><br><span class="line">DoTest(<span class="string">&quot;拼接数组(无分隔符)&quot;</span>, () =&gt; _strArray.toString(<span class="built_in">string</span>.Empty));</span><br><span class="line">DoTest(<span class="string">&quot;拼接数组&quot;</span>, () =&gt; _strArray.toString());</span><br><span class="line">DoTest(<span class="string">&quot;拼接数组(带回调)&quot;</span>, () =&gt; _strArray.toString(<span class="string">&quot;,&quot;</span>, str =&gt; str));</span><br><span class="line"></span><br><span class="line">DoTest(<span class="string">&quot;拼接字典 Value&quot;</span>, () =&gt; _strDic.toString());</span><br><span class="line">DoTest(<span class="string">&quot;拼接字典(带 Value 回调)&quot;</span>, () =&gt; _strDic.toString(<span class="string">&quot;,&quot;</span>, v =&gt; v));</span><br><span class="line">DoTest(<span class="string">&quot;拼接字典 K、V&quot;</span>, () =&gt; _strDic.toString(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;:&quot;</span>));</span><br><span class="line">DoTest(<span class="string">&quot;拼接字典 K、V(带 Key 回调)&quot;</span>, () =&gt; _strDic.toString(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;:&quot;</span>, k =&gt; k.ToString()));</span><br><span class="line">DoTest(<span class="string">&quot;拼接字典 K、V(带 Key、Value 回调)&quot;</span>, () =&gt; _strDic.toString(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;:&quot;</span>, k =&gt; k.ToString(), v =&gt; v));</span><br><span class="line">DoTest(<span class="string">&quot;拼接字典(字典转数组拼接)&quot;</span>, () =&gt; _strDic.ToArray().toString());</span><br><span class="line">DoTest(<span class="string">&quot;拼接字典(字典转列表拼接)&quot;</span>, () =&gt; _strDic.ToList().toString());</span><br></pre></td></tr></table></figure><ul><li>string.concat 拼接数组：0秒937毫秒</li><li>string.Join 拼接数组：1秒282毫秒</li><li>自定义函数拼接数组：1秒837毫秒</li><li>带回调自定义函数拼接数组：1秒809毫秒</li><li>string.Join 拼接列表：1秒858毫秒</li><li>自定义函数拼接列表：1秒916毫秒</li><li>带回调自定义函数拼接列表：1秒847毫秒</li><li>自定义函数拼接类类型：10秒400毫秒</li><li>自定义函数拼接类类型(GetDes()无计算)：1秒870毫秒</li><li>自定义函数拼接字典：2秒316毫秒</li><li>string.concat 拼接数组：0秒910毫秒</li><li>string.join 拼接数组：1秒253毫秒</li><li>拼接数组(无分隔符)：1秒638毫秒</li><li>拼接数组：1秒764毫秒</li><li>拼接数组(带回调)：1秒794毫秒</li><li>拼接字典 Value：2秒332毫秒</li><li>拼接字典(带 Value 回调)：2秒356毫秒</li><li>拼接字典 K、V：8秒121毫秒</li><li>拼接字典 K、V(带 Key 回调)：8秒111毫秒</li><li>拼接字典 K、V(带 Key、Value 回调)：8秒335毫秒</li><li>拼接字典(字典转数组拼接)：14秒391毫秒</li><li>拼接字典(字典转列表拼接)：15秒655毫秒</li></ul><p>(低版本 C# 的 string.concat、string.Join 连列表都不支持，甚至只能用在字符串数组上，所以上边说检测到对应情况(没有分隔符或纯字符串数组)后执行系统拼接函数只能在高版本下使用)</p><blockquote><p>[concat 由于低版本 C# 不支持除纯字符串数组之外的对象且有 object 重载，泛型数组也是可以直接丢进去的，然而直接当做 object.ToString 返回了，测试时发现消耗时间短得不可思议，仔细看才发现不对，例如上述『拼接列表(无分隔符)』就是走进这个分支判断的情况，只能先注释掉]</p></blockquote><h2 id="5-StringBuilder-源码"><a href="#5-StringBuilder-源码" class="headerlink" title="5. StringBuilder 源码"></a>5. StringBuilder 源码</h2><p>另外稍微看了下源码，StringBuilder 默认初始化 16 个字符大小的数组：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token: 0x060065BB RID: 26043 RVA: 0x00155704 File Offset: 0x00153904</span></span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span>(<span class="params"></span>) : <span class="title">this</span>(<span class="params"><span class="number">16</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Token: 0x060065BC RID: 26044 RVA: 0x0015570E File Offset: 0x0015390E</span></span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span>(<span class="params"><span class="built_in">int</span> capacity</span>) : <span class="title">this</span>(<span class="params"><span class="built_in">string</span>.Empty, capacity</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Token: 0x060065D7 RID: 26071 RVA: 0x001561B8 File Offset: 0x001543B8</span></span><br><span class="line">[<span class="meta">ComVisible(false)</span>]</span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">AppendLine</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.Append(<span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.Append(Environment.NewLine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容量足够的情况下，通过 unsafe 方法进行指针及直接内存操作：</p><ol><li>获取添加的字符串指针</li><li>获取字符数组待添加下标指针</li><li>调用 Buffer.Memcpy 进行内存拷贝进字符数组</li></ol><p>如果后续容量不够，则进行动态扩容：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token: 0x060065D1 RID: 26065 RVA: 0x0015603C File Offset: 0x0015423C</span></span><br><span class="line">[<span class="meta">SecuritySafeCritical</span>]</span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">unsafe</span> StringBuilder <span class="title">Append</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span> != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">char</span>[] chunkChars = <span class="keyword">this</span>.m_ChunkChars;</span><br><span class="line">        <span class="built_in">int</span> chunkLength = <span class="keyword">this</span>.m_ChunkLength;</span><br><span class="line">        <span class="built_in">int</span> length = <span class="keyword">value</span>.Length;</span><br><span class="line">        <span class="built_in">int</span> num = chunkLength + length;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; chunkChars.Length)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//容量足够</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//走扩容</span></span><br><span class="line">            <span class="keyword">this</span>.AppendHelper(<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过动态扩容不是直接扩容字符数组，而是通过单向链表的方式：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token: 0x06006615 RID: 26133 RVA: 0x0015730C File Offset: 0x0015550C</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ExpandByABlock</span>(<span class="params"><span class="built_in">int</span> minBlockCharCount</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (minBlockCharCount + <span class="keyword">this</span>.Length &lt; minBlockCharCount || minBlockCharCount + <span class="keyword">this</span>.Length &gt; <span class="keyword">this</span>.m_MaxCapacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="string">&quot;requiredLength&quot;</span>, Environment.GetResourceString(<span class="string">&quot;ArgumentOutOfRange_SmallCapacity&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> num = Math.Max(minBlockCharCount, Math.Min(<span class="keyword">this</span>.Length, <span class="number">8000</span>));</span><br><span class="line">    <span class="keyword">this</span>.m_ChunkPrevious = <span class="keyword">new</span> StringBuilder(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.m_ChunkOffset += <span class="keyword">this</span>.m_ChunkLength;</span><br><span class="line">    <span class="keyword">this</span>.m_ChunkLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.m_ChunkOffset + num &lt; num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.m_ChunkChars = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.m_ChunkChars = <span class="keyword">new</span> <span class="built_in">char</span>[num];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将当前数据全部转移至『上一个』节点，然后自己创建一个新的字符数组进行处理。</p><p>除 StringBuilder 本身外，string 类提供的一些静态操作方法也再次利用 StringBuilder 对性能进行优化，如 join、format 底层都会调到那边去，还采用了 StringBuilderCache 对象池。</p><h2 id="6-Join-部分源码"><a href="#6-Join-部分源码" class="headerlink" title="6. Join 部分源码"></a>6. Join 部分源码</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token: 0x060004B8 RID: 1208 RVA: 0x00010B4C File Offset: 0x0000ED4C</span></span><br><span class="line">[<span class="meta">SecuritySafeCritical</span>]</span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">unsafe</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Join</span>(<span class="params"><span class="built_in">string</span> separator, <span class="built_in">string</span>[] <span class="keyword">value</span>, <span class="built_in">int</span> startIndex, <span class="built_in">int</span> count</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//=======省略判断================</span></span><br><span class="line">	<span class="comment">//字符串类型数组，直接通过分配一大块字符串内存，通过 unsafe 内存拷贝实现</span></span><br><span class="line">    <span class="built_in">string</span> text = <span class="built_in">string</span>.FastAllocateString(num);</span><br><span class="line">    <span class="keyword">fixed</span> (<span class="built_in">char</span>* ptr = &amp;text.m_firstChar)</span><br><span class="line">    &#123;</span><br><span class="line">        UnSafeCharBuffer unSafeCharBuffer = <span class="keyword">new</span> UnSafeCharBuffer(ptr, num);</span><br><span class="line">        unSafeCharBuffer.AppendString(<span class="keyword">value</span>[startIndex]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = startIndex + <span class="number">1</span>; j &lt;= num2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            unSafeCharBuffer.AppendString(separator);</span><br><span class="line">            unSafeCharBuffer.AppendString(<span class="keyword">value</span>[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接迭代器(列表类型)通过 StringBuilder 进行</span></span><br><span class="line"><span class="comment">// Token: 0x060004B5 RID: 1205 RVA: 0x000109C4 File Offset: 0x0000EBC4</span></span><br><span class="line">[<span class="meta">ComVisible(false)</span>]</span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Join</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> separator, IEnumerable&lt;T&gt; values</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略部分处理代码</span></span><br><span class="line">	result = StringBuilderCache.GetStringAndRelease(stringBuilder);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接 object 数组类型，通过 StringBuilderCache 对象池取 StringBuilder 进行拼接</span></span><br><span class="line"><span class="comment">// Token: 0x060004B4 RID: 1204 RVA: 0x0001093C File Offset: 0x0000EB3C</span></span><br><span class="line">[<span class="meta">ComVisible(false)</span>]</span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Join</span>(<span class="params"><span class="built_in">string</span> separator, <span class="keyword">params</span> <span class="built_in">object</span>[] values</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//省略</span></span><br><span class="line">    <span class="keyword">return</span> StringBuilderCache.GetStringAndRelease(stringBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-string-Concat"><a href="#7-string-Concat" class="headerlink" title="7. string.Concat"></a>7. string.Concat</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当连接数量级比较低时，参数为 string 则直接通过创建最终字符串内存连接</span></span><br><span class="line"><span class="comment">// Token: 0x06000556 RID: 1366 RVA: 0x00013524 File Offset: 0x00011724</span></span><br><span class="line">[<span class="meta">SecuritySafeCritical</span>]</span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Concat</span>(<span class="params"><span class="built_in">string</span> str0, <span class="built_in">string</span> str1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//部分判断代码省略===============</span></span><br><span class="line">	<span class="built_in">int</span> length = str0.Length;</span><br><span class="line">	<span class="built_in">string</span> text = <span class="built_in">string</span>.FastAllocateString(length + str1.Length);</span><br><span class="line">	<span class="built_in">string</span>.FillStringChecked(text, <span class="number">0</span>, str0);</span><br><span class="line">	<span class="built_in">string</span>.FillStringChecked(text, length, str1);</span><br><span class="line">	<span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接迭代器(列表类型)通过 StringBuilder 进行</span></span><br><span class="line"><span class="comment">// Token: 0x06000555 RID: 1365 RVA: 0x000134B8 File Offset: 0x000116B8</span></span><br><span class="line">[<span class="meta">ComVisible(false)</span>]</span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Concat</span>(<span class="params">IEnumerable&lt;<span class="built_in">string</span>&gt; values</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//省略</span></span><br><span class="line">	<span class="keyword">return</span> StringBuilderCache.GetStringAndRelease(stringBuilder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当连接数量级比较低时，参数为 object 则直接通过符号连接</span></span><br><span class="line"><span class="comment">// Token: 0x06000551 RID: 1361 RVA: 0x00013330 File Offset: 0x00011530</span></span><br><span class="line">[<span class="meta">__DynamicallyInvokable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Concat</span>(<span class="params"><span class="built_in">object</span> arg0, <span class="built_in">object</span> arg1, <span class="built_in">object</span> arg2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//判断省略==========</span></span><br><span class="line">    <span class="keyword">return</span> arg0.ToString() + arg1.ToString() + arg2.ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcatArray(当 string.Concat 超过三个 object 对象时调用)</span></span><br><span class="line"><span class="comment">//超出这个数量则通过内存分配进行</span></span><br><span class="line"><span class="comment">// Token: 0x06000559 RID: 1369 RVA: 0x000136AC File Offset: 0x000118AC</span></span><br><span class="line">[<span class="meta">SecuritySafeCritical</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ConcatArray</span>(<span class="params"><span class="built_in">string</span>[] values, <span class="built_in">int</span> totalLength</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> text = <span class="built_in">string</span>.FastAllocateString(totalLength);</span><br><span class="line">    <span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; values.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span>.FillStringChecked(text, num, values[i]);</span><br><span class="line">        num += values[i].Length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接分配指定字符串数组所有字符串长度大小的大块字符串，然后通过 wstrcpy-&gt;Buffer.Memcpy 对内存直接进行拷贝操作。</p><h2 id="8-Format"><a href="#8-Format" class="headerlink" title="8. Format"></a>8. Format</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">FormatHelper</span>(<span class="params">IFormatProvider provider, <span class="built_in">string</span> format, ParamsArray args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (format == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;format&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StringBuilderCache.GetStringAndRelease(StringBuilderCache.Acquire(format.Length + args.Length * <span class="number">8</span>).AppendFormatHelper(provider, format, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对-string-Format-与普通拼接的性能测试"><a href="#对-string-Format-与普通拼接的性能测试" class="headerlink" title="对 string.Format 与普通拼接的性能测试"></a>对 string.Format 与普通拼接的性能测试</h3><p>除了对数组一类数据结构类型的拼接之外，常用的估计就 2~3 个带参数的简单字符串拼接了。</p><p>这种通常见到的还是直接+号进行，也有使用 string.Format 的。</p><p>为了评估以后究竟以使用哪种方式为准，我想再加一点测试，测一测使用 + 号与 string.Format 拼接简单字符串两者的性能。</p><p>每一项进行 10000 次操作，测试结果如下：</p><ul><li>简单拼接测试（X+1）：0秒3毫秒</li><li>简单拼接测试（1+X）：0秒3毫秒</li><li>简单拼接测试（X+1+Y）：0秒4毫秒</li><li>简单拼接测试（X+1+Y+2）：0秒6毫秒</li><li>简单拼接测试（X+1+Y+2+Z+3）：0秒11毫秒</li><li>简单拼接测试（X+1+Y+2+Z+3+W+4）：0秒14毫秒</li><li>string.concat（X+1）：0秒3毫秒</li><li>string.concat（1+X）：0秒3毫秒</li><li>string.concat（X+1+Y）：0秒4毫秒</li><li>string.concat（X+1+Y+2）：0秒6毫秒</li><li>string.concat（X+1+Y+2+Z+3）：0秒26毫秒</li><li>string.concat（X+1+Y+2+Z+3+W+4）：0秒14毫秒</li><li>string.format 拼接测试（X{0}）：0秒7毫秒</li><li>string.format 拼接测试（{0}X）：0秒7毫秒</li><li>string.format 拼接测试（X{0}Y）：0秒7毫秒</li><li>string.format 拼接测试（X{0}Y{1}）：0秒11毫秒</li><li>string.format 拼接测试（X{0}Y{1}Z{2}）：0秒16毫秒</li><li>string.format 拼接测试（X{0}Y{1}Z{2}W{3}）：0秒35毫秒</li><li>StringBuilder 拼接测试（X+1）：0秒4毫秒</li><li>StringBuilder 拼接测试（1+X）：0秒4毫秒</li><li>StringBuilder 拼接测试（X+1+Y）：0秒5毫秒</li><li>StringBuilder 拼接测试（X+1+Y+2）：0秒8毫秒</li><li>StringBuilder 拼接测试（X+1+Y+2+Z+3）：0秒11毫秒</li><li>StringBuilder 拼接测试（X+1+Y+2+Z+3+W+4）：0秒14毫秒</li></ul><p>每一项进行 100000 次操作，去除随机参数，测试结果如下：</p><ul><li>简单拼接测试（X+1）：0秒16毫秒</li><li>简单拼接测试（1+X）：0秒15毫秒</li><li>简单拼接测试（X+1+Y）：0秒20毫秒</li><li>简单拼接测试（X+1+Y+2）：0秒25毫秒</li><li>简单拼接测试（X+1+Y+2+Z+3）：0秒66毫秒</li><li>简单拼接测试（X+1+Y+2+Z+3+W+4）：0秒77毫秒</li><li>string.concat（X+1）：0秒17毫秒</li><li>string.concat（1+X）：0秒16毫秒</li><li>string.concat（X+1+Y）：0秒35毫秒</li><li>string.concat（X+1+Y+2）：0秒24毫秒</li><li>string.concat（X+1+Y+2+Z+3）：0秒65毫秒</li><li>string.concat（X+1+Y+2+Z+3+W+4）：0秒64毫秒</li><li>string.format 拼接测试（X{0}）：0秒60毫秒</li><li>string.format 拼接测试（{0}X）：0秒66毫秒</li><li>string.format 拼接测试（X{0}Y）：0秒68毫秒</li><li>string.format 拼接测试（X{0}Y{1}）：0秒71毫秒</li><li>string.format 拼接测试（X{0}Y{1}Z{2}）：0秒106毫秒</li><li>string.format 拼接测试（X{0}Y{1}Z{2}W{3}）：0秒145毫秒</li><li>StringBuilder 拼接测试（X+1）：0秒28毫秒</li><li>StringBuilder 拼接测试（1+X）：0秒27毫秒</li><li>StringBuilder 拼接测试（X+1+Y）：0秒33毫秒</li><li>StringBuilder 拼接测试（X+1+Y+2）：0秒38毫秒</li><li>StringBuilder 拼接测试（X+1+Y+2+Z+3）：0秒67毫秒</li><li>StringBuilder 拼接测试（X+1+Y+2+Z+3+W+4）：0秒62毫秒</li></ul><p>结果非常出乎意料，原以为 string.format 性能应该是比较好的，没成想竟然是最费的…也许由于字符串内部占位符需要单独做解析，导致了大量消耗？</p><p>于是看了下源码，发现在 AppendFormatHelper 方法中，对整个字符串都做了一次遍历，去分析是否有 {} 这种占位符，这个确实是个会随字符串量级增加而增加消耗的一个操作——string.format 对于连接字符串存在多个参数的情况下，耗费时间也同样会随着参数增长而增加。</p><p>因此除了字符串数组类型拼接方法外，可以自己专门定义一个方法用于连接『散』字符串，以选择性能更好的拼接方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据上面的测试——虽然这种测试不一定很准确(毕竟 Unity 中 .Net 版本比较低)，以及对 string 源码本身的查看，基本上可以总结以下几个注意点：</p><p>连接纯字符串超过 3 个时，有分隔符可以选择 StringBuilder、string.join(数组)，否则使用 string.concat(数组)，至于 string.format——除了好看一点，能不用就不要用了，性能上完全没有优势。</p><p>其中 string.concat 及 string.join 的源码显示，其对不同类型选择了不同的处理方式。</p><p>共同点有：</p><ul><li>字符串类型数组，直接通过分配一大块字符串内存，通过 unsafe 内存拷贝实现</li><li>连接迭代器(列表类型)或者连接 object 数组均通过 StringBuilderCache 取 StringBuilder 进行</li></ul><p>string.Concat 特有：</p><ul><li>参数为 string，当连接数量级比较低时，直接通过分配一块最终字符串大小内存，通过 unsafe 内存拷贝实现</li><li>参数为 object，当连接数量级比较低时(3个以下)， 则直接通过符号连接，超过三个则创建临时数组变量将 object 转字符串，再走正常字符串数组连接方法</li></ul><h4 id="最终可以得出结论："><a href="#最终可以得出结论：" class="headerlink" title="最终可以得出结论："></a>最终可以得出结论：</h4><p>拼接数量在2个：可以使用 + 号<br>拼接数量在4个及以下：字符串可以使用 string.concat(非字符串3个或以下时直接+号拼接，4个或以上时会生成临时数组变量将object.tostring，然后调用字符串数组拼接函数处理——调用不定参数方法时也是如此处理)，否则最好 StringBuilder<br>拼接数量在超过4个：StringBuilder (不推荐 string.concat 是因为通过可变参数传参它会生成额外临时字符串数组，直接拼接数组时更有优势)<br>连接字符串数组、字符串列表类型：可以用 string.join 或 string.concat(无分隔符)，有特殊回调需求则自定义 StringBuilder (注：内部实际上也是用 StringBuilder 拼接的，不过看 DotNetCore 的源码实现不一样，是创建一个结构体 ValueStringBuilder，通过 stackalloc 在栈上分配 char 数组(Span)结构进行拼接)<br>连接其它容器(比如字典)：StringBuilder</p><p>再解释一下：</p><p>连接字符串在4个及以下时，可以通过 string.concat (强调：字符串类型，非字符串可以 toString 传入)<br>字符串数组和字符串列表都可以用 string.join 或 string.concat (内部 StringBuilder ，有对象池)<br>其它类型的数组、列表或字典容器以及超出4个单字符串的连接，采用自己 StringBuilder 进行，并且可以缓存这个 StringBuilder 进行重复使用。<br>只有两个字符串拼接，才允许使用符号+</p><p>(注：上述均表示一次性拼接的前提，若连续多次连接，则 StringBuilder 无疑是最好选择)</p><div class="tags-container-bottom"><i class="fa fa-tag pr3 text-main-color"></i><a class="fw3 ph1 dib" href="/tags/性能优化/">#性能优化</a></div><br><br><hr><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><div id="vcomments"></div><script>new Valine({el:"#vcomments",appId:"MsaVbSzIr9cIfikihDExdun9-gzGzoHsz",appKey:"Bj6SEFUBomrLOTWx9B8S6zQH",placeholder:"请输入评论内容~",avatar:"mp",visitor:!1})</script></div><div class="fl w-100 w-30-l center fw3 lh-copy pl4-ns tl black-50"><hr class="dn-l mw4 black-50 mt5"><div class="mt5 mt0-l site-author"><article class="dt db-l mw8 mw8-m mw5-ns center ml0-l bg-white mv3"><div class="dn dtc-m db-l v-mid tc pr4 pr0-l" style="min-width:6rem"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/photo.jpg" class="mb4-l br-100 h3 w3 h4-l w4-l dib" title="CWHISME"></div><div class="dtc db-l v-mid lh-copy measure center f6 black-50 tj">悲观主义的末日</div></article></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>分类</h3><p><a href="/categories/C/">C#</a></p></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>近期文章</h3><p><a href="/2022/12/10/%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/">协变和逆变</a></p><p><a href="/2022/12/06/Unity%E7%9A%84%E9%98%B4%E5%BD%B1%E4%B8%8E%E5%85%89%E7%85%A7%E7%83%98%E7%84%99/">Unity 的阴影与光照烘焙</a></p><p><a href="/2022/11/23/%E6%89%93%E5%8C%85AssetBundle%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86/">打包 AssetBundle 的基础规则整理</a></p><p><a href="/2022/11/18/StringBuilder%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E7%A0%94%E7%A9%B6/">StringBuilder 扩容规则研究</a></p><p><a href="/2022/11/17/%E6%B5%8B%E8%AF%95%E6%89%8B%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">简单测试手动垃圾回收</a></p></div></div></div></div></div></div><div class="bg-1 ph2 ph5-ns pv5"><div class="mv8"><div class="center tc"><div class="dib mh3"><a class="f3 f2-ns white dim" href="https://github.com/CWHISME" target="_blank"><i class="fa fa-github"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="mailto:cwhisme@126.com" target="_blank"><i class="fa fa-envelope"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div></div><div class="f6 f5-ns center tc white pt5 fw3">Copyright © 2021 | Design & Hexo <a class="link dim white" target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-anodyne/">Jonathan Klughertz</a> | Modify By CWHISME</div></div></div></body></html>