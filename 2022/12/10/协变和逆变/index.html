<!DOCTYPE html><meta name="viewport" content="height=device-height,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=0"><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="cwhisme"><meta name="author" content="CWHISME"><meta property="og:title" content="协变和逆变"><meta property="og:description" content="cwhisme"><meta property="og:site_name" content="WangJiaYing"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><title>协变和逆变 - WangJiaYing</title><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/DateTimeAfeterCalc.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/particles-bg.js"></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/script.js"></script><link href="https://fastly.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/css/style.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tachyons@4.12.0/css/tachyons.min.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="WangJiaYing" type="application/atom+xml">
</head><body><canvas id="hackEffectCanvas" style="position:fixed;z-index:-1;pointer-events:none"></canvas><canvas class="fireworks" style="position:fixed;z-index:10;pointer-events:none"></canvas><div class="w-100 bg-1 ph5-ns ph3 text-light"><nav class="db dt-l w-100 mw8 center border-box pv3"><a class="db dtc-l v-mid link dim w-100 w-25-l tc tl-l mb2 mb0-l white" href="/" title="WangJiaYing"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/logo.svg" class="dib h3" alt="WangJiaYing"></a><div class="db dtc-l v-mid w-100 w-75-l tc tr-l"><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/" title="Home">Home </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/archives" title="Archives">Archives </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/tags" title="Tags">Tags </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/categories" title="Categories">Categories </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/bookmark" title="Bookmark">Bookmark </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/about" title="About">About</a></div></nav><div class="w-100 mw8 center vh-40 dt"><div class="dtc v-mid white"><h1 class="f1-l f2-m tc tc-m tl-ns">协变和逆变</h1><p class="f4 fw3 pab-100px tc tc-m tl-ns"><i class="fa fa-calendar-check-o" aria-hidden="true"></i> 2022-12-10&nbsp&nbsp <i class="fa fa-clock-o" aria-hidden="true"></i> <span id="dateTimeAfter">2022-12-10</span></p></div></div><div class="relative w-100 mw8 center white dn dn-m db-ns"><i class="header-icon fa fa-snowflake-o"></i></div></div><div class="w-100 ph2 ph4-m ph5-l mv5 mv6-l"><div class="content"><div class="mw8 center"><div class="cf"><div class="fl w-100 w-70-l mw7 left fw3 lh-copy pr4-ns pr0-m post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于协变和逆变，早在前些日子就在想整理一下了，不过由于前几天研究了下 <a href="">Unity 的阴影与光照烘焙</a> ，所以一直放在心上却没有实施，都忘了之前是准备想怎么写开头了…也忘了作笔记，只能现在重新想一想。</p><p>逆变 和 协变其实是对面向对象的一个补充，在 C# 中通过 in 标识逆变，out 标识 协变，如果没有标识，那么默认就是 『不变』。</p><p>之前想思考了好些天了，感觉有些地方还是有点没想透彻，这次整理的同时进行更多的试验，确定自己的想法对不对。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>变体仅针对引用类型，且只有 数组(隐式协变)、泛型委托、泛型接口 可以使用。</p><p><font color="red">注：对于同一泛型参数，逆变和协变不能同时存在。</font></p><p>正常来说，根据里氏替换原则：子类型（subtype）必须能够替换掉他们的基类型（base type）</p><p>我们通常在写代码的时候，也会不自觉地用到这一点：例如派生出多个子类的父类，可以作为一个『统一的方法参数』接受子类传递然后处理：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Log</span>(<span class="params">Parent pt</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(pt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child child = <span class="keyword">new</span> Child();</span><br><span class="line">ChildBoy childBoy = <span class="keyword">new</span> ChildBoy();</span><br><span class="line">Log(child);</span><br><span class="line">Log(childBoy);</span><br></pre></td></tr></table></figure><p>我们可以说一个类是另一个类的基类，但是一个接口、一个委托正常是没有这种关系的，所以当包裹一层(委托、接口)后就不行了——理论上它们并没有子类指向父类的关系。</p><p>泛型是对类型系统的进一步抽象，上面的变化映射至(数组、泛型委托、泛型接口)就是逆变与协变的概念。</p><p>从简单表现上来看：</p><ul><li>协变用于隐式将返回参数(容器)的子类转为父类</li><li>逆变用于隐式将传入参数(容器)的父类转为子类</li></ul><p>想想看：</p><ul><li>协——子类指向父类的关系符合原始的关系转换方向</li><li>逆——父类转子类</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试协变"><a href="#测试协变" class="headerlink" title="测试协变"></a>测试协变</h3><h4 id="1-数组"><a href="#1-数组" class="headerlink" title="(1) 数组"></a>(1) 数组</h4><p>数组的协变相信大多数人都不自觉使用过，例如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] strings = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">object</span>[] objects = strings;</span><br></pre></td></tr></table></figure><p>上述代码就是数组隐式支持的协变：我们可以把子类数组直接赋值给定义的基类数组。</p><p>上面已经解释过，协变用于 『返回值隐式转换为父类』</p><blockquote><p>因为不管如何从数组中取值：strings[index] 都可以转为 object</p></blockquote><p>符合 『子类指向父类的关系』，协变成立。</p><h4 id="2-接口"><a href="#2-接口" class="headerlink" title="(2) 接口"></a>(2) 接口</h4><p>接口的协变以 C# 内置 IReadOnlyList 接口为例，该接口标记了 out，List 就实现了该接口。</p><p>首先定义两个有父子关系的引用对象：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Parent：父类&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Child</span> : <span class="title">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Child：子类&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进行调用测试：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Child&gt; childList = <span class="keyword">new</span> List&lt;Child&gt;() &#123; <span class="keyword">new</span> Child() &#125;;</span><br><span class="line"><span class="comment">//====报错====列表是普通类，没有也不支持协变功能</span></span><br><span class="line"><span class="comment">//List&lt;Parent&gt; parentList = childList;</span></span><br><span class="line"><span class="comment">//正常赋值，协变使得声明子类的接口可隐式转为父类</span></span><br><span class="line">IReadOnlyList&lt;Parent&gt; baseList = childList;</span><br><span class="line">Debug.Log(baseList[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test (0.008s)</span><br><span class="line">---</span><br><span class="line">Child：子类</span><br></pre></td></tr></table></figure><p>可能在这里还会有点不明白发生了什么，再以 List 实现的另一个接口 <code>IList&lt;T&gt;</code> 为例，IList 接口并未做标识，因此它是『不变』的，如果我们想这样赋值：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//报错，提示无法隐式转换 List&lt;Child&gt;-&gt;IList&lt;Panret&gt;</span></span><br><span class="line">IList&lt;Parent&gt; list = childList;</span><br></pre></td></tr></table></figure><p>作为『不变』的泛型接口，想要将泛型子类赋值泛型父类就会得到报错。</p><p>现在应该大概有点感觉了——特别是当拥有多个子类，我们想统一接收的时候，拥有协变就可以直接这样写：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;Child&gt; childList = <span class="keyword">new</span> List&lt;Child&gt;() &#123; <span class="keyword">new</span> Child() &#125;;</span><br><span class="line">List&lt;ChildBoy&gt; childList2 = <span class="keyword">new</span> List&lt;ChildBoy&gt;() &#123; <span class="keyword">new</span> ChildBoy() &#125;;</span><br><span class="line">List&lt;ChildGirl&gt; childList3 = <span class="keyword">new</span> List&lt;ChildGirl&gt;() &#123; <span class="keyword">new</span> ChildGirl() &#125;;</span><br><span class="line">Log(childList);</span><br><span class="line">Log(childList2);</span><br><span class="line">Log(childList3);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Log</span>(<span class="params">IReadOnlyList&lt;Parent&gt; baseList</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(baseList[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Test (0.009s)</span><br><span class="line">---</span><br><span class="line">Child：子类</span><br><span class="line">ChildBoy：子类</span><br><span class="line">ChildGirl：子类</span><br></pre></td></tr></table></figure><blockquote><p>当我们调用 childList[0] 可以得到一个 Child<br>当我们调用 childList2[0] 可以得到一个 ChildBoy<br>当我们调用 childList3[0] 可以得到一个 ChildGirl</p></blockquote><p>最后从接口得到的这个对象，都可以安全转为 Parent<br>符合 『子类指向父类的关系』，协变成立。</p><h4 id="3-委托"><a href="#3-委托" class="headerlink" title="(3) 委托"></a>(3) 委托</h4><p>除此之外，还有接触最多的 <code>TResult Func&lt;out TResult&gt;</code> 委托，它的返回值也是支持协变的：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;Parent&gt; parentFunc = () =&gt; <span class="keyword">new</span> Parent();</span><br><span class="line">Func&lt;Child&gt; childFunc = () =&gt; <span class="keyword">new</span> Child();</span><br><span class="line">parentFunc = childFunc;</span><br></pre></td></tr></table></figure><p>上面已经解释过，协变用于 『返回值隐式转换为父类』：因为 Child 可以转为 Parent，所以<code>Func&lt;Child&gt;</code> 也可以安全转为 <code>Func&lt;Parent&gt;</code>.</p><blockquote><p>当我们调用 childFunc() 可以得到一个 子类<br>当我们调用 parentFunc() 可以得到一个 父类<br>当 parentFunc=childFunc 调用可以得到一个 父类</p></blockquote><p>符合 『子类指向父类的关系』，协变成立。</p><h3 id="测试逆变"><a href="#测试逆变" class="headerlink" title="测试逆变"></a>测试逆变</h3><p>协变标识返回值，逆变标识参数。</p><p>虽然听起来差不多，不过协变看着其实更符合思考，因为基于接口、委托的执行返回值我们可以更加直观地得出结论，逆变可能就没那么容易理解了。</p><p>还是先以 C# 内置 IComparable 接口为例，该接口标记了逆变，我们定义两个类：Parent 和 Child，并使 Parent 实现该接口。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IComparable&lt;Parent&gt; ip = <span class="keyword">new</span> Parent();</span><br><span class="line">IComparable&lt;Child&gt; iChild = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="comment">//====报错====</span></span><br><span class="line">ip = iChild;</span><br><span class="line"><span class="comment">//正常赋值，逆变使得声明父类接口隐式转为声明子类接口</span></span><br><span class="line">iChild = ip;</span><br></pre></td></tr></table></figure><p>在上述代码中，反而是 Child 接口能够接受 Parent 接口对象，第一个地方将 iChild(子类接口) 赋值 ip(父类接口) 为什么会报错呢？</p><p>在上面我们已经测试过协变了，协变得出的结论是最终返回结果的类型一定是符合转换规则的，那么这里应该也可以先从执行结果上考虑：</p><blockquote><p>若执行 <code>IComparable&lt;Parent&gt;</code> 接口，需要接受 Parent 或 Child 参数<br>若执行 <code>IComparable&lt;Child&gt;</code> 接口，只能接受 Child 参数</p></blockquote><ul><li>如果我们把 ip 赋值给 iChild，那么在参数中就变成只能接受 Child 类型了。</li><li>但是如果把 iChild 赋值给 ip，那么参数中种就变成也可以接受 Parent 类型了。</li></ul><p>所以，区别是什么？</p><p>区别在于：<font color="red">(1) ip 本来是接受父类型，变成只能接受子类型，是合理的。(2) iChild 本来只能接受子类型，如果变成接受父类型参数则不合理。</font></p><p>想一想，一个方法的参数接受的是子类，但是把父类传进去，是不是只有强制类型转换？但是强制类型转换是不是又涉及到这个『父类实际上装的并不是这个子类』问题呢？</p><p>说实话，逆变确实感觉更绕，但从结果上来看，又能感觉确实应当如此。</p><p>泛型委托也是一样的道理：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;Parent&gt; parentAction = (p) =&gt; Debug.Log(p);</span><br><span class="line">Action&lt;Child&gt; childAction = (c) =&gt; Debug.Log(c);</span><br><span class="line"><span class="comment">//报错，因为如果赋值成功，调用 parentAction(childAction) 就可以传入父类型了</span></span><br><span class="line">parentAction = childAction;</span><br><span class="line"><span class="comment">//正常赋值，childAction 只能接受 Child 类型，parentAction 接受 Child 类型符合父类指向子类的关系</span></span><br><span class="line">childAction = parentAction;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>协变(out)逆(in）：数组是协变的-子类数组可以隐式转为父类数组使用，只能用于『数组、泛型委托、泛型接口』，协变用于返回值隐式转为父类(容器)，逆变用于传入值可以被隐式转为子类(容器)(当然在调用时类型就变成确定了)，不变：不可互转，变体仅适用于引用类型。</p><ul><li>逆变常见是 Action&lt;子类&gt;=Action&lt;父类&gt;，参数为父类的委托赋值给参数子类的委托，调用时必须传入子类对象，根据面向对象规则子类一定包含父类字段或方法，可以正常调用</li><li>协变常见的比如 List 实现的 IEnumerable，正常情况下 List&lt;子类型&gt; 无法赋值给 List&lt;父类型&gt;，这个接口就标记了协变，使得可以声明 IEnumerabl&lt;父类型&gt; = List&lt;子类型&gt;</li><li>也可以简单记为：协变可以使得声明为父类的泛型可以装载子类，逆变使得声明子类的泛型可以可装载父类，其最终执行的返回值、参数符合里氏替换原则。</li></ul><p>对于这两者，从表现上来看：</p><ul><li>协变：声明的泛型容器子类可以赋值父类</li><li>逆变：声明的泛型容器父类可以赋值子类</li></ul><p>从调用结果上来看：</p><ul><li>协变：返回结果符合里氏替换原则，返回值为父类型的方法也可以返回子类型</li><li>逆变：接收参数符合里氏替换原则，参数为父类型的方法可以接受子类型的参数</li></ul><p>所以回到前面的一个问题：对于同一个模板参数 T ，协变和逆变不能同时存在，为什么呢？</p><blockquote><p>仔细考虑一下，如果一个接口参数同时支持协变和逆变，那么上述测试的赋值方式就必须同时双向支持，这样就会导致出现『参数为子类型的接口，可以传入父类型』，这是不合法的。<br>反之亦然，返回参数为子类型的接口，返回了实际为父类型的对象，也是不合法的。</p></blockquote><p>C# 中常见的自带协变逆变的接口或委托：</p><ul><li><code>IEnumerable&lt;out T&gt;</code></li><li><code>IEnumerator&lt;out T&gt;</code></li><li><code>System.Linq.IQueryable&lt;out T&gt;</code></li><li><code>IComparer&lt;in T&gt;</code></li><li><code>IComparable&lt;in T&gt;</code></li><li><code>IEqualityComparer&lt;in T&gt;</code></li><li><code>IReadOnlyList&lt;out T&gt;</code></li><li><code>TResult Func&lt;in T, out TResult&gt;(T arg) 等</code></li><li><code>void Action&lt;in T&gt;(T obj) 等</code></li><li>数组默认协变</li></ul><p>—————————————————————————————————————————</p><blockquote><p>参考文档：</p><ul><li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/standard/generics/covariance-and-contravariance">covariance-and-contravariance</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/VVStudy/p/11404300.html">C# - 协变、逆变 看完这篇就懂了</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/CLR010/p/3274310.html">逆变与协变详解</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Ninputer/archive/2008/11/22/generic_covariant.html">.NET 4.0中的泛型协变和反变</a></li></ul></blockquote><br><br><hr><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><div id="vcomments"></div><script>new Valine({el:"#vcomments",appId:"MsaVbSzIr9cIfikihDExdun9-gzGzoHsz",appKey:"Bj6SEFUBomrLOTWx9B8S6zQH",placeholder:"请输入评论内容~",avatar:"mp",visitor:!1})</script></div><div class="fl w-100 w-30-l center fw3 lh-copy pl4-ns tl black-50"><hr class="dn-l mw4 black-50 mt5"><div class="mt5 mt0-l site-author"><article class="dt db-l mw8 mw8-m mw5-ns center ml0-l bg-white mv3"><div class="dn dtc-m db-l v-mid tc pr4 pr0-l" style="min-width:6rem"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/photo.jpg" class="mb4-l br-100 h3 w3 h4-l w4-l dib" title="CWHISME"></div><div class="dtc db-l v-mid lh-copy measure center f6 black-50 tj">悲观主义的末日</div></article></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>分类</h3><p><a href="/categories/C/">C#</a></p></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>近期文章</h3><p><a href="/2022/12/10/%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/">协变和逆变</a></p><p><a href="/2022/12/06/Unity%E7%9A%84%E9%98%B4%E5%BD%B1%E4%B8%8E%E5%85%89%E7%85%A7%E7%83%98%E7%84%99/">Unity 的阴影与光照烘焙</a></p><p><a href="/2022/11/23/%E6%89%93%E5%8C%85AssetBundle%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86/">打包 AssetBundle 的基础规则整理</a></p><p><a href="/2022/11/18/StringBuilder%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E7%A0%94%E7%A9%B6/">StringBuilder 扩容规则研究</a></p><p><a href="/2022/11/17/%E6%B5%8B%E8%AF%95%E6%89%8B%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">简单测试手动垃圾回收</a></p></div></div></div></div></div></div><div class="bg-1 ph2 ph5-ns pv5"><div class="mv8"><div class="center tc"><div class="dib mh3"><a class="f3 f2-ns white dim" href="https://github.com/CWHISME" target="_blank"><i class="fa fa-github"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="mailto:cwhisme@126.com" target="_blank"><i class="fa fa-envelope"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div></div><div class="f6 f5-ns center tc white pt5 fw3">Copyright © 2021 | Design & Hexo <a class="link dim white" target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-anodyne/">Jonathan Klughertz</a> | Modify By CWHISME</div></div></div></body></html>