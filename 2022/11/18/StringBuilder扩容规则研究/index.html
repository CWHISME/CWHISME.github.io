<!DOCTYPE html><meta name="viewport" content="height=device-height,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=0"><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="cwhisme"><meta name="author" content="CWHISME"><meta property="og:title" content="StringBuilder 扩容规则研究"><meta property="og:description" content="cwhisme"><meta property="og:site_name" content="WangJiaYing"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><title>StringBuilder 扩容规则研究 - WangJiaYing</title><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/DateTimeAfeterCalc.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/particles-bg.js"></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/script.js"></script><link href="https://fastly.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/css/style.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tachyons@4.12.0/css/tachyons.min.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="WangJiaYing" type="application/atom+xml">
</head><body><canvas id="hackEffectCanvas" style="position:fixed;z-index:-1;pointer-events:none"></canvas><canvas class="fireworks" style="position:fixed;z-index:10;pointer-events:none"></canvas><div class="w-100 bg-1 ph5-ns ph3 text-light"><nav class="db dt-l w-100 mw8 center border-box pv3"><a class="db dtc-l v-mid link dim w-100 w-25-l tc tl-l mb2 mb0-l white" href="/" title="WangJiaYing"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/logo.svg" class="dib h3" alt="WangJiaYing"></a><div class="db dtc-l v-mid w-100 w-75-l tc tr-l"><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/" title="Home">Home </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/archives" title="Archives">Archives </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/tags" title="Tags">Tags </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/categories" title="Categories">Categories </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/bookmark" title="Bookmark">Bookmark </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/about" title="About">About</a></div></nav><div class="w-100 mw8 center vh-40 dt"><div class="dtc v-mid white"><h1 class="f1-l f2-m tc tc-m tl-ns">StringBuilder 扩容规则研究</h1><p class="f4 fw3 pab-100px tc tc-m tl-ns"><i class="fa fa-calendar-check-o" aria-hidden="true"></i> 2022-11-18&nbsp&nbsp <i class="fa fa-clock-o" aria-hidden="true"></i> <span id="dateTimeAfter">2022-11-18</span></p></div></div><div class="relative w-100 mw8 center white dn dn-m db-ns"><i class="header-icon fa fa-snowflake-o"></i></div></div><div class="w-100 ph2 ph4-m ph5-l mv5 mv6-l"><div class="content"><div class="mw8 center"><div class="cf"><div class="fl w-100 w-70-l mw7 left fw3 lh-copy pr4-ns pr0-m post-content"><div class="tags-container-vertical"><div class="tags-sub-container"><a class="fw3 ph1 dib" href="/tags/性能优化/">#性能优化</a></div></div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上面 <a href="">对项目字符串性能优化方式及测试</a> 文章中，我查看了 StringBuilder 的源码，并总结出了 StringBuilder 的一般及自动扩容规则：</p><p>容量足够的情况下，通过 unsafe 方法进行指针及直接内存操作：</p><ol><li>获取添加的字符串指针</li><li>获取字符数组待添加下标指针</li><li>调用 Buffer.Memcpy 进行内存拷贝进字符数组</li></ol><p>如果后续容量不够，则进行动态扩容，不过动态扩容不是直接扩容字符数组，而是通过单向链表的方式：</p><p><strong>将当前数据全部转移至『上一个』节点，然后自己创建一个新的字符数组进行处理。</strong></p><p>简单来说，就是创建一个新的 StringBuilder，把自己当前所有数据转移过去，自己创建一个新的数组继续继续处理余下的。</p><p>然后就一直有个疑问：如何做到每次扩容是之前的 2 倍大小的？</p><p>然后现在研究半天发现，都知道实现扩容的具体方法是通过单链表，2 倍扩容的原理其实已经是明面上的规则了：是个非常简单的原理，只是思维上一直没考虑到而已，所以作个记录。</p><p>这里前言先不说具体原理，从试验和测试开始，具体的留到文后总结再写吧。</p><h2 id="扩容测试"><a href="#扩容测试" class="headerlink" title="扩容测试"></a>扩容测试</h2><p>StringBuilder 默认容量是 16 个字符，如果测试扩容的话，数量太大容易混淆。</p><p>因此我传设置了默认的容量 1，并依次传入 1、2、3、4、5，并打印每个数值 Append 之后容量大小，测试代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 执行测试</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoTest</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">1</span>);</span><br><span class="line">    builder.Append(<span class="number">1</span>);</span><br><span class="line">    Console.WriteLine(builder.Capacity);</span><br><span class="line">    builder.Append(<span class="number">2</span>);</span><br><span class="line">    Console.WriteLine(builder.Capacity);</span><br><span class="line">    builder.Append(<span class="number">3</span>);</span><br><span class="line">    Console.WriteLine(builder.Capacity);</span><br><span class="line">    builder.Append(<span class="number">4</span>);</span><br><span class="line">    Console.WriteLine(builder.Capacity);</span><br><span class="line">    builder.Append(<span class="number">5</span>);</span><br><span class="line">    Console.WriteLine(builder.Capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>可以发现，每次扩容容量都是以 2 倍递增，所以为什么呢？</p><p>用反编译工具对 StringBuilder 的源代码看了又看，有点想不明白。</p><p>想不明白就像试一试，直接上调试大法，断点打到 StringBuilder 里边去：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2022/2022-11-18/m_28c3073b4ee0fe17074da5a4471f73b6_r.png"></p><p>上述截图显示的是：当前 StringBuilder 容量为 2，且 Append(3) 的情况。</p><p>盯着这个看了下，计算了一下数值与结果，一个个分析下：</p><ul><li>minBlockCharCount 当前为 1</li><li>当前长度 Length 为 2</li><li>扩容长度为 Max(Length,minBlockCharCount)[8000 是翻倍上限，后续翻倍到这数量级后最多扩容 8000，除非传入字符串剩余字符大于 8000]</li><li>即扩容 Max(2,1)</li></ul><p>而 Length 在这里是个属性，点进 Length 去看：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前实际存储字符长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Length</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.m_ChunkOffset + <span class="keyword">this</span>.m_ChunkLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其由 m_ChunkOffset+m_ChunkLength 构成。</p><p>将代码往上一层的 <code>Append(char* value, int valueCount)</code> 方法移动：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当空间不足走扩容逻辑时</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//当前剩余容量</span></span><br><span class="line">	<span class="built_in">int</span> num3 = <span class="keyword">this</span>.m_ChunkChars.Length - <span class="keyword">this</span>.m_ChunkLength;</span><br><span class="line">	<span class="keyword">if</span> (num3 &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//剩余容量大于0，就先复制一部分填满</span></span><br><span class="line">		<span class="keyword">new</span> ReadOnlySpan&lt;<span class="built_in">char</span>&gt;((<span class="keyword">void</span>*)<span class="keyword">value</span>, num3).CopyTo(<span class="keyword">this</span>.m_ChunkChars.AsSpan(<span class="keyword">this</span>.m_ChunkLength));</span><br><span class="line">		<span class="comment">//m_ChunkLength 设置为字符数组满长度</span></span><br><span class="line">		<span class="keyword">this</span>.m_ChunkLength = <span class="keyword">this</span>.m_ChunkChars.Length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//至少扩容长度=添加字符串长度-剩余已添加字符长度</span></span><br><span class="line">	<span class="built_in">int</span> num4 = valueCount - num3;</span><br><span class="line">	<span class="comment">//执行扩容</span></span><br><span class="line">	<span class="keyword">this</span>.ExpandByABlock(num4);</span><br><span class="line">	<span class="comment">//将剩余字符复制进扩容后的字符数组（以前的已经变成链表的上一个节点了）</span></span><br><span class="line">	<span class="keyword">new</span> ReadOnlySpan&lt;<span class="built_in">char</span>&gt;((<span class="keyword">void</span>*)(<span class="keyword">value</span> + num3), num4).CopyTo(<span class="keyword">this</span>.m_ChunkChars);</span><br><span class="line">	<span class="comment">//设置当前 StringBuilder 已使用长度</span></span><br><span class="line">	<span class="keyword">this</span>.m_ChunkLength = num4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，每次扩容之前，前一个数组必然是被填满的，也就是说：</p><ul><li>m_ChunkLength=上一个节点实际使用字符长度</li><li>m_ChunkOffset 直接可以在扩容方法中看到，为前面所有节点的 m_ChunkLength(通过+=赋值的)</li></ul><p>由此可以得出结果：在扩容的时候，Length=this.m_ChunkOffset + this.m_ChunkLength=所有节点的总长度<br>(注：只有在扩容的时候才是如此，否则 Capacity[this.m_ChunkChars.Length + this.m_ChunkOffset] 才是就算没装满的所有节点的总容量)</p><p>当依照 所有节点的总长度 创建一个新节点的时候，新节点的字符数组长度即为之前所有节点总和。</p><p>这时候统计的就是新的节点加上以前所有节点长度，两者相加：相当于就扩容了两倍！</p><p>例如旧的所有节点相加为 32，扩容的新节点为 32，那么新的总节点容量就是 64…..以此类推。</p><p>然后就焕然大悟了，原来这么回事啊。</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>现在知道扩容为什么是翻倍的了。</p><p>然后在这个过程中，突然想到插入问题，插入与追加显然是不同的方法：比较单链表的模式，每个链表节点都是一个单独数组，想往前面的数组插入值？</p><p>想想这种模式插入就不大好办，看了下 Insert 代码，插入一次就得创建一个 StringBuilder(除非之前的节点有空闲空间，正常情况下不可能)</p><p>而且，不遵守扩容规则：最大为扩容字符串长度，最小为默认的 16 个字符，然后重连链表结构。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MakeRooms：每次调用插入，都会先创建一个 StringBuilder 占位，然后填充数据，一一处理链表节点</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(Math.Max(count, <span class="number">16</span>), chunk.m_MaxCapacity, chunk.m_ChunkPrevious);</span><br></pre></td></tr></table></figure><p>如果插入的下标正好还处于某一个节点字符数据中间，还需要遍历链表通过 CopyTo 移动数据，所以插入操作是比较耗时的。</p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>为此我尝试使用 TestRunner 进行测试，分别测试 追加、插入开始、插入中间、插入结束的性能。</p><p>每个操作分别进行 100000 次，测试代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> TestNum = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestAppend</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.Append(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Log(<span class="string">&quot;TestAppend Capacity&quot;</span> + builder.Capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestInsertStart</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.Insert(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Log(<span class="string">&quot;TestInsertStart Capacity&quot;</span> + builder.Capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestInsertMiddle</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.Insert(builder.Length / <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Log(<span class="string">&quot;TestInsertMiddle Capacity&quot;</span> + builder.Capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestInsertEnd</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.Insert(builder.Length, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Log(<span class="string">&quot;TestInsertEnd Capacity&quot;</span> + builder.Capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestAppendNormalParams</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.Append(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">        builder.Append(<span class="number">1</span>);</span><br><span class="line">        builder.Append(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Log(<span class="string">&quot;TestAppendNormalParams Capacity：&quot;</span> + builder.Capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestAppendFormatParams</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; TestNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.AppendFormat(<span class="string">&quot;X&#123;0&#125;Y&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Log(<span class="string">&quot;TestAppend Capacity：&quot;</span> + builder.Capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TestAppend (0.026s)</span><br><span class="line">---</span><br><span class="line">TestAppend Capacity104192</span><br><span class="line"></span><br><span class="line">TestAppendNormalParams (0.030s)</span><br><span class="line">---</span><br><span class="line">TestAppendNormalParams Capacity：304192</span><br><span class="line"></span><br><span class="line">TestAppendFormatParams (0.032s)</span><br><span class="line">---</span><br><span class="line">TestAppend Capacity：304192</span><br><span class="line"></span><br><span class="line">TestInsertStart (5.795s)</span><br><span class="line">---</span><br><span class="line">TestInsertStart Capacity100000</span><br><span class="line"></span><br><span class="line">TestInsertMiddle (2.852s)</span><br><span class="line">---</span><br><span class="line">TestInsertMiddle Capacity100000</span><br><span class="line"></span><br><span class="line">TestInsertEnd (0.069s)</span><br><span class="line">---</span><br><span class="line">TestInsertEnd Capacity100000</span><br></pre></td></tr></table></figure><p>由于插入操作必须对插入节点后续的节点作额外处理，因此插入越靠前消耗越大，可以看出即使是直接插入最后一个节点，也是比追加字符操作更为耗时的，所以使用 StringBuilder 时，尽量不要采用插入操作。</p><p>另外 AppendFormat 采用了与 string.Format 类似的处理方式：遍历字符串找占位符，因此也会造成多余消耗(这里因为只有一个占位符，因此与普通3次追加差距不大，但消耗确实也多了，占位符越多消耗越大)。</p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>之前看源码，插入时通过创建一个新的 StringBuilder 插入链表，且默认最小容量为 16。</p><p>但是现在为什么打印出来的 Capacity 容量，这里插入操作的增加反而最小？难道之前分析错了？</p><p>—————————————————————————————————————————</p><p>于是另外写了一份更简单的插入代码，查看链表插入节点信息：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2022/2022-11-18/m_71f1f5a195aab49f88c42ce132b4910e_r.png"></p><p><strong>Capacity=this.m_ChunkChars.Length + this.m_ChunkOffset<br>m_ChunkLength=上一个节点实际使用字符长度<br>m_ChunkChars.Length=字符数组长度<br>m_ChunkOffset=之前节点实际使用长度总和</strong></p><p>这里插入起始的这个节点，真实容量 Capacity=16<br>但是到了后续节点，由于后边节点只统计实际使用长度，后续节点 Capacity=1+当前字符数组长度 ，导致只统计了插入字符串实际长度大小，容量就变回去了。</p><p>所以对于插入的节点，测试打印出来的 Capacity 增加很小是个错觉，每个插入的 StringBuilder 依然还是有占用，至少 16 个空字符数组大小。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后发现原因就是这么简单：因为是链表结构，扩容的新节点长度等于以前节点总和，所以同样有了倍增的效果。</p><p>不过插入操作则会打乱倍增规律：例如原本 4 个下一次倍增应该为 8，若此时插入一个字符，下一次则扩容为 10。</p><p>另外 AppendFormat 原理与普通 string.Format 类似：遍历字符串找占位符，因此也会造成多余消耗。</p><p>同时顺便测试了下追加与插入等操作的性能，插入原理是创建一个新的、至少 16 个字符容量的 StringBuilder，性能消耗很大，因此得出尽量不要使用插入操作的结论。</p><div class="tags-container-bottom"><i class="fa fa-tag pr3 text-main-color"></i><a class="fw3 ph1 dib" href="/tags/性能优化/">#性能优化</a></div><br><br><hr><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><div id="vcomments"></div><script>new Valine({el:"#vcomments",appId:"MsaVbSzIr9cIfikihDExdun9-gzGzoHsz",appKey:"Bj6SEFUBomrLOTWx9B8S6zQH",placeholder:"请输入评论内容~",avatar:"mp",visitor:!1})</script></div><div class="fl w-100 w-30-l center fw3 lh-copy pl4-ns tl black-50"><hr class="dn-l mw4 black-50 mt5"><div class="mt5 mt0-l site-author"><article class="dt db-l mw8 mw8-m mw5-ns center ml0-l bg-white mv3"><div class="dn dtc-m db-l v-mid tc pr4 pr0-l" style="min-width:6rem"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/photo.jpg" class="mb4-l br-100 h3 w3 h4-l w4-l dib" title="CWHISME"></div><div class="dtc db-l v-mid lh-copy measure center f6 black-50 tj">悲观主义的末日</div></article></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>分类</h3><p><a href="/categories/C/">C#</a></p></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>近期文章</h3><p><a href="/2022/12/10/%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/">协变和逆变</a></p><p><a href="/2022/12/06/Unity%E7%9A%84%E9%98%B4%E5%BD%B1%E4%B8%8E%E5%85%89%E7%85%A7%E7%83%98%E7%84%99/">Unity 的阴影与光照烘焙</a></p><p><a href="/2022/11/23/%E6%89%93%E5%8C%85AssetBundle%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86/">打包 AssetBundle 的基础规则整理</a></p><p><a href="/2022/11/18/StringBuilder%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E7%A0%94%E7%A9%B6/">StringBuilder 扩容规则研究</a></p><p><a href="/2022/11/17/%E6%B5%8B%E8%AF%95%E6%89%8B%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">简单测试手动垃圾回收</a></p></div></div></div></div></div></div><div class="bg-1 ph2 ph5-ns pv5"><div class="mv8"><div class="center tc"><div class="dib mh3"><a class="f3 f2-ns white dim" href="https://github.com/CWHISME" target="_blank"><i class="fa fa-github"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="mailto:cwhisme@126.com" target="_blank"><i class="fa fa-envelope"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div></div><div class="f6 f5-ns center tc white pt5 fw3">Copyright © 2021 | Design & Hexo <a class="link dim white" target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-anodyne/">Jonathan Klughertz</a> | Modify By CWHISME</div></div></div></body></html>