<!DOCTYPE html><meta name="viewport" content="height=device-height,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=0"><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="cwhisme"><meta name="author" content="CWHISME"><meta property="og:title" content="简单测试手动垃圾回收"><meta property="og:description" content="cwhisme"><meta property="og:site_name" content="WangJiaYing"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><title>简单测试手动垃圾回收 - WangJiaYing</title><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/DateTimeAfeterCalc.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/particles-bg.js"></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/script.js"></script><link href="https://fastly.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/css/style.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tachyons@4.12.0/css/tachyons.min.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="WangJiaYing" type="application/atom+xml">
</head><body><canvas id="hackEffectCanvas" style="position:fixed;z-index:-1;pointer-events:none"></canvas><canvas class="fireworks" style="position:fixed;z-index:10;pointer-events:none"></canvas><div class="w-100 bg-1 ph5-ns ph3 text-light"><nav class="db dt-l w-100 mw8 center border-box pv3"><a class="db dtc-l v-mid link dim w-100 w-25-l tc tl-l mb2 mb0-l white" href="/" title="WangJiaYing"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/logo.svg" class="dib h3" alt="WangJiaYing"></a><div class="db dtc-l v-mid w-100 w-75-l tc tr-l"><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/" title="Home">Home </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/archives" title="Archives">Archives </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/tags" title="Tags">Tags </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/categories" title="Categories">Categories </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/bookmark" title="Bookmark">Bookmark </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/about" title="About">About</a></div></nav><div class="w-100 mw8 center vh-40 dt"><div class="dtc v-mid white"><h1 class="f1-l f2-m tc tc-m tl-ns">简单测试手动垃圾回收</h1><p class="f4 fw3 pab-100px tc tc-m tl-ns"><i class="fa fa-calendar-check-o" aria-hidden="true"></i> 2022-11-17&nbsp&nbsp <i class="fa fa-clock-o" aria-hidden="true"></i> <span id="dateTimeAfter">2022-11-17</span></p></div></div><div class="relative w-100 mw8 center white dn dn-m db-ns"><i class="header-icon fa fa-snowflake-o"></i></div></div><div class="w-100 ph2 ph4-m ph5-l mv5 mv6-l"><div class="content"><div class="mw8 center"><div class="cf"><div class="fl w-100 w-70-l mw7 left fw3 lh-copy pr4-ns pr0-m post-content"><div class="tags-container-vertical"><div class="tags-sub-container"><a class="fw3 ph1 dib" href="/tags/性能优化/">#性能优化</a></div></div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这两天又复习了下垃圾回收机制，在看到 析构函数 的时候，突然想到：析构函数是在真正垃圾回收时才会执行的，那么是否可以用这个来测试一个对象，什么情况下可以立即被垃圾回收？或者说变成垃圾对象。</p><p>例如，使用完毕后立即赋值为空，它变成垃圾对象了吗？还是其它什么时机才会。</p><p>测试方式为：在不同场景下，调用 GC.Collect ，并查看运行结果：析构函数是否被调用。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>工具：</p><ul><li>VS2022</li><li>.Net6.0</li><li>测试类：<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Doing！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~TestClass()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;被垃圾被回收了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="1）情景一：方法内部定义对象使用后赋值为空"><a href="#1）情景一：方法内部定义对象使用后赋值为空" class="headerlink" title="1）情景一：方法内部定义对象使用后赋值为空"></a>1）情景一：方法内部定义对象使用后赋值为空</h3><p>方法内立即调用 GC.Collect()</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 执行测试</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoTest</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestMethod();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestMethod</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestClass test = <span class="keyword">new</span> TestClass();</span><br><span class="line">        test.DoSomething();</span><br><span class="line">        test = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        GC.Collect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Doing！</span><br></pre></td></tr></table></figure><p>析构函数未被调用。</p><p>将 GC.Collect() 方法调用移动到 DoTest() 方法的 TestMethod() 调用之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Doing！</span><br><span class="line">被垃圾被回收了！</span><br></pre></td></tr></table></figure><p>析构函数被调用了。</p><p>将 <code>test = null</code>去掉，依然执行了析构函数。</p><blockquote><h4 id="结论：方法块内的代码，使用完毕后无论是否赋值为空，都不会立即变成垃圾，当方法块结束后才会自动成为垃圾对象，能够被垃圾回收处理。"><a href="#结论：方法块内的代码，使用完毕后无论是否赋值为空，都不会立即变成垃圾，当方法块结束后才会自动成为垃圾对象，能够被垃圾回收处理。" class="headerlink" title="结论：方法块内的代码，使用完毕后无论是否赋值为空，都不会立即变成垃圾，当方法块结束后才会自动成为垃圾对象，能够被垃圾回收处理。"></a>结论：方法块内的代码，使用完毕后无论是否赋值为空，都不会立即变成垃圾，当方法块结束后才会自动成为垃圾对象，能够被垃圾回收处理。</h4></blockquote><h3 id="2）情景二：全局变量方法内部使用后赋值为空"><a href="#2）情景二：全局变量方法内部使用后赋值为空" class="headerlink" title="2）情景二：全局变量方法内部使用后赋值为空"></a>2）情景二：全局变量方法内部使用后赋值为空</h3><p>方法内立即调用 GC.Collect()</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestClass _test;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 执行测试</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoTest</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestMethod();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestMethod</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _test = <span class="keyword">new</span> TestClass();</span><br><span class="line">        _test.DoSomething();</span><br><span class="line">        _test = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        GC.Collect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Doing！</span><br></pre></td></tr></table></figure><p>析构函数未被调用。</p><p>将 GC.Collect() 方法调用移动到 DoTest() 方法的 TestMethod() 调用之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Doing！</span><br><span class="line">被垃圾被回收了！</span><br></pre></td></tr></table></figure><p>析构函数被调用了。</p><blockquote><h4 id="结论：全局变量方法内部使用后赋值为空，在该方法结束后，才会变成垃圾对象。"><a href="#结论：全局变量方法内部使用后赋值为空，在该方法结束后，才会变成垃圾对象。" class="headerlink" title="结论：全局变量方法内部使用后赋值为空，在该方法结束后，才会变成垃圾对象。"></a>结论：全局变量方法内部使用后赋值为空，在该方法结束后，才会变成垃圾对象。</h4></blockquote><h3 id="3）情景三：委托方法中包含对象"><a href="#3）情景三：委托方法中包含对象" class="headerlink" title="3）情景三：委托方法中包含对象"></a>3）情景三：委托方法中包含对象</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 执行测试</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoTest</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Action callback = TestMethod;</span><br><span class="line">        callback.Invoke();</span><br><span class="line">        GC.Collect();</span><br><span class="line">        GC.WaitForPendingFinalizers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestMethod</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestClass test = <span class="keyword">new</span> TestClass();</span><br><span class="line">        test.DoSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Doing！</span><br><span class="line">被垃圾被回收了！</span><br></pre></td></tr></table></figure><p>析构函数被调用了。</p><p>此处改成：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Action callback = () =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    TestClass test = <span class="keyword">new</span> TestClass();</span><br><span class="line">    test.DoSomething();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果一致。</p><blockquote><h4 id="结论：委托、匿名方法本身新建的局部变量，会按照正常的方法调用规则在调用结束后释放。"><a href="#结论：委托、匿名方法本身新建的局部变量，会按照正常的方法调用规则在调用结束后释放。" class="headerlink" title="结论：委托、匿名方法本身新建的局部变量，会按照正常的方法调用规则在调用结束后释放。"></a>结论：委托、匿名方法本身新建的局部变量，会按照正常的方法调用规则在调用结束后释放。</h4></blockquote><h3 id="4）情景四：匿名方法中包含对象"><a href="#4）情景四：匿名方法中包含对象" class="headerlink" title="4）情景四：匿名方法中包含对象"></a>4）情景四：匿名方法中包含对象</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 执行测试</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoTest</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestMethod().Invoke();</span><br><span class="line">        GC.Collect();</span><br><span class="line">        GC.WaitForPendingFinalizers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Action <span class="title">TestMethod</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestClass test = <span class="keyword">new</span> TestClass();</span><br><span class="line">        <span class="comment">//test.DoSomething();</span></span><br><span class="line">        <span class="keyword">return</span> () =&gt; test.DoSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Doing！</span><br></pre></td></tr></table></figure><p>析构函数未被调用，对象生命周期应该变成 DoTest 的了。</p><p>测试方法如下，在调用 DoTest 方法处再进行 GC.Collect 调用：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MainClass main = <span class="keyword">new</span> MainClass();</span><br><span class="line">main.DoTest();</span><br><span class="line">GC.Collect();</span><br><span class="line">GC.WaitForPendingFinalizers();</span><br></pre></td></tr></table></figure><p>则执行了析构函数。</p><p>缓存为类的全局变量：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Action callback;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 执行测试</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoTest</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    callback = TestMethod();</span><br><span class="line">    callback.Invoke();</span><br><span class="line">    callback = <span class="literal">null</span>;</span><br><span class="line">    GC.Collect();</span><br><span class="line">    GC.WaitForPendingFinalizers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未执行析构函数，除非与上述一样在 DoTest 执行完毕后调用 GC.Collect。</p><blockquote><h4 id="结论：匿名方法中引用了局部变量，会增加局部变量对象生命周期，提升至委托的调用-存放-级别，规则与普通对象一致——委托不被置为空，变量也会一直存活。"><a href="#结论：匿名方法中引用了局部变量，会增加局部变量对象生命周期，提升至委托的调用-存放-级别，规则与普通对象一致——委托不被置为空，变量也会一直存活。" class="headerlink" title="结论：匿名方法中引用了局部变量，会增加局部变量对象生命周期，提升至委托的调用(存放)级别，规则与普通对象一致——委托不被置为空，变量也会一直存活。"></a>结论：匿名方法中引用了局部变量，会增加局部变量对象生命周期，提升至委托的调用(存放)级别，规则与普通对象一致——委托不被置为空，变量也会一直存活。</h4></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在方法块内对某个对象赋值为空，不管是全局还是局部变量，该对象并不能立刻成为『垃圾』，至少等该方法块执行完毕后，才可能能够被回收。</p><p>若存在匿名方法使用了局部变量，其生存周期与委托绑定。</p><div class="tags-container-bottom"><i class="fa fa-tag pr3 text-main-color"></i><a class="fw3 ph1 dib" href="/tags/性能优化/">#性能优化</a></div><br><br><hr><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><div id="vcomments"></div><script>new Valine({el:"#vcomments",appId:"MsaVbSzIr9cIfikihDExdun9-gzGzoHsz",appKey:"Bj6SEFUBomrLOTWx9B8S6zQH",placeholder:"请输入评论内容~",avatar:"mp",visitor:!1})</script></div><div class="fl w-100 w-30-l center fw3 lh-copy pl4-ns tl black-50"><hr class="dn-l mw4 black-50 mt5"><div class="mt5 mt0-l site-author"><article class="dt db-l mw8 mw8-m mw5-ns center ml0-l bg-white mv3"><div class="dn dtc-m db-l v-mid tc pr4 pr0-l" style="min-width:6rem"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/photo.jpg" class="mb4-l br-100 h3 w3 h4-l w4-l dib" title="CWHISME"></div><div class="dtc db-l v-mid lh-copy measure center f6 black-50 tj">悲观主义的末日</div></article></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>分类</h3><p><a href="/categories/C/">C#</a></p></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>近期文章</h3><p><a href="/2022/12/10/%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/">协变和逆变</a></p><p><a href="/2022/12/06/Unity%E7%9A%84%E9%98%B4%E5%BD%B1%E4%B8%8E%E5%85%89%E7%85%A7%E7%83%98%E7%84%99/">Unity 的阴影与光照烘焙</a></p><p><a href="/2022/11/23/%E6%89%93%E5%8C%85AssetBundle%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86/">打包 AssetBundle 的基础规则整理</a></p><p><a href="/2022/11/18/StringBuilder%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E7%A0%94%E7%A9%B6/">StringBuilder 扩容规则研究</a></p><p><a href="/2022/11/17/%E6%B5%8B%E8%AF%95%E6%89%8B%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">简单测试手动垃圾回收</a></p></div></div></div></div></div></div><div class="bg-1 ph2 ph5-ns pv5"><div class="mv8"><div class="center tc"><div class="dib mh3"><a class="f3 f2-ns white dim" href="https://github.com/CWHISME" target="_blank"><i class="fa fa-github"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="mailto:cwhisme@126.com" target="_blank"><i class="fa fa-envelope"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div></div><div class="f6 f5-ns center tc white pt5 fw3">Copyright © 2021 | Design & Hexo <a class="link dim white" target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-anodyne/">Jonathan Klughertz</a> | Modify By CWHISME</div></div></div></body></html>