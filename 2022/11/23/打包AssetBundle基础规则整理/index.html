<!DOCTYPE html><meta name="viewport" content="height=device-height,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=0"><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="cwhisme"><meta name="author" content="CWHISME"><meta property="og:title" content="打包 AssetBundle 的基础规则整理"><meta property="og:description" content="cwhisme"><meta property="og:site_name" content="WangJiaYing"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><title>打包 AssetBundle 的基础规则整理 - WangJiaYing</title><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/DateTimeAfeterCalc.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/particles-bg.js"></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/script.js"></script><link href="https://fastly.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/css/style.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tachyons@4.12.0/css/tachyons.min.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="WangJiaYing" type="application/atom+xml">
</head><body><canvas id="hackEffectCanvas" style="position:fixed;z-index:-1;pointer-events:none"></canvas><canvas class="fireworks" style="position:fixed;z-index:10;pointer-events:none"></canvas><div class="w-100 bg-1 ph5-ns ph3 text-light"><nav class="db dt-l w-100 mw8 center border-box pv3"><a class="db dtc-l v-mid link dim w-100 w-25-l tc tl-l mb2 mb0-l white" href="/" title="WangJiaYing"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/logo.svg" class="dib h3" alt="WangJiaYing"></a><div class="db dtc-l v-mid w-100 w-75-l tc tr-l"><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/" title="Home">Home </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/archives" title="Archives">Archives </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/tags" title="Tags">Tags </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/categories" title="Categories">Categories </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/bookmark" title="Bookmark">Bookmark </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/about" title="About">About</a></div></nav><div class="w-100 mw8 center vh-40 dt"><div class="dtc v-mid white"><h1 class="f1-l f2-m tc tc-m tl-ns">打包 AssetBundle 的基础规则整理</h1><p class="f4 fw3 pab-100px tc tc-m tl-ns"><i class="fa fa-calendar-check-o" aria-hidden="true"></i> 2022-11-23&nbsp&nbsp <i class="fa fa-clock-o" aria-hidden="true"></i> <span id="dateTimeAfter">2022-11-23</span></p></div></div><div class="relative w-100 mw8 center white dn dn-m db-ns"><i class="header-icon fa fa-snowflake-o"></i></div></div><div class="w-100 ph2 ph4-m ph5-l mv5 mv6-l"><div class="content"><div class="mw8 center"><div class="cf"><div class="fl w-100 w-70-l mw7 left fw3 lh-copy pr4-ns pr0-m post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前其实有写一篇 『<a href="">AssetBundle 的实际测试与总结</a>』的文章，不过现在看了下，感觉漏了一些，而且不够完善。</p><p>但是感觉改又不好改了，于是新建了一篇文章，重新整理一下。</p><p>主要使用工具有：</p><ul><li>Unity3D 2018.4.36f1</li><li>Unity3D 2021.3.6f1</li><li>Microsoft Visual Studio 2022</li><li>Unity 工具：AssetBundles-Browser-1.7.0</li></ul><h2 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h2><p>已知目前 Unity 主要提供了两种方式打 AssetBundle 包</p><ul><li>一种是全打，根据整个项目资源的 AssetBundleName 标记自动生成，该过程全自动化，只有设置 AssetBundleName 这个步骤可以人为控制</li><li>另一种是单打，根据传入的资源路径、指定的 AssetBundleName 单独生成指定资源的 AssetBundle 包</li></ul><p>均为一个接口的两个重载：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全打接口，根据项目已设置 AssetBundleName 的资源</span></span><br><span class="line"><span class="comment">//传入参数为 整个输出路径、打包选项及打包平台</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AssetBundleManifest <span class="title">BuildAssetBundles</span>(<span class="params"><span class="built_in">string</span> outputPath, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//单打接口，可以传入一个『需要打包』的资源列表、打包选项及打包平台</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AssetBundleManifest <span class="title">BuildAssetBundles</span>(<span class="params"><span class="built_in">string</span> outputPath, AssetBundleBuild[] builds, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform</span>)</span></span><br></pre></td></tr></table></figure><h3 id="公共参数"><a href="#公共参数" class="headerlink" title="公共参数"></a>公共参数</h3><p>其中公共参数为：</p><ul><li>BuildAssetBundleOptions</li><li>BuildTarget</li></ul><h4 id="BuildTarget"><a href="#BuildTarget" class="headerlink" title="BuildTarget"></a>BuildTarget</h4><p>BuildTarget 就像名字一样很简单，主要是具体为哪个平台打的资源包，最简单的方式是直接使用 <code>EditorUserBuildSettings.activeBuildTarget</code> 即可。</p><p>或者利用预定义：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_STANDALONE_WIN</span></span><br><span class="line"><span class="comment">//BuildTarget.StandaloneWindows64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> UNITY_IPHONE</span></span><br><span class="line"><span class="comment">//BuildTarget.iOS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> UNITY_ANDROID</span></span><br><span class="line"><span class="comment">//BuildTarget.Android</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>单独分平台判断也可以(用预定义的话，有必要的情况下这里还可以做些其它操作)。</p><h4 id="BuildAssetBundleOptions"><a href="#BuildAssetBundleOptions" class="headerlink" title="BuildAssetBundleOptions"></a>BuildAssetBundleOptions</h4><p>默认情况下 AssetBundle 压缩格式为 LZMA，这个选项可以额外选择设置为 不压缩 或者 LZ4 压缩格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BuildAssetBundleOptions.UncompressedAssetBundle</span><br><span class="line">BuildAssetBundleOptions.ChunkBasedCompression</span><br></pre></td></tr></table></figure><p>可能有人会好奇两个同时传入会如何(比如说我)?</p><p>试了下编辑器会直接报错，提示：</p><blockquote><p><font color="red">Cannot use options UncompressedAssetBundle and ChunkBasedCompression at the same time.</font></p></blockquote><p>其它比较重要的还有：</p><h5 id="1）BuildAssetBundleOptions-DeterministicAssetBundle"><a href="#1）BuildAssetBundleOptions-DeterministicAssetBundle" class="headerlink" title="1）BuildAssetBundleOptions.DeterministicAssetBundle"></a>1）BuildAssetBundleOptions.DeterministicAssetBundle</h5><p><del>这个参数会保证同样的资源每次打出来的 AssetBundle 包二进制一致。</del></p><p><del>我的测试方式是：不传入该参数，先全打一次资源备份好，然后删除项目的 Library 再全打一次，就发现新的资源大小虽然跟原本的一样，但是内部二进制就有很大的不同了：<br>~~<br>~~(以下错误尝试及结论内容已删除)</del></p><p>经过反复尝试，多次试验后得出结果：DeterministicAssetBundle 似乎并非这个作用。<br>之所以第一次删除 Library 后打包得出结果不一致，主要是因为 Library 生成的缓存不一致。在试验中，除了第一次删除试验，之后每次重新删除 Library ，再重新打开，后续工程打出来的 AssetBundle 包对比文件均一致了。</p><p>尝试在一个工程同时打出带 DeterministicAssetBundle 及不带该选项的资源包，结果最终生成的二进制 AssetBundle 资源包同样完全一致：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2022/2022-11-23/m_bc96359133bb56dd0d1223b6639bf8d5_r.png"></p><p>只有在单打某个资源时，该选项打出的资源包才会产生差异。</p><p>说明这个选项，至少在同一个环境下全打资源是不会对 AssetBundle 资源包产生任何影响的。</p><p><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/current/ScriptReference/BuildAssetBundleOptions.DeterministicAssetBundle.html">官方文档说明</a>：</p><blockquote><p>重新构建资源包时，资源包中对象的 ID 将在完成重新构建后 保持不变。<br>从 DeterministicAssetBundle 中加载内容也比一般资源包要慢。</p></blockquote><p>那么这个选项究竟是起什么作用呢？有坏处，却没说明白好处。</p><p>官方的说明文档信息太少了，反复斟酌之后，偶然看到了说明的最后一行文字：</p><blockquote><p>注意：此功能会始终启用。</p></blockquote><p>……原来如此？难怪传入不传入，都没有影响。</p><p>后来又经过多方查找后，还看到有说找 Unity官方确认，确定 Unity5.X 以后的确是默认加入的选项了：</p><blockquote><p><a target="_blank" rel="noopener" href="https://answer.uwa4d.com/question/5a7a8b23847802258a065038">https://answer.uwa4d.com/question/5a7a8b23847802258a065038</a></p></blockquote><p>然后后续继续查找资料，在 Unity官方论坛 <a target="_blank" rel="noopener" href="https://forum.unity.com/threads/is-the-deterministic-asset-bundle-option-obsolete.455510/">Is the deterministic asset bundle option obsolete? </a>帖子也提到了同样的困惑，Unity 官方人员回答说该选项已经无效：</p><blockquote><p>It’s a bit of a mess, but yes, it’s enabled permanently - the option has no effect.</p></blockquote><p>但是为什么单打时，这个选项针对同一个资源，又会产生影响了？</p><p>测试单打资源显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BuildAssetBundleOptions.None: 54.7 KB (56,036 字节)</span><br><span class="line">BuildAssetBundleOptions.DeterministicAssetBundle：54.7 KB (56,039 字节)</span><br></pre></td></tr></table></figure><p>传入 DeterministicAssetBundle 选项时增加了 3 个字节大小，那么是否可以怀疑，单打时依然会有影响，官方说的『始终启用』仅针对全打资源的情况？</p><p>毕竟单打时的引用关系处理，跟全打也是有差异的。</p><p>所以这里可以总结为：该选项主要用于生成确定性 ID 以处理重新打包资源时依赖、引用关系，确保增量打包时没有真实修改的资源不会被重打。目前 Unity 全打接口已默认包含该项，且无论是否传入均不影响，单打资源时才会有影响且导致资源产生差异。</p><h5 id="2）BuildAssetBundleOptions-DisableWriteTypeTree"><a href="#2）BuildAssetBundleOptions-DisableWriteTypeTree" class="headerlink" title="2）BuildAssetBundleOptions.DisableWriteTypeTree"></a>2）BuildAssetBundleOptions.DisableWriteTypeTree</h5><p>禁用写入类型树。</p><p>根据相关介绍，这个为了给Unity跨版本之间做兼容性用的，在真机包出包版本与热更资源都是由一个版本出包情况下，这个选项可以考虑传入以优化性能。</p><p>禁用后可以降低包体和内存并提高加载效率，但是可能会造成 Unity 版本的兼容问题。</p><p>原理是根据序列化的字段进行反序列化，例如我们资源 meta 版本都有 serializedVersion ，以区分各个版本序列化选项情况，不同版本每个选项可能并不一致。</p><p>开启写入类型树时，Unity 在打 AssetBundle 时会先把数据内容的树状结构先写入一遍，然后再写入对应值，这样在加载 AssetBundle 时，先解析出字段的树状结构，然后与真机包包体的解析结构进对比，再解析实际数据值，处理缺失或多余字段，避免反序列化出错(错位)。</p><p>如果不写入，那就是直接根据顺序去反序列化了，换了 Unity 版本字段可能就会反序列化错位，导致出现问题。</p><p>为了确定上述说法，可以进行一个简单的测试。</p><p>我用 Unity2018.4.36f1 打了两个 Cube.prefab AssetBundle 资源包，分为默认启用以及禁用，压缩模式为 不压缩：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2022/2022-11-23/m_ce296dced15e16733103cfb044033bab_r.png"></p><p>然后在 Unity2021.3.6f1 中进行加载测试：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2022/2022-11-23/m_334251ea9573f4af016c1fdf351a5600_r.png"></p><p>默认打包模式是可以直接读取的(虽然按照名字加载失败了)，确实加载到了对应资源。<br>场景中也可以利用 <code>GameObject.Instantiate(x[0] as GameObject);</code> 正确实例化出来。</p><p>而换成加载 『cube2018_disablewritetypetree』则直接报错，提示：</p><blockquote><p>The AssetBundle ‘Assets\MyBundles\cube2018_disablewritetypetree’ could not be loaded because it contains run-time classes of incompatible version. Rebuild the AssetBundle to fix this error.</p></blockquote><p>对于上述测试，利用 AssetBundles-Browser 也可以直接看出问题，默认的可以预览 Cube 各项属性，DisableWriteTypeTree 的资源版本则报同样错误。</p><p>如图所示：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2022/2022-11-23/m_d2487c01c62a4a665b66a3d1deab67a2_r.png"></p><p>当然，这个兼容性也有代价，首先每个 AssetBundle 都得包含额外的 TypeTree 信息，加载 AssetBundle 资源时会先构建这个 TypeTree 结构，然后再解析字段，增加部分 CPU 和 内存消耗。</p><h5 id="3）BuildAssetBundleOptions-ForceRebuildAssetBundle"><a href="#3）BuildAssetBundleOptions-ForceRebuildAssetBundle" class="headerlink" title="3）BuildAssetBundleOptions.ForceRebuildAssetBundle"></a>3）BuildAssetBundleOptions.ForceRebuildAssetBundle</h5><p>默认为增量构建，基于上一次的打包结果，对发生变化的资源重新打包，若传入这个参数，会完全重新打一次。<br>经过测试，增量构建的关键点在于 Unity 为每个 AssetBundle 资源同时生成的 .manifest 文件。<br><font color="red">注1：删除文件的 .manifest 也会产生同样的效果。<br>注2：我们项目的 AssetBundle 关系由自己维护，尝试打完了之后删除 .manifest 节省空间，发现会被重新全打一次。<br>注3：关系总表的 .manifest 对其它资源不产生影响，只删除某个资源的 .manifest 就会导致该资源直接被重打。</font></p><h5 id="4）DisableLoadAssetByFileName、DisableLoadAssetByFileNameWithExtension"><a href="#4）DisableLoadAssetByFileName、DisableLoadAssetByFileNameWithExtension" class="headerlink" title="4）DisableLoadAssetByFileName、DisableLoadAssetByFileNameWithExtension"></a>4）DisableLoadAssetByFileName、DisableLoadAssetByFileNameWithExtension</h5><p>禁用使用 名字加载，这两个选项只影响内置的 AssetBundle.LoadAsset 方法。</p><p>如通过 AssetBundle.LoadAllAssets 加载后根据名字判断依然可行。</p><p>文件名+扩展名会在加载成功后生成，取决于项目的 AssetBundle 资源具体加载方式，可以传入减少一点点内存占用。例如通过全路径或者 AssetBundleRequest allAssets 自己判断方式。</p><p>例如，我们通常通过 AssetBundle.LoadAllAssets(LoadAllAssetsAsync) 加载全部资源，然后管理，AssetBundle 自带的 LoadAsset 接口是不会使用的，此时就可以禁用名字加载。</p><p>测试代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> pathDir = System.IO.Path.Combine(Application.dataPath, <span class="string">&quot;MyBundles&quot;</span>);</span><br><span class="line">AssetBundle assetBundle = AssetBundle.LoadFromFile(Path.Combine(pathDir, Name));</span><br><span class="line">Object[] x = assetBundle.LoadAllAssets();</span><br><span class="line">Object o = assetBundle.LoadAsset(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line">Object o1 = assetBundle.LoadAsset(<span class="string">&quot;Cube.prefab&quot;</span>);</span><br><span class="line">Object o2 = assetBundle.LoadAsset(<span class="string">&quot;Assets/Cube.prefab&quot;</span>);</span><br><span class="line">Debug.Log(<span class="string">&quot;OK2&quot;</span>);</span><br></pre></td></tr></table></figure><p>表现如下：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2022/2022-11-23/m_5b4b541cc358119d2bdfde8bf1e09a6d_r.png"></p><p>—————————————————————————————————————————</p><p>最后，简单测试一下各个不同选项打出来资源大小：</p><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LZMA：</span><br><span class="line">tex_default:272 KB (279,003 字节)</span><br><span class="line">tex_disablename：272 KB (278,994 字节)</span><br><span class="line">tex_disablewritetypetree：271 KB (278,163 字节)</span><br><span class="line">tex_disablewritetypetree_and_disablename：271 KB (278,147 字节)</span><br><span class="line"></span><br><span class="line">Uncompress:</span><br><span class="line">tex_default：466 KB (477,968 字节)</span><br><span class="line">tex_disablename：466 KB (477,984 字节)</span><br><span class="line">tex_disablewritetypetree：466 KB (477,904 字节)</span><br><span class="line">tex_disablewritetypetree_and_disablename：466 KB (477,936 字节)</span><br><span class="line"></span><br><span class="line">LZ4:</span><br><span class="line">tex_default：302 KB (309,643 字节)</span><br><span class="line">tex_disablename：302 KB (309,653 字节)</span><br><span class="line">tex_disablewritetypetree：300 KB (308,172 字节)</span><br><span class="line">tex_disablewritetypetree_and_disablename：300 KB (308,183 字节)</span><br></pre></td></tr></table></figure><h5 id="Prefab"><a href="#Prefab" class="headerlink" title="Prefab"></a>Prefab</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LZMA：</span><br><span class="line">tex_default：54.7 KB (56,036 字节)</span><br><span class="line">tex_disablename：54.7 KB (56,040 字节)</span><br><span class="line">tex_disablewritetypetree：47.6 KB (48,775 字节)</span><br><span class="line">tex_disablewritetypetree_and_disablename：47.6 KB (48,789 字节)</span><br><span class="line"></span><br><span class="line">Uncompress:</span><br><span class="line">tex_default：194 KB (198,880 字节)</span><br><span class="line">tex_disablename：194 KB (198,896 字节)</span><br><span class="line">tex_disablewritetypetree：116 KB (119,168 字节)</span><br><span class="line">tex_disablewritetypetree_and_disablename：116 KB (119,200 字节)</span><br><span class="line"></span><br><span class="line">LZ4:</span><br><span class="line">tex_default：80.2 KB (82,141 字节)</span><br><span class="line">tex_disablename：80.2 KB (82,148 字节)</span><br><span class="line">tex_disablewritetypetree：62.1 KB (63,668 字节)</span><br><span class="line">tex_disablewritetypetree_and_disablename：62.1 KB (63,678 字节)</span><br></pre></td></tr></table></figure><p>可以发现实际测试下来，在资源包大小上 DisableWriteTypeTree 影响更大，特别是 Prefab 资源，不压缩减少了 60% 左右、LZ4 模式减少了 25% 左右大小，LZMA 也有 13%。<br>虽然对纯图片资源这种(其它音效之类一样)减少不会很明显——差不多就 1KB 的样子，毕竟图片资源的 meta 项本身也不会太多。</p><p>相对来说禁止名字加载对资源包的大小基本就没什么影响了，顶多几个字节的差异(甚至是增加大小)，不过据说 DisableLoadAssetByFileName、DisableLoadAssetByFileNameWithExtension<br>更多是减少运行时内存——这一点在 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/BuildAssetBundleOptions.DisableLoadAssetByFileName.html">官方文档</a> 也有明确说明，更详细的内存方面的对比，后续我会再进行详细测试。</p><h3 id="全打接口"><a href="#全打接口" class="headerlink" title="全打接口"></a>全打接口</h3><p>关于全打接口，大概可以总结如下基本规则：</p><ol><li><strong>资源与其引用资源都指定了不同的 AssetBunldeName ，会分别分离单打</strong></li><li><strong>没有指定 AssetBunldeName，那么会跟引用它的对象打一个包</strong></li><li><strong>没有指定 AssetBunldeName，存在多个对它的引用就会有多个副本，造成内存冗余</strong></li></ol><p>对于全打接口的工作原理，使用 AssetBundles-Browser 也可以比较清晰看出其关系。</p><p>设置对应的 AseetbundleName 之后，就会展示在 AssetBundles-Browser 中。</p><ol><li>Prefab 和 图片设置不同 AseetbundleName：<br><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2022/2022-11-23/m_2bd4afc7e2d136def3d3d0b3c35716bf_r.png"></li><li>只设置 Prefab AseetbundleName:<br><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2022/2022-11-23/m_06a422a91bf2e0782625afe388a5f7e2_r.png"></li><li>不指定 AssetbunldeName，而又有多个对它产生引用的对象，AssetBundles-Browser 都会直接进行提示：<br><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2022/2022-11-23/m_26177c9cb01b7f3e654c5b61cfd11c6b_r.png"><br>若忽略提示，打包出来结果如下：<br><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2022/2022-11-23/m_4b5774781fe0214bc8fa42a0fdae1c72_r.png"><br>两个 Assetbunlde 包就分别包含了两份同样的图片资源。</li></ol><p>调用全打接口代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;AssetBundleTest/PackALL&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Pack</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    BuildPipeline.BuildAssetBundles(Path.Combine(Application.dataPath, <span class="string">&quot;MyBundles&quot;</span>), BuildAssetBundleOptions.DeterministicAssetBundle, EditorUserBuildSettings.activeBuildTarget);</span><br><span class="line">    AssetDatabase.Refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于上述设置一，会生成两个分别包含 RawImage(test1) 和 Tex(tex) 的AssetBundle 资源包</li><li>对于上述设置二，会生成一个同时包含 RawImage 和 Tex 的 AssetBundle 资源包，名字为 『test1』</li><li>对于上述设置三，会生成两个同时包含 Prefab 和 图片的 AssetBundle 资源包，名字为 『test1』、『test2』</li></ul><p>使用 <a target="_blank" rel="noopener" href="https://github.com/Perfare/AssetStudio">AssetStudio</a> 进行观察打出的 AssetBundle 资源包，可以验证与上述关系一致。</p><h3 id="单打接口"><a href="#单打接口" class="headerlink" title="单打接口"></a>单打接口</h3><p>单打接口实际规则，跟全打有一点差异。</p><p>总结规则如下：</p><ol><li><strong>若只有主资源存在列表，无论引用资源是否有设置其它 AssetBundleName，其引用资源会自动与主资源打成一个包</strong></li><li><strong>若将主资源及其引用资源都传入，且引用资源有自己的 AssetBundleName ，那么会分别根据各自的 AssetBundleName 单打</strong></li><li><strong><del>若将主资源及其引用资源都传入，但引用资源没有设置自己的 AssetBundleName ，那么引用资源都打入主资源一个包里。</del>(注：此处应当是因为触发了第一项规则)</strong></li></ol><p>与『全打资源』最大的区别，大概要数第一项：无论被引用资源是否设置自己的 AssetBundleName，只要这次单打没有传入引用资源，那么就会被打入主资源包里。</p><p>单打测试代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;AssetBundleTest/PackSelect(LZMA)&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PackSelectLZMA</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PackSelect(BuildAssetBundleOptions.DeterministicAssetBundle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PackSelect</span>(<span class="params">BuildAssetBundleOptions opt, <span class="built_in">string</span> extName = <span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Object o = Selection.activeObject;</span><br><span class="line">    <span class="built_in">string</span> path = AssetDatabase.GetAssetPath(o);</span><br><span class="line">    AssetImporter importer = AssetImporter.GetAtPath(path);</span><br><span class="line">    <span class="keyword">if</span> (importer == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    AssetBundleBuild build = <span class="keyword">new</span> AssetBundleBuild();</span><br><span class="line">    build.assetBundleName = <span class="built_in">string</span>.IsNullOrEmpty(extName) ? importer.assetBundleName : <span class="built_in">string</span>.Concat(importer.assetBundleName, <span class="string">&quot;_&quot;</span>, extName);</span><br><span class="line">    build.assetNames = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; path &#125;;</span><br><span class="line"></span><br><span class="line">    BuildPipeline.BuildAssetBundles(Path.Combine(Application.dataPath, <span class="string">&quot;MyBundles&quot;</span>), <span class="keyword">new</span> AssetBundleBuild[] &#123; build &#125;, opt, EditorUserBuildSettings.activeBuildTarget);</span><br><span class="line">    AssetDatabase.Refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上述『PackSelect』代码及上述资源为例，为 『RaweImage』『RaweImage2』及『Tex』分别设置不同的 AssetBunldeName，调用 PackSelect 传入各自的 AssetBunldeName 及资源路径分别进行单打操作，结果：<br><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2022/2022-11-23/m_24dd53cc74994ba2914dce5568cb0a08_r.png"><br>主资源及其引用图片被打进了一个包里。</p><p>对比调用 『PackALL』 全打资源结果：<br><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2022/2022-11-23/m_a445e82bab3e8e6d2ae40826775a5bd0_r.png"><br>其中 test1、test2 均引用了 tex 资源，从大小上看即可表明单打接口资源是被分别单打的了。</p><p>—————————————————————————————————————————</p><p>若单打资源，同时传入了主资源和引用资源呢？</p><p>稍微修改一下『PackSelect』代码，使其可以单打所有『当前选中』的资源：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;AssetBundleTest/PackSelectALL&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PackSelectALL</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Object[] o = Selection.GetFiltered&lt;Object&gt;(SelectionMode.Assets);</span><br><span class="line">    AssetBundleBuild[] buildArray = <span class="keyword">new</span> AssetBundleBuild[o.Length];</span><br><span class="line">    AssetImporter importer;</span><br><span class="line">    AssetBundleBuild build;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; buildArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        importer = AssetImporter.GetAtPath(AssetDatabase.GetAssetPath(o[i]));</span><br><span class="line">        build = <span class="keyword">new</span> AssetBundleBuild();</span><br><span class="line">        build.assetBundleName = importer.assetBundleName;</span><br><span class="line">        build.assetNames = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; importer.assetPath &#125;;</span><br><span class="line">        buildArray[i] = build;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BuildPipeline.BuildAssetBundles(Path.Combine(Application.dataPath, <span class="string">&quot;MyBundles&quot;</span>), buildArray, BuildAssetBundleOptions.DeterministicAssetBundle, EditorUserBuildSettings.activeBuildTarget);</span><br><span class="line">    AssetDatabase.Refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始研究这个单打接口，或许会写出这种单打当前选中所有资源的代码，然后总结出错误的结论(比如说我)：<del>若传入两个没有引用关系的资源，但是都为同一个 assetBundleName，单打会报错，只会生成其中一个资源的 assetBundle 包。</del></p><p>但要是深入一点测试、思考一下，就会发现这种写法是有问题的。</p><p>问题在哪儿呢？</p><p>首先尝试上述代码执行，选中两个设置了同一个 assetBundleName 的资源后，调用结果：</p><blockquote><p><font color="red">Trying to add file F:/Study/AssetbundleTest/Assets/MyBundles/tex.manifest to the list of ouptut files in the build report, but a file at that path has already been added.</font></p></blockquote><p>意思是添加的文件重复了，但明显资源名字是不同的，那问题可能就是在 assetBundleName？</p><p>然后往参数那边看，每一个 AssetBundleBuild 中的 assetNames 参数实际上是一个『数组』，也就是一系列的资源路径，所以对于单打接口，每个 AssetBundleBuild 都是独立的，它不会自动去判断传入的总列表中是否有重复的标签，因此需要我们手动去重：把同一个标签，重复的合并在一个结构中。</p><p>修改后代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;AssetBundleTest/PackSelectALL&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PackSelectALL</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Object[] o = Selection.GetFiltered&lt;Object&gt;(SelectionMode.Assets);</span><br><span class="line">    List&lt;AssetBundleBuild&gt; assetBundleBuilds = <span class="keyword">new</span> List&lt;AssetBundleBuild&gt;(o.Length);</span><br><span class="line">    AssetImporter importer;</span><br><span class="line">    AssetBundleBuild build;</span><br><span class="line">    <span class="built_in">int</span> index;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; o.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        importer = AssetImporter.GetAtPath(AssetDatabase.GetAssetPath(o[i]));</span><br><span class="line">        <span class="comment">//判断是否存在重复</span></span><br><span class="line">        index = assetBundleBuilds.FindIndex((x) =&gt; x.assetBundleName == importer.assetBundleName);</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            build = <span class="keyword">new</span> AssetBundleBuild();</span><br><span class="line">            build.assetBundleName = importer.assetBundleName;</span><br><span class="line">            build.assetNames = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; importer.assetPath &#125;;</span><br><span class="line">            assetBundleBuilds.Add(build);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//重复，则添加进去</span></span><br><span class="line">            build = assetBundleBuilds[index];</span><br><span class="line">            <span class="built_in">string</span>[] newAssets = <span class="keyword">new</span> <span class="built_in">string</span>[build.assetNames.Length + <span class="number">1</span>];</span><br><span class="line">            newAssets[<span class="number">0</span>] = importer.assetPath;</span><br><span class="line">            System.Array.Copy(build.assetNames, <span class="number">0</span>, newAssets, <span class="number">1</span>, build.assetNames.Length);</span><br><span class="line">            build.assetNames = newAssets;</span><br><span class="line">            assetBundleBuilds[index] = build;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BuildPipeline.BuildAssetBundles(Path.Combine(Application.dataPath, <span class="string">&quot;MyBundles&quot;</span>), assetBundleBuilds.ToArray(), BuildAssetBundleOptions.DeterministicAssetBundle, EditorUserBuildSettings.activeBuildTarget);</span><br><span class="line">    AssetDatabase.Refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次尝试，同一个 AssetBunldeName 没有引用关系的几个资源，顺利被打入同一个 AssetBundle 资源包。</p><h2 id="动画资源"><a href="#动画资源" class="headerlink" title="动画资源"></a>动画资源</h2><p>昨天主程会提到了动画脱壳，简单试一下资源包大小：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/2022/2022-11-23/m_0fbdab2ab9986238e383a031a9f9af5e_r.png"></p><p>上述分别为：</p><p>anim_off：带 FBX 动画，关闭 Anim.Compression<br>animall：带 FBX 动画，Anim.Compression 为默认的 KeyFramReduction<br>animreopt：不带 FBX 动画，Anim.Compression 为默认的 KeyFramReduction<br>animreduce：不带 FBX 动画，Anim.Compression 为 Optimal</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>调用全打资源接口时：</p><ol><li><strong>资源与其引用资源都指定了不同的 AssetBunldeName ，会分别分离单打</strong></li><li><strong>没有指定 AssetBunldeName，那么会跟引用它的对象打一个包</strong></li><li><strong>没有指定 AssetBunldeName，存在多个对它的引用就会有多个副本，造成内存冗余</strong></li></ol><p>调用单打资源接口时：</p><ol><li><strong>若只有主资源存在列表，无论引用资源是否有设置其它 AssetBundleName，其引用资源会自动与主资源打成一个包</strong></li><li><strong>若将主资源及其引用资源都传入，且引用资源有自己的 AssetBundleName ，那么会分别根据各自的 AssetBundleName 单打</strong></li></ol><p>取决于项目资源加载管理，可采用的优化选项：DisableWriteTypeTree、DisableLoadAssetByFileName、DisableLoadAssetByFileNameWithExtension</p><p>例如，像我们项目通过 AssetBundle.LoadAllAssets(LoadAllAssetsAsync) 加载全部资源，然后管理，AssetBundle 自带的 LoadAsset(Name) 接口是不会使用的，此时就可以禁用名字加载。(正常情况下加载一个资源，一般来说也是使用完整路径的)</p><p>另外，通常出包以及出热更包必然也是同一个 Unity 版本(应该不可能有 『项目还在线上就去动 release 分支 Unity 版本』的操作吧)，此时可以禁用写入类型树以优化内存及加载。</p><p><font color="red">其它：DeterministicAssetBundle 经测试与多方对比，可以认为全打资源默认始终包含该选项，仅单打资源时该项会对资源产生额外影响。(这大概也是为什么同为『始终启用』的 CollectDependencies 被标记为弃用，但它没有——大概就是因为 DeterministicAssetBundle 对于单打该选项还有效)</font></p><blockquote><p>参考文档：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/current/ScriptReference/BuildPipeline.BuildAssetBundles.html">BuildPipeline.BuildAssetBundles</a></li><li><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/current/Manual/AssetBundles-Building.html">AssetBundles-Building</a></li><li><a target="_blank" rel="noopener" href="https://developer.unity.cn/projects/61566223edbc2a0021557364">Asset的一生</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ybgame/p/3973177.html">Unity AssetBundle爬坑手记</a></li><li><a target="_blank" rel="noopener" href="https://answer.uwa4d.com/question/5a7a8b23847802258a065038">AB增量打包问题</a></li><li><a target="_blank" rel="noopener" href="https://forum.unity.com/threads/is-the-deterministic-asset-bundle-option-obsolete.455510/">Is the deterministic asset bundle option obsolete?</a></li><li><a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/current/ScriptReference/BuildAssetBundleOptions.DeterministicAssetBundle.html">DeterministicAssetBundle</a></li><li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/BuildAssetBundleOptions.DisableLoadAssetByFileName.html">DisableLoadAssetByFileName</a></li><li><a target="_blank" rel="noopener" href="https://forum.unity.com/threads/assetbundles-and-dependencies.377760/">assetbundles-and-dependencies</a></li></ul></blockquote><br><br><hr><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><div id="vcomments"></div><script>new Valine({el:"#vcomments",appId:"MsaVbSzIr9cIfikihDExdun9-gzGzoHsz",appKey:"Bj6SEFUBomrLOTWx9B8S6zQH",placeholder:"请输入评论内容~",avatar:"mp",visitor:!1})</script></div><div class="fl w-100 w-30-l center fw3 lh-copy pl4-ns tl black-50"><hr class="dn-l mw4 black-50 mt5"><div class="mt5 mt0-l site-author"><article class="dt db-l mw8 mw8-m mw5-ns center ml0-l bg-white mv3"><div class="dn dtc-m db-l v-mid tc pr4 pr0-l" style="min-width:6rem"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/photo.jpg" class="mb4-l br-100 h3 w3 h4-l w4-l dib" title="CWHISME"></div><div class="dtc db-l v-mid lh-copy measure center f6 black-50 tj">悲观主义的末日</div></article></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>分类</h3><p><a href="/categories/Unity3D/">Unity3D</a></p></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>近期文章</h3><p><a href="/2022/12/10/%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/">协变和逆变</a></p><p><a href="/2022/12/06/Unity%E7%9A%84%E9%98%B4%E5%BD%B1%E4%B8%8E%E5%85%89%E7%85%A7%E7%83%98%E7%84%99/">Unity 的阴影与光照烘焙</a></p><p><a href="/2022/11/23/%E6%89%93%E5%8C%85AssetBundle%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86/">打包 AssetBundle 的基础规则整理</a></p><p><a href="/2022/11/18/StringBuilder%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E7%A0%94%E7%A9%B6/">StringBuilder 扩容规则研究</a></p><p><a href="/2022/11/17/%E6%B5%8B%E8%AF%95%E6%89%8B%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">简单测试手动垃圾回收</a></p></div></div></div></div></div></div><div class="bg-1 ph2 ph5-ns pv5"><div class="mv8"><div class="center tc"><div class="dib mh3"><a class="f3 f2-ns white dim" href="https://github.com/CWHISME" target="_blank"><i class="fa fa-github"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="mailto:cwhisme@126.com" target="_blank"><i class="fa fa-envelope"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div></div><div class="f6 f5-ns center tc white pt5 fw3">Copyright © 2021 | Design & Hexo <a class="link dim white" target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-anodyne/">Jonathan Klughertz</a> | Modify By CWHISME</div></div></div></body></html>