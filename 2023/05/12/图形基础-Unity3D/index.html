<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="CWHISME" href="https://wangjiaying.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="CWHISME" href="https://wangjiaying.top/atom.xml"><link rel="alternate" type="application/json" title="CWHISME" href="https://wangjiaying.top/feed.json"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Unity3D,图形学,性能优化,笔记"><link rel="canonical" href="https://wangjiaying.top/2023/05/12/%E5%9B%BE%E5%BD%A2%E5%9F%BA%E7%A1%80-Unity3D/"><title>渲染基础 - Unity3D - 笔记 - Unity3D | Jiaying's Note = CWHISME = 人不能没有梦想，也要有足够的敬畏</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">渲染基础 - Unity3D - 笔记</h1><div class="meta"><span class="item" title="创建时间：2023-05-12 17:36:44"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-05-12T17:36:44+08:00">2023-05-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>16k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>14 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiaying's Note</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="/images/coverimages/large/acg40.webp"></li><li class="item" data-background-image="/images/coverimages/large/76580331_p0.webp"></li><li class="item" data-background-image="/images/coverimages/large/006gkh44ly1fw6amsexm3j31hc0xc7lx.webp"></li><li class="item" data-background-image="/images/coverimages/large/6833939bly1giclip4jbpj20zk0m87cv.webp"></li><li class="item" data-background-image="/images/coverimages/large/103466147_p0.webp"></li><li class="item" data-background-image="/images/coverimages/large/61351818_p0.webp"></li></ul></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Unity3D/" itemprop="item" rel="index" title="分类于 Unity3D"><span itemprop="name">Unity3D</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangjiaying.top/2023/05/12/%E5%9B%BE%E5%BD%A2%E5%9F%BA%E7%A1%80-Unity3D/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/../img/avator"><meta itemprop="name" content="WangJiaYing"><meta itemprop="description" content="人不能没有梦想，也要有足够的敬畏, 己所不欲，勿施于人"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="CWHISME"></span><div class="body md" itemprop="articleBody"><h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>部分来源于网络，并注明来源（已丢失除外），性能优化、批处理则主要整理自 Unity 官方文档<br>注 1：参考文档均在对应位置标注，文章末尾也贴了对应链接<br>注 2：对文章内容，后续可能会还会进行调整</p><h1 id="硬件"><a class="anchor" href="#硬件">#</a> 硬件</h1><h2 id="gpu的渲染架构"><a class="anchor" href="#gpu的渲染架构">#</a> GPU 的渲染架构</h2><h3 id="imrimmediate-mode-rendering主要用于pc平台"><a class="anchor" href="#imrimmediate-mode-rendering主要用于pc平台">#</a> IMR（Immediate Mode Rendering，主要用于 PC 平台）</h3><ul><li>即渲染模式。每个像素渲染的时候直接访问 DRAM，并写入到 FrameBuffer 上。PC 平台的显卡都是 IMR 架构</li></ul><h3 id="tbrtile-based-rendering基于tile渲染主要用于移动平台"><a class="anchor" href="#tbrtile-based-rendering基于tile渲染主要用于移动平台">#</a> TBR（Tile-Based Rendering，基于 Tile 渲染，主要用于移动平台）</h3><p>为了减少 GPU 访问 SystemMemory 的次数（延迟高、功耗高），将屏幕分成一小块儿一小块儿，确保这一小块渲染所需要的绝大部分数据都能同时装进小小的 OnChip memory，从而实现整个渲染大部分操作都可以在带宽较高的 OnChip memory 上完成</p><ul><li>大幅减少对显存带宽的消耗</li></ul><p>TBR 是以牺牲执行效率为代价，换来功耗降低。在移动平台直接访问 FrameBuffer 会有很大的带宽开销，进而影响功耗。所以 TBR 把屏幕分成格子之后，每个格子可以访问 SRAM（OnChip memory），一整块都访问好之后，再整理转移回 DRAM</p><ul><li>大部分手机的 GPU 用的都是手机的 System memory 和一块容量很小的，带宽比 System memory 更高的专供 OnChip memory<ul><li>SRAM，GPU 的 OnChip memory</li><li>DRAM，显存，离 GPU 较远，容量大访问速度慢</li></ul></li><li>从 GPU 直接对 FrameBuffer 的访问，就相当于一辆货车大量的在家（GPU）和市中心超市（DRAM）之间往返运输。带宽的消耗和发热量之大，是手机上无法接受的<ul><li>对移动平台而言，功耗是第一位。因为功耗意味着发热量、耗电量、芯片大小等等。</li><li>对功耗影响最大的是带宽。所以对移动芯片而言，第一考虑的不是渲染性能，而是如何通过缓存减少带宽消耗。即，减少对显存的访问</li></ul></li><li>实际上直接对 DRAM 进行读写速度是最快的。TBR 需要一块儿块儿的绘制然后往 DRAM 拷贝。可以简单理解为 TBR 是牺牲了执行效率，来解决更重要也更难处理的带宽功耗</li></ul><h4 id="其它"><a class="anchor" href="#其它">#</a> 其它</h4><ul><li>DeferredRenderingPath：对 Tile-Based GPUs (移动平台) 启用了 NativeRenderPass 选项的有优化，没启用要避免。原理是 合并 GBuffer 和光照通道存储至 Title Memery 中以优化延迟渲染，NativeRenderPass 在 Tile-Based GPUs 应该启用<ul><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NzQ1NDAzMjk=">URP 延迟渲染 + Native Renderpass 踩坑记录</span></li></ul><blockquote><p>利用移动端 TB (D) R 的硬件架构，相比于传统延迟管线在 basepass 结束后将 gbuffer store 回 system memory, 之后再在 lightpass 中 load 回来这种带宽压力极大的方案，Native Renderpass 可以在每个 tile 的 basepass 结束后将 gbuffer 保存在 On-Chip Memory 上，以供接下来的 lightpass 直接使用，直接优化掉了两个 pass 之间的 store/load 操作，极大减缓了带宽压力，这种形式的 rt 也被称之为 memoryless</p></blockquote></li></ul><h3 id="tbdrtile-based-deferred-rendering-针对tbr做了进一步优化主要是powervr在用"><a class="anchor" href="#tbdrtile-based-deferred-rendering-针对tbr做了进一步优化主要是powervr在用">#</a> TBDR（Tile-Based Deferred Rendering 针对 TBR 做了进一步优化，主要是 PowerVR 在用）</h3><p>基于 Tile 的延迟渲染。只对玩家能看到的像素做 pixel shader。通过 HSR 将不可见的点剔除掉。大幅减少对显存带宽的消耗</p><ul><li>IOS 一般都是 TBDR</li><li>HSR (隐藏面消除) Hidden Surface Removal，TBDR 新增的一个阶段，在光栅化阶段真正开始前实现像素级裁剪。</li></ul><p>TBDR，相对于 IMR，多了一个 FrameData 的数据，里面包含了有效信息，可以进行剔除操作</p><h3 id="mrtmulti-render-targets"><a class="anchor" href="#mrtmulti-render-targets">#</a> MRT(Multi Render Targets)</h3><p>OpenGL ES 多目标渲染，OpenGL ES 3.0 新特性，它允许应用程序一次渲染到多个缓冲区。</p><h2 id="early-z"><a class="anchor" href="#early-z">#</a> Early-Z</h2><p>在执行像素着色器之前，先进行一轮深度测试，避免会被深度测试剔除的片元，执行复杂的像素着色器的逻辑。这样可以减少显存带宽的消耗</p><ul><li>如果没有 Early-Z，那么很有可能屏幕上一个像素点会被渲染七八次，显存带宽消耗成倍的增加</li><li>discard 或 clip 会导致 Early-Z Culling 无效</li></ul><h2 id="渲染顺序"><a class="anchor" href="#渲染顺序">#</a> 渲染顺序</h2><ul><li>不透明物体，离摄像机近的先绘制，这样它会因为 ZTest 剔除掉后面的渲染内容，性能更好</li><li>半透明物体，必须从后往前画，先画离摄像机远的物体，才能保证渲染结果正确</li><li>Shader 非常复杂的模型，尽量后绘制。更加容易被 Z-Culling 剔除掉</li><li>不透明物体 (2000)----AlphaTest 物体 (2450)---- 半透明物体 (3000)，这个渲染顺序有利于 HSR 或者 Early-Z 的优化<ul><li>Alpha-Test 在不透明物体绘制完毕之后再绘制，可以避免 Alpha-Test 导致 EarlyZ 失效，最后绘制，至少不会影响到之前不透明物体的 EarlyZ</li><li>RenderQueue2500，区分了不透明和半透明。半透明物体（2500 以上）永远在不透明物体（2500 以下）后绘制<ul><li>如果物体的 RenderQueue 在 2500 的同一侧，则 sortingOrder 优先级更高：</li><li>Camera Depth &gt; Sorting Layer &gt; Order In Layer &gt; RenderQueue &gt; 距离相机的距离</li></ul></li></ul></li></ul><h1 id="性能状态"><a class="anchor" href="#性能状态">#</a> 性能状态</h1><h2 id="drawcall"><a class="anchor" href="#drawcall">#</a> DrawCall</h2><p>通常情况下，DrawCall 的准备工作比 DrawCall 本身更耗费资源</p><ul><li>准备 DrawCall：CPU 设置资源并更改 GPU 上的内部设置，即渲染状态<ul><li>对渲染状态的更改（例如切换到不同的材质）是图形 API 执行的资源密集型操作</li><li>由于渲染状态更改是资源密集型的，因此对其进行优化非常重要。优化渲染状态更改的主要方法是减少它们的数量</li></ul></li><li>优化：<ul><li>减少 DrawCall 调用数量，这同样会减少改变渲染状态的次数</li><li>合批：如果可以使用相同的渲染状态来执行多个 DrawCall，那么就可以将 DrawCall 组合在一起，而不需要执行太多的渲染状态更改</li></ul></li><li>Unity 提供优化：<ul><li>GPU instancing</li><li>Static batching、Dynamic batching</li><li>SRP Batcher</li><li>手动合批</li></ul></li></ul><p>注：对于移动设备，Drawcall 不只影响 CPU，还会影响到 GPU</p><ul><li>在 PC 上 Drawcall 和顶点数量对 GPU 没有太多严重影响。但是对于 TBDR，DrawCall 过多意味着 FrameData 数据过多，严重情况下可能会出现内存放不下的情况，这种情况下对 FrameData 的访问速度奇慢<br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9vcHRpbWl6aW5nLWRyYXctY2FsbHMuaHRtbA==">Unity - Manual: Optimizing draw calls</span></li></ul><h2 id="setpasscall"><a class="anchor" href="#setpasscall">#</a> SetPassCall</h2><p>渲染 Pass 的数量：一帧中切换 Shader Pass 的次数，一个 Shader 可能包含多个用于渲染的 Pass，每个 Pass 都需要 Unity 绑定一个新的着色器，必然会带来 CPU 开销</p><ul><li>内置渲染管线：是所有材质球的渲染 Pass 的数量</li><li>URP：渲染不同 Pass 的数量，与内置管线以材质球为准不一样，以 Shader 和关键字都一样为准，其中渲染的 Pass 通道</li><li>注：经测试，两个同一个 Sahder 材质，内置渲染管线启用禁用时，Batches 和 SetPassCall 均发生变化，而 URP 仅 Batches 发生变化<br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9SZW5kZXJpbmdTdGF0aXN0aWNzLmh0bWw=">Unity - Manual: The Rendering Statistics window</span></li></ul><h2 id="降低-cpu-渲染成本"><a class="anchor" href="#降低-cpu-渲染成本">#</a> 降低 CPU 渲染成本</h2><ul><li>通常，CPU 渲染时间的最大消耗是向 GPU 发送渲染命令的成本</li><li>渲染命令包括 DrawCall (绘制几何图形的命令)、以及在绘制几何图形之前更改 GPU 设置的命令</li><li>可考虑优化方式<ul><li>减少渲染的对象数量<ul><li>远景使用天空盒模拟</li><li>剔除</li><li>缩小相机的远裁剪平面</li><li>Camera.layerCullDistances</li></ul></li><li>减少渲染每个对象的次数<ul><li>使用光照贴图</li><li>前向渲染中，减少实时光 (影响物体) 数量</li><li>注意实时阴影的使用，非常耗性能</li></ul></li><li>合批<ul><li>减少准备和发送渲染命令所需的工作量</li></ul></li></ul></li><li>上面的优化方式，部分既可减轻 CPU 负担，也可以同时降低 GPU 消耗 (如减少渲染对象数量)</li></ul><h2 id="降低-gpu-渲染消耗"><a class="anchor" href="#降低-gpu-渲染消耗">#</a> 降低 GPU 渲染消耗</h2><ul><li>像素填充率问题<ul><li>降低片段着色器的复杂度</li><li>减少 overdraw ：UI、粒子和 Sprite</li><li>动态分辨率 (DynamicResolution)</li></ul></li><li>内存带宽问题：一般由于纹理过多或分辨率过大<ul><li>启用 3D 空间对象纹理的 Mipmap，会增加内存使用量和存储空间，但可以提高运行时 GPU 的性能</li><li>选择合适的压缩格式减小内存中纹理大小</li></ul></li><li>顶点处理问题<ul><li>降低顶点着色器的复杂度</li><li>优化网格</li><li>LOD，会增加内存使用，但可以提高 GPU 效率</li></ul></li><li>降低帧率，可以考虑比如打开静态 UI 后，降低帧率，即按需渲染<ul><li>OnDemandRendering：独立于所有其他子系统（如物理、输入或动画）来控制和查询有关应用程序渲染速度（注：独立于 Application.targetFrameRate）<br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9PcHRpbWl6aW5nR3JhcGhpY3NQZXJmb3JtYW5jZS5odG1s">Unity - Manual: Graphics performance fundamentals</span></li></ul></li></ul><h1 id="批处理"><a class="anchor" href="#批处理">#</a> 批处理</h1><p>Unity 批处理顺序：</p><ul><li>SRP Batcher and static batching<ul><li>注：Unity 还支持与 SRP Batch 兼容的 GameObjects 的静态批处理</li></ul></li><li>GPU instancing</li><li>Dynamic batching</li></ul><h2 id="静态批处理static-batching"><a class="anchor" href="#静态批处理static-batching">#</a> 静态批处理 (Static batching)</h2><ul><li>两种方式，一种是编辑器标记 Static Batching，一种是运行时代码调用 StaticBatchingUtility 接口合并<ul><li>编辑器标记的方式会在打包时统一合并，增加磁盘空间</li><li>代码合并则消耗运行时 CPU，且必须启用 Mesh 的 read/write</li></ul></li><li>增加磁盘空间、内存消耗、运行时无法移动<ul><li>将组合的 Mesh 转换到世界空间，并为它们构建一个共享顶点和索引缓冲区，使得一个 DrawCall 可以将合批对象都绘制出来</li><li>每个游戏对象都会创建一个 Mesh 副本，并将每个副本插入组合的 Mesh 中，意味着就算同一实例也会导致额外内存</li></ul></li><li>好处如同名字一样，按照官方说法，可以显著降低 DrawCall 开销，对于可见的 Mesh 执行更轻量级的 DrawCall</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9zdGF0aWMtYmF0Y2hpbmcuaHRtbA==">Unity - Manual: Static batching</span></li><li>注：需要先启用 PlayerSetting StaticBatching 选项</li><li>具有相同材质的对象才能进行批处理、对象不能为负缩放</li></ul><h2 id="动态批处理dynamic-batching"><a class="anchor" href="#动态批处理dynamic-batching">#</a> 动态批处理 (Dynamic batching)</h2><p>运行时每帧在 CPU 上动态合并网格，只有当合并消耗小于 DrawCall 消耗时才是一种优化，在现代图形 API，例如 IOS (Apple Metal) 上，基本上是消耗大于收益</p><ul><li>注：在现代消费类硬件上，动态批处理在 CPU 上所做的工作可能大于 DrawCall 本身的开销。这会对性能产生负面影响（言外之意就是不要用了，HDRP 已经移除支持）</li><li>注：需要先启用 PlayerSetting DynamicBatching 选项</li></ul><p>限制</p><ul><li>具有相同材质的对象才能进行批处理 (除 shadow caster rendering 外)</li><li>对象不能为负缩放</li><li>使用顶点属性低于 900 个，例如 Shader 同时使用 顶点位置、顶点法线、UV0、UV1 和顶点切线，则 Unity 只能批处理 180 个顶点 (900/5=180)</li><li>如果有光照贴图，必须指向同一个地方 (可忽略)</li><li>多 Pass 支持也有问题，例如只有第一个 Pass 生效，后续额外的像素光是无效的</li></ul><h2 id="手动合批"><a class="anchor" href="#手动合批">#</a> 手动合批</h2><ul><li>使用 API Mesh.CombineMeshes</li><li>注：手动合批的网格无法单独剔除</li></ul><h2 id="gpu-instancing"><a class="anchor" href="#gpu-instancing">#</a> GPU instancing</h2><ul><li>两种方式，一种是直接由 Unity 引擎自动处理，一种是使用代码一次性绘制<ul><li>支持 MaterialPropertyBlock 修改 Shader 中定义的 Instancing 属性</li></ul></li><li>材质自带的与 SRPBatcher 不兼容，优先 SRPBatcher<ul><li>如果开启了 SRP Batcher ，需要移除 Shader 中对 SRP Batcher 的兼容性<ul><li>只要 UnityPerMaterial 常量缓冲区中不存在材质属性，就会使着色器与 SRP Batcher 不兼容</li><li>使用 MaterialPropertyBlock 也会使 SRP Batcher 不兼容</li></ul></li></ul></li><li>注：使用完全相同的材质渲染大量相同的网格，GPU 实例化可能比 SRP Batcher 更高效</li></ul><h3 id="api"><a class="anchor" href="#api">#</a> API</h3><ul><li>Graphics.RenderMeshInstanced：可以使用实例化着色器多次渲染同一网格<ul><li>注 1：RenderParams.worldBounds 可以自定义边界</li><li>注 2：该接口一次最多只能渲染 1023 个实例</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL1NjcmlwdFJlZmVyZW5jZS9HcmFwaGljcy5SZW5kZXJNZXNoSW5zdGFuY2VkLmh0bWw=">Unity - Scripting API: Graphics.RenderMeshInstanced</span></li></ul></li><li>Graphics.RenderMeshIndirect：使用 commandBuffer 命令进行实例化渲染 (对实例数量没有限制)<ul><li>注 1：RenderParams.worldBounds 可以自定义边界</li><li>注 2：要求支持 compute shaders，着色器中有额外取值方式需求</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL1NjcmlwdFJlZmVyZW5jZS9HcmFwaGljcy5SZW5kZXJNZXNoSW5kaXJlY3QuaHRtbA==">Unity - Scripting API: Graphics.RenderMeshIndirect</span></li></ul></li><li>注：其它还有 DrawMeshInstanced、DrawMeshInstancedIndirect (可以直接做剔除) 等 API 效果同上，不过据说 RenderMeshInstanced 接口更新，例如接受 NativeArray</li><li>注：可通过 SystemInfo.supportsInstancing 判断平台是否支持</li><li>缺点：Unity 会自动计算此网格的所有实例的边界，并会将该网格的所有实例作为单个实体进行剔除和排序 (所以优先级才在 SRPBatcher 之下吧)</li></ul><h3 id="兼容性"><a class="anchor" href="#兼容性">#</a> 兼容性</h3><ul><li>OpenGL ES 3.0+(3.1 均没问题)</li><li>IOS 的 Metal 均支持 (Metal 从 iPhone 5s 开始支持)</li><li>具有相同材质、同一个 Mesh 的对象才能进行批处理</li></ul><h2 id="srp-batcher"><a class="anchor" href="#srp-batcher">#</a> SRP Batcher</h2><ul><li>支持 mesh 或 skinned mesh（非粒子）</li><li>不支持 MaterialPropertyBlock，使用 MaterialPropertyBlock 会导致 SRP Batcher 兼容失败</li><li>允许不同材质，同一个 Shader，同样的变体即可</li><li>支持代码启用禁用：GraphicsSettings.useScriptableRenderPipelineBatching = true</li></ul><h3 id="工作原理"><a class="anchor" href="#工作原理">#</a> 工作原理</h3><p>一般优化 DrawCall 的方式是减少调用数量，而 SRP Batcher 则主要减少了绘制调用之间的渲染状态更改<br><img data-src="/blogimages/2023/2023-05-12/1.png" alt=""><br>SRP Batcher 通过一系列组合将 bind 和 draw 命令合并，每个命令序列称为 SRP Batch<br>为优化性能，一个 SRP Batch 应包含尽可能多的 bind and draw 命令 (少用 Shader 变体)<br>当检测到新的材质时，CPU 会绑定相关属性到 GPU 常量缓冲区 (constant buffers)，使材质属性持久保存在显存中，若材质没有发生更改，SRP Batcher 就不会更改渲染状态</p><ul><li>所有材质均持久存在于 GPU 的显存 (常量缓冲区) 中</li><li>随后 CPU 再使用专门方式在 GPU 大型常量缓冲区进行每个物体的属性更新或管理<br><img data-src="/blogimages/2023/2023-05-12/2.png" alt=""></li><li>当 Shader 发生变化时，只需要<ul><li>重新绑定 Material CBUFFER (材质属性)</li><li>重新绑定 large CBUFFER (物体属性)</li><li>然后就可以执行新的渲染 (DrawCall)<br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9TUlBCYXRjaGVyLmh0bWw=">Unity - Manual: Scriptable Render Pipeline Batcher</span></li></ul></li></ul><h2 id="batchrenderergroupbrg"><a class="anchor" href="#batchrenderergroupbrg">#</a> BatchRendererGroup(BRG)</h2><p>物体不会参与到 Unity 场景 Render 的剔除，他真正的是管理每一个物体的剔除，也就是说如果有 1000 个小物体他们会分别计算剔除。最重要的是，RenderBatchGroup 给你的是一组相机参数，这意味着我们能在这里能对于每个 View 分别做 LOD 相关的东西</p><ul><li>比 GPU Instancing 更高效，并且可以在 CPU 上使用多线程、可以自定义剔除等</li><li>建立在 SRP Batcher 之上</li><li>要求<ul><li>需要禁用变体剔除选项，避免 Shader 中 DOTS Instancing 变体被剔除</li><li>需要启用不安全代码 (Allow unsafe code)</li></ul></li><li>兼容性：OpenGL, GLES and WebGL 暂不支持</li><li><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS51bml0eS5jb20vdGhyZWFkcy9uZXctYmF0Y2hyZW5kZXJlcmdyb3VwLWFwaS1mb3ItMjAyMi0xLjEyMzA2Njkv">https://forum.unity.com/threads/new-batchrenderergroup-api-for-2022-1.1230669/</span></li></ul><h3 id="使用步骤"><a class="anchor" href="#使用步骤">#</a> 使用步骤</h3><ul><li>创建 BatchRendererGroup 实例</li><li>new BatchRendererGroup(this.OnPerformCulling, IntPtr.Zero);</li><li>注册 Mesh 和材质<ul><li>可以重复注册，内部使用引用计数维护注册数量，注册一次递增 1，注销一次减 1，引用计数达到 0 内部才会才真的注销</li><li>已注册 Mesh 或 Material 的 RegisterMesh 或 RegisterMaterial 调用返回与上一次调用相同的 BatchMeshID 或 BatchMaterialID（若彻底注销后，重复注册返回不同 id）<br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjIuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9iYXRjaC1yZW5kZXJlci1ncm91cC1jcmVhdGluZy1hLXJlbmRlcmVyLmh0bWw=">Unity - Manual: Creating a renderer with BatchRendererGroup</span></li></ul></li></ul><h2 id="dots-instancing"><a class="anchor" href="#dots-instancing">#</a> DOTS Instancing</h2><p>DOTS 实例化比传统实例化更具有优势</p><ul><li>实例数据存储在 GraphicsBuffer 中，并在 GPU 上保持持久性<ul><li>这意味着 Unity 不需要在每次渲染实例时再次设置它，仅在实例实际更改时设置数据</li><li>注：传统的实例化需要一个引擎在每帧为每个实例设置所有数据</li></ul></li><li>设置实例数据的过程与设置 DrawCall 调用是分开的<ul><li>DrawCall 消耗更低</li><li>BRG 通过 SRP Batcher 一个特殊的快速通道使得每个 DrawCall 只做最少工作</li><li>可以更好地控制在每次绘制调用中渲染什么</li></ul></li><li>绘制调用的大小不再受常量或统一缓冲区中可以容纳多少实例数据的限制<ul><li>BRG 可以通过一个 DrawCall 来渲染更多的实例数量</li><li>注：实例索引的数量仍然限制了绘制调用的大小，因为每个索引仍然需要一些数据。然而，一个索引消耗的内存远远少于一组完整的实例化属性，这意味着更多的实例可以放在一个常量或统一的缓冲区中。例如，每个索引需要 16 个 byte，因此如果特定平台上缓冲区的内存限制为 64kb，则缓冲区中可以容纳 4096 个索引</li></ul></li><li>如果每个实例对给定的属性使用相同的值，则可以让所有实例从内存中的同一位置加载该值。这样可以节省内存和复制每个实例的值所花费的 GPU 周期数</li></ul><p>要求</p><ul><li>#pragma target 4.5 或更高<ul><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTkuNC9NYW51YWwvU0wtU2hhZGVyQ29tcGlsZVRhcmdldHMuaHRtbA==">着色器编译目标级别 - Unity 手册</span></li></ul></li><li>#pragma multi_compile _DOTS_INSTANCING_ON</li><li>声明 DOTS Instanced 属性块</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjIuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9kb3RzLWluc3RhbmNpbmctc2hhZGVycy5odG1s">Unity - Manual: DOTS Instancing shaders</span></li></ul><h1 id="光照"><a class="anchor" href="#光照">#</a> 光照</h1><h2 id="阴影"><a class="anchor" href="#阴影">#</a> 阴影</h2><p>阴影贴图本质上是从光源视角投射的纹理<br>注 1：URP 中，额外光源若选顶点光照则不能设置阴影<br>注 2：内置渲染管线未找到直接设置顶点光</p><h3 id="cascaded-shadow-mapscsm"><a class="anchor" href="#cascaded-shadow-mapscsm">#</a> Cascaded Shadow Maps(CSM)</h3><p>使用多张阴影贴图实现阴影的一种技术</p><ul><li>阴影贴图的缺点：空间中对象在阴影图比例太小，采样精度不够，产生锯齿 (增加阴影图分辨率可以改善，但治标不治本，同时也会增加内存消耗)<ul><li>而且一张阴影图会导致近处物体采样精度不够，远处物体采样精度浪费</li></ul></li><li>问题是阴影贴图分辨率低，级联阴影的关键就是生成和使用不同精细度的阴影贴图</li></ul><p>基础的阴影贴图方法对于大型场景渲染显得力不从心，由于阴影贴图分辨率问题，很容易出现阴影抖动和锯齿边缘现象<br>Cascaded Shadow Maps (CSM) 方法根据对象到观察者的距离提供不同分辨率的深度纹理来解决上述问题</p><ul><li>在一张阴影贴图中捕捉所有对象需要阴影贴图具有非常高的分辨率</li><li>使用多张阴影贴图就可以解决这个问题，对于近处的场景使用较高分辨率的阴影贴图，对于远处的场景使用粗糙的阴影贴图，在两张阴影贴图过渡的地方选择其中一张使用</li></ul><p>注：实时阴影，仅适用于平行光 (大场景最好至少 2 个，默认是 1 个 - 即仅一张)<br>注：因为需要多张阴影，因此会增加 DrawCall<br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MzY4OTk4Nw==">Cascaded Shadow Maps (CSM) 实时阴影的原理与实现</span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMDU0NDIvYXJ0aWNsZS9kZXRhaWxzLzExNzQyNzM5NQ==">Unity 实时阴影实现 ——Cascaded Shadow Mapping_unity 阴影</span></p><h3 id="bias"><a class="anchor" href="#bias">#</a> Bias</h3><p>阴影偏移，解决自遮挡阴影瑕疵 (Shadow acne) 而提出<br>因为 DepthMap 分辨率的关系，每个 Depth 像素对应地面上的一小块区域，而不是一个点</p><ul><li>这块区域中，如果都按照这个 Depth 值进行计算的话，就有的地方比 Depth 值大，有的地方比 Depth 值小，所以就会重现交错</li><li>（因此除 Bias 外也可以通过提升 DepthMap 的分辨率解决，但是...）<ul><li>当光源离得特别远的时候，你从光源角度看，整个场景可能都挤在几个像素里，特别的小，所以没办法只通过调整深度图的分辨率来控制 (MipMap？Cascade？)</li></ul></li></ul><p>因此在和 ShadowMap 中离散化的深度比较时，将这个深度加大一点点，这样只有当 ShadowMap 中的深度显著大于计算出来的深度时，才判断为产生阴影<br>注：若 Bias 值太大也会有副作用，例如会导致对象的底部与阴影有一定的距离，造成 &quot;浮空&quot; 的错觉<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQ5MDkwMzIx">关于 Shadow Mapping 产生的 Shadow Acne，我的理解是不是有问题？ - 知乎</span></p><h1 id="渲染方式"><a class="anchor" href="#渲染方式">#</a> 渲染方式</h1><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTc0NzUwMjg=">浅谈延迟渲染、移动 GPU 架构和 Metal</span></p><ul><li>前向渲染是一种非常直接的渲染方式，我们提交的 mesh，经过 vs、gs、fs 等 shader，直接绘制到 color buffer 等待输出到屏幕，很线性的 Per-Object/Per-Light 方式进行绘制。—— 光照对性能影响很大<ul><li>前向渲染渲染 n 个物体在 m 个光源下的着色，复杂度为 O (n*m) 次。</li></ul></li><li>延迟渲染 (Deferred Rendering)，即延迟着色（Deferred Shading），顾名思义，是将着色计算延后进行处理的一种渲染方法，可以将延迟渲染 ( Deferred Rendering) 理解为先将所有物体都先绘制到屏幕空间的缓冲（即 G-buffer，Geometric Buffer，几何缓冲区）中，再逐光源对该缓冲进行着色的过程，从而避免了因计算被深度测试丢弃的片元着色而产⽣的不必要的开销<ul><li>对应于前向渲染 O (m*n) 的复杂度，经典的延迟渲染复杂度为 O (n+m)</li><li>延迟管线下多了深度、法线、颜色等几张 G-Buffer。这些都是屏幕大小的尺寸的 Render Target，所带来的内存以及带宽压力很大</li><li>延迟渲染有以下特点：<ul><li>内存开销较大</li><li>读写 G-buffer 的内存带宽用量是性能瓶颈。</li><li>对透明物体的渲染存在问题。在这点上需要结合前向渲染进行渲染。</li><li>对多重采样抗锯齿（MultiSampling Anti-Aliasing, MSAA）的支持不友好，主要因为需开启 MRT。</li><li>由于 Deferred Shading 的 Deferred 阶段是在完全基于 G-Buffer 的屏幕空间进行，这也导致了物体材质信息的缺失，这样在处理多变的渲染风格时就需要额外的操作。</li></ul></li><li>针对上文的问题，业界有主流有两种优化方式：<ul><li>Light Pre-Pass 即 Deferred Lighting 延迟光照技术，通过减少经典延迟渲染所使用的 G-Buffer 数量来提高性能</li><li>分块延迟渲染，tile-based Deferred Rendering。该方法通过可以在一次绘制处理多个光源，以及来降低对 G-Buffer 的读写开销</li></ul></li></ul></li><li>影响功耗的最大因素是什么？带宽。</li></ul><h2 id="前向渲染forwardpass"><a class="anchor" href="#前向渲染forwardpass">#</a> 前向渲染 (ForwardPass)</h2><h3 id="渲染方式-2"><a class="anchor" href="#渲染方式-2">#</a> 渲染方式</h3><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTc0NzUwMjg=">浅谈延迟渲染、移动 GPU 架构和 Metal</span></p><ul><li>先渲染 ShadowMap</li><li>然后从近至远渲染不透明物体</li><li>最后从远至近渲染透明物体</li><li>因为有深度测试，因此先渲染近处物体可以提前剔除不可见像素，透明物体则相反，需要混合叠加，因此由远及近</li><li>unity 规定，2500 以下对象由近及远，以上由远及近</li><li>earlyz：几何阶段与片元着色器阶段之间（光栅化之后，片元着色器之前），不过最终还是会走一次正常的后置深度测试</li><li>若检测到在片元着色器存在抛弃片元和改写深度的操作，则 earlyz 优化将被弃用</li><li>例如使用了 alphatest 渲染物体（因为片元是在片元着色器丢弃的，丢弃后，它之后的片元就得显示，若进行了 earlyz 就会出问题）</li></ul><h3 id="前向实时剔除"><a class="anchor" href="#前向实时剔除">#</a> 前向实时剔除</h3><ul><li>前向渲染是逐对象渲染，若一个物体挡住了另一个物体，执行的渲染就无效了，为了解决这些问题，也提出了一些解决方法：如 Early-z 、Z-Prepass 、 Hi-Z</li><li>Early-z：在光栅化阶段，每个模型的深度就已经写入深度缓存了，先进行深度剔除再计算光照</li><li>Z-Prepass：首先把整个场景中的模型都渲染一遍，全部都写入 Z-Buffer ，这次渲染除了 Z-Buffer 其他的信息都不计算。然后再渲染一遍场景，这次渲染关闭深度写入，每个像素和 Z-Buffer 中已经存在的深度信息进行对比，只有通过测试的像素才会计算光照。这种方法虽然避免了无效的光照计算，但是却执行了两次顶点着色器，所以最好是在场景中物体的光照计算非常复杂但是顶点数量却不是很多的情况下使用。</li><li>Hi-Z ：上面两种方法都是在 GPU 段进行的，而 Hi-Z 这种方法是在 CPU 端进行的，在几何体被提交到 GPU 之前会进行遮挡测试，如果几何体被别的物体遮挡了就不会提交到 GPU</li></ul><h3 id="光照-2"><a class="anchor" href="#光照-2">#</a> 光照</h3><ul><li>多一个光源就会多一个 DrawCall，是因为重要光源的原因，在 ForwardPass 渲染路径中，默认最多支持 4 个 逐像素的重要光源 (可设置)，光源默认 Auto ，将光源设置为 Net Important 即可减少该消耗。(不重要的顶点光源同样是限制 4 个，Shader 中 unity_LightColor [4]--&gt; 仅 BasePass)</li><li>BasePass（LightMode=ForwardBase）：最重要逐像素平行光源 (_LightColor0)+ 不重要光源 (unity_LightColor [4])+LightMap + 环境光</li><li>AdditionalPass（LightMode=ForwardAdd）：其它逐像素重要光源 (_LightColor0) 在额外 Pass 渲染，与前者叠加，多一个就会导致多一份 DrawCall</li></ul><h3 id="阴影forward"><a class="anchor" href="#阴影forward">#</a> 阴影 (Forward)</h3><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVGZsNk1VUHRPVk5EQzJDeTNhWGpIQQ==">游戏中的动态阴影</span></p><ul><li>分为两部分，自己接收阴影以及投射阴影，MeshRender 上也可以单独设置</li><li>是否有阴影跟三个条件有关：(1) Shader 中的 接收投射阴影 Pass；(2) Render 上的接收投射开关；(3) 光源是否设置阴影</li><li>Shader 中阴影投射 Pass 必须：<ul><li>打 Tags {&quot;LightMode&quot;:&quot;ShadowCaster&quot;}，标记该 Pass 专用于阴影投射</li><li>增加预编译指令 #pragma multi_compile_shadowcaster</li><li>在顶点、片段中调用 Unity 提供的预定义进行处理：V2F_SHADOW_CASTER、TRANSFER_SHADOW_CASTER_NORMALOFFSET、SHADOW_CASTER_FRAGMENT<ul><li>V2F_SHADOW_CASTER：顶点到片段数据变量</li><li>TRANSFER_SHADOW_CASTER_NORMALOFFSET：在顶点 Shader 函数中计算了 物体顶点世界坐标 - 光源坐标，即当前顶点到光源向量，然后再转 clip 裁剪空间</li><li>SHADOW_CASTER_FRAGMENT：在片段 Shader 函数中将顶点到光源向量转长度，计算深度（光源设置的 shadowbias 就在这里用的：长度 + unity_Light_ShadowBias.x）</li></ul></li><li>Shader 中阴影接收 Pass 必须：<ul><li>打 Tags {&quot;LightMode&quot;:&quot;ForwardBase&quot;}，标记该 Pass 为向前渲染</li><li>增加预编译指令 #pragma multi_compile_fwdbase</li><li>在顶点、片段中调用 Unity 提供的预定义进行处理：SHADOWCOORDS (1)、<ul><li>SHADOWCOORDS (ID)：ID 是个数值，表示使用的 TEXCOORD+ID，保存顶点函数通过 ComputeScreenPos (o.pos) 计算的 showCoord</li><li>TRANFER_SHADOW (o)：通过顶点 clip 裁剪空间坐标计算屏幕空间阴影采样坐标 ComputeScrrenPos (o.pos)</li><li>SHADOW_ATTENUATION (i)：根据 showCoord 采样阴影颜色，返回叠加的阴影强度值。</li></ul></li></ul></li></ul></li><li>Forward：<ul><li>在光源位置渲染一张深度图，然后找物体 Shader 中的特殊的 阴影投射 Pass</li><li>在正常渲染时，判断当前深度是否大于阴影深度，叠加阴影颜色</li></ul></li><li>仅在使用像素光照的情况下才渲染法线贴图、光照剪影和实时阴影。此外，在像素模式下渲染时，聚光灯形状和点光源高光看起来要好得多。</li><li>CSM (Cascaded Shadows Map)：级联阴影，将摄像机前面空间分成多个层级，分别 (以不同分辨率) 绘制各个层级物体阴影深度，合成一张连续的 CSM 贴图</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTguNC9NYW51YWwvTGlnaHRQZXJmb3JtYW5jZS5odG1s">https://docs.unity.cn/cn/2018.4/Manual/LightPerformance.html</span></li></ul><h2 id="延迟渲染deferred"><a class="anchor" href="#延迟渲染deferred">#</a> 延迟渲染 (Deferred)</h2><ul><li>延迟渲染就是把光照计算延迟到深度测试之后的渲染方式，只渲染可见的像素，不会有无效的计算。</li><li>延迟渲染的思路就是先把几何体的信息都渲染到二维空间中（G-Buffer），然后把 G-Buffer 整体进行光照计算，G-Buffer 中存在的信息都是会最终呈现在屏幕上的，不会有无效计算。<ul><li>Z-prepass 也是先渲染出深度缓存进行深度测试后再计算光照的，和延迟渲染有什么不同？最大的不同点就在于 G-buffer ，Z-prepass 在深度测试后也还是按照一个几何体渲染完再进行下一个这种方式来渲染的 ，延迟渲染是几何体的信息传递到 G -buffer 之后就和几何体没多大关系了，接下来的操作都是对 G-buffer 进行的。</li></ul></li><li>G-Buffer：不同的引擎处理可能不一样，例如 PBR 会有深度、颜色、法线、世界空间坐标、模板、金属、粗糙、高光这些信息</li><li>缺点：<ul><li>前向渲染只需要深度缓冲和最终的颜色缓冲就够了，延迟渲染需要缓存的信息实在太多了，这造成了带宽的开销大幅增加。</li><li>对于半透明无能为力，所有半透明的物体都需要等待不透明物体以延迟渲染完成之后，在用前向渲染的方式渲染半透明物体。</li><li>无法记录通过半透明对象可见的对象和当前对象本身的深度和法线</li></ul></li><li><strong>分块延迟渲染</strong>：<ul><li>虽然延迟渲染已经把光照数量和三角形数量不再关联了，但是当场景中的光源数量不断上升之后，就算是延迟渲染也有点撑不住。</li><li>这时就需要分块延迟渲染，它的思路是把 G-Buffer 分成很多个小块，分析每个小块受到哪些光源的影响，然后逐个分块进行着色，那些受光源影响的数量少的小块就不需要那么多的光照计算了。这种渲染方式在光源数量少的情况下效果不明显，但是光源数量越多它优化的性能也就越多。</li></ul></li></ul><h3 id="前向与延迟渲染路径比较"><a class="anchor" href="#前向与延迟渲染路径比较">#</a> 前向与延迟渲染路径比较</h3><ul><li>后处理方式不同。需要深度信息进行后处理时：前向渲染需要单独渲染一张深度图；延迟渲染直接从 G-buffer 中的深度图进行计算。</li><li>着色计算不同（shader）。延迟渲染光照计算统一在 Lighting Pass 里计算，只能用一个光照模型，需要其它光照模型只能切换 Pass。</li><li>抗锯齿方式不同</li></ul><h2 id="forward-渲染"><a class="anchor" href="#forward-渲染">#</a> Forward+ 渲染</h2><p>思路是将屏幕划分为一个一个的块儿，控制每个块儿的影响灯光数量，从而减轻运算压力，让前向渲染也可以处理多光源的情况。</p><h1 id="后期处理"><a class="anchor" href="#后期处理">#</a> 后期处理</h1><h2 id="抗锯齿"><a class="anchor" href="#抗锯齿">#</a> 抗锯齿</h2><ul><li>MSAA (Multi Sample AA)：基于多边形抗锯齿，增加像素采样数 (增加额外显存及带宽开销)，只能用于 Forward，有 2X、4X<ul><li>对空间进行 4 倍采样，进行着色时，考虑 4 个子像素对同一个几何体的覆盖率；若三角形对这 4 个采样点的覆盖率是 100%，则仅进行一次着色，否则都需要着色，并根据每个三角形占据的采样比例计算该点平均值</li><li>现代的几何体密度较高，性能消耗也会比较高</li></ul></li><li>FXAA (Fast Approximately AA)：后处理抗锯齿，图形边缘进行柔化，速度很快但会糊。</li><li>SMAA (Subpixel Morphological)：后处理形态抗锯齿，改进了对模型边缘的判定算法，效果比 FXAA 更好，但是消耗比 FXAA 高一倍</li><li>TAA (Temporal AA)：时域抗锯齿，子像素采样点分布到多帧，需要运动矢量 (motion vectors)，原理是，通过 Motion Vector，找到上一帧的当前像素点的信息，然后混合，抖动投影矩阵的做法被称为 Jitter<ul><li>涉及两个 pass：渲染动态物体的运动矢量至速度缓存与 TAA</li></ul></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTkuNC9NYW51YWwvUG9zdFByb2Nlc3NpbmctQW50aWFsaWFzaW5nLmh0bWw=">抗锯齿 (Anti-aliasing) - Unity 手册</span><ul><li>Unity Quality 内置的就是 MSAA， 在 URP 中，渲染管线可以设置 MSAA，相机后处理可以选择 FXAA、SMAA，两者可以叠加。URP 不自带 TAA (缺少正确的 Motion Vectors)，【TAA 与 MSAA 不能叠加 -- 待定】</li><li>官方推荐：FXAA -- 移动端，SMAA、TAA-- 桌面和主机</li><li>Post Processing v2 倒是支持 TAA，但是 URP 集成的 PP 没有支持 (缺少 Motion Vectors 数据)，且内置的 Post Processing 替代了 PPv2 (<span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS51bml0eS5jb20vdGhyZWFkcy9wb3N0LXByb2Nlc3NpbmctYW5kLXVycC10aGUtcGxhbi43OTU0NTYv">post-processing-and-urp-the-plan</span>)</li><li>速度快慢：FXAA-&gt;SMAA-&gt;MSAA-&gt;TAA</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxlbWVudDNkcy5jb20vZm9ydW0ucGhwP21vZD12aWV3dGhyZWFkJmFtcDt0aWQ9MzkwMzEy">U3D 各种抗锯齿哪个好？各自特点是什么？性能如何？什么平台用什么合适？</span></li></ul></li></ul><h2 id="屏幕效果"><a class="anchor" href="#屏幕效果">#</a> 屏幕效果</h2><ul><li>Bloom 效果<ul><li>提取亮度、模糊处理、以及合并光晕</li><li>提取原图像，给定一个阈值，使用高斯模糊阈值范围上的图像。再与原图相加，获得 bloom 效果</li></ul></li><li>景深<ul><li>近距离模糊</li><li>焦点范围清晰</li><li>远距离模糊</li><li>注：可能需要用到深度，另外听说还有种物理景深算法</li></ul></li></ul><h1 id="性能优化"><a class="anchor" href="#性能优化">#</a> 性能优化</h1><ul><li>减少提交次数 DrawCall，减少数据交换量，带宽优化、也是显存优化、</li><li><strong>减少 CPU 与 GPU 的数据同步</strong>。减少 CPU 与 GPU 的数据同步也是一个方向，怪物尽可能由 GPU 绘制，最大可能减少数据同步，以达到最高异步效率</li><li>可变分辨率</li><li>Shader：避免不同数据类型混用或者叫避免不必要的精度转换，例如 half 和 float，精度转换也是有消耗的<ul><li>现在新型 GPU fixed 可能已经没了，等价于 Half</li><li>3D 贴图开启 Mipmap，以空间换时间</li><li>使用 Bilinear 代替 Trilinear 过滤</li><li>减少 Anisotropic 过滤采样数量</li></ul></li><li>使用 LightMap，如果实在要使用实时阴影，可以考虑 Subtractive + 低分辨率阴影配合正确的阴影级联 (cascade) 设置 (级联仅适用于方向光)</li><li>BVH</li></ul><h1 id="渲染调试"><a class="anchor" href="#渲染调试">#</a> 渲染调试</h1><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9GcmFtZURlYnVnZ2VyLmh0bWw=">FrameDebugger</span></p><h1 id="其它-2"><a class="anchor" href="#其它-2">#</a> 其它</h1><h2 id="模型"><a class="anchor" href="#模型">#</a> 模型</h2><ul><li>网格主要由：顶点、三角形索引数组、UV 三个基础数据组成</li></ul><h2 id="动画"><a class="anchor" href="#动画">#</a> 动画</h2><ul><li>分为两种：一种是用一种算法改变顶点位置，为顶点动画；另一种是用骨骼影响网格顶点，为骨骼动画。两种方式都是通过在每一帧偏移模型网格上的顶点，让模型变形从而实现动画，最终原理其实一样。</li><li>传统骨骼动画：每个顶点都有骨骼权重数据（被哪些骨骼影响，权重多少），在 unity 中可以设置每个顶点最多受四个骨骼权重影响 —— 传统骨骼动画由骨骼点与顶点权重数据计算得到，顶点与骨骼数量越多，有效权重数据越多，cpu 消耗也越大</li><li>skinmesh：bindposes 为旋转矩阵，是为了实现父节点旋转位移时更快计算出子节点的位移旋转的变化矩阵（父子节点有相对位置关系，相对位置，相对角度，相对比例不变）</li><li>传统骨骼动画计算：CPU 计算骨架 -&gt;GPU 顶点蒙皮</li><li>贴图骨骼动画：动画信息存储为图片，VertexShader 通过 tex2dlod 采样 (贴图模式采用 Point)<ul><li>通过 CPU 计算全单位 Mask 图：播放哪个动画，第几帧。一张贴图包含所欲单位实时状态信息，只有一次数据同步。</li></ul></li><li>大批量实例化绘制 (GPU Instancing)：DrawMeshInstanced，该函数一般用于加速静态物体，批量一次性绘制一个 Mesh 多次。由于动态物体有动画，难以完全一致 (当对象足够多的时候，当前帧动画可能一致就能用了)，形成动画对象大批量实例化技术。</li><li>批量化 GPU 阴影</li></ul><h2 id="urp"><a class="anchor" href="#urp">#</a> URP</h2><ul><li>URP 多相机使用：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTE2Mzg5NTk=">https://zhuanlan.zhihu.com/p/351638959</span></li><li>Depth Priming (Pre-Z Pass)：OverDraw 过度绘制可以启用，但是要避免在 Tile-Based GPUs (移动平台)，提高半透明物体效率？<ul><li>优化 OverDraw，会增加 DrawCall，需要判断是否是正优化。</li><li>只能用于 Forward，自定义 Shader 需要手动添加 DepthOnly Pass</li><li>手机上与 MSAA 同时开启会比 DrawCall 开销还要大</li><li>DrawCall 或其它图形 API 调用</li></ul></li><li>RenderingDebuger：URP 调试工具</li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTYzOTczMzQ=">URP 配置 — 保姆级新手指南</span></li></ul><p>光照</p><ul><li>注：额外光源若选顶点光照则不能设置阴影</li></ul><h1 id="参考文档"><a class="anchor" href="#参考文档">#</a> 参考文档</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvYngwOXNjbmExVDJkV0RSVmlKejBWQQ==">图形学基础篇</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNjM5NDQ1MzE=">(十)、图形渲染进阶知识</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9GcmFtZURlYnVnZ2VyLmh0bWw=">FrameDebugger</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NzQ1NDAzMjk=">URP 延迟渲染 + Native Renderpass 踩坑记录</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9vcHRpbWl6aW5nLWRyYXctY2FsbHMuaHRtbA==">Unity - Manual: Optimizing draw calls</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9SZW5kZXJpbmdTdGF0aXN0aWNzLmh0bWw=">Unity - Manual: The Rendering Statistics window</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9PcHRpbWl6aW5nR3JhcGhpY3NQZXJmb3JtYW5jZS5odG1s">Unity - Manual: Graphics performance fundamentals</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9zdGF0aWMtYmF0Y2hpbmcuaHRtbA==">Unity - Manual: Static batching</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL1NjcmlwdFJlZmVyZW5jZS9HcmFwaGljcy5SZW5kZXJNZXNoSW5zdGFuY2VkLmh0bWw=">Unity - Scripting API: Graphics.RenderMeshInstanced</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjMuMi9Eb2N1bWVudGF0aW9uL1NjcmlwdFJlZmVyZW5jZS9HcmFwaGljcy5SZW5kZXJNZXNoSW5kaXJlY3QuaHRtbA==">Unity - Scripting API: Graphics.RenderMeshIndirect</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9TUlBCYXRjaGVyLmh0bWw=">Unity - Manual: Scriptable Render Pipeline Batcher</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS51bml0eS5jb20vdGhyZWFkcy9uZXctYmF0Y2hyZW5kZXJlcmdyb3VwLWFwaS1mb3ItMjAyMi0xLjEyMzA2Njkv">https://forum.unity.com/threads/new-batchrenderergroup-api-for-2022-1.1230669/</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjIuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9iYXRjaC1yZW5kZXJlci1ncm91cC1jcmVhdGluZy1hLXJlbmRlcmVyLmh0bWw=">Unity - Manual: Creating a renderer with BatchRendererGroup</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTkuNC9NYW51YWwvU0wtU2hhZGVyQ29tcGlsZVRhcmdldHMuaHRtbA==">着色器编译目标级别 - Unity 手册</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjIuMi9Eb2N1bWVudGF0aW9uL01hbnVhbC9kb3RzLWluc3RhbmNpbmctc2hhZGVycy5odG1s">Unity - Manual: DOTS Instancing shaders</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MzY4OTk4Nw==">Cascaded Shadow Maps (CSM) 实时阴影的原理与实现</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMDU0NDIvYXJ0aWNsZS9kZXRhaWxzLzExNzQyNzM5NQ==">Unity 实时阴影实现 ——Cascaded Shadow Mapping_unity 阴影</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQ5MDkwMzIx">关于 Shadow Mapping 产生的 Shadow Acne，我的理解是不是有问题？ - 知乎</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTc0NzUwMjg=">浅谈延迟渲染、移动 GPU 架构和 Metal</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTc0NzUwMjg=">浅谈延迟渲染、移动 GPU 架构和 Metal</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVGZsNk1VUHRPVk5EQzJDeTNhWGpIQQ==">游戏中的动态阴影</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTguNC9NYW51YWwvTGlnaHRQZXJmb3JtYW5jZS5odG1s">https://docs.unity.cn/cn/2018.4/Manual/LightPerformance.html</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTkuNC9NYW51YWwvUG9zdFByb2Nlc3NpbmctQW50aWFsaWFzaW5nLmh0bWw=">抗锯齿 (Anti-aliasing) - Unity 手册</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS51bml0eS5jb20vdGhyZWFkcy9wb3N0LXByb2Nlc3NpbmctYW5kLXVycC10aGUtcGxhbi43OTU0NTYv">post-processing-and-urp-the-plan</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxlbWVudDNkcy5jb20vZm9ydW0ucGhwP21vZD12aWV3dGhyZWFkJmFtcDt0aWQ9MzkwMzEy">U3D 各种抗锯齿哪个好？各自特点是什么？性能如何？什么平台用什么合适？</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tLzIwMjEuMy9Eb2N1bWVudGF0aW9uL01hbnVhbC9GcmFtZURlYnVnZ2VyLmh0bWw=">FrameDebugger</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTE2Mzg5NTk=">https://zhuanlan.zhihu.com/p/351638959</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTYzOTczMzQ=">URP 配置 — 保姆级新手指南</span></li></ul><div class="tags"><a href="/tags/Unity3D/" rel="tag"><i class="ic i-tag"></i> Unity3D</a> <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag"><i class="ic i-tag"></i> 图形学</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag"><i class="ic i-tag"></i> 性能优化</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 笔记</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-06-11 19:16:20" itemprop="dateModified" datetime="2023-06-11T19:16:20+08:00">2023-06-11</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>WangJiaYing <i class="ic i-at"><em>@</em></i>CWHISME</li><li class="link"><strong>本文链接：</strong> <a href="https://wangjiaying.top/2023/05/12/%E5%9B%BE%E5%BD%A2%E5%9F%BA%E7%A1%80-Unity3D/" title="渲染基础 - Unity3D - 笔记">https://wangjiaying.top/2023/05/12/图形基础-Unity3D/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/05/11/%E5%AD%97%E8%8A%82%E5%8D%95%E4%BD%8D%E8%BD%AC%E6%8D%A2%E8%AE%A1%E7%AE%97/" itemprop="url" rel="prev" data-background-image="&#x2F;images&#x2F;coverimages&#x2F;large&#x2F;629d4efe1a8708add218e85f5c905497_3_2_art.webp" title="字节单位转换计算"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 理论研究</span><h3>字节单位转换计算</h3></a></div><div class="item right"><a href="/2023/05/27/Cinemachine%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" itemprop="url" rel="next" data-background-image="&#x2F;images&#x2F;coverimages&#x2F;large&#x2F;9bd9b167gy1g2qm53gpn3j21hc0u0e81.webp" title="Cinemachine文档整理翻译"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Unity3D</span><h3>Cinemachine文档整理翻译</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">硬件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gpu%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">GPU 的渲染架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#imrimmediate-mode-rendering%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8Epc%E5%B9%B3%E5%8F%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">IMR（Immediate Mode Rendering，主要用于 PC 平台）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tbrtile-based-rendering%E5%9F%BA%E4%BA%8Etile%E6%B8%B2%E6%9F%93%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">TBR（Tile-Based Rendering，基于 Tile 渲染，主要用于移动平台）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">其它</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tbdrtile-based-deferred-rendering-%E9%92%88%E5%AF%B9tbr%E5%81%9A%E4%BA%86%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96%E4%B8%BB%E8%A6%81%E6%98%AFpowervr%E5%9C%A8%E7%94%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">TBDR（Tile-Based Deferred Rendering 针对 TBR 做了进一步优化，主要是 PowerVR 在用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mrtmulti-render-targets"><span class="toc-number">2.1.4.</span> <span class="toc-text">MRT(Multi Render Targets)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#early-z"><span class="toc-number">2.2.</span> <span class="toc-text">Early-Z</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.3.</span> <span class="toc-text">渲染顺序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E7%8A%B6%E6%80%81"><span class="toc-number">3.</span> <span class="toc-text">性能状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#drawcall"><span class="toc-number">3.1.</span> <span class="toc-text">DrawCall</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setpasscall"><span class="toc-number">3.2.</span> <span class="toc-text">SetPassCall</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%8D%E4%BD%8E-cpu-%E6%B8%B2%E6%9F%93%E6%88%90%E6%9C%AC"><span class="toc-number">3.3.</span> <span class="toc-text">降低 CPU 渲染成本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%8D%E4%BD%8E-gpu-%E6%B8%B2%E6%9F%93%E6%B6%88%E8%80%97"><span class="toc-number">3.4.</span> <span class="toc-text">降低 GPU 渲染消耗</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">批处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86static-batching"><span class="toc-number">4.1.</span> <span class="toc-text">静态批处理 (Static batching)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86dynamic-batching"><span class="toc-number">4.2.</span> <span class="toc-text">动态批处理 (Dynamic batching)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%90%88%E6%89%B9"><span class="toc-number">4.3.</span> <span class="toc-text">手动合批</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpu-instancing"><span class="toc-number">4.4.</span> <span class="toc-text">GPU instancing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#api"><span class="toc-number">4.4.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">4.4.2.</span> <span class="toc-text">兼容性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#srp-batcher"><span class="toc-number">4.5.</span> <span class="toc-text">SRP Batcher</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.5.1.</span> <span class="toc-text">工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#batchrenderergroupbrg"><span class="toc-number">4.6.</span> <span class="toc-text">BatchRendererGroup(BRG)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.6.1.</span> <span class="toc-text">使用步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dots-instancing"><span class="toc-number">4.7.</span> <span class="toc-text">DOTS Instancing</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%89%E7%85%A7"><span class="toc-number">5.</span> <span class="toc-text">光照</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1"><span class="toc-number">5.1.</span> <span class="toc-text">阴影</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cascaded-shadow-mapscsm"><span class="toc-number">5.1.1.</span> <span class="toc-text">Cascaded Shadow Maps(CSM)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bias"><span class="toc-number">5.1.2.</span> <span class="toc-text">Bias</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">渲染方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93forwardpass"><span class="toc-number">6.1.</span> <span class="toc-text">前向渲染 (ForwardPass)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F-2"><span class="toc-number">6.1.1.</span> <span class="toc-text">渲染方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E5%AE%9E%E6%97%B6%E5%89%94%E9%99%A4"><span class="toc-number">6.1.2.</span> <span class="toc-text">前向实时剔除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E7%85%A7-2"><span class="toc-number">6.1.3.</span> <span class="toc-text">光照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1forward"><span class="toc-number">6.1.4.</span> <span class="toc-text">阴影 (Forward)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93deferred"><span class="toc-number">6.2.</span> <span class="toc-text">延迟渲染 (Deferred)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E4%B8%8E%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84%E6%AF%94%E8%BE%83"><span class="toc-number">6.2.1.</span> <span class="toc-text">前向与延迟渲染路径比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#forward-%E6%B8%B2%E6%9F%93"><span class="toc-number">6.3.</span> <span class="toc-text">Forward+ 渲染</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">后期处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%97%E9%94%AF%E9%BD%BF"><span class="toc-number">7.1.</span> <span class="toc-text">抗锯齿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E6%95%88%E6%9E%9C"><span class="toc-number">7.2.</span> <span class="toc-text">屏幕效果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E8%B0%83%E8%AF%95"><span class="toc-number">9.</span> <span class="toc-text">渲染调试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E5%AE%83-2"><span class="toc-number">10.</span> <span class="toc-text">其它</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.1.</span> <span class="toc-text">模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB"><span class="toc-number">10.2.</span> <span class="toc-text">动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#urp"><span class="toc-number">10.3.</span> <span class="toc-text">URP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="toc-number">11.</span> <span class="toc-text">参考文档</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2015/12/09/Unity3D-%E9%80%9A%E8%BF%87%E5%8A%A8%E7%94%BB%E4%BA%8B%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%84%9A%E5%8D%B0/" rel="bookmark" title="Unity3D 通过动画事件实现游戏脚印">Unity3D 通过动画事件实现游戏脚印</a></li><li><a href="/2015/12/29/%E5%B5%8C%E5%A5%97Prefab%E7%9A%84Editor%E5%8A%9F%E8%83%BD/" rel="bookmark" title="嵌套Prefab的Editor功能">嵌套Prefab的Editor功能</a></li><li><a href="/2016/04/19/%E5%9C%A8Unity%E4%B8%AD%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BAMesh/" rel="bookmark" title="在Unity中动态创建Mesh">在Unity中动态创建Mesh</a></li><li><a href="/2016/04/23/%E5%9C%A8Unity%E4%B8%AD%E5%8A%A8%E6%80%81%E6%94%B9%E5%8F%98Mesh/" rel="bookmark" title="在Unity中动态改变Mesh">在Unity中动态改变Mesh</a></li><li><a href="/2016/05/31/Unity3D%E4%B8%ADShader%E7%9A%84%E9%98%B4%E5%BD%B1/" rel="bookmark" title="Unity3D中Shader的阴影">Unity3D中Shader的阴影</a></li><li><a href="/2016/07/01/%E6%A0%B9%E6%8D%AE%E5%9C%B0%E5%BD%A2%E8%B4%B4%E5%9B%BE%E5%AE%9E%E7%8E%B0%E8%84%9A%E5%8D%B0%E5%8F%8A%E7%9B%B8%E5%BA%94%E6%95%88%E6%9E%9C/" rel="bookmark" title="根据所在地形贴图实现脚印等效果">根据所在地形贴图实现脚印等效果</a></li><li><a href="/2016/08/13/%E4%BD%9C%E5%93%81-CryStoryEditor/" rel="bookmark" title="CryStoryEditor">CryStoryEditor</a></li><li><a href="/2016/08/13/%E4%BD%9C%E5%93%81-%E5%B7%A5%E4%BD%9C%E4%B9%8B%E5%89%8D/" rel="bookmark" title="[Demo]工作之前">[Demo]工作之前</a></li><li><a href="/2016/10/29/%E4%BD%9C%E5%93%81-CryDialogSystem/" rel="bookmark" title="CryDialogSystem与设计原因">CryDialogSystem与设计原因</a></li><li><a href="/2016/11/04/Shader-%E5%83%8F%E7%B4%A0%E6%89%AD%E6%9B%B2%E6%95%88%E6%9E%9C/" rel="bookmark" title="[Shader]像素扭曲效果">[Shader]像素扭曲效果</a></li><li><a href="/2016/11/17/Unity3D%E8%B5%84%E6%BA%90%E5%BC%95%E7%94%A8%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/" rel="bookmark" title="Unity3D资源引用查询工具">Unity3D资源引用查询工具</a></li><li><a href="/2016/11/21/Unity3D-Tri-planar-Terrain/" rel="bookmark" title="Unity3D Tri-planar Terrain">Unity3D Tri-planar Terrain</a></li><li><a href="/2016/12/15/Tri-planar-Terrain-%E4%BA%8C-%E9%94%99%E8%AF%AF%E4%BF%AE%E6%AD%A3/" rel="bookmark" title="Tri-planar Terrain (二) 错误修正">Tri-planar Terrain (二) 错误修正</a></li><li><a href="/2017/02/10/%E4%BD%9C%E5%93%81-Magic-Civilizition/" rel="bookmark" title="[Demo]Magic Civilizition">[Demo]Magic Civilizition</a></li><li><a href="/2017/02/14/%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%9C%E5%BC%8A%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/" rel="bookmark" title="【工具】控制台类型的作弊系统实现">【工具】控制台类型的作弊系统实现</a></li><li><a href="/2017/03/09/2017-3-9-Unity-Optimization-Summary/" rel="bookmark" title="Unity3D性能优化总结">Unity3D性能优化总结</a></li><li><a href="/2017/05/07/2017-5-7-Unity-use-othographic-camera-map/" rel="bookmark" title="Unity3D以正交相机截取作大地图">Unity3D以正交相机截取作大地图</a></li><li><a href="/2017/05/10/2017-5-10-Unity-Kinect/" rel="bookmark" title="Unity Kinect 开发">Unity Kinect 开发</a></li><li><a href="/2021/01/26/Unity3DSahder%E5%85%B3%E9%94%AE%E5%AD%97/" rel="bookmark" title="Unity3D Sahder 关键字">Unity3D Sahder 关键字</a></li><li><a href="/2021/02/02/Sahder%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/" rel="bookmark" title="Sahder内置函数">Sahder内置函数</a></li><li><a href="/2021/03/10/Sahder%E4%B8%AD%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%8F%8A%E5%BA%94%E7%94%A8/" rel="bookmark" title="Unity3D中Sahder深度图及应用">Unity3D中Sahder深度图及应用</a></li><li><a href="/2021/07/08/Box2DSharp%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/" rel="bookmark" title="Box2DSharp的介绍与使用">Box2DSharp的介绍与使用</a></li><li><a href="/2021/07/15/%E4%BD%BF%E7%94%A8VS2019%E8%B0%83%E8%AF%95Unity2020%E4%B8%ADDLL%E9%97%AE%E9%A2%98/" rel="bookmark" title="使用VS2019调试Unity2020中DLL的问题">使用VS2019调试Unity2020中DLL的问题</a></li><li><a href="/2021/07/23/%E3%80%8E%E9%94%81%E3%80%8F%E5%B8%A7%E5%90%8C%E6%AD%A5%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/" rel="bookmark" title="『锁』帧同步的简单实现">『锁』帧同步的简单实现</a></li><li><a href="/2021/07/28/%E4%BD%BF%E7%94%A8MagicCloth%E5%81%9A%E8%A1%A3%E7%89%A9%E6%88%96%E5%A4%B4%E5%8F%91%E7%89%A9%E7%90%86%E6%95%88%E6%9E%9C/" rel="bookmark" title="使用MagicCloth做衣物或头发物理效果">使用MagicCloth做衣物或头发物理效果</a></li><li><a href="/2021/08/06/%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8TexturePacker%E6%89%93%E5%9B%BE%E9%9B%86%E5%B9%B6%E7%94%9F%E6%88%90%E5%8A%A8%E7%94%BB/" rel="bookmark" title="代码调用TexturePacker打图集并生成动画">代码调用TexturePacker打图集并生成动画</a></li><li><a href="/2021/09/15/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/" rel="bookmark" title="项目中资源打包流程">项目中资源打包流程</a></li><li><a href="/2021/09/28/%E5%85%B3%E4%BA%8EInjectFix%E4%BD%9C%E4%B8%BA%E7%83%AD%E6%9B%B4%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95/" rel="bookmark" title="关于InjectFix作为热更的一点记录">关于InjectFix作为热更的一点记录</a></li><li><a href="/2021/10/25/%E4%B8%8A%E6%9E%B6%E6%A3%80%E6%B5%8B%E6%8F%90%E7%A4%BA%E6%9C%89Unity%E5%B9%BF%E5%91%8A%E6%9C%8D%E5%8A%A1/" rel="bookmark" title="上架检测提示有Unity广告服务">上架检测提示有Unity广告服务</a></li><li><a href="/2022/06/14/%E6%96%B0%E5%87%BA%E7%9A%84Huatuo%E7%83%AD%E6%9B%B4%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%9D%E8%AF%95/" rel="bookmark" title="新出的Huatuo热更的一点尝试">新出的Huatuo热更的一点尝试</a></li><li><a href="/2022/07/20/%E5%85%B3%E4%BA%8E%E6%B1%89%E5%AE%A4%E5%A4%8D%E5%85%B4%E5%8D%87%E7%BA%A7Unity2021%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" rel="bookmark" title="关于汉室复兴升级Unity2021的问题记录">关于汉室复兴升级Unity2021的问题记录</a></li><li><a href="/2022/07/21/%E5%A4%84%E7%90%86Unity2019%E7%9A%84UGUI%E9%A1%B6%E7%82%B9%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E9%97%AE%E9%A2%98/" rel="bookmark" title="处理Unity2019的UGUI顶点数据更新后的图文混排问题">处理Unity2019的UGUI顶点数据更新后的图文混排问题</a></li><li><a href="/2022/08/31/%E5%85%B3%E4%BA%8E%E4%BB%8EUnity2021%E9%99%8D%E7%BA%A7%E4%B8%BAUnity2018%E7%9A%84%E9%97%AE%E9%A2%98/" rel="bookmark" title="关于从Unity2021降级为Unity2018的问题">关于从Unity2021降级为Unity2018的问题</a></li><li><a href="/2022/09/28/%E8%A7%A3%E5%86%B3%E5%AE%88%E6%9C%9B%E9%A1%B9%E7%9B%AE%E5%88%98%E6%B5%B7%E5%B1%8F%E7%9C%9F%E6%9C%BA%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" rel="bookmark" title="解决守望项目刘海屏真机白屏问题记录">解决守望项目刘海屏真机白屏问题记录</a></li><li><a href="/2022/09/30/%E5%85%B3%E4%BA%8E%E7%BA%AA%E5%85%83%E9%A1%B9%E7%9B%AEDemo/" rel="bookmark" title="关于纪元项目Demo">关于纪元项目Demo</a></li><li><a href="/2022/10/26/%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E6%A0%BC%E5%BC%8F%E8%AE%BE%E7%BD%AE%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%BB%E7%BB%93/" rel="bookmark" title="图片资源格式设置测试与总结">图片资源格式设置测试与总结</a></li><li><a href="/2022/11/08/%E9%9F%B3%E6%95%88%E8%B5%84%E6%BA%90%E8%AE%BE%E7%BD%AE%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%BB%E7%BB%93/" rel="bookmark" title="音效资源设置测试与总结">音效资源设置测试与总结</a></li><li><a href="/2022/11/23/%E6%89%93%E5%8C%85AssetBundle%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86/" rel="bookmark" title="打包 AssetBundle 的基础规则整理">打包 AssetBundle 的基础规则整理</a></li><li><a href="/2022/12/06/Unity%E7%9A%84%E9%98%B4%E5%BD%B1%E4%B8%8E%E5%85%89%E7%85%A7%E7%83%98%E7%84%99/" rel="bookmark" title="Unity 的阴影与光照烘焙">Unity 的阴影与光照烘焙</a></li><li><a href="/2022/12/28/%E6%B5%85%E8%B0%88Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="浅谈Unity内存管理-笔记">浅谈Unity内存管理-笔记</a></li><li><a href="/2022/12/28/%E6%8F%AD%E7%A7%98Unity%E7%9A%84%E9%BB%91%E7%9B%92%E4%B8%96%E7%95%8C-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="揭秘Unity的黑盒世界-笔记">揭秘Unity的黑盒世界-笔记</a></li><li><a href="/2022/12/30/Mesh%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E4%B8%8E%E6%89%B9%E5%A4%84%E7%90%86/" rel="bookmark" title="Mesh渲染优化与批处理">Mesh渲染优化与批处理</a></li><li><a href="/2023/02/17/%E5%85%B3%E4%BA%8EAssetBundleManifest%E4%BD%BF%E7%94%A8/" rel="bookmark" title="关于AssetBundleManifest使用疑问">关于AssetBundleManifest使用疑问</a></li><li><a href="/2023/02/24/%E5%86%8D%E6%8E%A2TexturePacker%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%BE%E7%BD%AE/" rel="bookmark" title="再探TexturePacker命令行设置">再探TexturePacker命令行设置</a></li><li><a href="/2023/04/27/CS%E4%B8%8EXLua%E4%BA%A4%E4%BA%92%E5%8E%9F%E7%90%86%E7%A0%94%E7%A9%B6/" rel="bookmark" title="C#与XLua交互原理研究">C#与XLua交互原理研究</a></li><li class="active"><a href="/2023/05/12/%E5%9B%BE%E5%BD%A2%E5%9F%BA%E7%A1%80-Unity3D/" rel="bookmark" title="渲染基础-Unity3D-笔记">渲染基础-Unity3D-笔记</a></li><li><a href="/2023/05/27/Cinemachine%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" rel="bookmark" title="Cinemachine文档整理翻译">Cinemachine文档整理翻译</a></li><li><a href="/2023/05/29/DOTS1-0-Metaverse%E5%A4%A7%E8%A1%8D%E7%A5%9E%E5%90%9B%E7%B3%BB%E5%88%97-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="DOTS1.0(Metaverse大衍神君系列)-笔记">DOTS1.0(Metaverse大衍神君系列)-笔记</a></li><li><a href="/2023/06/09/Timeline%E6%95%B4%E7%90%86%E7%BF%BB%E8%AF%91/" rel="bookmark" title="Timeline 整理翻译笔记">Timeline 整理翻译笔记</a></li><li><a href="/2023/06/16/Unity3DAssets-ResourcesAndAssetBundles-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="Assets、Resources 和 AssetBundles-翻译-笔记">Assets、Resources 和 AssetBundles-翻译-笔记</a></li><li><a href="/2023/07/10/Addressables-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="Unity Addressables 笔记">Unity Addressables 笔记</a></li><li><a href="/2023/11/18/JobSystem%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" rel="bookmark" title="JobSystem 的简单使用">JobSystem 的简单使用</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="WangJiaYing" data-src="/images/../img/avator"><p class="name" itemprop="name">CWHISME</p><div class="description" itemprop="description">己所不欲，勿施于人</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">127</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">24</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">35</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N3aGlzbWU=" title="https:&#x2F;&#x2F;github.com&#x2F;cwhisme"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9jd2hpc21lLTMzL3Bvc3Rz" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;cwhisme-33&#x2F;posts"><i class="ic i-zhihu"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmN3aGlzbWVAMTI2LmNvbQ==" title="mailto:cwhisme@126.com"><i class="ic i-envelope"></i></span> <a href="/atom.xml" title="&#x2F;atom.xml" class="item feedback"><i class="ic i-heart"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-clock"></i>统计</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/05/11/%E5%AD%97%E8%8A%82%E5%8D%95%E4%BD%8D%E8%BD%AC%E6%8D%A2%E8%AE%A1%E7%AE%97/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/05/27/Cinemachine%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="分类于 阅读笔记">阅读笔记</a></div><span><a href="/2023/06/26/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-2/" title="《.NET内存管理宝典》-笔记(2)">《.NET内存管理宝典》-笔记(2)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%90%86%E8%AE%BA%E7%A0%94%E7%A9%B6/" title="分类于 理论研究">理论研究</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%90%86%E8%AE%BA%E7%A0%94%E7%A9%B6/C/" title="分类于 C#">C#</a></div><span><a href="/2022/11/18/StringBuilder%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E7%A0%94%E7%A9%B6/" title="StringBuilder 扩容规则研究">StringBuilder 扩容规则研究</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%90%86%E8%AE%BA%E7%A0%94%E7%A9%B6/" title="分类于 理论研究">理论研究</a></div><span><a href="/2017/02/20/%E6%8A%95%E5%BD%B1%E5%85%AC%E5%BC%8F%E7%9A%84%E6%8E%A8%E5%AF%BC/" title="投影公式的推导">投影公式的推导</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment count_3"></ul></div></div><div class="status"><div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">WangJiaYing @ Jiaying's Note</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">747k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">11:19</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NXSElTTUUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/05/12/图形基础-Unity3D/",favicon:{show:"（●´3｀●）",hide:"(´Д｀)"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,justifiedGallery:!0,jquery:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script><script src="https://cdn.staticfile.org/pjax/0.2.8/pjax.min.js"></script><script src="https://cdn.staticfile.net/animejs/3.2.2/anime.min.js"></script><script src="https://cdn.staticfile.org/algoliasearch/4.17.0/algoliasearch-lite.umd.js"></script><script src="https://cdn.staticfile.org/instantsearch.js/4.54.1/instantsearch.production.min.js"></script><script src="https://cdn.staticfile.org/lozad.js/1.16.0/lozad.min.js"></script><script src="https://cdn.staticfile.org/quicklink/2.3.0/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/js/DateTimeAfeterCalc.js" async></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js" async></script></body></html>