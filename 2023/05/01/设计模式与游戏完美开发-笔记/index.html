<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="CWHISME" href="https://wangjiaying.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="CWHISME" href="https://wangjiaying.top/atom.xml"><link rel="alternate" type="application/json" title="CWHISME" href="https://wangjiaying.top/feed.json"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="笔记"><link rel="canonical" href="https://wangjiaying.top/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%AE%8C%E7%BE%8E%E5%BC%80%E5%8F%91-%E7%AC%94%E8%AE%B0/"><title>《设计模式与游戏完美开发》- 笔记 - 阅读笔记 | Jiaying's Note = CWHISME = 人不能没有梦想，也要有足够的敬畏</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">《设计模式与游戏完美开发》- 笔记</h1><div class="meta"><span class="item" title="创建时间：2023-05-01 16:56:13"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-05-01T16:56:13+08:00">2023-05-01</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>5.6k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>5 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiaying's Note</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="/images/coverimages/large/99038048_p0.webp"></li><li class="item" data-background-image="/images/coverimages/large/102799587_p0.webp"></li><li class="item" data-background-image="/images/coverimages/large/6833939bly1gipevarprfj20zk0m8npd.webp"></li><li class="item" data-background-image="/images/coverimages/large/79834784_p0.webp"></li><li class="item" data-background-image="/images/coverimages/large/86404256_p0.webp"></li><li class="item" data-background-image="/images/coverimages/large/acg40.webp"></li></ul></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" itemprop="item" rel="index" title="分类于 阅读笔记"><span itemprop="name">阅读笔记</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangjiaying.top/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%AE%8C%E7%BE%8E%E5%BC%80%E5%8F%91-%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/../img/avator"><meta itemprop="name" content="WangJiaYing"><meta itemprop="description" content="人不能没有梦想，也要有足够的敬畏, 己所不欲，勿施于人"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="CWHISME"></span><div class="body md" itemprop="articleBody"><h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>这本书是紧接着《CLR VIR C#》 开始的，依然是回家的时候看，顺便在手机语雀上记笔记：</p><p><img data-src="/blogimages/2023/2023-05-01/Snipaste_2023-05-01_17-07-25.png" alt=""></p><p>今天是 2023 年 5 月 1 日<br>也算是过了一遍了，这本书其实不是很厚 —— 至少跟 《CLR VIR C#》 相比就薄多了，也花了差不多一个月，主要是因为每周加两天班变成了常驻，另外还在追 DOTS1.0 的教程，导致时间上更短了。<br>这两天五一放假 (实际上前一天 28 号就提前请假了)，然后回来从责任链模式继续看，认真专心点，还是挺快的。</p><p>本文总结的主要是部分重要的理论描述，—— 文字上的，毕竟是手机记录。很多重要概念的还是得结合代码。</p><h1 id="简介"><a class="anchor" href="#简介">#</a> 简介</h1><ul><li>Gof：《设计模式》一书由四人合著（Gang of Four），代表 23 种设计模式</li><li>23 种设计模式可分为三大类<ul><li>生成模式（creational）<ul><li>产生对象的过程及方式</li></ul></li><li>结构模式（structural）<ul><li>类或对象之间组合的方式</li></ul></li><li>行为模式（behavioral）<ul><li>类或对象之间互动或责任分配的方式</li></ul></li></ul></li><li>六大设计原则<ul><li>开闭原则</li><li>里氏替换原则</li><li>依赖倒置原则</li><li>单一职责原则</li><li>迪米特法则</li><li>接口隔离原则</li><li>合成复用原则（六大原则有七个是常识对吧？）</li></ul></li></ul><h1 id="设计模式"><a class="anchor" href="#设计模式">#</a> 设计模式</h1><h1 id="状态模式state"><a class="anchor" href="#状态模式state">#</a> 状态模式（state）</h1><p>让一个对象的行为随着内部状态的改变而变化，而该对象也像是换了类一样</p><ul><li>当某个对象状态改变时，虽然其『表现的行为』会有所变化，但对于其它对象来说，并不会因为这样的变化而改变对它的『操作方法』或『信息沟通』的方式</li><li>即对象与外界的对应方式不会发生改变，一切只发生在对象内部</li><li>例子：场景管理</li><li>其它应用<ul><li>角色 AI</li><li>服务器连接状态</li><li>关卡进行状态</li><li>等</li></ul></li></ul><h1 id="单例模式singleton"><a class="anchor" href="#单例模式singleton">#</a> 单例模式（singleton）</h1><p>『确认类只有一个对象，并提供一个全局的方法来获取这个对象』<br>生活中许多物品都是唯一的：地球是唯一的、太阳是唯一的 等</p><ul><li>同时只存在一个对象</li><li>提供一个快速获取这个对象的方法</li></ul><p>哪些系统类适合以单例模式实现，需要精挑细选<br>缺点：</p><ul><li>不必为 如何传递对象、设置对象引用 而进行过多考虑，容易造成『单例癖』，过于沉迷单例模式带来的直接访问好处，导致设计思考不周，造成单例滥用</li><li>单例模式违反了 开闭原则，因为获取的是直接实现类</li><li>单例出现继承，出现 白马非马 问题</li></ul><h1 id="外观模式facade"><a class="anchor" href="#外观模式facade">#</a> 外观模式（facade）</h1><p>为子系统定义一组统一的接口，这个高级接口会让子系统更容易被使用</p><ul><li>以简单的行为操作复杂的接口，所使用的接口就是以外观模式定义的高级接口</li><li>重点在于，能将系统内部的互动细节隐藏起来，并提供一个简单方便的接口</li><li>优点<ul><li>减少耦合度、易于分工开发、增加系统安全性</li><li>随着开发需求变更，任何子系统的修改都被限制在系统内部</li></ul></li><li>注意<ul><li>由于将所有子系统集中于外观模式接口类中，会导致该类变得过于庞大，因此可以继续拆分</li></ul></li></ul><h1 id="中介者模式mediator"><a class="anchor" href="#中介者模式mediator">#</a> 中介者模式（mediator）</h1><p>定义一个接口用来封装一群对象的互动行为，中介者通过移除对象之间的引用，减少它们之间的耦合度，并能改变它们之间的互动独立性</p><ul><li>每一个系统除了会引用与之相关的类型外，无论是对信息获取或传递，都只通过中介者完成</li><li>这使得每一个系统对外依赖度缩小到只有一个类</li></ul><p>注意：</p><ul><li>避免担任过多中介者角色而出现 操作接口爆炸 的情况</li><li>可以搭配其它设计模式：如观察者模式</li></ul><p>其它应用：</p><ul><li>网络引擎，如通过中介者沟通，方便更换 tcp 或 udp 等连接方式</li></ul><h1 id="gameloop"><a class="anchor" href="#gameloop">#</a> GameLoop</h1><p>不继承 Monobehavior ，自己控制更新逻辑，包括游戏更新的时间点和方式</p><h1 id="桥接模式bridge"><a class="anchor" href="#桥接模式bridge">#</a> 桥接模式（Bridge）</h1><p>将抽象与实现分离，使二者可以独立地变化<br>注：并非 『依赖倒置原则』的另一个解释：定义一个接口类，然后将实现部分在子类完成<br>可以将两个群组有效分离，让两个群组彼此互不影响<br>如：</p><ul><li>角色 (不同角色) 与武器 (不同武器)</li><li>渲染引擎（不同渲染图形，不同平台选择 dx、opengl 等）</li></ul><h1 id="策略模式strategy"><a class="anchor" href="#策略模式strategy">#</a> 策略模式（Strategy）</h1><ul><li>将复杂的公式独立出来成为一个群组，之后可以按情况来决定使用的计算公式策略，提高了系统应用的灵活程度</li><li>由一群没有任何关系的类所组成，不知彼此的存在</li><li>是由封装计算算法而形成的一种设计模式，算法之间不存在任何依赖关系，有新增算法可以马上加入或替换</li><li>应用：<ul><li>属性系统</li><li>熟练度系统</li><li>登录策略</li></ul></li></ul><h1 id="模板方法模式template-method"><a class="anchor" href="#模板方法模式template-method">#</a> 模板方法模式（template method）</h1><p>在一个操作方法中定义算法流程，其中某些步骤由子类完成，模板方法模式让子类在不变更原有算法流程的情况下，还能重新定义其中步骤</p><ul><li>定义算法流程中，某些步骤需要由执行时 『当下环境』来决定</li><li>定义算法的流程中，针对每个步骤都提供了预设方案，但有时这个步骤中处理会出现『更好的解决方法』</li><li>优点：将可能出现重复的 算法流程 ，从子类提升到父类中，减少重复的发生，并且也开发了子类参与算法中各个步骤的执行或优化</li><li>注意：开放流程的平衡，开放太多并要求子类全部实现，反而造成困难</li><li>应用：<ul><li>登录流程</li><li>RPG 释放法术流程</li><li>释放技能流程</li><li>攻击流程</li></ul></li></ul><h1 id="工厂方法模式factory-method"><a class="anchor" href="#工厂方法模式factory-method">#</a> 工厂方法模式（factory method）</h1><p>定义一个可以产生对象的接口，但是让子类决定要产生哪一个类的对象。工厂方法模式让类的实例化程序延迟到子类中实施<br>将类产生流程集合管理的模式</p><ul><li>能针对对象产生流程制定规则</li><li>减少客户端参与对象生成过程，尤其是对象生产过程比较复杂的，降低生产耦合</li></ul><p>C# 支持泛型，泛型工厂比较方便<br>优点：将类群组对象的产生流程整合于同一个类下实现，并提供唯一的工厂方法，让项目内 对象产生流程 更加独立</p><ul><li>不过，类群组过多时，无论使用哪种方式，都存在工厂子类爆量或 switch case 语句过长问题</li></ul><p>应用：</p><ul><li>UI 管理器</li><li>角色工厂</li><li>资源加载工厂<ul><li>真机资源加载与编辑器资源加载方式</li></ul></li><li>武器工厂</li><li>属性生产工厂</li><li>当产生对象时，需要<ul><li>复杂的流程</li><li>需要加载外部资源</li><li>有对象上限或管理</li><li>可重复使用</li><li>就可以考虑采用工厂方法模式，将对象产生及相关初始化集中在一个地方，让对象的产生与管理更有效率</li></ul></li></ul><h1 id="建造者模式builder"><a class="anchor" href="#建造者模式builder">#</a> 建造者模式（builder）</h1><p>『将一个复杂对象的构建流程与它的对象表现分离出来，让相同的构建流程可以产生不同的对象行为表现』<br>工厂方法模式将生产对象全部集中管理，为了使生产对象过程更有效率和弹性，通常可以搭配建造者模式</p><ul><li>将复杂的构建流程独立出来，并将整个流程分成几个步骤，其中每个步骤可以是一个功能组件的设置，也可以是参数指定，并在一个构建方法中讲这些步骤串接起来</li><li>定义一个专门实现这些步骤的实现者，这些实现者知道如何完成每一部分，并能接受参数决定要产出功能，但不知道整个流程要组装的是什么</li><li>主要：流程分析安排、功能分开实现</li></ul><h1 id="享元模式flyweight"><a class="anchor" href="#享元模式flyweight">#</a> 享元模式（flyweight）</h1><p>『使用共享的方式，让一大群小规模对象能更有效地运行』</p><ul><li>享元模式用来解决 大量且重复对象 的管理问题，特别是 虽小却大量重复对象</li></ul><p>应用：</p><ul><li>道具属性（感觉并不合适）</li></ul><h1 id="组合模式composite"><a class="anchor" href="#组合模式composite">#</a> 组合模式（composite）</h1><p>『将对象以树状结构组合，用以表现部分 - 全体的层次关系，让客户端在操作各个对象或组合对象时是一致的』</p><h1 id="命令模式command"><a class="anchor" href="#命令模式command">#</a> 命令模式（command）</h1><p>『将请求封装成为对象，让你可以将客户端的不同请求参数化，并配合队列、记录、复原等方法来执行请求的操作』</p><ul><li>请求的封装<ul><li>封装参数，亦可封装执行</li></ul></li><li>请求的操作<ul><li>存储：排序、排队、移动、删除、暂缓执行等</li><li>记录：可记录已执行记录，查看过去执行流程和轨迹</li><li>复原：若请求执行了反向操作，则可将已执行请求复原</li></ul></li></ul><p>可以独立排队执行<br>注意：使用命令模式也要注意情况，例如是否需要排队执行、命令被对象化后，是否对其还有管理需求。<br>其它应用</p><ul><li>网络 client/server 数据传递，侧重执行与记录</li></ul><h1 id="责任链模式chain-of-responsibility"><a class="anchor" href="#责任链模式chain-of-responsibility">#</a> 责任链模式（chain of responsibility）</h1><p>『让一群对象都有机会来处理一项请求，以减少请求发送者与接收者之间的耦合度。将所有的接收者对象串联起来，让请求沿着串接传递，直到有一个对象可以处理为止』</p><ul><li>可以解决请求的接收者对象，能够了解请求并判断自身能否解决</li><li>接收者对象的串联：将每一个可能解决问题的接收者串接，对于被串接的接收者来说，若判断自身无法解决，则利用串接机制传递请求给下一个</li><li>请求自动转移：发出请求后，请求会自动往下转移传递，不需要发送者特别转换</li></ul><p>注：</p><ul><li>责任链模式根据需求，其实也可以不必从头开始判断</li><li>该模式让信息判断上有一致的操作接口，不必因不同接收者而执行 类转换操作</li><li>让所有信息接收者都有机会可以判断是否提供服务或将需求转为下一个，对后续系统修改维护也有利</li></ul><h1 id="观察者模式observer"><a class="anchor" href="#观察者模式observer">#</a> 观察者模式（observer）</h1><p>『在对象之间定义一个一对多的连接方法，当一个对象变换状态时，其它关联对象都会自动收到通知』<br>观察者模式与命令模式相似，都是希望 『事件发生』与『功能执行』之间不要有太多依赖<br>例如：</p><ul><li>社交软件上的 关注 功能</li><li>早期的 报社 - 订阅</li></ul><p>信息的 『推』 与 『拉』<br>主题（subject）改变时，改变内容如何让观察者（observer）得知，运行方式分为两种：</p><ul><li>推（push）：主题将变动内容主动 “推” 给观察者。一般在调用观察者进行通知时，同时将更新内容当做参数传递给观察者。<ul><li>优点：省去观察者再向主题查询操作，主题也不需要定义额太多额外接口供查询调用</li><li>缺点：如果推送内容过多，容易使观察者收到不必要信息或造成查询困难，也可能降低系统性能</li></ul></li><li>拉（pull）：主题变动时，只是先通知观察者当前内容已发生变动，观察者按照系统需求，再向主题查询所需信息<ul><li>优点：观察者更知道自己需要哪些信息，避免获取到不必要的冗余信息</li><li>缺点：主题必须提供查询方式，容易造成主题接口方法过多</li></ul></li></ul><p>一般为字典，key 为枚举或整型，value 为一个观察者类，或直接是个回调。<br>采用观察者类的方式，可能造成过多观察者类，因此采用回调可以更有效减少类的产生。<br>其它应用：</p><ul><li>机关</li><li>剧情触发</li></ul><h1 id="备忘录模式memento"><a class="anchor" href="#备忘录模式memento">#</a> 备忘录模式（memento）</h1><p>『在不违反封装的原则下，获取一个对象内部状态并保留在外部，让该对象可以在日后恢复到原先保留时的状态』<br>接口隔离原则 (isp)：除非必要，否则类应该尽量减少对外显示的内部数据结构，减少对外公布的操作方法</p><ul><li>为了不违背封装的原则，其数据由类主动提供</li><li>即让有记录保存需求的类，自行产生要保存的数据，外界完全不用了解这些记录产生的过程和来源</li></ul><h1 id="访问者模式visitor"><a class="anchor" href="#访问者模式visitor">#</a> 访问者模式（visitor）</h1><p>『定义一个能够在一个对象结构中对所有元素执行的操作，访问者让你可以定义一个新的操作，而不必更改到被操作元素的类接口』<br>重点：定义一个新的操作，而不必更改到被操作元素的类接口<br>优点</p><ul><li>新增功能只需要实现新的访问者</li><li>增加系统稳定性，减少对类接口不必要修改</li></ul><p>缺点</p><ul><li>被访问者封装性变差：因为需要尽可能提供所有可能的操作和信息</li></ul><p>其它应用</p><ul><li>需要使用 遍历所有对象 的功能</li><li>道具包</li><li>可使用角色</li></ul><h1 id="装饰模式decorator"><a class="anchor" href="#装饰模式decorator">#</a> 装饰模式（decorator）</h1><p>『动态地附加额外的责任给一个对象，装饰模式提供了一个灵活的选择，让子类可以用来扩展功能』<br>装饰模式具有很高的灵活度和透明性，可以一直不断地包覆下去<br>应用：</p><ul><li>属性前缀、后缀</li><li>网络协议加密</li><li>等</li></ul><p>优点在于不必更改太多现有实现类就能完成功能强化<br>注：适用于 目标已经存在，而装饰需求之后 出现的情况，不应滥用，过多装饰堆砌也会增加复杂度。</p><h1 id="适配器模式adapter"><a class="anchor" href="#适配器模式adapter">#</a> 适配器模式（adapter）</h1><p>『将一个类的接口转换成为客户端期待的类接口。适配器模式让原本接口不兼容的类能一起合作』<br>优点：不必使用复杂的方法，就能将两个不同接口的类对象交换使用。<br>应用：</p><ul><li>第三方库隔离职责</li><li>UI 组件适配</li></ul><h1 id="代理模式proxy"><a class="anchor" href="#代理模式proxy">#</a> 代理模式（proxy）</h1><p>『提供一个代理者位置给一个对象，好让代理者可以控制存取这个对象』<br>类似装饰模式，不用之处在于：</p><ul><li>对代理模式来说，它可以选择新功能是否执行；而装饰模式则是一定会一并执行</li><li>即代理模式是按职权『有选择』是否需要将需求转交给原始类。</li><li>而装饰模式则是必须在原始类被调用之前或之后，按照自己职权『增加』原始类没有的功能</li><li>与适配器模式差异：适配器着重在于『不同实现的转换』</li></ul><p>使用场景</p><ul><li>远程代理 (remote proxy)：常见于网页浏览器中代理服务器的设置</li><li>虚拟代理 (virtual proxy)：可作为 延后加载 功能的实现，让资源可以在真正要使用时才进行加载操作，其它情况都只是虚拟代理所呈现的一个假象</li><li>保护代理 (protection proxy)：代理者有职权可以控制是否要真正取用原始对象的资源</li><li>智能引用 (smart reference)：主要用于强化 C/C++ 语言对于指针控制的功能，减少内存遗失 (memory leak) 和空指针 (null pointer) 等问题</li></ul><p>优点</p><ul><li>可判断是否要将原始类的工作交由代理者类来执行，可以免去修改原始类的接口及实现</li></ul><p>其它应用</p><ul><li>临时资源代理呈现</li><li>服务器玩家在不同地图区块信息同步</li></ul><h1 id="其它模式"><a class="anchor" href="#其它模式">#</a> 其它模式</h1><ul><li>迭代器模式<ul><li>在不知道集合内部细节的情况下，提供一个按序方法存取一个对象集合体的每一个单元</li><li>C# 已直接提供支持</li></ul></li><li>原型模式<ul><li>使用原型对象来产生指定类的对象，所以产生对象时，是使用复制原型对象来完成</li><li>例如实例化</li></ul></li><li>解释器模式<ul><li>定义一个程序设计语言所需要的语句，并提供解释来解析执行</li></ul></li><li>抽象工厂模式<ul><li>工厂方法模式：定义一个可以产生对象的接口，但是让子类决定要产生哪一个类的对象。工厂方法模式让类的实例化延迟到子类执行</li><li>抽象工厂模式：提供一个能够建立整个类群组或有关联的对象，而不必指明它们的具体类</li><li>即：例如两组继承统一抽象工厂的工厂，根据不同环境调用哪一种生成不同的两组对象</li></ul></li></ul><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>不知道为啥，作者是把 abstract 父类命名为接口，也就是说，这本书所说的接口是将继承关系的抽象父类称为接口，所以其实并没有使用语言『规则』上的『接口』。抽象类虽然可以将方法实现延迟到子类，但它是单继承且依然代表一类对象，它的子类必然还是具有父类所有成员的。</p><p>整书完整贴代码还是挺多的，也就是更多偏向于展示作者的代码，理论反而比较少，基本结构大概就是：描述《P 级阵地》需求 -&gt;（硬编码示例）-&gt; 引用 Gof 下对应设计模式的描述 -&gt; 想如何设计 -&gt; 然后代码 -&gt; 结论</p><p>要是之前没有概念、并且想从实践入手的话，可以考虑一看（可能需要多一点耐心，代码还是比较基础）<br>但也因为上面说的原因，有些代码有些冗余。例如，访问者模式下的示例，要是利用泛型就不用写那么多方法及手动调用了。<br>当然，也可能是作者是为了『更简单』描述出原理。</p><p>本书将一整个 23 种设计模式全都囊括且给出了游戏应用示例 —— 说实话，除了这一本和另一本叫《游戏编程模式》的之外，我还没见到另外以『游戏』作为设计模式讲解的书 (如果有的话，希望提醒下)</p><div class="tags"><a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 笔记</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-05-02 20:26:22" itemprop="dateModified" datetime="2023-05-02T20:26:22+08:00">2023-05-02</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>WangJiaYing <i class="ic i-at"><em>@</em></i>CWHISME</li><li class="link"><strong>本文链接：</strong> <a href="https://wangjiaying.top/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%AE%8C%E7%BE%8E%E5%BC%80%E5%8F%91-%E7%AC%94%E8%AE%B0/" title="《设计模式与游戏完美开发》- 笔记">https://wangjiaying.top/2023/05/01/设计模式与游戏完美开发-笔记/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/04/27/CS%E4%B8%8EXLua%E4%BA%A4%E4%BA%92%E5%8E%9F%E7%90%86%E7%A0%94%E7%A9%B6/" itemprop="url" rel="prev" data-background-image="&#x2F;blogimages&#x2F;2023&#x2F;2023-04-27&#x2F;image1.png" title="C#与XLua交互原理研究"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Unity3D</span><h3>C#与XLua交互原理研究</h3></a></div><div class="item right"><a href="/2023/05/11/%E5%AD%97%E8%8A%82%E5%8D%95%E4%BD%8D%E8%BD%AC%E6%8D%A2%E8%AE%A1%E7%AE%97/" itemprop="url" rel="next" data-background-image="&#x2F;images&#x2F;coverimages&#x2F;large&#x2F;94444612_p0.webp" title="字节单位转换计算"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 理论研究</span><h3>字节单位转换计算</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8Fstate"><span class="toc-number">4.</span> <span class="toc-text">状态模式（state）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8Fsingleton"><span class="toc-number">5.</span> <span class="toc-text">单例模式（singleton）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8Ffacade"><span class="toc-number">6.</span> <span class="toc-text">外观模式（facade）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8Fmediator"><span class="toc-number">7.</span> <span class="toc-text">中介者模式（mediator）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gameloop"><span class="toc-number">8.</span> <span class="toc-text">GameLoop</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8Fbridge"><span class="toc-number">9.</span> <span class="toc-text">桥接模式（Bridge）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8Fstrategy"><span class="toc-number">10.</span> <span class="toc-text">策略模式（Strategy）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8Ftemplate-method"><span class="toc-number">11.</span> <span class="toc-text">模板方法模式（template method）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8Ffactory-method"><span class="toc-number">12.</span> <span class="toc-text">工厂方法模式（factory method）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8Fbuilder"><span class="toc-number">13.</span> <span class="toc-text">建造者模式（builder）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8Fflyweight"><span class="toc-number">14.</span> <span class="toc-text">享元模式（flyweight）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8Fcomposite"><span class="toc-number">15.</span> <span class="toc-text">组合模式（composite）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8Fcommand"><span class="toc-number">16.</span> <span class="toc-text">命令模式（command）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8Fchain-of-responsibility"><span class="toc-number">17.</span> <span class="toc-text">责任链模式（chain of responsibility）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8Fobserver"><span class="toc-number">18.</span> <span class="toc-text">观察者模式（observer）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8Fmemento"><span class="toc-number">19.</span> <span class="toc-text">备忘录模式（memento）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8Fvisitor"><span class="toc-number">20.</span> <span class="toc-text">访问者模式（visitor）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8Fdecorator"><span class="toc-number">21.</span> <span class="toc-text">装饰模式（decorator）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8Fadapter"><span class="toc-number">22.</span> <span class="toc-text">适配器模式（adapter）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8Fproxy"><span class="toc-number">23.</span> <span class="toc-text">代理模式（proxy）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">24.</span> <span class="toc-text">其它模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">25.</span> <span class="toc-text">总结</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8A/" rel="bookmark" title="《CLR VIR C#》笔记(上)">《CLR VIR C#》笔记(上)</a></li><li><a href="/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="bookmark" title="《CLR VIR C#》笔记(下)-多线程">《CLR VIR C#》笔记(下)-多线程</a></li><li class="active"><a href="/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%AE%8C%E7%BE%8E%E5%BC%80%E5%8F%91-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《设计模式与游戏完美开发》-笔记">《设计模式与游戏完美开发》-笔记</a></li><li><a href="/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《数据结构与算法之美》-笔记">《数据结构与算法之美》-笔记</a></li><li><a href="/2023/06/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8_1/" rel="bookmark" title="《.NET内存管理宝典》-笔记(1)">《.NET内存管理宝典》-笔记(1)</a></li><li><a href="/2023/06/26/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-2/" rel="bookmark" title="《.NET内存管理宝典》-笔记(2)">《.NET内存管理宝典》-笔记(2)</a></li><li><a href="/2023/07/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-3/" rel="bookmark" title="《.NET内存管理宝典》-笔记(3)">《.NET内存管理宝典》-笔记(3)</a></li><li><a href="/2023/07/19/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-4/" rel="bookmark" title="《.NET内存管理宝典》-笔记(4)">《.NET内存管理宝典》-笔记(4)</a></li><li><a href="/2023/08/04/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-5/" rel="bookmark" title="《.NET内存管理宝典》-笔记(5)">《.NET内存管理宝典》-笔记(5)</a></li><li><a href="/2023/08/21/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-6-%E5%AE%8C/" rel="bookmark" title="《.NET内存管理宝典》-笔记(6)[完]">《.NET内存管理宝典》-笔记(6)[完]</a></li><li><a href="/2023/09/25/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《游戏编程模式》-笔记">《游戏编程模式》-笔记</a></li><li><a href="/2023/10/02/CPP_Primer_%E7%AC%AC%E4%BA%94%E7%89%88_%E7%AC%94%E8%AE%B0-1/" rel="bookmark" title="《C++ Primer(第五版)》-笔记(1)">《C++ Primer(第五版)》-笔记(1)</a></li><li><a href="/2023/10/22/CPP-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%AC%94%E8%AE%B0-2/" rel="bookmark" title="《C++ Primer(第五版)》-笔记(2)">《C++ Primer(第五版)》-笔记(2)</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="WangJiaYing" data-src="/images/../img/avator"><p class="name" itemprop="name">CWHISME</p><div class="description" itemprop="description">己所不欲，勿施于人</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">127</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">24</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">35</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N3aGlzbWU=" title="https:&#x2F;&#x2F;github.com&#x2F;cwhisme"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9jd2hpc21lLTMzL3Bvc3Rz" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;cwhisme-33&#x2F;posts"><i class="ic i-zhihu"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmN3aGlzbWVAMTI2LmNvbQ==" title="mailto:cwhisme@126.com"><i class="ic i-envelope"></i></span> <a href="/atom.xml" title="&#x2F;atom.xml" class="item feedback"><i class="ic i-heart"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-clock"></i>统计</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/04/27/CS%E4%B8%8EXLua%E4%BA%A4%E4%BA%92%E5%8E%9F%E7%90%86%E7%A0%94%E7%A9%B6/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/05/11/%E5%AD%97%E8%8A%82%E5%8D%95%E4%BD%8D%E8%BD%AC%E6%8D%A2%E8%AE%A1%E7%AE%97/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%9A%E5%AE%A2/" title="分类于 博客">博客</a></div><span><a href="/2023/01/01/%E5%85%B3%E4%BA%8EShoka%E5%9B%BE%E5%BA%8A%E6%8C%82%E4%BA%86%E8%BF%99%E4%BB%B6%E4%BA%8B/" title="关于Shoka图床又挂了这件事">关于Shoka图床又挂了这件事</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%90%86%E8%AE%BA%E7%A0%94%E7%A9%B6/" title="分类于 理论研究">理论研究</a></div><span><a href="/2021/04/28/Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" title="Ado.Net与EF6.X的简单使用">Ado.Net与EF6.X的简单使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="分类于 阅读笔记">阅读笔记</a></div><span><a href="/2023/06/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8_1/" title="《.NET内存管理宝典》-笔记(1)">《.NET内存管理宝典》-笔记(1)</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment count_3"></ul></div></div><div class="status"><div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">WangJiaYing @ Jiaying's Note</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">747k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">11:19</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NXSElTTUUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/05/01/设计模式与游戏完美开发-笔记/",favicon:{show:"（●´3｀●）",hide:"(´Д｀)"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,justifiedGallery:!0,jquery:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script><script src="https://cdn.staticfile.org/pjax/0.2.8/pjax.min.js"></script><script src="https://cdn.staticfile.net/animejs/3.2.2/anime.min.js"></script><script src="https://cdn.staticfile.org/algoliasearch/4.17.0/algoliasearch-lite.umd.js"></script><script src="https://cdn.staticfile.org/instantsearch.js/4.54.1/instantsearch.production.min.js"></script><script src="https://cdn.staticfile.org/lozad.js/1.16.0/lozad.min.js"></script><script src="https://cdn.staticfile.org/quicklink/2.3.0/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/js/DateTimeAfeterCalc.js" async></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js" async></script></body></html>