<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="CWHISME" href="https://wangjiaying.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="CWHISME" href="https://wangjiaying.top/atom.xml"><link rel="alternate" type="application/json" title="CWHISME" href="https://wangjiaying.top/feed.json"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="笔记"><link rel="canonical" href="https://wangjiaying.top/2023/08/21/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-6-%E5%AE%8C/"><title>《.NET 内存管理宝典》- 笔记 (6)[完] - 阅读笔记 | Jiaying's Note = CWHISME = 人不能没有梦想，也要有足够的敬畏</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">《.NET 内存管理宝典》- 笔记 (6)[完]</h1><div class="meta"><span class="item" title="创建时间：2023-08-21 09:33:55"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-08-21T09:33:55+08:00">2023-08-21</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>11k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>10 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiaying's Note</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/blogimages/2023/2023-06-26/book.webp"></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" itemprop="item" rel="index" title="分类于 阅读笔记"><span itemprop="name">阅读笔记</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangjiaying.top/2023/08/21/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-6-%E5%AE%8C/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/../img/avator"><meta itemprop="name" content="WangJiaYing"><meta itemprop="description" content="人不能没有梦想，也要有足够的敬畏, 己所不欲，勿施于人"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="CWHISME"></span><div class="body md" itemprop="articleBody"><h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本文包含原书第七章至第十五章，也就是本书最后一部分。<br>主要为对象资源释放、线程局部存储、托管指针、ref 类型、非托管类型、非托管约束、 <code>Span&lt;T&gt;</code> 、 <code>Memory&lt;T&gt;</code> 、Unsafe 类、面向数据设计 等高级主题。</p><p>这是本书的最后一份笔记，没想到整体看完这本书花了 2 月有余... 说来惭愧，这两个月花了太多时间在其它东西上去了：玩游戏，比如最近的蔚蓝档案、或者在家看 HDRP 相关的教程。<br>虽然除了玩游戏也不能说全无相关，但确实是这次没有专心看书了，导致时间线被严重拉长 —— 特别是本来每天就只有下班时间两个小时的情况下。</p><p>后面得再紧张一点了。</p><h1 id="第十二章-对象生存期"><a class="anchor" href="#第十二章-对象生存期">#</a> 第十二章 对象生存期</h1><h2 id="终结"><a class="anchor" href="#终结">#</a> 终结</h2><p>.NET 有两种终结方式：非确定性终结与确定性终结，也可以称为 隐式清除 和 显式清除</p><ul><li>析构函数</li><li>IDisposable</li></ul><p>终结机制和垃圾回收机制在概念上并没有直接关系。<br>终结器对象特点：</p><ul><li>执行时间非确定</li><li>执行顺序、及其持有的对象图只有在运行完终结器之后才能被回收</li><li>执行线程不确定</li><li>不保证终结器代码一定会执行一次 (如出错会阻塞执行线程)</li><li>在终结器引发异常会很危险 (无法执行终结器被视为最严重故障)</li><li>可终结对象对 GC 有额外开销</li></ul><p>因此，推荐显式 IDisposable 释放而非使用终结器<br>注：值类型可以有终结器，但只会在装箱实例上运行。其在 .NET Core 则直接无效。<br>调用时间点</p><ul><li>当 GC 结束时</li><li>当运行时卸载 AppDomain 和运行时终止时</li></ul><h3 id="关键终结器"><a class="anchor" href="#关键终结器">#</a> 关键终结器</h3><p>CriticalFinalizerObject<br>关键终结器是一种常规终结器，但其带有额外的保证，保证其代码一定会执行。</p><ul><li>是一个不包含实现的抽象类，只是类型系统和运行时之间的一个协议</li><li>运行时将采取一些预防措施确保在任何情况下都执行关键终结器 (如运行时会提前 jit 代码，避免后续因 out-of-memory 而无法 jit 编译和执行)</li></ul><p>(SafeHandle 继承 CriticalFinalizerObject)</p><h3 id="终结器内部实现"><a class="anchor" href="#终结器内部实现">#</a> 终结器内部实现</h3><p>GC 使用一个 finalization queue (终结器队列) 记录所有可终结对象</p><ul><li>在执行 GC 期间，GC 会在标记阶段结束后检查终结器队列，查看是否有可终结对象已死亡</li><li>若有，则将其移动到 fReachable queue (可达对象队列)，然后通知专门的终结器线程执行</li><li>终结器线程执行发生在 GC 将托管线程从挂起恢复到正常状态之后</li><li>由于引用这些对象的根已经从终结器队列移除，下一次 GC 时会最终对其执行回收：即可终结对象至少能存活到下一次 GC</li></ul><p>注 1：由于终结器线程不一定能在下一次 GC 前执行完毕，fReachable queue 在标记阶段也会被视为一个根，并导致终结器对象被提升到老一代，面临『中年危机』<br>注 2：.NET 提供一个方法 GC.WaitForPendingFunalizers ，可阻塞线程直到可达对象队列执行完毕<br>另外还有两个与终结器相关的重要 API：</p><ul><li>GC.ReRegisterForFinalize(object)</li><li>GC.SuppressFinalize (object)：设置对象标头中的一个 bit，终结器线程工作期间，不会调用此 bit 被设置过的对象的 Finalize 方法</li></ul><p>为什么需要专门的 queue 和终结器线程？</p><ul><li>终结器代码是用户的，以异步方式执行终结器代码更安全</li></ul><h3 id="终结器开销"><a class="anchor" href="#终结器开销">#</a> 终结器开销</h3><ul><li>默认情况下，分配对象时强制使用慢速分支</li><li>默认情况下，至少会让对象被提升一次，增加对象生存期</li><li>如果可终结对象分配速度快于被终结速度，导致危险后果</li></ul><h3 id="复活"><a class="anchor" href="#复活">#</a> 复活</h3><p>终结器代码可以将自身赋值给某个根，导致此对象重新变为可达，这种情况称为复活。</p><ul><li>注：复活后除非重新注册终结器队列，否则死亡时不会再执行终结器代码</li></ul><p>使用复活机制的场景之一是对象池的隐式回收，但隐式池化管理并没有特别的好处。</p><h3 id="终结器注意点"><a class="anchor" href="#终结器注意点">#</a> 终结器注意点</h3><ul><li>总是检查是否存在期待资源：如从构造函数抛出异常，会导致终结器在对象状态未完全初始化的情况下执行</li><li>避免在终结器分配资源：如果出现 OutOfMemory 会是严重错误</li><li>避免任何线程上下文依赖</li><li>不要在终结器抛出异常</li><li>避免从终结器调用 virtual 成员</li></ul><p>首选显式清理。</p><h2 id="idisposable"><a class="anchor" href="#idisposable">#</a> IDisposable</h2><p>通常可以将隐式释放的终结器与要求显式释放的 IDisposable 接口结合，若显示调用了 Dispose 方法则使用 GC.SuppressFinalize 抑制终结器的调用，否则以终结器兜底。<br>注：抑制终结器如上所示，操作很简单，没有性能影响</p><h2 id="安全句柄"><a class="anchor" href="#安全句柄">#</a> 安全句柄</h2><p>用于安全处理非托管资源的类型，构建于关键终结器 (CriticalFinalizerObject) 之上。</p><ul><li>即结合了显式和隐式释放</li></ul><p>CLR 在 P/Invoke 期间会以特殊方式处理：不会 (像 HandleRef 那样) 被垃圾回收，而是基于安全原因使用引用计数逻辑</p><ul><li>每个 P/Invoke 都包含 JIT 编译的用于递增引用计数逻辑，并在调用结束后递减计数器</li></ul><p>相比其它替代者，SafeHandle 好处有：</p><ul><li>拥有关键终结器，比常规终结器更可靠</li><li>仅对非托管资源 (句柄) 进行了最小化的简单封装</li><li>使用 SafeHandle 的对象无需使用终结器</li><li>更好的生存期管理：GC 在 P/Invoke 调用期间自动保持其存活状态，无需手动 GC.KeepAlive</li><li>有多个对应不同资源的 SafeHandle 子类型，比直接使用 IntPtr 拥有更好的强类型支持</li><li>对句柄重用攻击防范使得安全性提高</li></ul><p>注：P/Invoke marshaling 机制可以在底层将 SafeHandle 派生类视为 IntPtr (直接将 IntPtr 句柄赋值给 SafeHandle 派生类)</p><h3 id="预定义安全句柄"><a class="anchor" href="#预定义安全句柄">#</a> 预定义安全句柄</h3><ul><li>SafeFileHandle</li><li>SafeMemoryMappedFileHandle、SafeMemoryMappedViewHandle：内存映射文件句柄相关的安全句柄</li><li>SafeNCryptKeyHandle、SafeNCrypProviderHandle、SafeNCrypSecretHandle</li><li>SafePipeHandle：命名管道句柄的安全句柄</li><li>SafeProcessHandle：用于进程的安全句柄</li><li>SafeRegistryHandle：用于注册表键的安全句柄</li><li>SafeWaitHandle：安全等待句柄 (用于同步场景)</li></ul><p>注：若底层非托管代码某些部分确实需要直接使用 IntPtr，可以通过 DangerousGetHandle 获取原始句柄。</p><h2 id="弱引用"><a class="anchor" href="#弱引用">#</a> 弱引用</h2><p>存储一个对象的引用，但其自身不被视为一个根 (它对目标对象的引用不会使得后者保持可达状态)</p><ul><li>短弱句柄 (short weak handle)：当 GC 决定回收对象，在终结器运行之前被清零。即使终结器复活了对象，引用它的弱句柄依然保持清零状态。</li><li>长弱句柄 (long weak handle)：当对象由于终结被提升时，它们的目标仍然保持有效。如果终结器复活了对象，长弱句柄将保持有效状态。</li></ul><p>主要应用场景：</p><ul><li>各种类型的观察和侦听器</li><li>缓存</li></ul><p>.NET 提供：GCHandle 及封装其的 WeakReference 和 WeakReference<t>（请使用 TryGetTarget）<br>注：WPF 中存在 WeakEventManager 实现了弱事件的模式</t></p><h1 id="第十三章-其它主题"><a class="anchor" href="#第十三章-其它主题">#</a> 第十三章 其它主题</h1><h2 id="依赖句柄"><a class="anchor" href="#依赖句柄">#</a> 依赖句柄</h2><p>依赖句柄允许我们将两个对象的生存期耦合起来</p><ul><li>像其它 GC 句柄一样指向一个目标</li><li>行为像一个弱句柄：即不能使目标一直保持存活</li></ul><p>行为如下：</p><ul><li>句柄本身不会影响两个对象的生存期</li><li>只要主对象存活，次要对象也存活</li></ul><p>使用它的唯一方法是使用包装类 ConditionalWeakTable，其被组织为 Dictionary，其 key 存储主要对象，value 存储次要对象。</p><ul><li>注：此类的 key 是弱引用</li></ul><p>依赖句柄的底层弱引用行为像长弱引用：即使主要对象终结仍然会保持维护主要对象和次要对象之间的关系，使其可以正确处理复活场景。</p><h2 id="线程局部存储"><a class="anchor" href="#线程局部存储">#</a> 线程局部存储</h2><p>线程局部存储 (TLS)</p><ul><li>其行为像一个全局变量，但数据是为每个线程单独存储的。</li></ul><p>当前再 .NET 中有三种使用线程局部存储方法：</p><ul><li>线程静态字段：添加 <code>ThreadStatic</code> 属性标记后，就可以作为静态字段使用</li><li>包装线程静态字段的帮助类： <code>ThreadLocal&lt;T&gt;</code> 类型</li><li>线程数据插槽：在 <code>Thread.SetData</code> 和 <code>Thread.GetData</code> 方法的帮助下使用</li></ul><p>注：线程静态字段性能比线程数据插槽性能更好，且线程静态字段是强类型，而线程数据插槽始终对 object 进行操作。</p><h3 id="线程静态字段"><a class="anchor" href="#线程静态字段">#</a> 线程静态字段</h3><p>使用 ThreadStatic 标记常规静态字段即可，值和引用类型都可以用作线程静态字段。<br>注：若线程静态字段具有初始化程序，将只会在执行静态构造函数的线程上调用一次，会导致后续其它线程字段将保持其默认值。</p><ul><li>为克服类似问题，后续 .NET 提供了 <code>ThreadLocal&lt;T&gt;</code> 类以提供更好、更确定性的初始化行为。</li><li>当然，也因此 <code>ThreadLocal&lt;T&gt;</code> 会比直接使用 ThreadStatic 方式性能差一些</li></ul><h3 id="线程数据插槽"><a class="anchor" href="#线程数据插槽">#</a> 线程数据插槽</h3><p>使用非常简单，不过不建议使用，性能和 object 这种非强类型操作都很不妥当。</p><h3 id="线程局部存储内部"><a class="anchor" href="#线程局部存储内部">#</a> 线程局部存储内部</h3><p>有一个特殊的内存区域专用于每个线程自己的目的，在 Windows 中称为线程局部存储 (Thread Local Storage,TLS)，在 Linux 中称为线程专用数据 (thread-specific data)</p><ul><li>但是这样的区域相当小，例如 Windows 保证每个进程仅有 64 个此类插槽可用，且最大数量不超过 1088 个，其无法保存数据本身</li></ul><p>CLR 使用了 C++ 中使用线程局部存储方法，定义了一个 ThreadLocalInfo struct 类型的全局线程静态变量，其保留三个 CLR 内部数据地址：</p><ul><li>表示当前正在运行的托管线程的非托管 Thread 类的实例</li><li>正在执行当前线程的 AppDomain 实例</li><li>ClrTlsInfo 结构的实例</li></ul><p>当我们在 .NET 使用线程局部存储技术时，只存储了 ThreadLocalInfo 结构指针在 TLS 中，其它所有内容都驻留在 CLR 私有堆和 GC 堆中，即与常规静态变量实现方式类似：实例通常由堆分配，只是它们的引用存储在专用的常规对象数组中。</p><p><img data-src="/blogimages/2023/2023-08-21/2140760369.jpeg" alt="2140760369.jpeg"></p><p>由于在编译时已经知道了类型的数量，因此专用的 Object [] 数组和静态 blob 都具有恒定的、预先计算的大小。<br>总的来说 TLS 仅用作对应数据结构的线程相关性的功能实现细节，它本身并没有加快任何速度 (甚至会有额外开销)</p><h3 id="使用场景"><a class="anchor" href="#使用场景">#</a> 使用场景</h3><ul><li>需要存储和管理线程敏感数据</li><li>可以利用单线程相关性：<ul><li>日志记录或诊断</li><li>缓存 (如 StreamBuilderCache)</li></ul></li></ul><p>注：使用线程静态变量显然不适合异步编程，因为异步方法的延续不能保证会在同一个线程执行。</p><ul><li>因此作为 ThreadLocal 的补充，AsyncLocal<t>可用于在所有异步方法执行期间保留数据。</t></li></ul><h2 id="托管指针"><a class="anchor" href="#托管指针">#</a> 托管指针</h2><p>简称 byref。<br>对象的引用实际上是一个类型安全指针 (地址)，该指针始终指向对象 MethidTable 引用字段 (通常说指向对象的开头)，有了对象引用，就有了整个对象地址。</p><ul><li>例如 GC 可通过常量偏移量快速访问标头</li><li>通过 MethodTable 中存储的信息，字段地址也很容易计算</li></ul><p>相比引用而言，托管指针可以定义为一种更通用的指针类型，它可以指向其它位置，而不是对象的开头。</p><ul><li>局部变量</li><li>参数</li><li>复合类型的字段</li><li>数组元素</li></ul><p>托管指针任然还是类型，有一个指向 System.Int32 对象的托管指针类型，强类型使它们比纯粹的非托管指针更安全。</p><ul><li>但托管指针只允许用于局部变量和参数签名</li><li>由于这些限制，托管指针并没有直接暴露于 C#，以 ref 参数形式存在 (因此通常也称为 byref)</li></ul><h3 id="ref-局部变量"><a class="anchor" href="#ref-局部变量">#</a> ref 局部变量</h3><p>可视为存储托管指针的局部变量</p><h3 id="ref-返回值"><a class="anchor" href="#ref-返回值">#</a> ref 返回值</h3><p>允许我们从方法中返回托管指针</p><ul><li>返回值的生存期必须超过方法执行范围</li><li>例如不能返回方法中局部变量，可以是类的实例或静态字段、或传递给方法的参数</li></ul><h3 id="只读-ref-和-in-参数"><a class="anchor" href="#只读-ref-和-in-参数">#</a> 只读 ref 和 in 参数</h3><p>用于控制 ref 变量存储变化能力</p><ul><li>对于值类型：保证该值不会更改</li><li>对于引用类型：保证该引用不会被更改</li></ul><p>注：如果在只读 ref 结构调用可修改值的方法也可以确保不被修改：因为这是通过防御性复制方法来实现。因为编译器分析调用方法是否确实会修改状态。<br>创建防御性副本是一个明显开销，可以通过将此类结构设为只读 (如果适用) 来避免防御性复制。</p><ul><li>编译器可以安全略过直接在传递值类型参数上创建防御性复制和调用方法的操作。</li></ul><h3 id="ref-类型的内部"><a class="anchor" href="#ref-类型的内部">#</a> ref 类型的内部</h3><ul><li>指向堆栈分配对象的托管指针</li><li>指向堆分配对象的托管指针<ul><li>指向内部字段 (内部指针) 如何保证其主对象没有其它引用时存活：有一个 brick 表和 plug 树，判断并使内部指针成为根 (但是有开销)</li></ul></li></ul><p>他们均需要对 GC 进行报告，以使 GC 能够检测到目标可达性</p><p><img data-src="/blogimages/2023/2023-08-21/52284544.jpeg" alt="52284544.jpeg"></p><h3 id="c-中的托管指针-ref-变量"><a class="anchor" href="#c-中的托管指针-ref-变量">#</a> C# 中的托管指针 - ref 变量</h3><p>ref (参数、局部变量、返回值) 都是围绕托指针的小型包装器，显然不应该被视为指针，而是属于变量。</p><blockquote><p>避免复制数据 - 特别是大型结构 - 以类型安全方式</p></blockquote><h2 id="关于更多结构知识"><a class="anchor" href="#关于更多结构知识">#</a> 关于更多结构知识</h2><p>只读结构</p><ul><li>public readonly struct xxx</li><li>避免防御性副本</li></ul><p>ref 结构</p><ul><li>public ref struct xxx</li><li>编译器对其施加了很多限制，以使其只会被堆栈分配 (不能装箱)<ul><li>不能声明为常规结构或类的字段</li><li>不能声明为静态字段</li><li>不能装箱：不能分配 / 强转为对象、动态或任何接口类型，也不能用作数组元素</li><li>不能用作迭代器、泛型参数</li><li>不能在异步方法用作局部变量：因为会被闭包类装箱</li><li>不能被 lambda 或局部函数捕获 (因为会被闭包装箱)</li></ul></li><li>特性：永远不会被堆分配、永远不会被多个线程访问到 (线程间传递堆栈地址非法)</li></ul><h3 id="固定大小缓冲区"><a class="anchor" href="#固定大小缓冲区">#</a> 固定大小缓冲区</h3><p>将结构的一个字段定义为数组时，该字段只是对堆分配数组的引用 (而不是数组本身)</p><ul><li>固定大小缓冲区即是将整个数组嵌入结构中</li><li>唯一限制：数组必须具有预定义的大小，类型只能是基元类型之一 (bool、byte、char、short、int、long、sbyte、ushort、uint、ulong、float、double)</li><li>使用固定大小缓冲区的结构需要标记为 unsafe</li></ul><p>固定大小缓冲区最长用于 P/Invoke 上下文中。</p><ul><li>也可以考虑将其用于通用代码，作为一种定义更密集数据结构的便捷方法，即使将此类结构作为泛型集合的一部分进行堆分配，生成代码也能提供更好的数据局部性。</li></ul><p><img data-src="/blogimages/2023/2023-08-21/1037927430.jpeg" alt="1037927430.jpeg"></p><p>注：还可以将它们与 stackalloc 组合使用，以创建包含『其它』数组的元素的堆栈分配数组。</p><h2 id="对象结构布局"><a class="anchor" href="#对象结构布局">#</a> 对象 / 结构布局</h2><p>数据对齐</p><ul><li>每种基元数据类型都有其自己首选的对齐方式 —— 存储其地址的值的倍数。</li><li>通常，这种基元类型对齐方式与其大小相等</li><li>（CPU 访问未对齐数据需要更多指令）</li></ul><p>在包含基元类型的复杂类型在布局这些字段时也需要考虑它们的对齐要求，因此会在字段之间引入填充</p><ul><li>复杂类型实例本身也应对齐，以确保其成为更复杂类型 (如数组) 一部分时其字段仍然对齐</li></ul><p>MSDN 为有关对象的布局定义了三个规则：</p><ul><li>类型的对齐方式是其最大元素的大小或指定的打包大小 (以较小者为准)</li><li>每个字段必须与其自身大小或类型的对齐方式 (以较小者为准) 对齐</li><li>在字段之间添加填充以满足对齐要求</li></ul><p>两种类型类别中字段布局设计决策：</p><ul><li>结构：默认情况具有顺序布局 (因为默认假定其会传递给非托管代码)，这会引入填充并增加生成结构的大小</li><li>类：默认情况下具有自动布局，字段会以最高效的方式重新排序</li></ul><p>.NET 提供的控制字段布局方法：</p><ul><li>LayoutKind.Sequential：顺序布局</li><li>LayoutKind.Auto：自动布局</li><li>LayoutKind.Explicit：显式手动布局</li></ul><p>注 1：当为结构体添加托管的引用类型字段时，排列会自动更改为自动布局 (引用类型通常为第一个字段)。当该结构包含其它自动布局结构时，默认布局行为也会变为自动。<br>注 2：类和非托管结构的自动布局是无法更改的<br>注 3：上述特性提供了具有 Pack 参数的重载，即指定的打包大小，类型对齐也会以此为准</p><h3 id="联合"><a class="anchor" href="#联合">#</a> 联合</h3><p>手动指定布局时，故意让字段相互重叠，则称为可区分联合 (discriminated union)</p><h3 id="字段对齐工具"><a class="anchor" href="#字段对齐工具">#</a> 字段对齐工具</h3><ul><li>ObjectLayoutInspector：用于检查对象内存布局，可打印类型布局信息。</li><li><span class="exturl" data-url="aHR0cDovL1NoYXJwbGFiLmlv">Sharplab.io</span></li><li>WinDbg</li></ul><h2 id="非托管类型unmanaged-type"><a class="anchor" href="#非托管类型unmanaged-type">#</a> 非托管类型 (Unmanaged Type)</h2><ul><li>14 种基元类型 + Decimal (decimal)</li><li>枚举类型</li><li>指针类型（比如 int*， long*）</li><li>只包含 Unmanaged 类型字段的结构体</li></ul><h3 id="非托管约束"><a class="anchor" href="#非托管约束">#</a> 非托管约束</h3><p>非托管类型是一直不是引用类型的类型，并且在任何嵌套级别都不包含引用类型字段。</p><ul><li>即上文提到过的不包含 (嵌套) 引用类型的结构体</li></ul><p>借助非托管泛型约束，可以让编译器为我们检查非托管类型条件，可用于泛型方法和泛型结构类型。<br>使用：where T:unmanaged</p><h3 id="非托管约束的作用"><a class="anchor" href="#非托管约束的作用">#</a> 非托管约束的作用</h3><ul><li>可以使用 T 的指针 (也可以转换为 void*)</li><li>可以使用 sizeof (T)</li><li>可以对 T 使用 stackalloc</li></ul><p>注：由于非托管约束意味着 T 是一个值类型，因此不需要固定即可获取参数的指针 (通过引用传递、或在结构实例方法中使用时，还是必须固定，因为可能是装箱的堆分配)<br>另外还可以借此更方便使用非托管内存类型。</p><h2 id="blittable-类型"><a class="anchor" href="#blittable-类型">#</a> blittable 类型</h2><p>blittable 类型被定义为托管和非托管代码在内存中都具有相同的表示形式。<br>非托管类型与 bilittable 类型几乎相同，不过后者比前者更为严格。因为有些值类型只是『有时是 bilttable』：</p><ul><li>deceimal：二进制表示形式不够完善，因此不能采用非托管方面格式</li><li>bool：通常在托管和非托管方面都占用 1 字节，但有时在非托管方面占用会更大</li><li>char：通常占用 2 字节，但有时在非托管方面会更小或更大 (取决于编码)</li><li>DateTime：具有自动布局结构因此不能 blittable</li><li>Guid：内部表示取决于机器端</li></ul><p>因此包含这种特殊值类型字段的结构是有效的非托管类型 (满足非托管泛型约束)，但在 Interop marshal 意义上是不能 bilittable 的<br>总结：</p><ul><li>非托管类型 (以及非托管泛型约束) 主要用于通用编程，通常于 unsafe 上下文使用，对序列化等功能进行底层内存优化</li><li>Blittable 类型在 Interop marshal 处理场景中使用</li></ul><p>更多知识：<br><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MveEcxVGo0cjh0VS1oMlNNdlRUdFFNUQ==">.NET 的基元类型包括哪些？Unmanaged 和 Blittable 类型又是什么？</span></p><h1 id="第十四章-高级技巧"><a class="anchor" href="#第十四章-高级技巧">#</a> 第十四章 高级技巧</h1><h2 id="spant"><a class="anchor" href="#spant">#</a> <code>Span&lt;T&gt;</code></h2><p>为值类型 (ref struct)，可以表示各种形式的值的连续集合，可以像使用数组一样使用，并内置切片功能。</p><ul><li>由于其分配在堆栈上，因此完全没有堆分配开销</li><li>编译器也能智能地处理封装到 <code>Span&lt;T&gt;</code> 中的数据的生存期 (如返回局部 stack 数据会报错，返回封装托管数组 (或非托管内存) 的 span 则被允许)</li></ul><p>注：C# 不允许将 stackalloc 的执行结果赋值给一个已经定义的变量 (它只能赋值给正在初始化的变量)<br>注：其它比如还可以使用 <code>string.AsSpan().Slice()</code> 代替开销更大的 SubString</p><h3 id="内部实现"><a class="anchor" href="#内部实现">#</a> 内部实现</h3><p>在 .NET Core 2.1 之后运行时提供了一种模拟内部指针 (byref) 的功能，称为快速 span，在这之前则称为慢速 span (兼容版本)。</p><ul><li>注 1：目前 byref (内部指针) 不支持定义为字段 (即使是 byref 类型中也不行)</li><li>注 2：快速和慢速之分，实际相差 25%，通常使用情况下只相差 12%~15%</li></ul><h2 id="memoryt"><a class="anchor" href="#memoryt">#</a> <code>Memory&lt;T&gt;</code></h2><p><code>Span&lt;T&gt;</code> 存在种种限制，如无法存在于堆中。<br><code>Memory&lt;T&gt;</code> 同样表示任意内存中一段连续区间，不过它既不是 byref 式类型，也不包含 byref 式实例字段。可用于封装如下数据：</p><ul><li>arrayT[]</li><li>字符串</li><li>实现 <code>IMemoryOwner&lt;T&gt;</code> 的类型 (对生存期有控制)</li></ul><p>可以将 <code>Memory&lt;T&gt;</code> 想象成一个能自由分配并传入传出的盒子，通常不会直接访问其存储内容，而是：</p><ul><li>从它生成 <code>Span&lt;T&gt;</code> 以供局部高效使用 (因此也称为 <code>Span&lt;T&gt;</code> 工厂)</li><li>对于 <code>Memory&lt;char&gt;</code> 可以 ToString 生成字符串，其它类型 ToArray 生成数组</li><li>与 <code>Span&lt;T&gt;</code> 一样支持数据切片</li><li>注：切片和生成 Span 都是非常高效的操作</li></ul><p>注：不允许 <code>Memory&lt;T&gt;</code> 封装 stack 数据 (如 stackalloc 返回值)</p><h2 id="unsafe类"><a class="anchor" href="#unsafe类">#</a> Unsafe 类</h2><p>相比使用普通的不安全代码 (基于指针和 fixed 语句)</p><ul><li>System.Runtime.CompilerServices.Unsafe 提供了一组泛型 / 底层功能以一种更安全的方式操作指针</li><li>并暴露了一些 CIL 支持但 C# 不直接支持的功能</li></ul><p>注：当然实际上它所做的操作仍然是不安全且危险的<br>其提供了大量方法，按功能分组如下：</p><ul><li>类型转换和重解释：在非托管指针和 ref 类型之间来回转换，或在任意两种 ref 类型之间转换</li><li>指针运算：可以像操作普通指针一样对 ref 类型实例做加法和减法</li><li>信息：获取各种信息，如两个 ref 类型实例的大小或字节差异</li><li>内存访问：从任何位置写入或读取任何内容</li></ul><p>注：使用 Unsafe 的方法并不需要标记为 unsafe<br>MemoryMarshal 辅助类</p><ul><li>AsBytes：将任何基元类型 (结构) 的 <code>Span&lt;T&gt;</code> 转换为 <code>Span&lt;byte&gt;</code></li><li>Cast：在两种不同基元类型 (结构) <code>Span&lt;T&gt;</code> 之间相互转换</li><li>TryGetArray、TryGetMrmoryManager、TryGetString：尝试将指定 <code>Memory&lt;T&gt;</code> 或 <code>ReadOnlyMemory&lt;T&gt;</code> 转换成一种特定类型</li><li>GetReference：以 ref 返回值 (ref return) 方式返回底层 <code>Span&lt;T&gt;</code> 或 <code>ReadOnlySpan&lt;T&gt;</code> 对象</li></ul><p>对非托管内存的封装 (原生内存分配)：</p><ul><li><span class="exturl" data-url="aHR0cDovL2plbWFsbG9jLk5FVA==">jemalloc.NET</span></li><li>Snowflake</li></ul><p>Unsafe 原理：</p><ul><li>对受 IL 支持但 C# 不支持的底层操作的封装</li></ul><h2 id="面向数据设计"><a class="anchor" href="#面向数据设计">#</a> 面向数据设计</h2><p>即基于最高效的内存访问目的来设计数据，与面向对象设计针锋相对：</p><ul><li>设计数据和功能时尽量实现循序内存访问，同时考虑 cacheline 的限制 (将最常用数据打包在一起) 和分层缓存得影响 (将尽可能多的数据保持在高层缓存中)</li><li>设计类型和数据以及使用它们的算法时，使其易于并行化且无需高开销的同步锁</li></ul><p>面向数据设计还可以进一步细分为两类：</p><ul><li>战术型面向数据设计：专注于『局部』数据结构，如最高效的字段布局或以正确的顺序访问数据 (可以很容易在面向对象应用程序应用)</li><li>战略型面向数据设计：从架构层面专注于应用程序的高层设计</li></ul><h3 id="战术型设计"><a class="anchor" href="#战术型设计">#</a> 战术型设计</h3><ol><li>将类型设计成把尽可能多的关联数据容纳进首个 cacheline（例如托管类型自动内存布局将引用字段放置于对象起始位置）</li><li>将数据设计成可以填充进更高层级的缓存</li><li>将数据设计成易于并行化</li><li>避免非循序，特别是随机式内存访问</li></ol><h3 id="战略型设计"><a class="anchor" href="#战略型设计">#</a> 战略型设计</h3><p>战略型设计需要程序员大幅度转变自己的思维</p><ol><li>从 Array-of-structures 走向 Structures-of-arrays（值类型数组才能提供更好的数据局部性）</li><li>Entity Component System<ul><li>实体 (Entity)：一个具有标识符的简单对象，不包含任何数据货逻辑。定义实体的功能是通过向它添加或移除特定组件。</li><li>组件 (Component)：只包含数据而不包含逻辑的简单对象。组件包含的数据表示了它所代表的功能的当前状态。</li><li>系统 (System)：特定功能与特性的逻辑所在，系统对过滤后的实体列表逐个进行操作。</li><li>注：过滤实体的效率对系统很重要，但只要管理得当，数据组件将被循序访问，获得良好的数据局部性和预取命中率。</li></ul></li></ol><h2 id="未来特性"><a class="anchor" href="#未来特性">#</a> 未来特性</h2><ul><li>可空引用类型</li><li>Piplines：替代 streams，具有更好性能和避免分配，大量使用了 Span 和 Memory。目前 Kestrel 是 Piplines 主要使用者之一。</li></ul><h1 id="第十五章-编程-api"><a class="anchor" href="#第十五章-编程-api">#</a> 第十五章 编程 API</h1><h2 id="gc-api"><a class="anchor" href="#gc-api">#</a> GC API</h2><h3 id="收集数据和统计"><a class="anchor" href="#收集数据和统计">#</a> 收集数据和统计</h3><ol><li>GC.MaxGeneration：告知 GC 当前实现的最大代数</li><li>GC.CollectionCount (Int32)：告知自程序启动以来特定代的 GC 出现次数 (包含性)</li><li>GC.GetGeneration：告知给定对象所属的代</li><li>GC.GetTotalMemory：返回所有代中正在使用的字节数 (不包括碎片)，即托管堆上所有托管对象的总大小 (非常耗性能)</li><li>GC.GetAllocatedBytesForCurrentThread：返回当前线程到目前为止分配过的字节总数 (注：只考虑分配过多少数量，并不考虑垃圾回收后的)</li><li>GC.KeepAlive：延长堆栈根存活性，使传递的参数在调用此方法时至少可以到达行 (从而影响生成的 GC 信息)</li><li>GCSetting.LargeObjectHeapCompactionMode：例如设置为 CompactOnce，可以显式请求发生第一个完全阻塞 GC 时压缩 LOH</li><li>GCSetting.LatencyMode</li><li>GCSetting.IsServerGC</li></ol><h3 id="gc-通知"><a class="anchor" href="#gc-通知">#</a> GC 通知</h3><p>只有阻塞垃圾回收才会引发此类通知：</p><ul><li>GC.RegisterForFullGCNotification：如果满足完全阻塞 GC 条件将引发此通知 (该通知并不能保证将会发生完全 GC，只有条件达到足以进行完全 GC 的阈值才会发生)</li><li>GC.CancelFullGCNotification</li><li>GC.WaitForFullGCApproach：无限期等待 GC 通知</li><li>GC.WaitForFullGCComplete：无限期等待完全 GC 的完成</li></ul><h3 id="控制非托管内存压力"><a class="anchor" href="#控制非托管内存压力">#</a> 控制非托管内存压力</h3><p>通知 GC 某些托管对象正在持有 (或释放) 一些非托管内存：</p><ul><li>GC.AddMemoryPressure(Int64)</li><li>GC.RemoveMemoryPressure(Int64)</li></ul><h3 id="无-gc-区域"><a class="anchor" href="#无-gc-区域">#</a> 无 GC 区域</h3><p>创建运行时尝试禁止 GC 的代码区域：</p><ul><li>GC.TryStartNoGCRegion</li><li>GC.EndNoGCRegion</li></ul><h3 id="终结finalization管理"><a class="anchor" href="#终结finalization管理">#</a> 终结 (Finalization) 管理</h3><ul><li>GC.ReRegiterForFinalize</li><li>GC.SuppressFinalize</li><li>GC.WaitForPendingFinalizers</li></ul><h2 id="clr-hosting"><a class="anchor" href="#clr-hosting">#</a> CLR Hosting</h2><p>略</p><h2 id="clrmd"><a class="anchor" href="#clrmd">#</a> ClrMD</h2><p>一组用于自检托管进程和内存转储的托管 API，提供与 WinDBG 的 SOS 相似功能不过可以用 C# 更方便使用。<br>注：如 Netext 和 SOSEX 这些 WinDbg 扩展就是围绕 ClrMD 的包装器。</p><h2 id="traceevent"><a class="anchor" href="#traceevent">#</a> TraceEvent</h2><p>略</p><h2 id="自定义-gc"><a class="anchor" href="#自定义-gc">#</a> 自定义 GC</h2><p>从 .NET Core 2.1 开始，垃圾回收与执行引擎之间的耦合已经松动很多，并引入本地 GC 的概念，意味着现在 GC 是可插拔的：我们可以通过设置单个环境变量来插入自定义 GC。<br>它允许完全替换 GC 的实现。</p><div class="tags"><a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 笔记</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-10-02 17:13:03" itemprop="dateModified" datetime="2023-10-02T17:13:03+08:00">2023-10-02</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>WangJiaYing <i class="ic i-at"><em>@</em></i>CWHISME</li><li class="link"><strong>本文链接：</strong> <a href="https://wangjiaying.top/2023/08/21/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-6-%E5%AE%8C/" title="《.NET 内存管理宝典》- 笔记 (6)[完]">https://wangjiaying.top/2023/08/21/NET内存管理宝典-6-完/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/08/04/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-5/" itemprop="url" rel="prev" data-background-image="&#x2F;blogimages&#x2F;2023&#x2F;2023-06-26&#x2F;book.webp" title="《.NET内存管理宝典》-笔记(5)"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 阅读笔记</span><h3>《.NET内存管理宝典》-笔记(5)</h3></a></div><div class="item right"><a href="/2023/09/18/%E8%99%9A%E5%B9%BB5%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-C/" itemprop="url" rel="next" data-background-image="&#x2F;images&#x2F;coverimages&#x2F;large&#x2F;6833939bly1gipexbei4hj20zk0m8npd.webp" title="虚幻5基础学习笔记-详细(C++)"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>虚幻5基础学习笔记-详细(C++)</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="toc-number">2.</span> <span class="toc-text">第十二章 对象生存期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%88%E7%BB%93"><span class="toc-number">2.1.</span> <span class="toc-text">终结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%BB%88%E7%BB%93%E5%99%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">关键终结器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%E5%99%A8%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">终结器内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%80%E9%94%80"><span class="toc-number">2.1.3.</span> <span class="toc-text">终结器开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%B4%BB"><span class="toc-number">2.1.4.</span> <span class="toc-text">复活</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%E5%99%A8%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">2.1.5.</span> <span class="toc-text">终结器注意点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#idisposable"><span class="toc-number">2.2.</span> <span class="toc-text">IDisposable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%8F%A5%E6%9F%84"><span class="toc-number">2.3.</span> <span class="toc-text">安全句柄</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%89%E5%85%A8%E5%8F%A5%E6%9F%84"><span class="toc-number">2.3.1.</span> <span class="toc-text">预定义安全句柄</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">2.4.</span> <span class="toc-text">弱引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%85%B6%E5%AE%83%E4%B8%BB%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">第十三章 其它主题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%8F%A5%E6%9F%84"><span class="toc-number">3.1.</span> <span class="toc-text">依赖句柄</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8"><span class="toc-number">3.2.</span> <span class="toc-text">线程局部存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5"><span class="toc-number">3.2.1.</span> <span class="toc-text">线程静态字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E6%8F%92%E6%A7%BD"><span class="toc-number">3.2.2.</span> <span class="toc-text">线程数据插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8%E5%86%85%E9%83%A8"><span class="toc-number">3.2.3.</span> <span class="toc-text">线程局部存储内部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.4.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E6%8C%87%E9%92%88"><span class="toc-number">3.3.</span> <span class="toc-text">托管指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ref-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.1.</span> <span class="toc-text">ref 局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.3.2.</span> <span class="toc-text">ref 返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB-ref-%E5%92%8C-in-%E5%8F%82%E6%95%B0"><span class="toc-number">3.3.3.</span> <span class="toc-text">只读 ref 和 in 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E9%83%A8"><span class="toc-number">3.3.4.</span> <span class="toc-text">ref 类型的内部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E4%B8%AD%E7%9A%84%E6%89%98%E7%AE%A1%E6%8C%87%E9%92%88-ref-%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.5.</span> <span class="toc-text">C# 中的托管指针 - ref 变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%9B%B4%E5%A4%9A%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86"><span class="toc-number">3.4.</span> <span class="toc-text">关于更多结构知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">3.4.1.</span> <span class="toc-text">固定大小缓冲区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%B8%83%E5%B1%80"><span class="toc-number">3.5.</span> <span class="toc-text">对象 &#x2F; 结构布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88"><span class="toc-number">3.5.1.</span> <span class="toc-text">联合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7"><span class="toc-number">3.5.2.</span> <span class="toc-text">字段对齐工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E6%89%98%E7%AE%A1%E7%B1%BB%E5%9E%8Bunmanaged-type"><span class="toc-number">3.6.</span> <span class="toc-text">非托管类型 (Unmanaged Type)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%89%98%E7%AE%A1%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.6.1.</span> <span class="toc-text">非托管约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%89%98%E7%AE%A1%E7%BA%A6%E6%9D%9F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.6.2.</span> <span class="toc-text">非托管约束的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#blittable-%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.7.</span> <span class="toc-text">blittable 类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7"><span class="toc-number">4.</span> <span class="toc-text">第十四章 高级技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#spant"><span class="toc-number">4.1.</span> <span class="toc-text">Span&lt;T&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">内部实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memoryt"><span class="toc-number">4.2.</span> <span class="toc-text">Memory&lt;T&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unsafe%E7%B1%BB"><span class="toc-number">4.3.</span> <span class="toc-text">Unsafe 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.4.</span> <span class="toc-text">面向数据设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%98%E6%9C%AF%E5%9E%8B%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.4.1.</span> <span class="toc-text">战术型设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%98%E7%95%A5%E5%9E%8B%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.4.2.</span> <span class="toc-text">战略型设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E6%9D%A5%E7%89%B9%E6%80%A7"><span class="toc-number">4.5.</span> <span class="toc-text">未来特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E7%BC%96%E7%A8%8B-api"><span class="toc-number">5.</span> <span class="toc-text">第十五章 编程 API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gc-api"><span class="toc-number">5.1.</span> <span class="toc-text">GC API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE%E5%92%8C%E7%BB%9F%E8%AE%A1"><span class="toc-number">5.1.1.</span> <span class="toc-text">收集数据和统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc-%E9%80%9A%E7%9F%A5"><span class="toc-number">5.1.2.</span> <span class="toc-text">GC 通知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E9%9D%9E%E6%89%98%E7%AE%A1%E5%86%85%E5%AD%98%E5%8E%8B%E5%8A%9B"><span class="toc-number">5.1.3.</span> <span class="toc-text">控制非托管内存压力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0-gc-%E5%8C%BA%E5%9F%9F"><span class="toc-number">5.1.4.</span> <span class="toc-text">无 GC 区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%BB%93finalization%E7%AE%A1%E7%90%86"><span class="toc-number">5.1.5.</span> <span class="toc-text">终结 (Finalization) 管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clr-hosting"><span class="toc-number">5.2.</span> <span class="toc-text">CLR Hosting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clrmd"><span class="toc-number">5.3.</span> <span class="toc-text">ClrMD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#traceevent"><span class="toc-number">5.4.</span> <span class="toc-text">TraceEvent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-gc"><span class="toc-number">5.5.</span> <span class="toc-text">自定义 GC</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8A/" rel="bookmark" title="《CLR VIR C#》笔记(上)">《CLR VIR C#》笔记(上)</a></li><li><a href="/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="bookmark" title="《CLR VIR C#》笔记(下)-多线程">《CLR VIR C#》笔记(下)-多线程</a></li><li><a href="/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%AE%8C%E7%BE%8E%E5%BC%80%E5%8F%91-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《设计模式与游戏完美开发》-笔记">《设计模式与游戏完美开发》-笔记</a></li><li><a href="/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《数据结构与算法之美》-笔记">《数据结构与算法之美》-笔记</a></li><li><a href="/2023/06/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8_1/" rel="bookmark" title="《.NET内存管理宝典》-笔记(1)">《.NET内存管理宝典》-笔记(1)</a></li><li><a href="/2023/06/26/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-2/" rel="bookmark" title="《.NET内存管理宝典》-笔记(2)">《.NET内存管理宝典》-笔记(2)</a></li><li><a href="/2023/07/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-3/" rel="bookmark" title="《.NET内存管理宝典》-笔记(3)">《.NET内存管理宝典》-笔记(3)</a></li><li><a href="/2023/07/19/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-4/" rel="bookmark" title="《.NET内存管理宝典》-笔记(4)">《.NET内存管理宝典》-笔记(4)</a></li><li><a href="/2023/08/04/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-5/" rel="bookmark" title="《.NET内存管理宝典》-笔记(5)">《.NET内存管理宝典》-笔记(5)</a></li><li class="active"><a href="/2023/08/21/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-6-%E5%AE%8C/" rel="bookmark" title="《.NET内存管理宝典》-笔记(6)[完]">《.NET内存管理宝典》-笔记(6)[完]</a></li><li><a href="/2023/09/25/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《游戏编程模式》-笔记">《游戏编程模式》-笔记</a></li><li><a href="/2023/10/02/CPP_Primer_%E7%AC%AC%E4%BA%94%E7%89%88_%E7%AC%94%E8%AE%B0-1/" rel="bookmark" title="《C++ Primer(第五版)》-笔记(1)">《C++ Primer(第五版)》-笔记(1)</a></li><li><a href="/2023/10/22/CPP-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%AC%94%E8%AE%B0-2/" rel="bookmark" title="《C++ Primer(第五版)》-笔记(2)">《C++ Primer(第五版)》-笔记(2)</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="WangJiaYing" data-src="/images/../img/avator"><p class="name" itemprop="name">CWHISME</p><div class="description" itemprop="description">己所不欲，勿施于人</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">125</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">22</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">32</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N3aGlzbWU=" title="https:&#x2F;&#x2F;github.com&#x2F;cwhisme"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9jd2hpc21lLTMzL3Bvc3Rz" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;cwhisme-33&#x2F;posts"><i class="ic i-zhihu"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmN3aGlzbWVAMTI2LmNvbQ==" title="mailto:cwhisme@126.com"><i class="ic i-envelope"></i></span> <a href="/atom.xml" title="&#x2F;atom.xml" class="item feedback"><i class="ic i-heart"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-clock"></i>统计</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/08/04/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-5/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/09/18/%E8%99%9A%E5%B9%BB5%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-C/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/C/" title="分类于 C#">C#</a></div><span><a href="/2023/04/14/%E5%AF%B9%E5%88%97%E8%A1%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%BC%95%E7%94%A8%E4%BC%A0%E5%8F%82%E7%9A%84%E4%B8%80%E7%82%B9%E6%B5%8B%E8%AF%95/" title="对列表容器中值类型引用传参的一点测试">对列表容器中值类型引用传参的一点测试</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Unity3D/" title="分类于 Unity3D">Unity3D</a> <i class="ic i-angle-right"></i> <a href="/categories/Unity3D/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" title="分类于 图形学">图形学</a></div><span><a href="/2016/11/04/Shader-%E5%83%8F%E7%B4%A0%E6%89%AD%E6%9B%B2%E6%95%88%E6%9E%9C/" title="[Shader]像素扭曲效果">[Shader]像素扭曲效果</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="分类于 阅读笔记">阅读笔记</a></div><span><a href="/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%AE%8C%E7%BE%8E%E5%BC%80%E5%8F%91-%E7%AC%94%E8%AE%B0/" title="《设计模式与游戏完美开发》-笔记">《设计模式与游戏完美开发》-笔记</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment count_3"></ul></div></div><div class="status"><div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">WangJiaYing @ Jiaying's Note</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">736k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">11:09</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NXSElTTUUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/08/21/NET内存管理宝典-6-完/",favicon:{show:"（●´3｀●）",hide:"(´Д｀)"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,justifiedGallery:!0,jquery:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script><script src="https://cdn.staticfile.org/pjax/0.2.8/pjax.min.js"></script><script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script><script src="https://cdn.staticfile.org/algoliasearch/4.17.0/algoliasearch-lite.umd.js"></script><script src="https://cdn.staticfile.org/instantsearch.js/4.54.1/instantsearch.production.min.js"></script><script src="https://cdn.staticfile.org/lozad.js/1.16.0/lozad.min.js"></script><script src="https://cdn.staticfile.org/quicklink/2.3.0/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/js/DateTimeAfeterCalc.js" async></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js" async></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?62952472c154f9131a14a4ab57bfefec";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html>