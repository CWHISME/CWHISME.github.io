<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="CWHISME" href="https://wangjiaying.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="CWHISME" href="https://wangjiaying.top/atom.xml"><link rel="alternate" type="application/json" title="CWHISME" href="https://wangjiaying.top/feed.json"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="笔记"><link rel="canonical" href="https://wangjiaying.top/2023/08/04/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-5/"><title>《.NET 内存管理宝典》- 笔记 (5) - 阅读笔记 | Jiaying's Note = CWHISME = 人不能没有梦想，也要有足够的敬畏</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">《.NET 内存管理宝典》- 笔记 (5)</h1><div class="meta"><span class="item" title="创建时间：2023-08-04 14:31:59"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-08-04T14:31:59+08:00">2023-08-04</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>6.9k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>6 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiaying's Note</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/blogimages/2023/2023-06-26/book.webp"></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" itemprop="item" rel="index" title="分类于 阅读笔记"><span itemprop="name">阅读笔记</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangjiaying.top/2023/08/04/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/../img/avator"><meta itemprop="name" content="WangJiaYing"><meta itemprop="description" content="人不能没有梦想，也要有足够的敬畏, 己所不欲，勿施于人"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="CWHISME"></span><div class="body md" itemprop="articleBody"><h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本文包含原书第七章至第十一章，主要为 .NET 垃圾回收过程的详细描述</p><h1 id="第七章-垃圾回收-简介"><a class="anchor" href="#第七章-垃圾回收-简介">#</a> 第七章 垃圾回收 - 简介</h1><h2 id="高层视图"><a class="anchor" href="#高层视图">#</a> 高层视图</h2><p>.NET GC 的两种模式：</p><ul><li>工作站模式：最大限度减少 GC 引入的延迟，GC 频率更高<ul><li>非并发：GC 时应用程序所有托管线程都挂起</li></ul></li><li>服务器模式：最大限度提高应用程序的吞吐量，GC 频率更低<ul><li>并发：GC 的某些部分在托管现在还在工作时执行</li></ul></li></ul><h2 id="gc-过程示例"><a class="anchor" href="#gc-过程示例">#</a> GC 过程示例</h2><p>垃圾回收是在特定代的上下文中发生，该代称为被判决的代。</p><ul><li>可决定同时回收比当前被判决代更小的代</li></ul><h3 id="第-0-代被判决的垃圾回收"><a class="anchor" href="#第-0-代被判决的垃圾回收">#</a> 第 0 代被判决的垃圾回收：</h3><ul><li>仅检查第 0 代中对象的可达性</li><li>第 0 代变为空 (只有意保留非常小的空间)，最小一代所有对象要么被回收，要么提升到更大的一代</li><li>第 0 代可达对象提升至第 1 代</li><li>第 1 代增长</li><li>第 2 代和 LOH 不变</li></ul><p><img data-src="/blogimages/2023/2023-08-04/139468769.jpeg" alt="139468769.jpeg"></p><h3 id="第-1-代被判决的垃圾回收"><a class="anchor" href="#第-1-代被判决的垃圾回收">#</a> 第 1 代被判决的垃圾回收：</h3><ul><li>仅检查第 0 代和第 1 代中对象的可达性</li><li>第 0 代变为空</li><li>第 0 代的可达性对象被提升到第 1 代</li><li>第 1 代的可达性对象被提升到第 2 代</li><li>第 1 代可能会增长或缩小</li><li>第 2 代增长</li><li>LOH 不变</li></ul><p>从性能上讲，第 1 代被判决的垃圾回会有更多的对象被分析，不过在这两种情况下，GC 都在单个临时段内运行</p><h3 id="第-2-代被判决完全gc"><a class="anchor" href="#第-2-代被判决完全gc">#</a> 第 2 代被判决 (完全 GC)</h3><p>与前两种情况相比，这种完全 GC 需要分析更多对象，且标记阶段将分析整个托管堆：第 0、1、2 和 LOH ，并可能跨越多个段</p><ul><li>所有代和 LOH 的所有对象的可达性都经检查</li><li>第 0 代变为空</li><li>第 0、1 代的可达对象相应提升到第 1、2 代</li><li>第 2 代可达对象继续留在第 2 代中</li><li>LOH 在没有压缩的情况下被回收，空闲空间被 空闲列表记录以便重用</li></ul><p>最后，第 2 代在段中增长后，可能大到导致第 0、1 代没有足够空间：</p><ul><li>当前临时段被更改为只有第 2 代的段</li><li>创建一个新的临时段，将第 0 代的所有可达性对象都压缩过去 (作为第 1 代对象)<ul><li>如果有一个已存在的且具有较小第 2 代的『只有第 2 代的段』也可作为新的临时段重新使用</li></ul></li><li>LOH 照常使用清除回收处理</li></ul><p>完全垃圾回收与第 0、1 代被判决的临时垃圾回收之间的开销差异可能是几个数量级的，因此尽可能避免完全垃圾回收。</p><h2 id="gc-过程步骤"><a class="anchor" href="#gc-过程步骤">#</a> GC 过程步骤</h2><ol><li>触发垃圾回收</li><li>挂起托管线程</li><li>用户线程启动 GC 代码</li><li>选择要判决的代</li><li>标记</li><li>计划</li><li>清除或压缩</li><li>恢复托管线程</li></ol><h2 id="垃圾回收数据"><a class="anchor" href="#垃圾回收数据">#</a> 垃圾回收数据</h2><h3 id="静态数据"><a class="anchor" href="#静态数据">#</a> 静态数据</h3><p>表示 .NET 运行时初始设置的配置，以后将永远不会更改</p><ul><li>最小大小：最小分配预算</li><li>最大大小：最大分配预算</li><li>碎片限制和碎片比率限制：在决定是否应该压缩时使用</li><li>限制和最大限制：用于计算代分配预算的增长</li><li>时间限制：指定开始回收代要达到的时间</li><li>时间时钟：指定开始回收代要达到的时间，以性能计数</li><li>GC 时钟：指定开始回收代要达到的 GC 数量</li></ul><p><img data-src="/blogimages/2023/2023-08-04/-1582334348.jpeg" alt="-1582334348.jpeg"></p><p>注：</p><ul><li>SSIZE_T_MAX：(最大地址限制) 字长的一半</li></ul><h3 id="动态数据"><a class="anchor" href="#动态数据">#</a> 动态数据</h3><p>表示托管堆当前状态，会在 GC 期间更新，计算各种决策所需的数据</p><ul><li>分配预算：GC 希望在下一次 GC 之前用于新分配的大小<ul><li>代表 GC 希望用于特定代分配的总大小</li><li>在回收该代的每个 GC 上，分配预算会动态更改，主要基于该代的存活率</li></ul></li><li>新分配：在当前分配预算下，在下一次 GC 之前剩余分配空间的大小<ul><li>对于分配器和 GC 的合作至关重要，跟踪一代中相对于分配预算进行了多少分配，如果为负数，则意味已经超出分配预算，将为该代触发垃圾回收</li></ul></li><li>碎片：该代中空闲对象消耗的总大小</li><li>存活的大小：存活对象占用的总大小</li><li>存活固定的大小：存活固定插头占用的总大小</li><li>存活率：存活字节数除以总字节数的比率</li><li>当前大小：GC 发生后所有对象的总大小 (不包括碎片部分)</li><li>GC 时钟：回收这一代 GC 的数量</li><li>时间时钟：回收这一代的上一次 GC 开始时间</li></ul><p>注：代只是被简单创建为空，跟它们默认大小无关，随着对象被分配和提升，它们大小会根据分配预算而增加。</p><h2 id="回收触发器"><a class="anchor" href="#回收触发器">#</a> 回收触发器</h2><h3 id="分配触发器"><a class="anchor" href="#分配触发器">#</a> 分配触发器</h3><p>如果无法为正在创建的对象找到合适的空间，小对象堆分配器和大对象堆分配器都可能触发垃圾回收。</p><ul><li>小对象分配 (AllocSmall)：在对象分配期间，第 0 代预算已用完 (最常见)，在第 0 代分配预算超出的情况下触发</li><li>大对象分配 (AllocLarge)：在大对象分配期间，LOH 的预算已经用完</li><li>慢速路径上的小对象分配 (OutOfSpaceSOH)</li><li>慢速路径上的大对象分配 (OutOfSpaceLOH)</li></ul><p>如果没有分配，则不会发生这种触发。</p><h3 id="显式触发器"><a class="anchor" href="#显式触发器">#</a> 显式触发器</h3><p>显示调用相关 API：</p><ul><li><code>GC.Collect()</code> 及其重载</li><li><code>GC.AddMemoryPresure</code> (非托管内存)</li></ul><p>调用 GC.Collect 很少是合理的，显式调用会干扰内部启发式垃圾回收算法，破坏 GC 的自我调整。</p><h3 id="低内存级别系统触发器"><a class="anchor" href="#低内存级别系统触发器">#</a> 低内存级别系统触发器</h3><p>操作系统发现内存不足，.NET 接收到信号后触发</p><h3 id="各种内部触发器"><a class="anchor" href="#各种内部触发器">#</a> 各种内部触发器</h3><ul><li>AppDomain 卸载</li><li>清理表示为死线程的线程对象 (每个线程由一个托管对象表示)</li><li>在启动 NoGC 区域之前 (15 章)</li></ul><h2 id="ee-挂起"><a class="anchor" href="#ee-挂起">#</a> EE 挂起</h2><p>挂起用户代码的所有线程的过程称为『EE 挂起』</p><ul><li>即执行引擎挂起，意为挂起托管线程</li><li>从应用程序角度看，整个世界都是在垃圾回收时暂停的</li></ul><p>安全点是一个可以检查寄存器和堆栈位置的实时引用的代码位置，安全点的实现并非易事，挂起也必须是非常高效的。</p><ul><li>如果一个线程被挂起在安全点之外 (这很可能)，那么当前堆栈帧的返回地址将被操作到一个特殊的存根，这个根将把它『停』在一个安全点上。</li></ul><p>注：非托管线程不会挂起和重启，若创建一个后台本机线程执行，则它将独立于 EE 挂起运行 (当然 P/Invoke 机制肯定会从非托管代码返回托管代码时阻塞)</p><h1 id="第八章-垃圾回收-标记阶段"><a class="anchor" href="#第八章-垃圾回收-标记阶段">#</a> 第八章 垃圾回收 - 标记阶段</h1><p>在非并发 GC 的情况下，一开始所有线程均会挂起，托管堆以此确保自己不会发生任何变化，保持 GC 的独占性，以安全地浏览堆，从中搜寻出所有可达对象。</p><h2 id="对象的遍历与标记"><a class="anchor" href="#对象的遍历与标记">#</a> 对象的遍历与标记</h2><p>对于一个特定的根地址，遍历程序将执行以下步骤：</p><ol><li>将其转换为一个托管对象的确切地址：如果根地址是个内部指针 (表示它并不指向托管对象的开头，而是指向对象内部的某个位置)，则需要进行此转换</li><li>设置固定标记：如果一个对象被固定，则在对象头中设置一个合适的位</li><li>开始遍历对象的引用：由于有存储于 MethodTable 中的类型信息，GC 可以知道哪些偏移位置 (字段) 代表传出的引用<ul><li>GC 以深度优先方式访问所有这些引用并维护到一个集合，称为标记堆栈<ul><li>已访问对象将被跳过</li><li>尚未访问对象将被标记：通过在 MethodTable 指针中设置一个位来完成 (此操作不会破坏 MT 指针，其至少有两个未被使用的最低位)</li><li>添加传出引用到标记堆栈集合中</li></ul></li><li>当标记堆栈中不再有尚未访问的对象时，遍历操作即完成</li><li>注：使用自己实现的标记堆栈而不是递归，是为了避免堆栈溢出</li></ul></li></ol><p>GC 根是 .NET 内存管理中最有用的部分，根包含可达对象的整个图并可能导致：</p><ul><li>占用大量内存</li><li>内存泄露</li></ul><p>标记机制始于各种不同类型的根并随之逐渐构建出包含所有可达对象的完整对象图。<br>注：暂存字符串和静态引用数据采用了和其它对象完全一致的标记机制。</p><h2 id="局部变量根"><a class="anchor" href="#局部变量根">#</a> 局部变量根</h2><ul><li>局部变量存储：可以存储在堆栈或 CPU 寄存器中</li><li>堆栈根：既可能位于堆栈中，也可能位于 CPU 寄存器中</li><li>词法作用域：定义了变量可见代码区域</li><li>存活堆栈根与词法作用域：在 Debug 编译模式下，JIT 编译器将所有局部变量的可达性延长至方法结束 (Release 将进行更多优化)</li><li>带有渐进式根回收的存活堆栈根：Release 模式下 JIT 将使用激进式根回收，不需要通过将局部变量设置为 null 来『通知』GC 对象不再使用，通过激进式根回收，编译器和 JIT 可以完美确定变量的实际使用范围。(编译器会优化掉冗余的 null 赋值语句)<ul><li>由于编译器会尽量最短化局部变量的生存周期，可能会进行方法『其中一部分 (调用了实例本身的语句)』的代码内联化 (不至于影响代码逻辑的情况)，以使对象可以更早被回收</li><li>GC.KeepAlive：不包含任何代码，而是使用 MethodImplOptions.NoInLining 选项为方法添加一个特性，使对象不被内联，传入参数将被视为可达</li></ul></li></ul><h3 id="gc-信息"><a class="anchor" href="#gc-信息">#</a> GC 信息</h3><p>GC 信息实际上是非常紧密的二进制数据，当前唯一可以查看 GC 信息的工具是带有 SOS 扩展的 WinDbg</p><h3 id="固定局部变量"><a class="anchor" href="#固定局部变量">#</a> 固定局部变量</h3><p>固定局部变量是一种特殊类型的局部变量，在 C# 中使用 fixed 关键字可以显式创建</p><ul><li>JIT 编译器会针对固定局部变量生成适当的 GC 信息，有关根本身的信息也被保持为固定状态。</li><li>这种被固定的根只在很短时间内可见 (仅在包含它的方法执行期间)</li></ul><h3 id="堆栈根扫描"><a class="anchor" href="#堆栈根扫描">#</a> 堆栈根扫描</h3><p>当所有线程在安全点挂起时，可以从 GC 信息中解码出存在哪些存活插槽，每个这样的插槽 (无论位于堆栈或寄存器中) 都被视为根并从它们开始执行标记遍历操作。</p><h2 id="终结根"><a class="anchor" href="#终结根">#</a> 终结根</h2><p>终结器对象第一次被回收时，放入终结器队列，会成为终结器根？</p><h2 id="gc-内部根"><a class="anchor" href="#gc-内部根">#</a> GC 内部根</h2><p>例如卡根扫描</p><h2 id="gc-句柄根"><a class="anchor" href="#gc-句柄根">#</a> GC 句柄根</h2><p>句柄有各种不同类型，全都存储在一个全局句柄表映射中。扫描句柄表后，扫描到的一组句柄类型与它们指向的目标都将被视为根。</p><ul><li>强句柄 (GCHandle.Alloc)：类似普通引用</li><li>固定句柄：强句柄的子类别</li></ul><h2 id="处理内存泄露"><a class="anchor" href="#处理内存泄露">#</a> 处理内存泄露</h2><p>持续增长的内存使用率和内存泄露一定不会是因为垃圾回收器无法正常识别对象是否处于可达状态</p><ul><li>而很可能是因为有些对象持续持有对其它对象的引用</li><li>因此关键在于找出哪些根在持续持有应当回收但始终存活的对象</li></ul><h1 id="第九章-垃圾回收-计划阶段"><a class="anchor" href="#第九章-垃圾回收-计划阶段">#</a> 第九章 垃圾回收 - 计划阶段</h1><p>标记阶段之后，所有对象都被标记为可达或不可达，那些可达对象将用一个专用位进行标记，某些被标记对象可能还要用额外一个位标记为固定的。此时，垃圾回收器已经有了启动其工作所需的所有信息。<br>计划阶段计算与压缩过程结果直接对应的所有信息，这些信息『在侧面』准备，并没有实际去移动对象。并让随后的清理和压缩阶段使用。</p><ul><li>如进行『虚假的压缩』得到结果并评估是否值得压缩</li></ul><p>注：源码中方法为 plan_phase (int)，该阶段准备了所有必要数据，后续阶段只是以适当方式使用这些数据。</p><h2 id="小对象堆"><a class="anchor" href="#小对象堆">#</a> 小对象堆</h2><h3 id="插头和间隙"><a class="anchor" href="#插头和间隙">#</a> 插头和间隙</h3><p>通过将对象组织成 slot 和 gap，可以非常高效获得如下一整套信息：</p><ul><li>压缩效率</li><li>如果是清除回收，应在哪里创建空闲列表</li><li>如果是压缩回收，将把可达对象移到哪里</li></ul><p>不过，这些数据存储在哪里？</p><ul><li>.NET 重用了托管对象标头位置</li></ul><p>如果我们适当地建立 slot 和 gap，那么每个 slot 在其之前都会具有其对应的 gap，而 gap 的内容可以安全覆盖：它只包含将不再使用的不可达对象。</p><ul><li>这样的 slot 信息精确占用 24 字节 (32 位 12 字节)</li><li>它包含相应的间隙大小、slot 重定位偏移量及一些附加数据</li></ul><p><img data-src="/blogimages/2023/2023-08-04/-697247850.jpeg" alt="-697247850.jpeg"></p><p>最后可以构建一个包含所有插头地址的二叉插头树 (组织成二叉搜索树 - BST)</p><h3 id="砖表"><a class="anchor" href="#砖表">#</a> 砖表</h3><p>插头树的根需要存储在某个地方，但为整个托管堆创建一个巨大的插头树不切实际。</p><ul><li>一种更实际的方法是为连续地址范围构建插头树</li><li>这样的范围在 CLR 中称为砖，砖大小为 2048B (32 位) 和 4096B (64 位)</li><li>砖存储在覆盖整个托管堆的砖表中</li></ul><p>通过将砖表条目与与每个插头头的左 / 右偏移量组合，可以高效地表示插头树。</p><h3 id="固定"><a class="anchor" href="#固定">#</a> 固定</h3><p>如果一个对象被固定，则很可能是因为我们想把它的地址传递给非托管代码。<br>有两种固定源：</p><ul><li>固定局部变量：fixed 关键字隐式创建的局部变量对象</li><li>固定句柄：通过固定句柄引用显式固定的对象 (GCHandle.Allocate)</li></ul><p>因为要固定，所以实际上可能有三种对象组：</p><ul><li>插头：表示一组已标记 (可达) 的对象</li><li>固定插头：表示一组被固定 (并因此标记) 的对象</li><li>间隙：表示一组未标记 (不可达) 对象</li></ul><h3 id="代边界"><a class="anchor" href="#代边界">#</a> 代边界</h3><p>在清除或压缩后，代边界将相应地更改。<br>在计划阶段，内部分配器计算插头的新地址，也计算新的代边界。</p><ul><li>所有这些操作都是在实际上没有移动任何对象的情况下完成的。</li></ul><h3 id="降级"><a class="anchor" href="#降级">#</a> 降级</h3><p>固定对象可能会提升和降级。</p><h2 id="大对象堆"><a class="anchor" href="#大对象堆">#</a> 大对象堆</h2><p>事实上，LOH 中的计划阶段几乎不需要，因为它基本只是清除 (除非我们明确要求进行压缩)</p><ul><li>仅在启用压缩时才需要大对象堆的压缩阶段</li><li>LOH 是特殊的，因为它确保只有大对象活在其中，因此有一些简化<ul><li>在每个插头前存储的信息仅包含插头的重定位偏移量</li><li>由于大对象堆内部也没有代，因此也无需重新计算代边界，也没有降级的可能性</li></ul></li></ul><p>与 SOH 相比，LOH 中的固定并没有区别，因此一样会引入可能碎片化的问题。</p><h2 id="压缩决策"><a class="anchor" href="#压缩决策">#</a> 压缩决策</h2><p>在计划阶段执行了复杂的计算后，GC 会决定是否值得压缩。大多数情况下，该决策基于碎片化级别。<br>决定压缩的原因：</p><ul><li>这是抛出 OutOfMemoryException 之前最后一个完全 GC，GC 尽可能尝试回收内存</li><li>显式指定压缩 (GC.Collect 参数)</li><li>用完了临时段中的空间</li><li>代的碎片化程度较高</li><li>系统中物理内存负载较高</li></ul><p>如上所述，决策中，代的碎片化阈值起到作用最重：</p><p><img data-src="/blogimages/2023/2023-08-04/-1519001997.jpeg" alt="-1519001997.jpeg"></p><h1 id="第十章-清除和压缩"><a class="anchor" href="#第十章-清除和压缩">#</a> 第十章 清除和压缩</h1><p>尽管大部分计算已在之前完成，但从性能开销角度看，清除和压缩仍然是性能消耗最大的一个阶段，因为修改和移动内存中数据是最耗时的操作。<br>最典型的 GC 组合是：</p><ul><li>执行 SOH 的压缩和 LOH 的清除，并在 SOH 压缩之前完成 LOH 的清除</li></ul><h2 id="清除阶段"><a class="anchor" href="#清除阶段">#</a> 清除阶段</h2><p>清除回收很简单：所有不可达对象都被转换成空闲内存空间，即 GC 把所有或某些内存间隙转换成空闲列表项。</p><h3 id="小对象堆-2"><a class="anchor" href="#小对象堆-2">#</a> 小对象堆</h3><ul><li>基于内存中的间隙创建空闲列表项<ul><li>将每个尺寸大于两个最小对象的间隙创建一个空闲列表项并组织进一个空闲列表</li><li>尺寸更小的间隙将被视为未使用空闲空间</li></ul></li><li>恢复已保存的前置和后置插头</li><li>完成其它统计工作以更新终结器队列并提升 (或降级) 适当类型的存活句柄</li><li>相应地重排段，如移除掉一些不再需要的段</li></ul><h3 id="大对象堆-2"><a class="anchor" href="#大对象堆-2">#</a> 大对象堆</h3><p>清除操作将逐个扫描对象，并简单地在被标记对象之间创建空闲列表项，所有不再需要的 LOH 段将被删除 (或启用段重用后进行缓存)</p><h2 id="压缩阶段"><a class="anchor" href="#压缩阶段">#</a> 压缩阶段</h2><p>包含两个主要子步骤：移动 (或复制) 对象并将所有指向被移动对象的引用更新到对象所在的新位置。<br>注：压缩阶段比清除阶段复杂得多，可能导致大量内存操作</p><h3 id="小对象堆-3"><a class="anchor" href="#小对象堆-3">#</a> 小对象堆</h3><ol><li>如果需要，则获取一个新的临时段</li><li>重定位引用<ul><li>堆栈上的引用</li><li>存储在跨代记忆集中的对象内的引用</li><li>SOH 和 LOH 中对象内的引用<ul><li>SOH：重定位操作大量使用砖和插头树，以快速将当前地址转换为新地址</li><li>LOH：逐个扫描存活下来的 LOH 对象</li></ul></li><li>前置和后置插头内的引用<ul><li>某些对象的结尾可能被插头信息覆盖而损坏，其原始内存内容存储在固定插头队列的条目中</li></ul></li><li>终结器队列中对象内的引用</li><li>句柄表中的引用：句柄需要更新其指针</li></ul></li><li>压缩对象<ul><li>复制对象：使用计算出的重定位偏移量逐个 slot 完成复制<ul><li>采用滑动压缩，总是首先复制低位内存空间，只要复制的单位足够小，就不会产生覆盖问题</li></ul></li><li>恢复前置和后置插头信息：从存储于固定插头队列条目内的副本中恢复对象的损坏部分</li></ul></li><li>修复代边界</li><li>若需要，删除或反提交段</li><li>创建空闲列表项</li><li>提升根</li></ol><h3 id="大对象堆-3"><a class="anchor" href="#大对象堆-3">#</a> 大对象堆</h3><p>压缩大对象堆与小对象堆类似，不过实现更简单</p><h1 id="第十一章-gc-风格"><a class="anchor" href="#第十一章-gc-风格">#</a> 第十一章 GC 风格</h1><h2 id="模式概述"><a class="anchor" href="#模式概述">#</a> 模式概述</h2><h3 id="工作站与服务器模式"><a class="anchor" href="#工作站与服务器模式">#</a> 工作站与服务器模式</h3><p>工作站模式</p><ul><li>GC 将会更频繁发生</li><li>作为上一点副作用：内存使用率将更低</li><li>只有一个托管堆</li><li>段更小</li></ul><p>服务器模式</p><ul><li>GC 的发生频率将更低</li><li>作为上一点副作用：内存使用率见更高</li><li>有多个托管堆</li><li>默认段大小更大</li><li>因此，服务器模式将消耗更多内存，但带来更小的 Time in GC 值</li></ul><h3 id="并发模式与非并非模式"><a class="anchor" href="#并发模式与非并非模式">#</a> 并发模式与非并非模式</h3><p>这两种模式在工作站与服务器模式下都支持。<br>非并发模式</p><ul><li>在 GC 期间，所有托管用户线程都将被挂起。执行完毕后恢复。</li></ul><p>并发模式</p><ul><li>并发 GC 在普通用户线程工作时运行，用户线程和回收器在工作期间必须进行额外同步。</li></ul><h2 id="模式配置"><a class="anchor" href="#模式配置">#</a> 模式配置</h2><h3 id="net-framework"><a class="anchor" href="#net-framework">#</a> .NET Framework</h3><ul><li><span class="exturl" data-url="aHR0cDovL0FTUC5ORVQ=">ASP.NET</span> WEB 应用程序：web.config</li><li>控制台应用程序或 Windows 服务：[应用程序名].exe.config</li></ul><h3 id="net-core"><a class="anchor" href="#net-core">#</a> .NET Core</h3><p>文件配置方式与 .NET Framework 相似<br>并引入了 配置旋钮 概念，可通过多种方式提供值。</p><h2 id="gc-停顿和开销"><a class="anchor" href="#gc-停顿和开销">#</a> GC 停顿和开销</h2><h2 id="模式模式"><a class="anchor" href="#模式模式">#</a> 模式模式</h2><h3 id="非并发工作站模式"><a class="anchor" href="#非并发工作站模式">#</a> 非并发工作站模式</h3><p>即典型的 GC</p><ul><li>整个 GC 期间，所有托管线程都将挂起</li><li>GC 代码在触发回收的用户线程上执行 (从分配器内部)</li><li>GC 总是在『停止世界』阶段执行</li></ul><h3 id="并发工作站模式40版本之前"><a class="anchor" href="#并发工作站模式40版本之前">#</a> 并发工作站模式 (4.0 版本之前)</h3><ul><li>有一个专用于 GC 目的的额外线程 (多数时间挂起等待)</li><li>临时回收总是非并发</li><li>完全 GC 可以两种模式执行<ul><li>并发 GC</li><li>非并发 GC</li></ul></li><li>并发完全 GC 附加特性：<ul><li>用户托管线程可能在其工作期间分配对象，此类分配仅限于临时段大小 (如果用完了将挂起，直到 GC 结束)</li><li>包含两个短的『停止世界』阶段 (开始和中间)</li><li>从 GC 开始到第二个『停止世界』阶段之前分配的对象将被提升</li><li>在第二个『停止世界』阶段之后分配的所有事物都将被提升</li></ul></li></ul><h3 id="后台工作站模式"><a class="anchor" href="#后台工作站模式">#</a> 后台工作站模式</h3><p>.NET Framework4.0 后取代并发工作站模式<br>主要改进在于：即使在并发 GC 期间，如果需要也可以触发临时 GC</p><h4 id="并发标记"><a class="anchor" href="#并发标记">#</a> 并发标记</h4><p>标记一个对象意味着在 MethodTable 中设置一个位，完成后恢复。<br>但并发工作时意味着线程可能正在使用它，因此不能这样干。</p><ul><li>并发标记会将有关标记的信息存储在一个专用的单独的标记数组中，组织结构类似于卡表</li></ul><h3 id="非并发服务器模式"><a class="anchor" href="#非并发服务器模式">#</a> 非并发服务器模式</h3><p>默认情况下，托管堆的数量与 CPU 逻辑内核一样多</p><ul><li>有专用于 GC 的线程，默认与托管堆数量相同</li><li>所有回收都是非并发 GC</li><li>标记是从多个 GC 线程并行完成</li></ul><h3 id="后台服务器模式"><a class="anchor" href="#后台服务器模式">#</a> 后台服务器模式</h3><p>最复杂的 GC，也是最消耗资源的 GC</p><ul><li>每个托管堆都有两个专用于 GC 目的的线程<ul><li>服务器 GC 线程</li><li>后台 GC 线程</li></ul></li><li>临时回收是非并发 GC</li><li>完全 GC 可能以一以下两种模式执行：<ul><li>非并发 GC</li><li>后台 GC</li></ul></li><li>后台完全 GC 还有以下额外特征：<ul><li>用户托管线程能够在其工作期间分配对象，这些分配可以触发临时回收 (前台 GC)</li><li>在后台 GC 期间，前台 GC 可能会多次发生</li><li>包含两个短暂的『停止世界』阶段 (GC 开始和中间)</li></ul></li></ul><h2 id="延迟模式"><a class="anchor" href="#延迟模式">#</a> 延迟模式</h2><ul><li>批处理模式</li><li>交互式模式</li><li>持续低延迟模式</li><li>无 GC 区域模式</li><li>延迟优化目标</li></ul><h2 id="选择-gc-风格"><a class="anchor" href="#选择-gc-风格">#</a> 选择 GC 风格</h2><p><img data-src="/blogimages/2023/2023-08-04/-1641765449.jpeg" alt="-1641765449.jpeg"></p><p>注：并发 (后台) 版本 GC 的托管堆会更大，频繁的非压缩后台 GC 会导致更严重的碎片化。</p><div class="tags"><a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 笔记</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-10-02 17:13:03" itemprop="dateModified" datetime="2023-10-02T17:13:03+08:00">2023-10-02</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>WangJiaYing <i class="ic i-at"><em>@</em></i>CWHISME</li><li class="link"><strong>本文链接：</strong> <a href="https://wangjiaying.top/2023/08/04/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-5/" title="《.NET 内存管理宝典》- 笔记 (5)">https://wangjiaying.top/2023/08/04/NET内存管理宝典-5/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/07/19/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-4/" itemprop="url" rel="prev" data-background-image="&#x2F;blogimages&#x2F;2023&#x2F;2023-06-26&#x2F;book.webp" title="《.NET内存管理宝典》-笔记(4)"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 阅读笔记</span><h3>《.NET内存管理宝典》-笔记(4)</h3></a></div><div class="item right"><a href="/2023/08/21/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-6-%E5%AE%8C/" itemprop="url" rel="next" data-background-image="&#x2F;blogimages&#x2F;2023&#x2F;2023-06-26&#x2F;book.webp" title="《.NET内存管理宝典》-笔记(6)[完]"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 阅读笔记</span><h3>《.NET内存管理宝典》-笔记(6)[完]</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">第七章 垃圾回收 - 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%B1%82%E8%A7%86%E5%9B%BE"><span class="toc-number">2.1.</span> <span class="toc-text">高层视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gc-%E8%BF%87%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.</span> <span class="toc-text">GC 过程示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-0-%E4%BB%A3%E8%A2%AB%E5%88%A4%E5%86%B3%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">第 0 代被判决的垃圾回收：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-1-%E4%BB%A3%E8%A2%AB%E5%88%A4%E5%86%B3%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">第 1 代被判决的垃圾回收：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-2-%E4%BB%A3%E8%A2%AB%E5%88%A4%E5%86%B3%E5%AE%8C%E5%85%A8gc"><span class="toc-number">2.2.3.</span> <span class="toc-text">第 2 代被判决 (完全 GC)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gc-%E8%BF%87%E7%A8%8B%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.3.</span> <span class="toc-text">GC 过程步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">2.4.</span> <span class="toc-text">垃圾回收数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">2.4.1.</span> <span class="toc-text">静态数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">2.4.2.</span> <span class="toc-text">动态数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">2.5.</span> <span class="toc-text">回收触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text">分配触发器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">显式触发器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8E%E5%86%85%E5%AD%98%E7%BA%A7%E5%88%AB%E7%B3%BB%E7%BB%9F%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">2.5.3.</span> <span class="toc-text">低内存级别系统触发器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%86%85%E9%83%A8%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">2.5.4.</span> <span class="toc-text">各种内部触发器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ee-%E6%8C%82%E8%B5%B7"><span class="toc-number">2.6.</span> <span class="toc-text">EE 挂起</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="toc-number">3.</span> <span class="toc-text">第八章 垃圾回收 - 标记阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E6%A0%87%E8%AE%B0"><span class="toc-number">3.1.</span> <span class="toc-text">对象的遍历与标记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%A0%B9"><span class="toc-number">3.2.</span> <span class="toc-text">局部变量根</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gc-%E4%BF%A1%E6%81%AF"><span class="toc-number">3.2.1.</span> <span class="toc-text">GC 信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">固定局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E6%A0%B9%E6%89%AB%E6%8F%8F"><span class="toc-number">3.2.3.</span> <span class="toc-text">堆栈根扫描</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%E6%A0%B9"><span class="toc-number">3.3.</span> <span class="toc-text">终结根</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gc-%E5%86%85%E9%83%A8%E6%A0%B9"><span class="toc-number">3.4.</span> <span class="toc-text">GC 内部根</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gc-%E5%8F%A5%E6%9F%84%E6%A0%B9"><span class="toc-number">3.5.</span> <span class="toc-text">GC 句柄根</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">3.6.</span> <span class="toc-text">处理内存泄露</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E8%AE%A1%E5%88%92%E9%98%B6%E6%AE%B5"><span class="toc-number">4.</span> <span class="toc-text">第九章 垃圾回收 - 计划阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E5%AF%B9%E8%B1%A1%E5%A0%86"><span class="toc-number">4.1.</span> <span class="toc-text">小对象堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%A4%B4%E5%92%8C%E9%97%B4%E9%9A%99"><span class="toc-number">4.1.1.</span> <span class="toc-text">插头和间隙</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%96%E8%A1%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">砖表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A"><span class="toc-number">4.1.3.</span> <span class="toc-text">固定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E8%BE%B9%E7%95%8C"><span class="toc-number">4.1.4.</span> <span class="toc-text">代边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%8D%E7%BA%A7"><span class="toc-number">4.1.5.</span> <span class="toc-text">降级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%A0%86"><span class="toc-number">4.2.</span> <span class="toc-text">大对象堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%86%B3%E7%AD%96"><span class="toc-number">4.3.</span> <span class="toc-text">压缩决策</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%B8%85%E9%99%A4%E5%92%8C%E5%8E%8B%E7%BC%A9"><span class="toc-number">5.</span> <span class="toc-text">第十章 清除和压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5"><span class="toc-number">5.1.</span> <span class="toc-text">清除阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E5%AF%B9%E8%B1%A1%E5%A0%86-2"><span class="toc-number">5.1.1.</span> <span class="toc-text">小对象堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%A0%86-2"><span class="toc-number">5.1.2.</span> <span class="toc-text">大对象堆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E9%98%B6%E6%AE%B5"><span class="toc-number">5.2.</span> <span class="toc-text">压缩阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E5%AF%B9%E8%B1%A1%E5%A0%86-3"><span class="toc-number">5.2.1.</span> <span class="toc-text">小对象堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%A0%86-3"><span class="toc-number">5.2.2.</span> <span class="toc-text">大对象堆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-gc-%E9%A3%8E%E6%A0%BC"><span class="toc-number">6.</span> <span class="toc-text">第十一章 GC 风格</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">模式概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E7%AB%99%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.1.</span> <span class="toc-text">工作站与服务器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%9D%9E%E5%B9%B6%E9%9D%9E%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.2.</span> <span class="toc-text">并发模式与非并非模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE"><span class="toc-number">6.2.</span> <span class="toc-text">模式配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#net-framework"><span class="toc-number">6.2.1.</span> <span class="toc-text">.NET Framework</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#net-core"><span class="toc-number">6.2.2.</span> <span class="toc-text">.NET Core</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gc-%E5%81%9C%E9%A1%BF%E5%92%8C%E5%BC%80%E9%94%80"><span class="toc-number">6.3.</span> <span class="toc-text">GC 停顿和开销</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text">模式模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%B9%B6%E5%8F%91%E5%B7%A5%E4%BD%9C%E7%AB%99%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.1.</span> <span class="toc-text">非并发工作站模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%B7%A5%E4%BD%9C%E7%AB%99%E6%A8%A1%E5%BC%8F40%E7%89%88%E6%9C%AC%E4%B9%8B%E5%89%8D"><span class="toc-number">6.4.2.</span> <span class="toc-text">并发工作站模式 (4.0 版本之前)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E5%B7%A5%E4%BD%9C%E7%AB%99%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.3.</span> <span class="toc-text">后台工作站模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0"><span class="toc-number">6.4.3.1.</span> <span class="toc-text">并发标记</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.4.</span> <span class="toc-text">非并发服务器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.5.</span> <span class="toc-text">后台服务器模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.5.</span> <span class="toc-text">延迟模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9-gc-%E9%A3%8E%E6%A0%BC"><span class="toc-number">6.6.</span> <span class="toc-text">选择 GC 风格</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8A/" rel="bookmark" title="《CLR VIR C#》笔记(上)">《CLR VIR C#》笔记(上)</a></li><li><a href="/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="bookmark" title="《CLR VIR C#》笔记(下)-多线程">《CLR VIR C#》笔记(下)-多线程</a></li><li><a href="/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%AE%8C%E7%BE%8E%E5%BC%80%E5%8F%91-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《设计模式与游戏完美开发》-笔记">《设计模式与游戏完美开发》-笔记</a></li><li><a href="/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《数据结构与算法之美》-笔记">《数据结构与算法之美》-笔记</a></li><li><a href="/2023/06/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8_1/" rel="bookmark" title="《.NET内存管理宝典》-笔记(1)">《.NET内存管理宝典》-笔记(1)</a></li><li><a href="/2023/06/26/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-2/" rel="bookmark" title="《.NET内存管理宝典》-笔记(2)">《.NET内存管理宝典》-笔记(2)</a></li><li><a href="/2023/07/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-3/" rel="bookmark" title="《.NET内存管理宝典》-笔记(3)">《.NET内存管理宝典》-笔记(3)</a></li><li><a href="/2023/07/19/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-4/" rel="bookmark" title="《.NET内存管理宝典》-笔记(4)">《.NET内存管理宝典》-笔记(4)</a></li><li class="active"><a href="/2023/08/04/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-5/" rel="bookmark" title="《.NET内存管理宝典》-笔记(5)">《.NET内存管理宝典》-笔记(5)</a></li><li><a href="/2023/08/21/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-6-%E5%AE%8C/" rel="bookmark" title="《.NET内存管理宝典》-笔记(6)[完]">《.NET内存管理宝典》-笔记(6)[完]</a></li><li><a href="/2023/09/25/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《游戏编程模式》-笔记">《游戏编程模式》-笔记</a></li><li><a href="/2023/10/02/CPP_Primer_%E7%AC%AC%E4%BA%94%E7%89%88_%E7%AC%94%E8%AE%B0-1/" rel="bookmark" title="《C++ Primer(第五版)》-笔记(1)">《C++ Primer(第五版)》-笔记(1)</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="WangJiaYing" data-src="/images/../img/avator"><p class="name" itemprop="name">CWHISME</p><div class="description" itemprop="description">己所不欲，勿施于人</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">122</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">22</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">32</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N3aGlzbWU=" title="https:&#x2F;&#x2F;github.com&#x2F;cwhisme"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9jd2hpc21lLTMzL3Bvc3Rz" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;cwhisme-33&#x2F;posts"><i class="ic i-zhihu"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmN3aGlzbWVAMTI2LmNvbQ==" title="mailto:cwhisme@126.com"><i class="ic i-envelope"></i></span> <a href="/atom.xml" title="&#x2F;atom.xml" class="item feedback"><i class="ic i-heart"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-clock"></i>统计</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/07/19/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-4/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/08/21/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-6-%E5%AE%8C/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Unity3D/" title="分类于 Unity3D">Unity3D</a> <i class="ic i-angle-right"></i> <a href="/categories/Unity3D/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" title="分类于 图形学">图形学</a></div><span><a href="/2021/01/26/Unity3DSahder%E5%85%B3%E9%94%AE%E5%AD%97/" title="Unity3D Sahder 关键字">Unity3D Sahder 关键字</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%90%86%E8%AE%BA%E7%A0%94%E7%A9%B6/" title="分类于 理论研究">理论研究</a></div><span><a href="/2021/07/07/%E6%88%98%E6%96%97%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="关于手游战斗系统">关于手游战斗系统</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%90%86%E8%AE%BA%E7%A0%94%E7%A9%B6/" title="分类于 理论研究">理论研究</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%90%86%E8%AE%BA%E7%A0%94%E7%A9%B6/C/" title="分类于 C#">C#</a></div><span><a href="/2022/12/10/%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/" title="协变和逆变">协变和逆变</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment count_3"></ul></div></div><div class="status"><div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">WangJiaYing @ Jiaying's Note</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">719k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">10:54</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NXSElTTUUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/08/04/NET内存管理宝典-5/",favicon:{show:"（●´3｀●）",hide:"(´Д｀)"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,justifiedGallery:!0,jquery:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script><script src="https://cdn.staticfile.org/pjax/0.2.8/pjax.min.js"></script><script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script><script src="https://cdn.staticfile.org/algoliasearch/4.17.0/algoliasearch-lite.umd.js"></script><script src="https://cdn.staticfile.org/instantsearch.js/4.54.1/instantsearch.production.min.js"></script><script src="https://cdn.staticfile.org/lozad.js/1.16.0/lozad.min.js"></script><script src="https://cdn.staticfile.org/quicklink/2.3.0/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/js/DateTimeAfeterCalc.js" async></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js" async></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?62952472c154f9131a14a4ab57bfefec";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html>