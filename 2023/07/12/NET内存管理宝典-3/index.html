<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="CWHISME" href="https://wangjiaying.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="CWHISME" href="https://wangjiaying.top/atom.xml"><link rel="alternate" type="application/json" title="CWHISME" href="https://wangjiaying.top/feed.json"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="笔记"><link rel="canonical" href="https://wangjiaying.top/2023/07/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-3/"><title>《.NET 内存管理宝典》- 笔记 (3) - 阅读笔记 | Jiaying's Note = CWHISME = 人不能没有梦想，也要有足够的敬畏</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">《.NET 内存管理宝典》- 笔记 (3)</h1><div class="meta"><span class="item" title="创建时间：2023-07-12 15:38:51"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-07-12T15:38:51+08:00">2023-07-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>8.9k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>8 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiaying's Note</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/blogimages/2023/2023-06-26/book.webp"></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" itemprop="item" rel="index" title="分类于 阅读笔记"><span itemprop="name">阅读笔记</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangjiaying.top/2023/07/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/../img/avator"><meta itemprop="name" content="WangJiaYing"><meta itemprop="description" content="人不能没有梦想，也要有足够的敬畏, 己所不欲，勿施于人"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="CWHISME"></span><div class="body md" itemprop="articleBody"><h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本篇包含原书的第三章和第四章，第三章主要讲了一些测试工具使用，我自己也看得也比较囫囵吞枣 (毕竟个人是搞 Unity3D，这块多数工具基本都是没用的，当然部分理论依然还是可以参考的)。</p><p>其次是第四章的 <code>.NET基础知识</code> ，这一章名字说是基础知识，实际上还是比较深入的，比如各个字段的内存区域、详细描述了为什么值类型 <code>更快</code> 等等。评价是 <code>比较重要</code> 。</p><h1 id="第三章-内存测量"><a class="anchor" href="#第三章-内存测量">#</a> 第三章 内存测量</h1><h2 id="尽早测量"><a class="anchor" href="#尽早测量">#</a> 尽早测量</h2><p>与其过早地专注于优化，不如先测量评估一下我们是否有这方面的需求。</p><h3 id="开销和侵入性"><a class="anchor" href="#开销和侵入性">#</a> 开销和侵入性</h3><p>开销：额外消耗<br>侵入性：游戏应用程序本身功能</p><h3 id="采样与跟踪"><a class="anchor" href="#采样与跟踪">#</a> 采样与跟踪</h3><p>跟踪：诊断数据在特定的、被关注的时间触发时收集 (基于事件)，优势是具有数据精确性。<br>采样：可以接受数据精度丢失，仅间隔一定时间搜集 (基于时间) 采样频率越低，从测量中得到的数据就越不精确。</p><h3 id="调用树"><a class="anchor" href="#调用树">#</a> 调用树</h3><ul><li>独占：仅包含该特定函数的值。</li><li>包含：测量该特定函数的值及其所有子函数的测量值的总和。(在该函数时间、它所调用的所有其它函数的时间，及调用的所有函数等时间总和)</li></ul><p>浏览这个树，我们可以很快找出最慢的函数，或不一定很慢但被多次调用的方法。<br>同样的想法亦可用于可视化内存使用情况，其每个节点代表一种特定类型对象，子级是该对象包含或引用的该对象实例的其它类型。<br><img data-src="/blogimages/2023/2023-07-12/1390063999.jpeg" alt="1390063999.jpeg"></p><h3 id="对象图"><a class="anchor" href="#对象图">#</a> 对象图</h3><p>表示内存中对象之间关系的图，称为对象图或引用图。</p><ul><li>最短根路径：取决于所选对象，从特定对象到某个根的引用的最短路径。</li><li>依赖关系子图：取决于所选对象，是包含对象本身以及被其直接或间接引用的所有对象的子图。</li><li>保留子图：取决于所选定对象，指如果删除了给定对象本身则也会被删除的对象的子图。<ul><li>(因为依赖关系图很复杂，因此删除对象并不意味着所有依赖于它的对象都被删除了，对它们的引用可能仍然由其它对象保留着)</li></ul></li></ul><p>指示对象大小</p><ul><li>浅大小：对象本身大小 (其所有字段、包括对其它对象的引用的大小)</li><li>总大小：对象的浅大小与其直接或间接引用的所有对象的浅大小之和</li><li>保留大小：保留子图中所有对象的总和，即保留大小是删除给定对象后可以释放的内存量。对象图中不同引用共享的对象越多，保留大小就越小于总大小。（需要对整个对象图进行复杂分析）</li></ul><h3 id="统计"><a class="anchor" href="#统计">#</a> 统计</h3><ul><li>平均值：直观，计算方便，但是其结果没有指向任何特定样本，且容易掩盖数据分发的真实本质。</li><li>中位数：将样本分为高低两半的值</li><li>百分位数：低于给定百分比的样本的值</li><li>直方图：样本分布的图形表示（最好的测量方法）</li></ul><h3 id="延迟与吞吐量"><a class="anchor" href="#延迟与吞吐量">#</a> 延迟与吞吐量</h3><p>阿姆达尔定律</p><ul><li>潜在的延迟加速受程序的串行 (无法并行化) 部分的限制。</li><li>例如，如果程序的 90% 部分可以并行化，但仍有 10% 的部分必须正常执行，那么最大潜在加速度被限制为最多 10 倍。</li></ul><h3 id="内存转储-跟踪-实时调试"><a class="anchor" href="#内存转储-跟踪-实时调试">#</a> 内存转储、跟踪、实时调试</h3><p>监视：通过跟踪或采样方式生成诊断信息。<br>内存转储：在给定时刻保存进程的内存状态。</p><ul><li>如果没有时间变化背景，有时很难得出具体结论，因此一般进行两个或多个内存转储并相互比较。</li><li>崩溃转储可作为内存转储一种特殊情况</li></ul><p>实时调试：最具侵入性的方法，将调试器直接连接到进程上，然后逐步分析应用程序。</p><h2 id="windows-环境"><a class="anchor" href="#windows-环境">#</a> Windows 环境</h2><h3 id="vmmap"><a class="anchor" href="#vmmap">#</a> VMMap</h3><p>查看进程内存使用情况分析，vmmap 检测 .net 托管堆使用的页以及专用于堆栈或加载的二进制文件专用的页。</p><h3 id="性能计数器"><a class="anchor" href="#性能计数器">#</a> 性能计数器</h3><ul><li>性能计数器值的读取完全由我们使用的工具采样的频率来控制。</li><li>仅当发生特定事件时，才会更新性能计数器数据，之后其值将一直保持不变。</li></ul><h3 id="windows-事件跟踪"><a class="anchor" href="#windows-事件跟踪">#</a> Windows 事件跟踪</h3><p>EWT<br>（诊断功能强大）</p><h3 id="windows-性能工具包"><a class="anchor" href="#windows-性能工具包">#</a> Windows 性能工具包</h3><p>Windows performance toolkit,WPT 是 Windows 环境中的一组诊断工具，具有搜集和分析 EWT 数据能力。</p><ul><li>Windows performance recorder (WPR，Windows 性能记录器)：充当 EWT 的控制器</li><li>Windows performance analyzer (WPA，Windows 性能分析器)：充当 EWT 的使用者</li></ul><h3 id="perfview"><a class="anchor" href="#perfview">#</a> PerfView</h3><h3 id="procdump-debugdiag"><a class="anchor" href="#procdump-debugdiag">#</a> ProcDump、DebugDiag</h3><p>进行内存转储的工具<br>前着为命令行，后者为 GUI 工具</p><h3 id="windbg"><a class="anchor" href="#windbg">#</a> WinDbg</h3><p>最底层的工具，不管是 net 托管程序还是原生 Windows 应用程序或调试内核本身。<br>也可以直接附加到托管程序并调试。<br>默认情况下，windbg 作为原生调试器工作，因此必须使用 windbg 扩展以为其提供 net 相关概念：</p><ul><li>SOS</li><li>SOSEX</li><li>NetExt 和 MEX</li></ul><p>由于一次又一次地输入所有命令非常麻烦，可使用命令树窗口简化。</p><h3 id="benchmarkdotnet"><a class="anchor" href="#benchmarkdotnet">#</a> BenchmarkDotNet</h3><p>代码性能测量</p><h3 id="商业工具"><a class="anchor" href="#商业工具">#</a> 商业工具</h3><p>visual studio<br>Scitech .Net Memory Profiler<br>JetBrain dotMemory<br>RedGate ANTS Memory Profiler<br>Intel VTune Amplifier 和 AMD CodeAnalyst Performance Analyzer</p><ul><li>专门用于基于硬件的底层代码分析，这些工具通常由处理器制造商提供</li><li>可以从硬件中内置的硬件计数器中获取其有关内部行为的信息：缓存和内存利用率、管道停顿等</li><li>只有这样的底层工具才能清楚地指出诸如第二章中显示的伪共享之类的问题。</li></ul><p>Dynatrace 和 AppDynamics</p><ul><li>用于监视应用程序性能的上层工具，可持续收集数据</li></ul><h2 id="linux-环境"><a class="anchor" href="#linux-环境">#</a> Linux 环境</h2><p>略</p><h1 id="第四章-net基础知识"><a class="anchor" href="#第四章-net基础知识">#</a> 第四章 .NET 基础知识</h1><p>.NET 整个概念都基于 common language infrastructure (CLI) 的规范，CLI 描述了代码和运行时 环境的概念，并确保无需重新编译的情况在不同计算机运行。<br>有很多不同 .NET 实现，此处略。</p><h2 id="net-内部原理"><a class="anchor" href="#net-内部原理">#</a> .NET 内部原理</h2><p>代码被编译为 CIL (common intermediate language) 然后由 common language runtime (CLR) 执行。CLR 是托管环境的执行核心。<br>CLR 主要职责：</p><ul><li>JIT 编译器：将 cil 代码转换为机器码。这种执行托管代码方式其实是对原生系统机制的巧妙封装，就像内存管理包含了线程堆栈和堆一样。</li><li>类型系统：负责管理类型控制和兼容性机制。包括 common type system (CTS) 和 (用于反射机制的) 元数据。</li><li>异常处理：负责在用户程序和运行时两个层次上进行异常处理。</li><li>内存管理 (通常指垃圾回收器)：运行时中管理内存的组件。</li><li>执行引擎：负责大部分运行时的职责，包括 jit 编译和异常处理，ecma-335 中被称为虚拟执行系统 (VES)，负责加载和运行为 cli 编写的程序。</li><li>垃圾回收器：负责内存管理、对象分配，回收不再使用的内存区域。</li></ul><p>托管代码：包含足够额外信息的代码，这些信息用于使 CLI 为代码执行提供一组核心服务。</p><ul><li>如给出代码中一个方法地址，CLI 必须能够定位到描述该方法的元数据，还必须能够遍历 stack、处理异常、存储和获取安全信息。</li></ul><p>一些误解：</p><ul><li>.NET 并非一般意义上的虚拟机，.NET 运行时不会创建一个隔离环境，也不会模拟任何特定的架构或计算机。其重用了诸如操作系统内存管理之类的内置系统资源，包括 heap、stack、进程和线程等，然后再在这些内置资源之上构建一些附加功能 (自动内存管理等)</li><li>计算机不会始终运行着一个 .NET 运行时，每个 .NET 程序运行时才被加载和执行</li></ul><p>.maxstack：</p><ul><li>不是 CIL 指令，而是一个元数据描述，其它工具可以使用它验证代码安全性 (防止缓冲区溢出攻击)。其描述了方法执行期间 evaluation stack 中最多可以分配多少字节。</li></ul><p>.NET stack machine 的位置概念：</p><ul><li>方法中局部变量</li><li>方法参数</li><li>另一个值的实例字段</li><li>(类、接口或模块的) 静态字段</li><li>本地内存池</li><li>暂时放在 evaluation stack 上</li></ul><p>JIT 编译器会负责将每个 逻辑位置 映射到特定的计算机架构 (即寄存器操作的机器码)。</p><h2 id="程序集和应用程序域"><a class="anchor" href="#程序集和应用程序域">#</a> 程序集和应用程序域</h2><p>为满足安全性、可靠性或版本化需求，应用程序域提供将应用程序代码不同部分隔离到应用程序域中的功能。</p><ul><li>注：由于为使得 .NET Core 保持精简，应用程序域已移除，不过 CoreCLR 内部依然使用了应用程序域</li><li>（微软建议开放人员使用进程或新式容器实现 .NET Core 程序隔离）</li></ul><p>应用程序域分类：</p><ul><li>共享域：不同应用程序域之间共享代码加载此域。包括 basic class library、system 命名空间中的类型</li><li>系统域：核心运行时组件加载到此域，负责创建和初始化其它应用程序域。还保存了进程范围内暂存的字符串文本。</li><li>默认域：用户代码会加载至该域。</li><li>动态域：通过 AppDomain.CreateDomain 根据需要创建，.NET Core 不提供该功能。</li></ul><p>所有共享代码由共享域负责处理，所有用户代码由单个默认域处理。系统域仅存在结构和逻辑，在进程内存中不可见。</p><h2 id="进程内存区域"><a class="anchor" href="#进程内存区域">#</a> 进程内存区域</h2><p>每个应用程序域，包括共享域、系统域、默认域及其它所有动态加载的域，都各自有自己的一组堆：</p><ul><li>High Frequency Heap (高频堆)：应用程序域基于其内部目的，将频繁访问的数据存储于此。<ul><li>CoreCLR 描述：这些堆用于分配应用程序域生命周期内始终存在的数据。为更好管理 page，应将频繁分配的对象分配到高频堆。</li><li>如详细的方法和字段描述等基元静态数据也存放在这。</li></ul></li><li>Low Frequency Heap (低频堆)：包含了较少使用的类型相关数据，如 EEClass、JIT 编译、反射、类型加载机制所需要的其它数据。</li><li>Stub Heap：文档描述 -- 保存了实现代码访问安全 (CAS)、COM 包装调用和 P/Invoke 的 sub</li><li>Virtual Call Stub：包含用于虚拟 stub 调度 (VSD) 技术所使用的数据结构和代码。<ul><li>VSD 技术：使用 stub 用于虚拟方法调用，而非使用传统的虚拟方法表。</li></ul></li><li>High Frequency Heap、Low Frequency Heap、Stub Heap 和各种 Virtual Call Stub 都统称为 Loader Heap 类型，因为它们存储的都是类型系统所需的各种数据 (因此加载任何一个类型时都需要它们)<ul><li>即虽然有 Loader Heap 这个术语，但内存其实不存在一个 Loader Heap，而是代表上述内存区域统称</li><li>注：加载至 Loader Heap 区域的类型的生命周期跟随应用程序域。</li></ul></li></ul><h2 id="类型系统"><a class="anchor" href="#类型系统">#</a> 类型系统</h2><p>Common Type System (通用类型系统)<br>.NET 中每种类型都由一个称为 MethodTable 的数据结构描述，其中包含类型的大量信息，最重要的有：</p><ul><li>GCInfo：用于垃圾回收器用途的数据结构</li><li>标志：描述各种类型的属性</li><li>基本实例大小：每个对象的大小</li><li>EEClass 引用：存储通常仅用于类型加载、JIT 编译或反射的『冷』数据，包括所有方法、字段和接口的描述信息。</li><li>调用所有方法 (包括继承自基类的方法) 所需要的描述信息。</li><li>静态字段有关的数据：包括与基元静态字段有关的数据。</li></ul><p>只要有需要，运行时将通过访问 MethodTable 的地址 (表示为 TypeHandle) 获取被加载的类型信息。</p><h3 id="类型的分类"><a class="anchor" href="#类型的分类">#</a> 类型的分类</h3><ul><li>值类型：这种类型的实例直接包含其所有数据 (值类型的值是自包含的)</li><li>引用类型：这种类型的实例包含对其数据的引用 (引用类型所描述的值指示其它值的位置)</li></ul><h4 id="生存期"><a class="anchor" href="#生存期">#</a> 生存期</h4><ul><li>值类型实例包含的数据，其生存期与实例本身一样长</li><li>引用类型的值描述了其它值的位置，那些值的生存期并不取决于引用类型值本身</li></ul><h4 id="可共享性"><a class="anchor" href="#可共享性">#</a> 可共享性</h4><ul><li>值类型的值不可共享，如果想在其它地方使用，默认只会按照字节复制一份出来。复制值不影响原始值。</li><li>引用类型的值可被共享，在传递之后会多出一个指向同一个位置的引用类型实例。</li></ul><h4 id="相等性"><a class="anchor" href="#相等性">#</a> 相等性</h4><ul><li>值类型不存在相等性，当且仅当它们值的二进制序列一样时才认为完全相同</li><li>引用类型当且仅当它们指示的位置一样就是完全相同的</li></ul><h3 id="类型的存储"><a class="anchor" href="#类型的存储">#</a> 类型的存储</h3><p>存储在堆栈，还是存储在堆？这是实现细节上的决策。通常值类型和引用类型存储位置的说法，并不准确，因为他们存在包含关系。<br>注：CLI 标准中并未指定关于存储位置的任何实现细节决策。</p><h3 id="值类型"><a class="anchor" href="#值类型">#</a> 值类型</h3><p>ECMA335：类似整数或浮点数，值类型使用了一种简单的将数据直接按位存储模式。每个值都有一个类型，该类型描述了它使用的存储空间以及它的表现方法中各个位 (bit) 的含义，也描述了对该表现方式进行的操作。在编程语言中，值通常用于表现简单类型和非对象。<br>通用语言规范 (CLS) 定义了两种值类型：</p><ul><li>结构：包括许多内置整型类型 (char/byte/integer)、浮点类型和布尔类型</li><li>枚举：基本是整型类型的扩展，由一组命名常量构成。从内存管理的角度看就是整型类型（内部本质上是结构）</li></ul><h4 id="值类型的存储"><a class="anchor" href="#值类型的存储">#</a> 值类型的存储</h4><p>『堆栈是一种轻量级机制，只需要创建一个大小合适的 activation frame 并在不再需要时将其关闭，就可以在堆栈上 分配 和 回收 对象』<br>但堆栈的生存期和值本身需要的生存期不匹配，生存期和值共享这两个因素，决定我们可以使用何种机制存储值类型数据。<br>值类型可能出现位置：</p><ul><li>方法中局部变量：具有非常严格和定义良好的生存期，其长度和方法的调用时长相同。<ul><li>CLI 指出：引用局部变量或参数变量的托管指针，有可能出现引用失效的问题，因为它的行为无法验证。</li></ul></li><li>方法的参数：可以完全被视作局部变量。</li><li>引用类型的实例字段：其生存期取决于父值的生存期。将于引用类型一并被分配于堆。</li><li>另一个值类型的实例字段：跟随父值。</li><li>(类 / 接口 / 模块中的) 静态字段：静态字段的生存期和定义此字段的类型等长，因此肯定不能使用堆栈保存。</li><li>局部内存池：生存周期与方法生存期严格等长，堆栈</li><li>evaluation stack 上临时值：处于性能考虑，JIT 显然会尽量使用 CPU 寄存器和堆栈。</li></ul><h4 id="结构"><a class="anchor" href="#结构">#</a> 结构</h4><ul><li>分配于堆上而非栈上：可以从实现细节上受益，例如避免 GC 管理它们所带来的开销。</li><li>较小：结构只存储其数据而无需存储任何额外的元数据，因此所需内存更小。</li><li>提供了更佳的数据局部性：由于结构更小，因此可以更密集地在集合中打包数据。</li><li>访问速度更快：直接包含数据，因此访问时无需进行额外的解引用 (dereferencing) 操作。</li><li>天然具有传值语义</li></ul><h4 id="结构概述"><a class="anchor" href="#结构概述">#</a> 结构概述</h4><p><img data-src="/blogimages/2023/2023-07-12/1515094104.jpeg" alt="1515094104.jpeg"></p><p>上图内存区域可能位于堆栈、堆，甚至 CPU 寄存器。<br>不过当前 CLR 实现不允许直接在托管堆上使用上述布局，托管堆中的对象必须是自描述的引用类型。因此当需要在堆中存储结构时，将执行装箱 (boxing)。</p><ul><li>当结构被装箱，就将很难再获得结构的种种优点。结构的真正能力只在未被装箱的情况才能得以体现。</li></ul><p>优化内存和性能的核心规则之一是：避免分配，结构即是帮助我们应用这条规则的利器。<br>此外，由于结构的限制，比如不带继承功能，可以让编译器可以对其使用方式进行大量预判。</p><h4 id="结构的存储"><a class="anchor" href="#结构的存储">#</a> 结构的存储</h4><ul><li>ldloca.s 0：将第一个局部变量的地址推入 evaluation stack</li><li>initobj：从 evaluation stack 取出并移除地址，将其指向内存初始化为指定类型初始值</li><li>ldarg.0：将方法的第一个参数 (实例方法为 this) 推入 evaluation stack（后续参数依此类推）</li><li>ldloc.0：将第一个局部变量的值推入 evaluation stack</li><li>call：调用方法，结果放入 evaluation stack</li><li>ret：从方法返回至调用者</li><li>newobj：堆分配</li></ul><p>对于小型结构数据，JIT 可以仅使用 CPU 寄存器从而完全避免使用堆栈以极大优化性能 (生成的机器码中彻底没有了结构的概念)。<br>还可以对 (大型) 结构体使用传引用优化复制效率。<br>结构是高效的数据容器，其简洁性提供了极大的代码优化潜力，『局部结构类型变量被分配在堆栈上』确实不假，但实际情况可能比这更好，局部变量可以被优化成完全由 CPU 寄存器处理而无需用到堆栈，从而使按值传递也不过需要对 CPU 寄存器进行一些操作而已。<br>注 1：release 和 debug 模式编译后代码有很大差异。<br>注 2：影响 JIT 优化与否的大小大概是 24 字节，可以安全假设 JIT 将对不超过 16 字节的结构进行优化。(注意测试代码是 64 位 RyuJIT 编译器)<br>注 3：在一个结构体方法中可以将新值赋给 this 字段，是由于结构体直接存储数据，可看作再次初始化。</p><h3 id="引用类型"><a class="anchor" href="#引用类型">#</a> 引用类型</h3><p>通用规范中定义了两种主要的引用类型：</p><ul><li>对象类型： ECMA335 所述，对象是 自描述值的引用类型，类型显示存储于其表现形式中。包括类和委托。</li><li>指针类型：一个指向某个内存位置的特定于当前计算机的纯地址。指针分为托管指针和非托管指针两种。</li></ul><p>概念区分：</p><ul><li>一个引用类型的值是对其数据的引用，引用本身可被视为一个值类型，内部是个 32 位或 64 位地址，引用具有传值语义。</li><li>引用类型的数据：被引用的一段内存区域，标准中并未定义数据的存储位置，反正它肯定存储在引用本身以外的其它位置。</li></ul><p>引用可以被视为指针的一种，但与普通指针不同的是运行时为引用提供了额外的安全性。</p><p><img data-src="/blogimages/2023/2023-07-12/-1385607071.jpeg" alt="-1385607071.jpeg"></p><p>注：存在一种逃逸分析的技术，也许可以让类分配于堆栈，不过 .NET 目前不支持。</p><h4 id="类"><a class="anchor" href="#类">#</a> 类</h4><p>由于 .NET 内存管理的设计方式，堆上每个对象都有严格的内存布局：</p><ul><li>object header：存储了需要附加到对象上的所有附加信息，大多数时候都是 0。<ul><li>常见的用途有：此对象上的 lock 信息或 GetHashCode 结果缓存值（遵循先到先得规则）</li></ul></li><li>method table reference：即 MethodTable 引用，指向类型描述数据结构中的一个相应条目 (位于 high frequency heap)。这里也是对象相互引用时的引用点。</li><li>数据占位符 (若类型没有字段)：当前垃圾回收器要求每个对象都至少有一个指针大小的字段。<ul><li>该字段不必专门用于垃圾回收，而是可以其它各种用途重用 (如用作存储对象第一个字段 - 如果有的话)</li></ul></li></ul><p><img data-src="/blogimages/2023/2023-07-12/-1159290546.jpeg" alt="-1159290546.jpeg"></p><p>堆上每个对象都至少包含上述三个字段。<br>32 位 最小堆对象为 12 字节：</p><ul><li>4 字节用于对象标头</li><li>4 字节 (一个指针大小) 用于 method table reference</li><li>4 字节 (一个指针大小) 用于内部数据占位符</li></ul><p>64 位 最小堆对象位 24 字节：</p><ul><li>8 字节用于对象标头：实际只用到 4 个字节，另外以 0 填充的 4 字节仅用于对齐目的（64 位架构基于 8 字节对齐）</li><li>8 字节 (一个指针大小) 用于 method table reference</li><li>8 字节 (一个指针大小) 用于内部数据占位符</li></ul><p>一个包含 1 字节数据的分配于堆栈上的结构仅占用 1 字节空间 (内存对齐可能有额外开销)，而一个包含 1 字节数据的分配于堆上的类将在 64 位运行时占用 24 字节空间，两者内存开销相差明显。<br>另外，类生成的最终汇编代码也比结构更复杂，在测试代码中，类的性能与结构之间相差超过 4 倍。</p><h2 id="字符串"><a class="anchor" href="#字符串">#</a> 字符串</h2><p>字符串不可变性仅体现在 Basic Class Library 未提供任何修改字符串的 API，但在运行时并没有这个限制。</p><ul><li>它只是一段连续的、以某种方式表示字符的字节区块，完全可以使用 unsafe 模式使用指针修改 —— 当然这种做法是不受支持的。</li></ul><p>string.format、string.join 等常见辅助函数内部已经使用了 stringbuilder，为进一步优化甚至甚至进一步封装了 StringBuilderCache</p><ul><li>StringBuilderCache 内部存储了一个 thread static stringbuilder，每个线程上都会创建一个专门的实例，因此是线程安全的。</li></ul><p>字符串不可变优缺点：</p><ul><li>优点<ul><li>安全性</li><li>并发性</li></ul></li><li>缺点<ul><li>修改操作将导致额外字符串实例</li></ul></li></ul><h3 id="字符串暂存"><a class="anchor" href="#字符串暂存">#</a> 字符串暂存</h3><p>.NET 运行时内部有一个名为字符串暂存 (string interning) 的机制，此机制默认仅适用于字符串字面量 (string literal)。</p><ul><li>.NET 内部也提供了手动暂存的 API</li></ul><p>暂存的字符串由 StringLiteralMap 和 LargeHeapHandleTable 注册和管理，这几个数据结构生成周期与应用程序一样长。</p><p><img data-src="/blogimages/2023/2023-07-12/592931748.jpeg" alt="592931748.jpeg"></p><p>字符串暂存优缺点</p><ul><li>优点<ul><li>消除重复字符串</li><li>提供相等比较性能</li></ul></li><li>缺点<ul><li>永续性：暂存字符串将永远保持可达状态</li><li>创建临时字符串：只能暂存已创建的字符串，因此即使仅用于检查是否存在某个已暂存字符串，也会有一个留存极短时间的未暂存字符串。</li></ul></li></ul><p>结论：字符串暂存仅在大量重复字符串需要长时间保留于内存下才有意义。(该场景似乎并不常见)</p><h2 id="装箱与拆箱"><a class="anchor" href="#装箱与拆箱">#</a> 装箱与拆箱</h2><p>是一个效率较低的操作，应尽量避免。例如避免在需要对象 (引用类型) 的地方使用值类型。</p><ul><li>作为一个通用规则：尽量避免在调用以 object 类型为参数的方法。</li></ul><p>注：以接口类型使用值类型实例 (若值类型实现了该接口)，由于接口是引用类型，因此同样会导致装箱。（可以考虑利用泛型优化，泛型方法将被编译为特定具体类型的方法）<br>foreach 遍历值类型列表，会导致隐式装箱。</p><ul><li>为何 list&lt;&gt; 这类常见集合类型采用结构实现枚举器？<ul><li>绝大部分场景中，枚举器都被当做一个局部变量，值类型可以快速低廉地在堆栈上分配 (好处超过装箱可能带来的问题)</li></ul></li></ul><p>与装箱对应是拆箱，不过拆箱不会导致太大内存开销。</p><h2 id="按引用传递"><a class="anchor" href="#按引用传递">#</a> 按引用传递</h2><p>我们可以按引用传递任何值，无论它是值类型实例还是引用类型实例。</p><h2 id="类型数据局部性"><a class="anchor" href="#类型数据局部性">#</a> 类型数据局部性</h2><p>结构的数据构造内存使用效率更好。<br>且结构体数组才是内存连续，而引用类型数组只包含连续的引用，实际值分散于整个托管堆。</p><ul><li>类实例数组有额外一次解引用，并且无法在内存中连续排列，因此类实例数组具有更差的数据局部性，加载类数组必须使用更多的 cache line，导致其性能会相差更大。</li></ul><h2 id="静态数据"><a class="anchor" href="#静态数据">#</a> 静态数据</h2><p>静态数据可以被视作程序中的一种全局变量。</p><ul><li>C# 仅支持一种静态数据类型：静态字段</li></ul><h3 id="静态字段"><a class="anchor" href="#静态字段">#</a> 静态字段</h3><p>静态字段的值被该类型的所有实例所共享，通过使用类型名称，在任何可以访问该类型的地方都可以访问该类型上定义的静态字段。</p><ul><li>静态数据具有应用程序域作用域 (每个应用程序域单独一份实例)</li><li>定义在一个程序集的类型上的静态数据将一直存活到应用程序域被卸载 (使其引用的静态数据和对象也将保持可达)。</li></ul><p>实现细节</p><ul><li>静态基元数据 (如数字) 存储于相应应用程序域的一个 HighFrequencyHeap 中</li><li>静态引用类型实例存储于常规 GC Heap 中，与普通对象区别在于额外被一个内部 static table 引用</li><li>静态用户自定义值类型实例 (结构) 将以装箱形式存储于常规 GC Heap 中</li></ul><p><img data-src="/blogimages/2023/2023-07-12/1274258931.jpeg" alt="1274258931.jpeg"></p><p>访问</p><ul><li>对于基元类型静态字段，已知维护此字段的 DomainLocalModule 地址和要访问的字段在 statics blob 中的偏移量，计算后可得静态数据的绝对地址</li><li>对于引用类型静态字段 (包括结构类型，其以装箱形式分配在堆上)，已知对应 object [] 数组的地址和访问字段偏移量，计算出静态字段的绝对地址，获得指向托管堆真正实例数据的引用。</li></ul><p>访问基元静态字段的速度非常快，它唯一做的操作就是从适当的 statics blob 区域读取一个指定值。<br>访问类型 / 结构静态字段数据需要执行解引用操作，并随之带来额外开销。</p><div class="tags"><a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 笔记</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-10-02 17:13:03" itemprop="dateModified" datetime="2023-10-02T17:13:03+08:00">2023-10-02</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>WangJiaYing <i class="ic i-at"><em>@</em></i>CWHISME</li><li class="link"><strong>本文链接：</strong> <a href="https://wangjiaying.top/2023/07/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-3/" title="《.NET 内存管理宝典》- 笔记 (3)">https://wangjiaying.top/2023/07/12/NET内存管理宝典-3/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/07/10/Addressables-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="prev" data-background-image="&#x2F;images&#x2F;coverimages&#x2F;large&#x2F;43430aaf2d3edda7c32a68ad9fb1e545_2_2_art.webp" title="Unity Addressables 笔记"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Unity3D</span><h3>Unity Addressables 笔记</h3></a></div><div class="item right"><a href="/2023/07/19/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-4/" itemprop="url" rel="next" data-background-image="&#x2F;blogimages&#x2F;2023&#x2F;2023-06-26&#x2F;book.webp" title="《.NET内存管理宝典》-笔记(4)"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 阅读笔记</span><h3>《.NET内存管理宝典》-笔记(4)</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E6%B5%8B%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">第三章 内存测量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BD%E6%97%A9%E6%B5%8B%E9%87%8F"><span class="toc-number">2.1.</span> <span class="toc-text">尽早测量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E9%94%80%E5%92%8C%E4%BE%B5%E5%85%A5%E6%80%A7"><span class="toc-number">2.1.1.</span> <span class="toc-text">开销和侵入性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%87%E6%A0%B7%E4%B8%8E%E8%B7%9F%E8%B8%AA"><span class="toc-number">2.1.2.</span> <span class="toc-text">采样与跟踪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%A0%91"><span class="toc-number">2.1.3.</span> <span class="toc-text">调用树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%9B%BE"><span class="toc-number">2.1.4.</span> <span class="toc-text">对象图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1"><span class="toc-number">2.1.5.</span> <span class="toc-text">统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E4%B8%8E%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">2.1.6.</span> <span class="toc-text">延迟与吞吐量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%BD%AC%E5%82%A8-%E8%B7%9F%E8%B8%AA-%E5%AE%9E%E6%97%B6%E8%B0%83%E8%AF%95"><span class="toc-number">2.1.7.</span> <span class="toc-text">内存转储、跟踪、实时调试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#windows-%E7%8E%AF%E5%A2%83"><span class="toc-number">2.2.</span> <span class="toc-text">Windows 环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vmmap"><span class="toc-number">2.2.1.</span> <span class="toc-text">VMMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">性能计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windows-%E4%BA%8B%E4%BB%B6%E8%B7%9F%E8%B8%AA"><span class="toc-number">2.2.3.</span> <span class="toc-text">Windows 事件跟踪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windows-%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7%E5%8C%85"><span class="toc-number">2.2.4.</span> <span class="toc-text">Windows 性能工具包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#perfview"><span class="toc-number">2.2.5.</span> <span class="toc-text">PerfView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#procdump-debugdiag"><span class="toc-number">2.2.6.</span> <span class="toc-text">ProcDump、DebugDiag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windbg"><span class="toc-number">2.2.7.</span> <span class="toc-text">WinDbg</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#benchmarkdotnet"><span class="toc-number">2.2.8.</span> <span class="toc-text">BenchmarkDotNet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%95%86%E4%B8%9A%E5%B7%A5%E5%85%B7"><span class="toc-number">2.2.9.</span> <span class="toc-text">商业工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-%E7%8E%AF%E5%A2%83"><span class="toc-number">2.3.</span> <span class="toc-text">Linux 环境</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-net%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">3.</span> <span class="toc-text">第四章 .NET 基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#net-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">.NET 内部原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%9B%86%E5%92%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9F%9F"><span class="toc-number">3.2.</span> <span class="toc-text">程序集和应用程序域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">3.3.</span> <span class="toc-text">进程内存区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.4.</span> <span class="toc-text">类型系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.4.1.</span> <span class="toc-text">类型的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">生存期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%85%B1%E4%BA%AB%E6%80%A7"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">可共享性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E6%80%A7"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">相等性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">3.4.2.</span> <span class="toc-text">类型的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.3.</span> <span class="toc-text">值类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">值类型的存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">结构概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">3.4.3.4.</span> <span class="toc-text">结构的存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.4.</span> <span class="toc-text">引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9A%82%E5%AD%98"><span class="toc-number">3.5.1.</span> <span class="toc-text">字符串暂存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-number">3.6.</span> <span class="toc-text">装箱与拆箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">3.7.</span> <span class="toc-text">按引用传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-number">3.8.</span> <span class="toc-text">类型数据局部性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">3.9.</span> <span class="toc-text">静态数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5"><span class="toc-number">3.9.1.</span> <span class="toc-text">静态字段</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8A/" rel="bookmark" title="《CLR VIR C#》笔记(上)">《CLR VIR C#》笔记(上)</a></li><li><a href="/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="bookmark" title="《CLR VIR C#》笔记(下)-多线程">《CLR VIR C#》笔记(下)-多线程</a></li><li><a href="/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%AE%8C%E7%BE%8E%E5%BC%80%E5%8F%91-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《设计模式与游戏完美开发》-笔记">《设计模式与游戏完美开发》-笔记</a></li><li><a href="/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《数据结构与算法之美》-笔记">《数据结构与算法之美》-笔记</a></li><li><a href="/2023/06/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8_1/" rel="bookmark" title="《.NET内存管理宝典》-笔记(1)">《.NET内存管理宝典》-笔记(1)</a></li><li><a href="/2023/06/26/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-2/" rel="bookmark" title="《.NET内存管理宝典》-笔记(2)">《.NET内存管理宝典》-笔记(2)</a></li><li class="active"><a href="/2023/07/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-3/" rel="bookmark" title="《.NET内存管理宝典》-笔记(3)">《.NET内存管理宝典》-笔记(3)</a></li><li><a href="/2023/07/19/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-4/" rel="bookmark" title="《.NET内存管理宝典》-笔记(4)">《.NET内存管理宝典》-笔记(4)</a></li><li><a href="/2023/08/04/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-5/" rel="bookmark" title="《.NET内存管理宝典》-笔记(5)">《.NET内存管理宝典》-笔记(5)</a></li><li><a href="/2023/08/21/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-6-%E5%AE%8C/" rel="bookmark" title="《.NET内存管理宝典》-笔记(6)[完]">《.NET内存管理宝典》-笔记(6)[完]</a></li><li><a href="/2023/09/25/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《游戏编程模式》-笔记">《游戏编程模式》-笔记</a></li><li><a href="/2023/10/02/CPP_Primer_%E7%AC%AC%E4%BA%94%E7%89%88_%E7%AC%94%E8%AE%B0-1/" rel="bookmark" title="《C++ Primer(第五版)》-笔记(1)">《C++ Primer(第五版)》-笔记(1)</a></li><li><a href="/2023/10/22/CPP-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%AC%94%E8%AE%B0-2/" rel="bookmark" title="《C++ Primer(第五版)》-笔记(2)">《C++ Primer(第五版)》-笔记(2)</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="WangJiaYing" data-src="/images/../img/avator"><p class="name" itemprop="name">CWHISME</p><div class="description" itemprop="description">己所不欲，勿施于人</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">131</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">24</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">35</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N3aGlzbWU=" title="https:&#x2F;&#x2F;github.com&#x2F;cwhisme"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9jd2hpc21lLTMzL3Bvc3Rz" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;cwhisme-33&#x2F;posts"><i class="ic i-zhihu"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmN3aGlzbWVAMTI2LmNvbQ==" title="mailto:cwhisme@126.com"><i class="ic i-envelope"></i></span> <a href="/atom.xml" title="&#x2F;atom.xml" class="item feedback"><i class="ic i-heart"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-clock"></i>统计</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/07/10/Addressables-%E7%AC%94%E8%AE%B0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/07/19/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-4/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%B7%A5%E5%85%B7/" title="分类于 工具">工具</a></div><span><a href="/2023/01/21/%E4%BD%BF%E7%94%A8WPF%E5%BC%80%E5%8F%91%E6%97%B6%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" title="使用WPF开发时问题记录">使用WPF开发时问题记录</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%90%86%E8%AE%BA%E7%A0%94%E7%A9%B6/" title="分类于 理论研究">理论研究</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%90%86%E8%AE%BA%E7%A0%94%E7%A9%B6/C/" title="分类于 C#">C#</a></div><span><a href="/2022/11/18/StringBuilder%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E7%A0%94%E7%A9%B6/" title="StringBuilder 扩容规则研究">StringBuilder 扩容规则研究</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%9A%E5%AE%A2/" title="分类于 博客">博客</a></div><span><a href="/2022/12/23/%E4%BF%AE%E5%A4%8DShoka%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E9%97%AE%E9%A2%98/" title="修复 Shoka 主题的一点小问题">修复 Shoka 主题的一点小问题</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment count_3"></ul></div></div><div class="status"><div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">WangJiaYing @ Jiaying's Note</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">772k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">11:42</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NXSElTTUUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/07/12/NET内存管理宝典-3/",favicon:{show:"（●´3｀●）",hide:"(´Д｀)"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,justifiedGallery:!0,jquery:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.staticfile.net/pace/1.2.4/pace.min.js"></script><script src="https://cdn.staticfile.net/pjax/0.2.8/pjax.min.js"></script><script src="https://cdn.staticfile.net/animejs/3.2.2/anime.min.js"></script><script src="https://cdn.staticfile.net/algoliasearch/4.17.0/algoliasearch-lite.umd.js"></script><script src="https://cdn.staticfile.net/instantsearch.js/4.54.1/instantsearch.production.min.js"></script><script src="https://cdn.staticfile.net/lozad.js/1.16.0/lozad.min.js"></script><script src="https://cdn.staticfile.net/quicklink/2.3.0/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/js/DateTimeAfeterCalc.js" async></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js" async></script></body></html>