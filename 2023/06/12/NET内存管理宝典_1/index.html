<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="CWHISME" href="https://wangjiaying.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="CWHISME" href="https://wangjiaying.top/atom.xml"><link rel="alternate" type="application/json" title="CWHISME" href="https://wangjiaying.top/feed.json"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="笔记"><link rel="canonical" href="https://wangjiaying.top/2023/06/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8_1/"><title>《.NET 内存管理宝典》- 笔记 (1) - 阅读笔记 | Jiaying's Note = CWHISME = 人不能没有梦想，也要有足够的敬畏</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">《.NET 内存管理宝典》- 笔记 (1)</h1><div class="meta"><span class="item" title="创建时间：2023-06-12 10:56:47"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-06-12T10:56:47+08:00">2023-06-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>5.9k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>5 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiaying's Note</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/blogimages/2023/2023-06-26/book.webp"></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" itemprop="item" rel="index" title="分类于 阅读笔记"><span itemprop="name">阅读笔记</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangjiaying.top/2023/06/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8_1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/../img/avator"><meta itemprop="name" content="WangJiaYing"><meta itemprop="description" content="人不能没有梦想，也要有足够的敬畏, 己所不欲，勿施于人"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="CWHISME"></span><div class="body md" itemprop="articleBody"><h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>之前的几本书，都是 <code>全都读完</code> 之后，再将笔记从语雀转移到自己的 Hexo 博客上，但是想想一本书有多少？笔记就算记得再少也少不到哪里去。</p><p>这就导致一个问题：文字太多，自己都...em...</p><p>于是这次想转变一下思路和做法，感觉可以单独先『移记』一下的，那就先在整理到博客上。</p><h1 id="第一章-基本概念"><a class="anchor" href="#第一章-基本概念">#</a> 第一章 基本概念</h1><h2 id="术语"><a class="anchor" href="#术语">#</a> 术语</h2><p>位 (bit)：小写字母 b 指代位<br>字节 (byte)：使用大写字母 B 表示<br>随机存取存储器 (RAM)：允许不管访问的存储器区域如何，都能在相同的访问时间内读取数据<br>非均匀访问存储器：与 RAM 相反，访问存储器所需时间取决于其在物理存储器上的位置（在访问之前必须将存储介质放置，例如旋转到正确位置）<br>地址 (address)：表示整个存储区中的特定位置<br>算数逻辑单元 (ALU)：负责执行加法和减法运算，计算机核心。现代计算机包括多个 ALU，可实现计算并行化<br>控制单元 (control unit)：解码从内存中读取的程序指令 (操作码)。根据内部指令的描述，执行哪些算数或逻辑运算以及要对哪些数据进行运算</p><ul><li>控制单元存储一个称为指令指针 (IP) 或程序计数器 (PC) 的附加寄存器，以指向当前执行的指令。正常程序执行非常简单，只需要将存储在 PC 中的地址递增到后续指令即可，循环或跳出之类就像将指令指针的值更改为另一个地址和指定要移动程序执行的位置一样简单。</li><li>注：严格说，操作码只是指令的一部分，指令包括操作码和地址码</li></ul><p><img data-src="/blogimages/2023/2023-06-12/-1807417749.jpeg" alt=""></p><p>寄存器 (register)：通常包含在内存中的可以直接从 ALU 和 / 或控制单元 (可以统称为执行单元) 快速访问的内存位置，速度极快，没有地方比它更接近执行单元的了<br>字 (word)：特定计算机设计中使用的固定大小的基本数据单位。反映在许多设计领域，如大多数寄存器大小、最大地址或在单个操作中传输的最大数块。常用位表示，称为字长。如 32 位或 64 位长寄存器。</p><h3 id="静态分配"><a class="anchor" href="#静态分配">#</a> 静态分配</h3><p>在编译期间，甚至在执行程序之前，就必须知道所需内存的数量和确切位置</p><h3 id="寄存器机"><a class="anchor" href="#寄存器机">#</a> 寄存器机</h3><p>使用寄存器 (或特殊情况下的累加器) 在算数逻辑单元 (ALU) 上操作的机器。<br>构成这种设计的机器称为寄存器机：因为在这样的机器上执行程序时，实际上是在寄存器上进行计算。如果要进行加法、除法或其它操作时，必须先将对应的数据从内存加载到对应的寄存器中，然后调用特定指令对其执行对应操作，然后调用另一个指令将其中一个寄存器的结果存储到内存中。</p><h3 id="堆栈stack"><a class="anchor" href="#堆栈stack">#</a> 堆栈 (Stack)</h3><p>概念上，堆栈是一种数据结构，可以简单地描述为 后进先出 (LIFO) 列表<br>堆栈一开始就与计算机编程有着内在联系，主要是因为子例程的概念<br>堆栈帧 (stack frame)：为特定目的保存在堆栈上的任何结构化数据</p><ul><li>嵌套调用子例程只需要重复这个模式，即可为每个调用添加一个活动帧</li><li>子例程调用的嵌套越多，堆栈上的活动帧就越多（这也使得无限嵌套调用成为不可能）</li></ul><p><img data-src="/blogimages/2023/2023-06-12/-888697750.jpeg" alt=""></p><p>如图所示，堆栈指针 (SP) 保留一个指示堆栈当前边界的地址。程序计数器 (PC) 指向执行函数内部某个位置<br>现代计算机中的堆栈既有硬件层面 (通过为堆栈指针提供专用寄存器) 的支持，也有软件层面 (通过操作系统对线程及其指定为堆栈的内存部分的抽象) 的支持</p><ul><li>堆栈可以存储在 cpu 内部专用内存块或专用芯片上</li><li>也可以直接重用普通计算机内存（大多数现代架构中情况）</li></ul><h3 id="堆栈机"><a class="anchor" href="#堆栈机">#</a> 堆栈机</h3><p>与寄存器不同，在堆栈机中，所有指令都在专用表达式堆栈 (或求值堆栈) 上操作。</p><ul><li>注：此处堆栈机与前文讨论的堆栈不必相同</li></ul><p>在这样的计算机中，默认情况下，指令从表达式堆栈顶部获取参数，结果也存储在堆栈顶部，这种情况下它们被称为纯堆栈计算机</p><ul><li>与不纯的实现相对应 (当操作不仅可以从堆栈顶部访问值，而且还可以访问更深的值时，称为不纯的实现)</li></ul><p>表达式堆栈操作：</p><ul><li>例如，假想的乘法指令，将从求值堆栈顶部弹出两个值，将其相乘，然后将结果放回求值堆栈</li></ul><p>堆栈机概念带来了非常清晰和易于理解的代码</p><ul><li>与如何以及在何处存储临时值无关，不管是在寄存器、堆栈还是在主内存。<ul><li>从概念上将，比试图以最佳方式管理所有这些可能的目标更容易，因此简化了实现。</li></ul></li><li>由于存在许多无操作数或单操作数指令，因此在所需内存方面操作码可以更短<ul><li>这允许对指令进行高效的二进制编码，从而产生高密度的二进制代码。因此即使指令数量可能比基于寄存器机的方法要多 (由于更多的加载 / 存储操作)，但仍然是受益的</li></ul></li></ul><p>尽管堆栈机有其优点，但它很少在硬件上实现。但这种架构是设计独立于平台的虚拟机或执行引擎的好方法。（如 java 虚拟机和 .net 运行时就是堆栈机的完美示例，它们实现了堆栈机逻辑，并由 x86 或 ARM 寄存器机执行）<br>虚拟堆栈机 (不是由真正的硬件堆栈机执行的堆栈机) 可以在生成高性能代码的同时提供良好的平台独立性。<br>堆栈机代码的层次更高，可以更好地从实际底层硬件抽象出来，其概念非常简单、优雅和高效。</p><ul><li>另一方面，基于寄存器的虚拟机设计更接近其实际运行的真实硬件设计，对可能的优化更有用（所解释的代码与机器代码相似越多，效果越好）</li></ul><p>目前 .Net 执行引擎是作为一个堆栈机实现的，不过并不是完全纯的，例如会将求值堆栈映射到包含寄存器和内存的底层硬件上。<br>注：并非所有虚拟机和执行引擎都是堆栈机</p><h3 id="指针"><a class="anchor" href="#指针">#</a> 指针</h3><p>将位置地址存储在内存中的变量，允许通过地址引用内存中的其它位置。<br>指针大小与字长有关，由计算机架构决定，如今我们通常处理 32 位或 64 位宽的指针。由于只是内存的一小部分，因此也可以将其放置在堆栈中 (例如作为局部变量或函数参数) 或 cpu 寄存器上。<br>指针还可以提供指针算数，可以加上或减去内存的相对引用部分。</p><ul><li>例如增量运算符将指针的值加上指向的对象大小的值，而不是单个字节。</li></ul><p>悬空指针：释放后没有置为 null</p><h3 id="堆heap"><a class="anchor" href="#堆heap">#</a> 堆 (Heap)</h3><p>堆 (也称为自由存储区) 是一个用于动态分配对象的内存区域。</p><ul><li>自由存储区：没有体现任何内部结构，而只体现了一个目的。</li><li>与有序的堆栈空间相反，堆传统英语含义：混乱的地方</li><li>注：堆数据结构与堆没有关系</li></ul><p>堆是一种内存机制，能够提供具有指定大小的连续内存块。该操作被称为动态内存分配。</p><ul><li>由于内存的位置在编译时是不知道的，因此动态分配的内存必须要由指针来引用，因此指针与堆本质上是相关的。</li><li>指针可以存放在堆栈中、堆本身或其它任何地方。</li></ul><p>堆碎片：尽管堆上有足够可用空间，但是并不连续。</p><h2 id="自动内存管理"><a class="anchor" href="#自动内存管理">#</a> 自动内存管理</h2><p>最初在 lisp 语言中诞生，自动内存管理和垃圾回收名称可以互换使用。<br>可以将其定义为一种机制，该机制一旦创建对象，便会在不再需要时自动销毁 (并且恢复它们的内存)，从而使程序员无需承担手动内存管理的责任。<br>但，即使内存管理是完全自动化的，也会产生问题。</p><h3 id="mutator"><a class="anchor" href="#mutator">#</a> Mutator</h3><p>内存管理最基本也是最重要的概念，称为 mutator 的抽象。<br>最简单来看，可以将 mutator 定义为负责执行应用程序代码的实体，或者说所有可能修改内存的东西，无论是通过修改现有对象还是通过创建新对象。</p><ul><li>是应用程序中有关内存的所有更改的驱动器。</li></ul><p>为了完全可操作，mutator 需要为运行的应用程序提供以下三种操作：</p><ul><li>new (amount)：分配给定数量内存，然后由新创建对象使用（这种抽象级别上，不考虑对象的类型信息，只是提供所需分配的内存大小）</li><li>write (address,value)：在给定地址下写入指定值</li><li>read (address)：从指定地址读取一个值</li></ul><p>mutator 抽象最常见的一个实现是基于线程。不过就操作系统线程而言，不必将 mutator 实现为线程，例如 erlangVM、fiber</p><h3 id="分配器allocator"><a class="anchor" href="#分配器allocator">#</a> 分配器 (Allocator)</h3><p>分配器是一个负责管理动态内存分配和解除分配的实体。<br>分配器必须提供两个主要操作：</p><ul><li>Allocator.Allocate (amount)：分配指定数量内存<ul><li>如果类型信息可用于分配器，则可以通过能够为特定类型的对象分配内存的方法来扩展此方法，如被 Mutator.New 操作内部使用</li></ul></li><li>Allocator.Deallocate (address)：释放给定地址下的内存以供将来分配。<ul><li>在自动内存管理情况下，此方法为内部方法，不会暴露给 Mutotor (用户不可显式调用)</li></ul></li></ul><p>两种最流行的分配器：顺序和自由列表</p><h3 id="回收器collector"><a class="anchor" href="#回收器collector">#</a> 回收器 (Collector)</h3><p>当我们将 mutator 定义为负责执行应用程序代码的实体时，也可以将回收器定义为运行垃圾回收 (自动回收内存) 代码实体。<br>可达性并不意味着对象的存活性，而只是我们拥有的最佳近似值。</p><ul><li>如果某个对象无法从任何 mutator 到达，则可以安全回收。</li><li>但它的反面显然不是事实，可到达对象可以永远保持可到达状态 (由于一些复杂的引用图来保持)，但由于执行条件可能永远无法访问，因此实际上已经死了。（大多托管内存泄露都存活性和可到达性之间）</li></ul><p>mutator 在可达性方面的起点称为根，确切内容取决于特定 mutator 实现。不过大多情况，当 mutator 是一个线程时，可以是：</p><ul><li>局部变量和子例程参数，放置在堆栈或寄存器中</li><li>静态分配的对象，放置于堆上</li><li>存储在回收器自身内部的其它内部数据结构</li></ul><h2 id="引用计数"><a class="anchor" href="#引用计数">#</a> 引用计数</h2><p>自动内存管理的两种最流行的方法之一。<br>优点</p><ul><li>确定性释放时刻，我们知道只要引用计数降为零即会发生释放。</li><li>更少内存限制，内存回收与不再使用对象速度一样快，等待回收的对象不会占用任何内存开销</li><li>不需要运行时支持即可实现<ul><li>可以作为外部库的某些特定类型的附加机制来实现。(如 c++ 智能指针)</li></ul></li></ul><p>缺点</p><ul><li>增加大量开销 (简单在运行时引入)</li><li>多线程同步问题处理开销</li><li>降低 cpu 缓存使用效率</li><li>循环引用</li></ul><p>C++ 的智能指针是基于标准库之上，而不是语言本身。直接在设计中就引入智能指针的语言：</p><ul><li>rust</li><li>swift</li></ul><h2 id="跟踪回收器tracking-collector"><a class="anchor" href="#跟踪回收器tracking-collector">#</a> 跟踪回收器 (Tracking Collector)</h2><p>查找对象可达性很困难，因为它是对象的全局属性，而释放对象的简单显式调用是非常局部的，在该局部上下文中，我们并不了解全局上下文 —— 现在是否还有其它对象在使用该对象？</p><ul><li>引用计数试图通过只查看该局部上下文以及一些附加信息 (对象的引用计数) 来克服这一问题。会导致循环引用出现问题及一些其它缺点。</li></ul><p>跟踪垃圾回收器是基于对象生存期的全局上下文的了解，从而可以更好地决定是否是删除对象 (回收内存) 的最佳时机。</p><ul><li>这是一种非常流行的方法，当人们谈到垃圾回收器时，可能指的就是跟踪垃圾回收器。</li><li>核心思路是，跟踪垃圾回收器通过从 mutator 的根开始并递归地跟踪程序的整个对象图，来发现对象的真正可到达性。</li></ul><p>跟踪垃圾回收器最典型方法包括以下两个主要步骤：</p><ul><li>标记：回收器通过找到它们的可达性来确定内存中哪些对象可以被回收</li><li>回收：回收器将回收那些所发现的不再可到达的对象的内存</li></ul><p>例如 .net 中：标记 - 计划 - 清除 - 压缩</p><h3 id="标记阶段"><a class="anchor" href="#标记阶段">#</a> 标记阶段</h3><p>从 mutator 根开始，回收器遍历整个对象图并标记访问过的对象。在标记阶段结束时那些未标记对象将是不可达的。由于对象标记，将不再存在循环引用问题。<br>由于程序正常执行图会不断变化，遍历这样的图会很困难，因此在某些垃圾回收器实现中，所有 mutator 都在标记阶段的时间内停止。</p><ul><li>一旦线程恢复运行，回收器基于对象图所掌握的知识就会过时，但对于不可达对象来说不是问题：如果它以前不可达，那么将再也无法到达</li></ul><h4 id="保守垃圾回收器conservation-garbage-collector"><a class="anchor" href="#保守垃圾回收器conservation-garbage-collector">#</a> 保守垃圾回收器（conservation garbage collector）</h4><p>这种类型的回收器可以被看成一个保底的解决方案。</p><ul><li>当运行时或编译器无法通过提供确切的类型信息 (对象在内存中布局) 从而不能直接支持回收时，并且在使用指针进行操作时回收器不能获得 mutator 支持时可以使用的解决方案。</li></ul><p>如果保守回收器想要找出什么对象是可达的，就要扫描整个堆栈、静态数据区和寄存器</p><ul><li>由于没有任何帮助，它不知道什么是指针，只能试图去猜测 (即前面说的保底的意思)</li><li>通过检查一些东西来做到，最重要的一个检查是：将给定字解释为地址 (指针) 是否是指向由分配器堆区域管理的有效地址。</li><li>如果结果肯定，回收器将保守地假定它确实是一个指针，并把它当做一个引用来遵循。</li><li>显然猜测时可能犯错，随机会使有些位看起来像是具有正确地址的有效指针 (实际并不是)，将导致在垃圾回收中依旧保留对应内存不做回收。</li></ul><p>保守垃圾回收主要优点是可以在没有运行时支持的情况下工作，它仅扫描内存，因此不需要运行时支持 (引用跟踪)<br>不过，保守回收器需要分配器的支持才能解决未知对象的内存布局问题。<br>优点</p><ul><li>对于不支持从头开始进行垃圾回收的环境 (如早期运行时阶段或非托管语言) 而言，更容易使用</li></ul><p>缺点</p><ul><li>不精确：随机会导致看起来像一个指针的所有内容都会阻止内存被回收 (尽管并不常见)</li></ul><p>在简单方法中，对象不能移动 (压缩)，因为回收器不确定哪些是指针 (而且它不能仅仅更新一个仅假定为指针的值)</p><h4 id="精确垃圾回收器precise-garbage-collector"><a class="anchor" href="#精确垃圾回收器precise-garbage-collector">#</a> 精确垃圾回收器（precise garbage collector）</h4><p>与保守垃圾回收器相比，精确垃圾回收器则简单许多，因为编译器或运行时为回收器提供了有关对象的内存布局的全部信息。还可以支持堆栈爬网 (枚举堆栈上所有对象的根)。<br>从定义明确的根开始，只需要逐个对象来扫描内存。</p><h3 id="回收阶段"><a class="anchor" href="#回收阶段">#</a> 回收阶段</h3><p>跟踪垃圾回收器找到了可到达对象之后，就可以从所有其它死对象中回收内存。回收器的回收阶段可以有多种不同的方式进行设计。</p><h4 id="清除sweep"><a class="anchor" href="#清除sweep">#</a> 清除（sweep）</h4><p>在这种方法中，死对象被简单地标记为可用空间，以便以后重用。这可能是一个非常快速的操作，因为仅需更改存储块的单个单位标记。<br>另外还有不简单的实现，可能需要通过构建数据结构来存储有关可用内存块的信息，以便更快地检索，通常采用空闲列表的形式，而且这些空闲列表必须足够智能，以合并相邻的可用内存块。<br>虽然清除速度很快，但最终会导致内存碎片变大或变小：可能会导致尽管总体上有足够的空闲内存，但是没有单个连续的空闲空间来用于新对象。</p><h4 id="压缩compact"><a class="anchor" href="#压缩compact">#</a> 压缩（compact）</h4><p>消除碎片会降低性能，因为它需要在内存中的对象之间移动。<br>主要有两种方式：</p><ul><li>复制所有存活对象，会带来更大内存开销：因此一般只用于特定的小内存区域（而不是整个进程内存）</li><li>就地压缩：将对象移向彼此，以消除间隙。主要问题是：如何在不相互覆盖且不使用任何临时缓冲区的情况下相对于彼此来移动对象（如 .net）</li></ul><h3 id="比较"><a class="anchor" href="#比较">#</a> 比较</h3><p>保守垃圾回收器实现了清除回收，精确垃圾回收器实现了压缩回收。<br>跟踪垃圾回收器优缺点：</p><ul><li>优点<ul><li>从开发人员角度看，完全透明，内存被抽象为无限，开发人员无需考虑如何释放不再需要的对象内存</li><li>不存在循环引用问题</li><li>在 mutator 上没有太大开销</li></ul></li><li>缺点<ul><li>更复杂的实现</li><li>非确定地释放对象</li><li>停止标记阶段程序线程</li><li>更大的内存约束 —— 由于在不需要对象时无法快速回收对象，因此可能会引入更大的内存压力</li></ul></li></ul><p>主要是因为第一个优点，因此跟踪垃圾回收器在不同的运行时间和环境中非常流行。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>应该始终致力于扩展知识，以努力成为一名专业人士 —— 知识是不会自动跑到大脑里的，需要跳出舒适区。<br>如果不能理解原理，止步于用 .net、jvm 框架之类的，会像星期天的司机一样，只能从方向盘和踏板的角度来看待我们的车。</p><div class="tags"><a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 笔记</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-10-02 17:13:03" itemprop="dateModified" datetime="2023-10-02T17:13:03+08:00">2023-10-02</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>WangJiaYing <i class="ic i-at"><em>@</em></i>CWHISME</li><li class="link"><strong>本文链接：</strong> <a href="https://wangjiaying.top/2023/06/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8_1/" title="《.NET 内存管理宝典》- 笔记 (1)">https://wangjiaying.top/2023/06/12/NET内存管理宝典_1/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/06/11/%E8%9B%8B%E7%B3%95/" itemprop="url" rel="prev" data-background-image="&#x2F;blogimages&#x2F;2023&#x2F;2023-06-11&#x2F;IMG_20230611_163653.webp" title="蛋糕"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 生活</span><h3>蛋糕</h3></a></div><div class="item right"><a href="/2023/06/16/Unity3DAssets-ResourcesAndAssetBundles-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="next" data-background-image="&#x2F;images&#x2F;coverimages&#x2F;large&#x2F;87092008_p0.webp" title="Assets、Resources 和 AssetBundles-翻译-笔记"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Unity3D</span><h3>Assets、Resources 和 AssetBundles-翻译-笔记</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">第一章 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">2.1.</span> <span class="toc-text">术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">2.1.1.</span> <span class="toc-text">静态分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%9C%BA"><span class="toc-number">2.1.2.</span> <span class="toc-text">寄存器机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88stack"><span class="toc-number">2.1.3.</span> <span class="toc-text">堆栈 (Stack)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E6%9C%BA"><span class="toc-number">2.1.4.</span> <span class="toc-text">堆栈机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">2.1.5.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86heap"><span class="toc-number">2.1.6.</span> <span class="toc-text">堆 (Heap)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">自动内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mutator"><span class="toc-number">2.2.1.</span> <span class="toc-text">Mutator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%99%A8allocator"><span class="toc-number">2.2.2.</span> <span class="toc-text">分配器 (Allocator)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E5%99%A8collector"><span class="toc-number">2.2.3.</span> <span class="toc-text">回收器 (Collector)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">引用计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%9F%E8%B8%AA%E5%9B%9E%E6%94%B6%E5%99%A8tracking-collector"><span class="toc-number">2.4.</span> <span class="toc-text">跟踪回收器 (Tracking Collector)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="toc-number">2.4.1.</span> <span class="toc-text">标记阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E5%AE%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8conservation-garbage-collector"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">保守垃圾回收器（conservation garbage collector）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%BE%E7%A1%AE%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8precise-garbage-collector"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">精确垃圾回收器（precise garbage collector）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5"><span class="toc-number">2.4.2.</span> <span class="toc-text">回收阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E9%99%A4sweep"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">清除（sweep）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9compact"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">压缩（compact）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83"><span class="toc-number">2.4.3.</span> <span class="toc-text">比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8A/" rel="bookmark" title="《CLR VIR C#》笔记(上)">《CLR VIR C#》笔记(上)</a></li><li><a href="/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="bookmark" title="《CLR VIR C#》笔记(下)-多线程">《CLR VIR C#》笔记(下)-多线程</a></li><li><a href="/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%AE%8C%E7%BE%8E%E5%BC%80%E5%8F%91-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《设计模式与游戏完美开发》-笔记">《设计模式与游戏完美开发》-笔记</a></li><li><a href="/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《数据结构与算法之美》-笔记">《数据结构与算法之美》-笔记</a></li><li class="active"><a href="/2023/06/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8_1/" rel="bookmark" title="《.NET内存管理宝典》-笔记(1)">《.NET内存管理宝典》-笔记(1)</a></li><li><a href="/2023/06/26/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-2/" rel="bookmark" title="《.NET内存管理宝典》-笔记(2)">《.NET内存管理宝典》-笔记(2)</a></li><li><a href="/2023/07/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-3/" rel="bookmark" title="《.NET内存管理宝典》-笔记(3)">《.NET内存管理宝典》-笔记(3)</a></li><li><a href="/2023/07/19/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-4/" rel="bookmark" title="《.NET内存管理宝典》-笔记(4)">《.NET内存管理宝典》-笔记(4)</a></li><li><a href="/2023/08/04/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-5/" rel="bookmark" title="《.NET内存管理宝典》-笔记(5)">《.NET内存管理宝典》-笔记(5)</a></li><li><a href="/2023/08/21/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-6-%E5%AE%8C/" rel="bookmark" title="《.NET内存管理宝典》-笔记(6)[完]">《.NET内存管理宝典》-笔记(6)[完]</a></li><li><a href="/2023/09/25/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《游戏编程模式》-笔记">《游戏编程模式》-笔记</a></li><li><a href="/2023/10/02/CPP_Primer_%E7%AC%AC%E4%BA%94%E7%89%88_%E7%AC%94%E8%AE%B0-1/" rel="bookmark" title="《C++ Primer(第五版)》-笔记(1)">《C++ Primer(第五版)》-笔记(1)</a></li><li><a href="/2023/10/22/CPP-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%AC%94%E8%AE%B0-2/" rel="bookmark" title="《C++ Primer(第五版)》-笔记(2)">《C++ Primer(第五版)》-笔记(2)</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="WangJiaYing" data-src="/images/../img/avator"><p class="name" itemprop="name">CWHISME</p><div class="description" itemprop="description">己所不欲，勿施于人</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">124</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">22</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">32</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N3aGlzbWU=" title="https:&#x2F;&#x2F;github.com&#x2F;cwhisme"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9jd2hpc21lLTMzL3Bvc3Rz" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;cwhisme-33&#x2F;posts"><i class="ic i-zhihu"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmN3aGlzbWVAMTI2LmNvbQ==" title="mailto:cwhisme@126.com"><i class="ic i-envelope"></i></span> <a href="/atom.xml" title="&#x2F;atom.xml" class="item feedback"><i class="ic i-heart"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-clock"></i>统计</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/06/11/%E8%9B%8B%E7%B3%95/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/06/16/Unity3DAssets-ResourcesAndAssetBundles-%E7%AC%94%E8%AE%B0/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/C/" title="分类于 C#">C#</a></div><span><a href="/2023/03/28/C-%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%8B%E8%AF%95/" title="C#结构体初始化测试">C#结构体初始化测试</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%90%86%E8%AE%BA%E7%A0%94%E7%A9%B6/" title="分类于 理论研究">理论研究</a></div><span><a href="/2023/05/11/%E5%AD%97%E8%8A%82%E5%8D%95%E4%BD%8D%E8%BD%AC%E6%8D%A2%E8%AE%A1%E7%AE%97/" title="字节单位转换计算">字节单位转换计算</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="分类于 阅读笔记">阅读笔记</a></div><span><a href="/2023/07/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-3/" title="《.NET内存管理宝典》-笔记(3)">《.NET内存管理宝典》-笔记(3)</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment count_3"></ul></div></div><div class="status"><div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">WangJiaYing @ Jiaying's Note</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">733k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">11:06</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NXSElTTUUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/06/12/NET内存管理宝典_1/",favicon:{show:"（●´3｀●）",hide:"(´Д｀)"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,justifiedGallery:!0,jquery:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script><script src="https://cdn.staticfile.org/pjax/0.2.8/pjax.min.js"></script><script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script><script src="https://cdn.staticfile.org/algoliasearch/4.17.0/algoliasearch-lite.umd.js"></script><script src="https://cdn.staticfile.org/instantsearch.js/4.54.1/instantsearch.production.min.js"></script><script src="https://cdn.staticfile.org/lozad.js/1.16.0/lozad.min.js"></script><script src="https://cdn.staticfile.org/quicklink/2.3.0/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/js/DateTimeAfeterCalc.js" async></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js" async></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?62952472c154f9131a14a4ab57bfefec";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html>