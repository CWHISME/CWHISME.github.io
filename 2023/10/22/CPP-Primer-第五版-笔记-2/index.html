<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="CWHISME" href="https://wangjiaying.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="CWHISME" href="https://wangjiaying.top/atom.xml"><link rel="alternate" type="application/json" title="CWHISME" href="https://wangjiaying.top/feed.json"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="笔记,CPP"><link rel="canonical" href="https://wangjiaying.top/2023/10/22/CPP-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%AC%94%E8%AE%B0-2/"><title>《C++ Primer (第五版)》- 笔记 (2) - C++ - 阅读笔记 | Jiaying's Note = CWHISME = 人不能没有梦想，也要有足够的敬畏</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">《C++ Primer (第五版)》- 笔记 (2)</h1><div class="meta"><span class="item" title="创建时间：2023-10-22 15:57:06"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-10-22T15:57:06+08:00">2023-10-22</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>8.2k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiaying's Note</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/blogimages/2023/2023-10-02/book.webp"></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" itemprop="item" rel="index" title="分类于 阅读笔记"><span itemprop="name">阅读笔记</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/C/" itemprop="item" rel="index" title="分类于 C++"><span itemprop="name">C++</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangjiaying.top/2023/10/22/CPP-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%AC%94%E8%AE%B0-2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/../img/avator"><meta itemprop="name" content="WangJiaYing"><meta itemprop="description" content="人不能没有梦想，也要有足够的敬畏, 己所不欲，勿施于人"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="CWHISME"></span><div class="body md" itemprop="articleBody"><h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本篇笔记从原书第二部分开始，到第三部分第十四章重载运算与类型转换结束，不过对于 第八章 (IO 库)、第九章 (顺序容器)、第十一章 (关联容器) 基本略过。<br>因为这几章个人也只是粗略翻过，考虑到就算 UE5 里边，容器算法这些估计也都是全套 UE 系列自定义的模板，所以对于标准库提供的感觉目前大概了解下、有个印象就行了。<br>同理，第十章泛型算法也是如此，不过还是记录了部分思想。</p><hr><p>本来之前还计划国庆节把这本书看完，结果因为国庆身体中招了，加上研究了下其它 (UE5 C++ 及其动画、AI 等)，国庆后又忙于工作交接，导致现在其实也还剩了三分之一，因此觉得还是分一下阶段比较好... 可能还是得分成三份了。</p><h1 id="第九章-顺序容器"><a class="anchor" href="#第九章-顺序容器">#</a> 第九章 顺序容器</h1><ul><li><code>vector</code> ：可变大小数组，具有 size 和 capacity，当添加元素导致 size 超出 capacity 则翻倍扩容。</li><li><code>deque</code> ：双端队列，支持快速随机访问，在 头 (尾) 插入 (删除) 元素很快。</li><li><code>list</code> ：双向链表</li><li><code>forward_lis</code> t：单链表</li><li><code>array</code> ：固定大小数组，与内置数组相比更安全、更容易使用</li><li><code>string</code> ：与 vector 类似，保存字符容器</li></ul><p>容器适配器</p><ul><li><code>stack</code> ：栈，默认基于 deque 实现。</li><li><code>queue</code> ：队列，默认基于 deque 实现。</li><li><code>priority_queue</code> ：优先级队列，默认基于 vector 实现。</li></ul><h1 id="第十章-泛型算法"><a class="anchor" href="#第十章-泛型算法">#</a> 第十章 泛型算法</h1><p>标准库并未给每个容器都定义成员函数来实现各种操作，而是定义了一组 泛型算法。</p><ul><li>这组算法实现了一些经典算法的公共接口 (如排序、搜索)</li><li>一般情况这些算法不直接操作容器，而是遍历由两个迭代器指定的元素范围</li><li>迭代器令算法不依赖于容器：泛型算法本身不执行容器的操作，而是运行于迭代器之上，执行迭代器操作</li></ul><h2 id="lamda-表达式"><a class="anchor" href="#lamda-表达式">#</a> lamda 表达式</h2><p>对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它为可调用的。</p><ul><li>函数和函数指针</li><li>重载了函数调用运算符的类</li><li>lambda 表达式</li></ul><p>一个 lambda 表达式表示一个可调用的代码单元，可理解为一个未命名的内联函数。</p><ul><li><code>[捕获列表](参数列表)-&gt;返回类型&#123;函数体&#125;</code></li><li>参数列表和返回类型可被忽略： <code>auto f=[]&#123;return 42;&#125;</code></li><li>注：捕获列表只用于局部非 static 变量，lambda 可直接使用局部 static 变量和它所在函数之外声明的名字。</li></ul><p>lambda 捕获和返回</p><ul><li>当定义一个 lambda 时，编译器生成一个与 lambda 对应的新的 (未命名的) 类类型。</li><li>默认情况下，从 lambda 生成的类都包含一个对应该 lambda 所捕获的变量的数据成员 (类似任何普通类的数据成员)，lambda 数据成员也在 lambda 对象创建时被初始化。</li></ul><p>值捕获</p><ul><li><code>auto f=[v1]&#123;return v1;&#125;</code></li><li>与传值参数类似，采用值拷贝的前提是变量可以拷贝，与参数不同，被捕获的变量在 lambda 创建时被拷贝 (进 lambda 数据成员)。</li></ul><p>引用捕获</p><ul><li><code>auto f=[&amp;v1]&#123;return v1;&#125;</code></li><li>以引用捕获方式与其它任何类型的引用的行为类似，当在 lambda 内使用时，实际操作的是引用所绑定对象。</li><li>引用捕获与返回引用有相同问题和限制：必须确保执行时被引用对象依然存在。</li></ul><p>隐式捕获</p><ul><li>让编译器根据 lambda 体中的代码来推断需要使用哪些变量</li><li>捕获列表：&amp;(引用捕获) 或 =(值捕获)</li><li>可混合使用： <code>[&amp;,c]xxxx、[=,&amp;c]xxxx</code> ，捕获列表中第一个元素 (&amp; 或 =) 指定了默认捕获方式为引用或值。</li></ul><p>可变 lambda</p><ul><li>默认情况下，值捕获的被拷贝的变量，lambda 不会改变其值</li><li>若想改变需要加上 mutable 关键字</li><li><code>[v1]()mutable &#123;return ++v1;&#125;</code></li></ul><h2 id="标准库-bind-函数"><a class="anchor" href="#标准库-bind-函数">#</a> 标准库 bind 函数</h2><p><code>auto newCallable=bind(callable,arg_list);</code></p><ul><li>arg_list：参数列表， 形如『 <code>_n</code> 』，n 表示参数占位符</li><li>可看作一个通用函数适配器</li><li>接受一个可调用对象，生成一个新的可调用对象来 适配 原对象的参数列表</li><li>可用 bind 修正参数的值、调整顺序等</li></ul><p>绑定引用参数</p><ul><li>引用：ref (val)，ref 返回一个对象，包含给定的引用</li><li>常量引用：cref (val)，cref 生成一个保存 const 引用的类</li><li>例：bind (print,ref (os),_1,' ')</li></ul><h2 id="再探迭代器"><a class="anchor" href="#再探迭代器">#</a> 再探迭代器</h2><p>额外迭代器：</p><ul><li>插入迭代器：绑定于容器，用于插入元素</li><li>流迭代器：绑定到输入或输出流，用于遍历关联 IO 流</li><li>反向迭代器：向后而不是向前移动，除 forward_list 均有</li><li>移动迭代器：移动元素</li></ul><h1 id="第十一章-关联容器"><a class="anchor" href="#第十一章-关联容器">#</a> 第十一章 关联容器</h1><p>按关键字有序保存元素</p><ul><li><code>map</code> ：关联数组，保存关键字 - 值对<ul><li>如果关键字还未在 map 中，下标运算会添加一个新元素</li></ul></li><li><code>set</code> ：关键字即值</li><li><code>multimap</code> ：关键字可重复出现的 map</li><li><code>multiset</code> ：关键字可重复出现的 set</li></ul><p>无序集合</p><ul><li><code>unorderd_map</code> ：哈希函数组织的 map</li><li><code>unorderd_set</code> ：哈希函数组织的 set</li><li><code>unorderd_multimap</code></li><li><code>unorderd_multiset</code></li></ul><h2 id="pair-类型"><a class="anchor" href="#pair-类型">#</a> pair 类型</h2><p>一个 pair 保存两个数据成员</p><ul><li><code>make_pair</code></li></ul><h1 id="第十二章-动态内存"><a class="anchor" href="#第十二章-动态内存">#</a> 第十二章 动态内存</h1><p>动态分配的对象生存期与它们在哪里创建无关，只有显示释放才会销毁。<br>在 C++ 中，动态内存管理运算符 new 和 delete 完成。</p><ul><li>在自由空间分配的内存是无名的，new 运算符返回指向该对象的指针</li><li><code>int *pi1=new int; //默认初始化，*pi1 的值未定义</code></li><li><code>int *pi2=new int() //值初始化为 0，*pi2 为 0</code></li><li>注：对于定义了自己构造函数的类类型来说，不管采用哪种方式都会通过默认构造函数来初始化。默认初始化和值初始化仅影响内置类型成员。</li><li>const 对象使用 new 分配是合法的 (也可以 delete)</li><li>内存耗尽时，new 表达式就会失败</li><li>由内置指针 (而非智能指针) 管理的动态内存在被显式释放前一直都会存在。</li></ul><p>空悬指针：指向一块曾经保存数据对象但现在已经无效的内存的指针。</p><h2 id="智能指针"><a class="anchor" href="#智能指针">#</a> 智能指针</h2><p>智能指针也是模板。<br>默认初始化的智能指针中保存着一个空指针，如果在一个条件判断语句中使用智能指针，效果就是检测其是否为空。</p><ul><li>解引用一个智能指针返回它指向的对象</li></ul><p>即使发生异常，(由于局部对象会被销毁) 智能指针也会释放其对象。</p><h3 id="类型"><a class="anchor" href="#类型">#</a> 类型</h3><p><code>shared_ptr</code></p><ul><li>允许多个指针指向同一个对象。</li><li>通过引用计数器记录，当我们拷贝 shared_ptr 时计数递增，被拷贝对象离开作用域被销毁递减</li><li>计数器归零则自动释放所管理对象 (通过析构函数)</li></ul><p><code>unique_ptr</code></p><ul><li>『独占』所指向的对象</li></ul><p><code>weak_ptr</code></p><ul><li>一种弱引用，指向 shared_ptr 所管理的对象</li></ul><h3 id="make_shared-函数"><a class="anchor" href="#make_shared-函数">#</a> make_shared 函数</h3><p>此函数在动态内存分配一个对象并初始化，返回指向对象的 shared_ptr</p><ul><li>可传递匹配对应对象构造函数的参数</li><li>若不传递任何参数，对象会被进行值初始化</li></ul><h3 id="shared_ptr-和-new-结合使用"><a class="anchor" href="#shared_ptr-和-new-结合使用">#</a> shared_ptr 和 new 结合使用</h3><p>这两者允许结合使用，使用 new 返回的指针初始化智能指针 (但必须使用直接初始化方式)：</p><ul><li><code>shared_ptr&lt;int&gt; p(new int(1024))</code></li><li>另外 shared_ptr 提供了 get 函数返回普通指针</li><li>reset：<ul><li>释放绑定的普通指针</li><li>或重新绑定智能指针维护的普通指针</li><li>(会更新引用计数)</li></ul></li></ul><p>注 1：默认情况下初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用 delete 释放关联对象。可使用 shared_ptr<t>p (q,d) (d 为可调用对象) 接管释放对象操作。<br>注 2：但是不要混合使用智能指针和普通指针</t></p><h3 id="自定义-shared_ptr-释放操作"><a class="anchor" href="#自定义-shared_ptr-释放操作">#</a> 自定义 shared_ptr 释放操作</h3><p>可以传递一个可选的指向删除器函数的参数</p><h3 id="智能指针使用注意"><a class="anchor" href="#智能指针使用注意">#</a> 智能指针使用注意</h3><ul><li>不使用相同的内置指针初始化 (或 reset) 多个智能指针</li><li>不 delete get () 返回的内置指针</li><li>不使用 get () 返回的内置指针初始化或 reset 另外一个智能指针</li><li>使用 get () 返回的内置指针时，注意智能指针自动释放后，该内置指针指向内存也会无效</li><li>如果智能指针不是管理的 new 操作符分配的动态内存，注意需要传递一个删除器以使其正确释放对象</li></ul><h3 id="unique_ptr"><a class="anchor" href="#unique_ptr">#</a> unique_ptr</h3><p>某个时刻只有一个 unique_ptr 指向一个给定对象<br>因此 unique_ptr 不支持普通的拷贝或赋值操作，只能采用直接初始化方式：</p><ul><li><code>unique_ptr&lt;int&gt; p(new int(1024))</code></li><li>注：拷贝限制的例外之处在于即将销毁时，例如允许从函数返回一个 unique_ptr</li></ul><p>需要注意的是 release 操作：</p><ul><li>该操作会切断 unique_ptr 与其管理的对象间的联系，返回对象内置指针 (不会释放对象内存)</li><li>返回的内置指针需要我们自己维护 (释放)，或转移至另外一个智能指针管理</li><li>(会导致释放对象的操作与 shared_ptr 一样，是 reset)</li></ul><h3 id="weak_ptr"><a class="anchor" href="#weak_ptr">#</a> weak_ptr</h3><p>一种不控制所指向对象生存期的智能指针，其指向一个 shared_ptr，即使有 weak_ptr 指向，当其它指向 shared_ptr 销毁时对象就会被 shared_ptr 销毁。<br>主要操作</p><ul><li>expired ()：若 shared_ptr 数量为 0 (对象可能已释放)，返回 true，否则 false</li><li>lock ()：若 expired () 为 true，返回空，否则返回 shared_ptr</li><li>use_count ()：shared_ptr 共享数量</li></ul><p>使用： <code>if(shared_ptr&lt;int&gt; p=wp.lock())&#123;&#125;</code></p><h2 id="动态数组"><a class="anchor" href="#动态数组">#</a> 动态数组</h2><ul><li>new T []，返回一个数组元素类型的指针</li><li>delete [] array，释放</li><li>或使用智能指针管理：<ul><li><code>unique_ptr&lt;int[]&gt; array(new int[10])</code></li><li><code>array.release()</code></li><li>对于 unique_ptr 指向的数组不能使用点或箭头成员运算符，但可以使用下标访问元素</li><li>注：shared_ptr 不直接支持动态数组，如果想使用 shared_ptr 管理动态数组，需要提供自定义的删除器且访问也更麻烦 (通过获取内置指针)</li></ul></li><li>注：动态数组并不是数组类型，也不能使用 begin 或 end 获取迭代器</li></ul><p>建议：大多数应用应该使用标准库容器而不是动态分配的数组。标准库容器更简单、安全，性能也更好。</p><h2 id="allocator-类"><a class="anchor" href="#allocator-类">#</a> allocator 类</h2><p>new 将内存分配和对象构造组合在了一起，灵活性更有局限。<br>allocator 类将内存分配和对象构造分离开来，其分配的内存是原始的、未构造的。<br>操作</p><ul><li><code>allocator&lt;T&gt; a</code> ：定义一个可以为类型 T 分配内存的 allocator 对象</li><li><code>allocate(n)</code> ：分配可以存储 n 个对象的原始内存</li><li><code>deallocate(p,n)</code> ：释放，调用之前必须对每个对象先调用过 destroy</li><li><code>construct(p,args)</code> ：实际构造对象</li><li><code>destroy(p)</code> ：对 p 指针指向对象执行析构函数</li></ul><p>注：为使用 allocate 返回的内存，必须用 construct 构造对象。<br>另外还提供了可以拷贝和填充未初始化内存算法：</p><ul><li><code>uninitialized_copy</code></li><li><code>uninitialized_copy_n</code></li><li><code>uninitialized_fill</code></li><li><code>uninitialized_fill_n</code></li></ul><h1 id="第十三章-拷贝控制"><a class="anchor" href="#第十三章-拷贝控制">#</a> 第十三章 拷贝控制</h1><p>当定义一个类时，我们显式指定在此类型的对象拷贝、移动、赋值和销毁时做什么：</p><ul><li>拷贝构造函数：当用同类型的另一个对象初始化本对象时做什么</li><li>拷贝赋值运算符：将一个对象赋予同类型另一个对象时做什么</li><li>移动构造函数：当用同类型的另一个对象初始化本对象时做什么</li><li>移动赋值运算符：将一个对象赋予同类型另一个对象时做什么</li><li>析构函数：销毁时做什么</li><li>注：这些操作若我们未显式定义，则编译器会自动生成</li></ul><h2 id="拷贝构造函数"><a class="anchor" href="#拷贝构造函数">#</a> 拷贝构造函数</h2><p>一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值</p><ul><li>Foo (); // 默认构造函数</li><li>Foo (const Foo&amp;); // 拷贝构造函数</li></ul><p>拷贝初始化</p><ul><li>拷贝初始化通常使用拷贝构造函数完成，不过一个类有移动构造函数时，有时会使用移动构造函数完成</li><li>string s (&quot;1&quot;) // 直接初始化</li><li>string s2=s; // 拷贝初始化</li><li>其它发生情况：<ul><li>将一个对象作为实参传递给一个非引用类型的形参</li><li>从一个返回类型为非引用类型的函数返回一个对象</li><li>花括号列表初始化一个数组中的元素或一个聚合类中的成员</li></ul></li></ul><h2 id="拷贝赋值运算符"><a class="anchor" href="#拷贝赋值运算符">#</a> 拷贝赋值运算符</h2><p>重载赋值运算符</p><ul><li>重载运算符本质上是函数，其名字由 operator 关键字后接表示要定义的运算符的符号组成</li><li>因此赋值运算符是一个名为 operator= 的函数，类似于任何其它函数</li><li>运算符函数也有一个返回类型和一个参数列表</li></ul><p>拷贝赋值运算符表现：</p><ul><li><code>Foo&amp; operator=(const Foo&amp;);</code></li></ul><p>注：注意即使一个对象赋值给自身，也需要正确工作。因此处理拷贝控制时需要临时变量做缓存，即销毁左侧运算对象资源之前拷贝右侧运算对象。</p><h2 id="析构函数"><a class="anchor" href="#析构函数">#</a> 析构函数</h2><p>资源释放<br>注 1：析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的。析构函数体作为成员销毁步骤之外的另一部分而进行。<br>注 2：根据三 / 五法则，如果一个类需要定义析构函数，几乎可以肯定它也需要自定义拷贝构造函数和拷贝赋值运算符。</p><h2 id="阻止拷贝"><a class="anchor" href="#阻止拷贝">#</a> 阻止拷贝</h2><p>可以通过将拷贝构造函数和拷贝赋值运算符定义为 删除的函数 来阻止拷贝。</p><ul><li><code>NoCopy()=default; //使用合成的默认构造函数</code></li><li><code>NoCopy(const NoCopy&amp;)=delete; //阻止拷贝</code></li><li><code>NoCopy &amp;operator=(const NoCopy&amp;) =delete; //阻止赋值</code></li></ul><p>注 1：不同于 =default，我们可以对任何函数指定 =delete<br>注 2：本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。</p><h2 id="拷贝控制和资源管理"><a class="anchor" href="#拷贝控制和资源管理">#</a> 拷贝控制和资源管理</h2><p>众所周知，若一个类对象被拷贝，若成员是指针，而我们定义了释放该指针的析构函数，每个发生释放的拷贝对象都会释放指针资源，导致错误问题。<br>因此需要同时重载拷贝构造函数。</p><h3 id="行为像值的类"><a class="anchor" href="#行为像值的类">#</a> 行为像值的类</h3><p>重载的拷贝构造函数或拷贝赋值运算符中，将指针对象重新分配一次，每个拷贝对象中指针都指向内容相同但实际不同的对象。<br>这样每次析构函数释放时都是释放自己指向的指针。</p><h3 id="行为像指针的类"><a class="anchor" href="#行为像指针的类">#</a> 行为像指针的类</h3><p>需要定义拷贝构造函数和拷贝赋值运算符，以拷贝成员本身而不是它指向的对象。<br>而析构函数释放关联对象内存的方式，必须是最后一个指向关联对象的该对象销毁才可以释放。</p><ul><li>因此最好的方法是使用 shared_ptr 管理类中资源</li><li>或自定义引用计算进行管理<ul><li>构造函数还需要创建一个引用计算，记录有多少对象与正在创建对象共享状态</li><li>拷贝构造函数不分配新的计数器，而是拷贝数据成员并递增共享的计数器</li><li>析构函数递减计数器，若计数器达到 0，则释放状态</li><li>拷贝赋值运算符递增右侧运算对象计数器，递减左侧运算对象计数器，同时判断左侧计数器是否为 0 以决定是否释放其资源</li><li>注：引用计数不能直接作为对象数据成员，可以使用动态内存分配指针</li></ul></li></ul><h2 id="交换操作"><a class="anchor" href="#交换操作">#</a> 交换操作</h2><p>swap 标准库函数，有时需要定义自己的 swap 覆盖标准库的函数，避免额外分配。<br>可以在赋值运算符中使用使用 swap，使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。</p><h3 id="移动构造函数与-stdmove"><a class="anchor" href="#移动构造函数与-stdmove">#</a> 移动构造函数与 std:move</h3><h2 id="对象移动"><a class="anchor" href="#对象移动">#</a> 对象移动</h2><p>IO 类和 unique_ptr 可以移动但不能拷贝</p><h3 id="右值引用"><a class="anchor" href="#右值引用">#</a> 右值引用</h3><p>左值持久，右值短暂<br>&amp;&amp;：只能绑定到临时对象，如对象将要销毁、对象没有其它用具</p><ul><li>使用右值引用可以自由地接管所引用对象的资源</li><li>变量是左值：因此不能将右值引用直接绑定到一个变量上，即使这个变量是右值引用也不行</li></ul><p>但是允许使用 move 函数显式将一个左值转换为对应右值引用类型</p><ul><li><code>int &amp;&amp;rr3=std::move(rr1);</code></li><li>调用 move 意味着承诺：除了对 rr1 赋值或销毁它外，我们将不再使用它</li><li>注：使用 move 应使用 std:move</li></ul><h2 id="移动构造函数和移动赋值运算符"><a class="anchor" href="#移动构造函数和移动赋值运算符">#</a> 移动构造函数和移动赋值运算符</h2><p>这两个成员类似对应拷贝操作，但它们从给定对象『窃取』资源而不是拷贝资源。</p><ul><li>移动构造函数不分配任何新的内存</li><li>类名 (类名 &amp;&amp;s) noexcept:{}</li></ul><p>noexcept</p><ul><li>承诺一个函数不抛出异常</li><li>移动构造函数通常不应抛出异常，因此可以以此标识，通知标准库减少一些额外操作</li></ul><p>移动赋值运算符执行与析构函数和移动构造函数相同工作。</p><ul><li>移动赋值运算符必须销毁左侧运算对象的旧状态</li></ul><p>注 1：在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值做任何假设。<br>注 2：编译器根本不会为某些类合成移动操作。特别是一个类已定义自己的 拷贝构造函数、拷贝赋值运算符或析构函数，就不会合成移动构造函数和移动赋值运算符。—— 只有当一个类没有定义任何自己版本的拷贝控制成员，且所有数据成员都能移动构造或移动赋值时，编译器才会为其合成移动操作。<br>注 3：如果一个类没有移动构造函数或移动赋值运算符，则类会使用对应的拷贝操作来代替移动操作。</p><h2 id="右值引用的成员函数"><a class="anchor" href="#右值引用的成员函数">#</a> 右值引用的成员函数</h2><p>成员函数也可以同时提供拷贝和移动版本。</p><h2 id="引用限定符"><a class="anchor" href="#引用限定符">#</a> 引用限定符</h2><p>通过 &amp; 或 &amp;&amp; 分别指出 this 可以指向一个左值或一个右值</p><ul><li><code>Foo &amp;operator=(const Foo&amp;) &amp;; //只能向可修改的左值赋值</code></li><li><code>Foo sorted() &amp;&amp;; //可用于可改变的右值</code></li></ul><h1 id="第十四章-重载运算与类型转换"><a class="anchor" href="#第十四章-重载运算与类型转换">#</a> 第十四章 重载运算与类型转换</h1><p><img data-src="/blogimages/2023/2023-10-22/-1327189457.jpeg" alt=""></p><p>赋值运算符</p><ul><li>例如使类型可以像 vector 一样接受花括号初始化</li><li><code>xxx &amp;operator=(std::initializer_list&lt;std::string&gt;);</code></li></ul><p>下标运算符</p><ul><li><code>operator[]</code></li></ul><p>递增和递减运算符</p><ul><li>区分前置和后置</li><li>前置返回对象引用，后置返回对象的原值</li></ul><p>成员访问运算符</p><ul><li><code>*</code></li><li><code>-&gt;</code></li><li>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</li></ul><p>函数调用运算符</p><ul><li><code>operator()</code></li><li>可以像使用函数一样使用该类对象</li><li>如果类定义了调用运算符，则该类对象称作 函数对象</li></ul><p>lambda</p><ul><li>lambda 生成的匿名类型中含有一个重载函数调用运算符</li><li><code>stable_sort(words.begin(),words.end(),类名());</code></li><li>捕获变量的 lambda 则生成构造函数带有对应参数</li></ul><h2 id="可调用对象与-function"><a class="anchor" href="#可调用对象与-function">#</a> 可调用对象与 function</h2><p>C++ 语言中有几种可调用对象：</p><ul><li>函数</li><li>函数指针</li><li>lambda 表达式</li><li>bind 创建的对象</li><li>重载了函数调用运算符的类</li></ul><p>可调用对象也有类型，但两个不同类型的可调用对象可能共享同一种 调用形式。</p><ul><li>调用形式：指明了调用返回的类型及传递给调用的实参类型</li></ul><h3 id="标准库-function-类型"><a class="anchor" href="#标准库-function-类型">#</a> 标准库 function 类型</h3><ul><li>function 是一个模板，定义时可用于指定该 function 类型能够表示的对象的调用形式。</li><li>只要可调用对象满足指定的调用形式，就可以存储于同一个 function 类型中。</li><li>例如：<ul><li><code>function&lt;int(int,int)&gt;</code></li><li>表示接受两个 int，返回一个 int 的可调用对象</li><li>如此声明后，可用于表示任意一种类似可调用类型：函数指针、函数对象类的对象 (函数对象)、lambda</li></ul></li></ul><h3 id="重载函数与-function"><a class="anchor" href="#重载函数与-function">#</a> 重载函数与 function</h3><ul><li>如果函数存在重载，那么直接通过函数名称存储会导致二义性</li><li>可通过 存储函数指针而非函数名字，或 lambda 表达式来消除二义性<ul><li>定义函数指针： <code>int (*fp)(int,int)=add</code></li><li>定义 lambda： <code>[](int a,int b)&#123;return add(a,b);&#125;</code></li></ul></li></ul><h2 id="重载-类型转换与运算符"><a class="anchor" href="#重载-类型转换与运算符">#</a> 重载、类型转换与运算符</h2><h3 id="类型转换运算符"><a class="anchor" href="#类型转换运算符">#</a> 类型转换运算符</h3><p>类型转换运算符是类的一种特殊的成员函数，负责将一个类类型转换成其它类型。</p><ul><li><code>operator type() const</code></li><li>一个类型转换函数必须是类的成员函数，它不能声明返回类型，形参列表也必须为空 (类型转换运算符是隐式执行的)。类型转换函数通常应该是 const (不应修改待转换对象的内容)</li></ul><h3 id="显式的类型转换运算符"><a class="anchor" href="#显式的类型转换运算符">#</a> 显式的类型转换运算符</h3><ul><li>为防止隐式转换可能产生的异常情况</li><li><code>explicit operator type() const</code></li><li>显式的类型转换也可能会被隐式执行：<ul><li>if、while 及 do 语句条件部分</li><li>for 语句头的条件表达式</li><li>逻辑非运算符 (!)、逻辑或运算符 (||)、逻辑与运算符 (&amp;&amp;) 的运算对象</li><li>条件运算符 <code>(? :)</code> 的条件表达式</li></ul></li><li>注：向 bool 的类型转换通常用在条件部分，因此 operator bool 一般定义成 explicit 的</li></ul><h3 id="避免二义性转换"><a class="anchor" href="#避免二义性转换">#</a> 避免二义性转换</h3><ul><li>例如定义了多个类型转换规则，可以通过其它类型转换联系到一起。</li><li>重载构造函数 (默认隐式转换) 也可能导致</li><li>对同一个类既提供转换目标是算数类型的类型转换，也提供了重载的运算符，重载运算符与内置运算符将会有二义性问题</li></ul><div class="tags"><a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 笔记</a> <a href="/tags/CPP/" rel="tag"><i class="ic i-tag"></i> CPP</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-10-22 17:57:56" itemprop="dateModified" datetime="2023-10-22T17:57:56+08:00">2023-10-22</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>WangJiaYing <i class="ic i-at"><em>@</em></i>CWHISME</li><li class="link"><strong>本文链接：</strong> <a href="https://wangjiaying.top/2023/10/22/CPP-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%AC%94%E8%AE%B0-2/" title="《C++ Primer (第五版)》- 笔记 (2)">https://wangjiaying.top/2023/10/22/CPP-Primer-第五版-笔记-2/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/10/06/%E8%99%9A%E5%B9%BB5%E5%8A%A8%E7%94%BB%E9%80%82%E9%85%8D-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="prev" data-background-image="&#x2F;images&#x2F;coverimages&#x2F;large&#x2F;971a48f7d7f9c35be5139261b16bab8c_2_2_art.webp" title="虚幻5动画适配方式-笔记"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 虚幻引擎</span><h3>虚幻5动画适配方式-笔记</h3></a></div><div class="item right"><a href="/2023/11/18/JobSystem%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" itemprop="url" rel="next" data-background-image="&#x2F;images&#x2F;coverimages&#x2F;large&#x2F;81113906_p0.webp" title="JobSystem 的简单使用"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Unity3D</span><h3>JobSystem 的简单使用</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">第九章 顺序容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">第十章 泛型算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lamda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">lamda 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93-bind-%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">标准库 bind 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">再探迭代器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">第十一章 关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pair-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">pair 类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-number">5.</span> <span class="toc-text">第十二章 动态内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">5.1.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#make_shared-%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.2.</span> <span class="toc-text">make_shared 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared_ptr-%E5%92%8C-new-%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.3.</span> <span class="toc-text">shared_ptr 和 new 结合使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-shared_ptr-%E9%87%8A%E6%94%BE%E6%93%8D%E4%BD%9C"><span class="toc-number">5.1.4.</span> <span class="toc-text">自定义 shared_ptr 释放操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F"><span class="toc-number">5.1.5.</span> <span class="toc-text">智能指针使用注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique_ptr"><span class="toc-number">5.1.6.</span> <span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak_ptr"><span class="toc-number">5.1.7.</span> <span class="toc-text">weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">5.2.</span> <span class="toc-text">动态数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#allocator-%E7%B1%BB"><span class="toc-number">5.3.</span> <span class="toc-text">allocator 类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">第十三章 拷贝控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.</span> <span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.2.</span> <span class="toc-text">拷贝赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E6%8B%B7%E8%B4%9D"><span class="toc-number">6.4.</span> <span class="toc-text">阻止拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">6.5.</span> <span class="toc-text">拷贝控制和资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%83%8F%E5%80%BC%E7%9A%84%E7%B1%BB"><span class="toc-number">6.5.1.</span> <span class="toc-text">行为像值的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%83%8F%E6%8C%87%E9%92%88%E7%9A%84%E7%B1%BB"><span class="toc-number">6.5.2.</span> <span class="toc-text">行为像指针的类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">6.6.</span> <span class="toc-text">交换操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E-stdmove"><span class="toc-number">6.6.1.</span> <span class="toc-text">移动构造函数与 std:move</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8"><span class="toc-number">6.7.</span> <span class="toc-text">对象移动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">6.7.1.</span> <span class="toc-text">右值引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.8.</span> <span class="toc-text">移动构造函数和移动赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">6.9.</span> <span class="toc-text">右值引用的成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">6.10.</span> <span class="toc-text">引用限定符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.</span> <span class="toc-text">第十四章 重载运算与类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%B8%8E-function"><span class="toc-number">7.1.</span> <span class="toc-text">可调用对象与 function</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93-function-%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.1.1.</span> <span class="toc-text">标准库 function 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E4%B8%8E-function"><span class="toc-number">7.1.2.</span> <span class="toc-text">重载函数与 function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.2.</span> <span class="toc-text">重载、类型转换与运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.2.1.</span> <span class="toc-text">类型转换运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.2.2.</span> <span class="toc-text">显式的类型转换运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BA%8C%E4%B9%89%E6%80%A7%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.2.3.</span> <span class="toc-text">避免二义性转换</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/10/02/CPP_Primer_%E7%AC%AC%E4%BA%94%E7%89%88_%E7%AC%94%E8%AE%B0-1/" rel="bookmark" title="《C++ Primer(第五版)》-笔记(1)">《C++ Primer(第五版)》-笔记(1)</a></li><li class="active"><a href="/2023/10/22/CPP-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%AC%94%E8%AE%B0-2/" rel="bookmark" title="《C++ Primer(第五版)》-笔记(2)">《C++ Primer(第五版)》-笔记(2)</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="WangJiaYing" data-src="/images/../img/avator"><p class="name" itemprop="name">CWHISME</p><div class="description" itemprop="description">己所不欲，勿施于人</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">125</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">22</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">32</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N3aGlzbWU=" title="https:&#x2F;&#x2F;github.com&#x2F;cwhisme"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9jd2hpc21lLTMzL3Bvc3Rz" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;cwhisme-33&#x2F;posts"><i class="ic i-zhihu"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmN3aGlzbWVAMTI2LmNvbQ==" title="mailto:cwhisme@126.com"><i class="ic i-envelope"></i></span> <a href="/atom.xml" title="&#x2F;atom.xml" class="item feedback"><i class="ic i-heart"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-clock"></i>统计</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/10/06/%E8%99%9A%E5%B9%BB5%E5%8A%A8%E7%94%BB%E9%80%82%E9%85%8D-%E7%AC%94%E8%AE%B0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/11/18/JobSystem%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Unity3D/" title="分类于 Unity3D">Unity3D</a></div><span><a href="/2017/05/07/2017-5-7-Unity-use-othographic-camera-map/" title="Unity3D以正交相机截取作大地图">Unity3D以正交相机截取作大地图</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Unity3D/" title="分类于 Unity3D">Unity3D</a></div><span><a href="/2021/10/25/%E4%B8%8A%E6%9E%B6%E6%A3%80%E6%B5%8B%E6%8F%90%E7%A4%BA%E6%9C%89Unity%E5%B9%BF%E5%91%8A%E6%9C%8D%E5%8A%A1/" title="上架检测提示有Unity广告服务">上架检测提示有Unity广告服务</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%9A%E5%AE%A2/" title="分类于 博客">博客</a></div><span><a href="/2021/06/13/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Live2D%E7%9C%8B%E6%9D%BF%E5%A8%98/" title="为博客添加Live2D看板娘折腾的那些事">为博客添加Live2D看板娘折腾的那些事</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment count_3"></ul></div></div><div class="status"><div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">WangJiaYing @ Jiaying's Note</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">736k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">11:09</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NXSElTTUUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/10/22/CPP-Primer-第五版-笔记-2/",favicon:{show:"（●´3｀●）",hide:"(´Д｀)"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,justifiedGallery:!0,jquery:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script><script src="https://cdn.staticfile.org/pjax/0.2.8/pjax.min.js"></script><script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script><script src="https://cdn.staticfile.org/algoliasearch/4.17.0/algoliasearch-lite.umd.js"></script><script src="https://cdn.staticfile.org/instantsearch.js/4.54.1/instantsearch.production.min.js"></script><script src="https://cdn.staticfile.org/lozad.js/1.16.0/lozad.min.js"></script><script src="https://cdn.staticfile.org/quicklink/2.3.0/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/js/DateTimeAfeterCalc.js" async></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js" async></script></body></html>