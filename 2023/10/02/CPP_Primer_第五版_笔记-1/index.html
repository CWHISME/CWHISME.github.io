<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="CWHISME" href="https://wangjiaying.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="CWHISME" href="https://wangjiaying.top/atom.xml"><link rel="alternate" type="application/json" title="CWHISME" href="https://wangjiaying.top/feed.json"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="笔记,CPP"><link rel="canonical" href="https://wangjiaying.top/2023/10/02/CPP_Primer_%E7%AC%AC%E4%BA%94%E7%89%88_%E7%AC%94%E8%AE%B0-1/"><title>《C++ Primer (第五版)》- 笔记 (1) - C++ - 阅读笔记 | Jiaying's Note = CWHISME = 人不能没有梦想，也要有足够的敬畏</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">《C++ Primer (第五版)》- 笔记 (1)</h1><div class="meta"><span class="item" title="创建时间：2023-10-02 17:14:12"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-10-02T17:14:12+08:00">2023-10-02</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>9.4k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>9 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiaying's Note</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/blogimages/2023/2023-10-02/book.webp"></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" itemprop="item" rel="index" title="分类于 阅读笔记"><span itemprop="name">阅读笔记</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/C/" itemprop="item" rel="index" title="分类于 C++"><span itemprop="name">C++</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangjiaying.top/2023/10/02/CPP_Primer_%E7%AC%AC%E4%BA%94%E7%89%88_%E7%AC%94%E8%AE%B0-1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/../img/avator"><meta itemprop="name" content="WangJiaYing"><meta itemprop="description" content="人不能没有梦想，也要有足够的敬畏, 己所不欲，勿施于人"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="CWHISME"></span><div class="body md" itemprop="articleBody"><h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本篇笔记主要包含原书第一部分，第一章～第七章，从变量定义到类结束。</p><p>这次仔细从头开始看，包括最基础的语法都给重新过了一遍，虽然可能看得稍微有点快，而且做不到看完就熟稔了，不过至少重点记录了笔记，后续翻看一下，总能回忆不少印象。</p><p>说实话的话，补完这几章，再去看 UE 的 C++ 代码的时候，看起来就感觉更轻松些了 —— 毕竟理论知识确实是基础，自然比全然不知道的情况下去总结经验来得强。</p><p>这本书还是有点厚，不知道这次国庆节抽出的时间看不看得完。</p><hr><ul><li>像编译器一样来思考和理解 C++</li><li>本书主要为 C++11 标准</li></ul><h1 id="第一章-开始"><a class="anchor" href="#第一章-开始">#</a> 第一章 开始</h1><p>错误的注释比完全没有注释更糟糕。<br>点运算符只能用于类类型对象。</p><h1 id="第二章-变量和基本类型"><a class="anchor" href="#第二章-变量和基本类型">#</a> 第二章 变量和基本类型</h1><p>为赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据类型，类型决定数据所占比特数及如何解释这些比特内容。<br>整型和浮点型具有字面值</p><ul><li>整型字面值的具体数据类型由它的值和符号决定 (int、long、long long 尺寸最小的一个)</li><li>严格来说，十进制字面值不会是负数，『-42』这种字面值的负号不在字面值之内，作用是对字面值取负值</li><li>浮点型的字面值是一个 double</li><li>类型 short 没有对应的字面值</li></ul><p>字符串字面值</p><ul><li>是由常量字符构成的数组，字符串结尾会被编译器添加一个空字符 (\0)，因此字符串字面值实际长度比内容多一个。</li></ul><p>指针字面值</p><ul><li>nullptr</li></ul><p>指定字面值类型</p><ul><li>通过添加值的前缀或后缀，可指定字面值的默认类型</li><li>如 3.14F 表示 float</li></ul><h2 id="变量"><a class="anchor" href="#变量">#</a> 变量</h2><p>通常情况下，对象指一块能够存储数据并具有某种类型的内存空间。</p><h3 id="初始值值初始化"><a class="anchor" href="#初始值值初始化">#</a> 初始值 (值初始化)</h3><p>当对象在创建时获得了一个特定的值<br>注：(虽然都是等号) 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义则是把对象当前值擦除，而以一个新值替代</p><h3 id="列表初始化"><a class="anchor" href="#列表初始化">#</a> 列表初始化</h3><ul><li>可使用花括号初始值，称为列表初始化</li><li>注：对结构的数据成员进行初始化时，必须使用列表初始化进行</li></ul><h3 id="默认初始化"><a class="anchor" href="#默认初始化">#</a> 默认初始化</h3><ul><li>若定义变量时没有指定初值，则变量被默认初始化</li><li>此时变量被赋予 &quot;默认值&quot;</li><li>内置类型定义于函数体内时，将不被初始化，未初始化内置类型变量值属于未定义，访问将引发错误。(定义于函数体外则被默认初始化为 0)</li></ul><p>注：每个类各自决定其初始化对象的方式，是否允许不经初始化就定义对象也由类自己决定。多数类都支持无需显式初始化而定义对象。</p><h3 id="变量声明和定义"><a class="anchor" href="#变量声明和定义">#</a> 变量声明和定义</h3><p>为支持分离式编译，C++ 将声明 (declaration) 和定义 (definition) 区分开类。</p><ul><li>声明规定了变量类型和名字</li><li>定义除声明功能外，还申请存储空间，或为变量赋一个初始值</li></ul><p>例如</p><ul><li>仅声明：extern int i;</li><li>声明并定义：int j;</li><li>注：包含显式初始化的声明即成为定义，如 extern int x=12 表示的是定义 (extern 声明相当于无效)</li></ul><p>注 1：变量可以被多次声明，但只能被定义一次<br>注 2：C++ 是一种静态类型语言，编译器会在编译阶段检查类型，因此要求我们在使用某个变量之前必须声明其类型</p><h3 id="作用域"><a class="anchor" href="#作用域">#</a> 作用域</h3><p>当第一次使用变量时再定义它<br>全局作用域</p><ul><li>:: 变量名</li><li>如果函数有可能用到某全局变量，则不宜再定义一个同名局部变量 (此处记录表示可以有这种操作)</li></ul><h2 id="复合类型"><a class="anchor" href="#复合类型">#</a> 复合类型</h2><h3 id="引用"><a class="anchor" href="#引用">#</a> 引用</h3><p>引用为对象起了另外一个名字，引用类型引用另外一种类型。</p><ul><li>通过声明符 &amp; 定义引用类型</li><li>定义引用时，程序把引用和它的初始值绑定在一起</li><li>对引用的所有操作都是在与之绑定的对象上进行</li><li>引用必须被初始化，并且无法再重新绑定给另外对象</li><li>(引用本身不是一个对象，因此不能定义引用的引用)</li></ul><h3 id="指针"><a class="anchor" href="#指针">#</a> 指针</h3><p>指针是指向另外一种类型的复合类型，与引用类似，指针也实现了对其它对象的间接访问。</p><ul><li>指针本身是一个对象，允许对指针赋值和拷贝</li><li>指针允许无需在定义时赋初值</li><li>(与其它内置类型一样，块作用域定义的指针若未初始化则具有不确定值)</li></ul><p>解引用符 (*) 可用于访问指针指向的对象 (仅适用于确实指向了某个对象的有效指针)<br>空指针</p><ul><li>赋值 nullptr (推荐)</li><li>赋值 0</li><li>赋值 NULL (cstdlib 预处理变量，值实际为 0)</li></ul><p>void* 指针</p><ul><li>特殊的指针类型，可用于存放任意对象的地址</li><li>不能直接操作 void* 指针所指的对象 (因为不确定类型)</li><li>即 void* 仅代表内存空间，无法访问内存空间中所存储的对象</li></ul><p>注：面对一条比较复杂的指针或引用声明时，从右往左阅读有助于弄清楚它的真实含义。</p><h3 id="const-限定符"><a class="anchor" href="#const-限定符">#</a> const 限定符</h3><p>const 对象一旦创建后其值就不能改变因此 const 对象必须初始化。<br>默认状态下，const 对象仅在文件内有效</p><ul><li>编译器将在编译过程中把用到该变量的地方都替换成对应的值</li><li>添加 extern 关键字可以改变默认行为，使其全局 (多个文件之间共享) 生效</li></ul><h4 id="const-的引用"><a class="anchor" href="#const-的引用">#</a> const 的引用</h4><ul><li>可以把引用绑定到 const 对象上，称为对常量的引用，对常量的引用不能修改它所绑定的对象</li><li>const int &amp;r1=xxx</li><li>注：常量引用仅对引用可参与的操作做出限定，对于引用本身是否是一个常量未做限定</li></ul><h4 id="指针和-const"><a class="anchor" href="#指针和-const">#</a> 指针和 const</h4><ul><li>指针添加 const 称为 指向常量的指针</li><li>const double *ptr=&amp;xxx</li><li>指向常量的指针不能指向非常量地址，也不能修改指向对象的值 (也可以指向非常量对象，相当于多了不能修改的限制)</li></ul><h4 id="const-指针"><a class="anchor" href="#const-指针">#</a> const 指针</h4><ul><li>常量指针必须初始化，而且一旦初始化完成，其值 (指向的地址) 就不能再改变</li><li>把 * 放在 const 之前说明指针是一个常量，不变的是指针本身的值而非指向地址的值</li><li>int *const ptr=&amp;xxx</li></ul><h3 id="constexpr-和常量表达式"><a class="anchor" href="#constexpr-和常量表达式">#</a> constexpr 和常量表达式</h3><p>常量表达式</p><ul><li>指值不会改变并且在编译过程就能得到计算结果的表达式</li></ul><h4 id="constexpr-变量"><a class="anchor" href="#constexpr-变量">#</a> constexpr 变量</h4><ul><li>在一个复杂系统中很难分辨一个初始值到底是不是常量表达式</li><li>因此 C++11 规定，允许将变量声明为 constexpr 类型以便又编译器来验证变量的值是否是一个常量表达式</li></ul><h4 id="constexpr-函数"><a class="anchor" href="#constexpr-函数">#</a> constexpr 函数</h4><ul><li>这种函数应该足够简单以使得编译时就可以计算其结果</li><li>这样就能用 constexpr 函数去初始化 constexpr 变量了</li></ul><hr><p>注：常量表达式的值需要在编译时就得到计算，因此对声明 constexpr 的类型必须有所限制 —— 称为字面值类型<br>指针和 constexpr</p><ul><li>constexpr 仅对指针有效，与指针所指对象无关</li><li>即：constexpr 定义的一定是 常量指针 (指针本身不可变)</li></ul><h2 id="处理类型"><a class="anchor" href="#处理类型">#</a> 处理类型</h2><h3 id="类型别名"><a class="anchor" href="#类型别名">#</a> 类型别名</h3><ul><li>typedef a b</li><li>using b=a</li></ul><h3 id="auto-类型说明符"><a class="anchor" href="#auto-类型说明符">#</a> auto 类型说明符</h3><ul><li>auto 让编译器通过初始值推算变量的类型 (因此定义必须有初始值)</li></ul><h3 id="decltype-类型指示符"><a class="anchor" href="#decltype-类型指示符">#</a> decltype 类型指示符</h3><ul><li>选择并返回操作数的数据类型</li><li>编译器分析表达式并得到它的类型，却不实际计算表达式的值</li><li>如果 decltype 使用的表达式不是一个变量，则 decltype 返回表达式结果对应的类型</li><li>decltype (func ()) sum=x; //sum 的类型即 func 函数返回类型</li></ul><p>注 1：decltype 与 auto 的区别是 decltype 的结果类型与表达式形式密切相关。<br>注 2：decltype ((variable))(注意是双括号) 的结果永远是引用，而 decltype (variable) 结果只有当 variable 本身就是一个引用时才是引用。</p><h2 id="自定义数据结构"><a class="anchor" href="#自定义数据结构">#</a> 自定义数据结构</h2><p>可使用 struct 定义自己的数据类型<br>确保头文件多次包含仍能安全工作的常用技术是雨处理器。<br>头文件保护符</p><ul><li>#define</li><li>#ifdef</li><li>#ifndef</li><li>#endif</li></ul><h1 id="第三章-字符串-向量和数组"><a class="anchor" href="#第三章-字符串-向量和数组">#</a> 第三章 字符串、向量和数组</h1><h2 id="命名空间的-using-声明"><a class="anchor" href="#命名空间的-using-声明">#</a> 命名空间的 using 声明</h2><p>使用 using namespace::name 后，可直接访问 name</p><ul><li>using std::cin;</li><li>cin&gt;&gt;x; // 正确</li></ul><p>注 1：每个 using 声明引入命名空间中的 一个 成员<br>注 2：头文件不应包含 using 声明 (可以做，但可能导致名字冲突)</p><h3 id="直接初始化和拷贝初始化"><a class="anchor" href="#直接初始化和拷贝初始化">#</a> 直接初始化和拷贝初始化</h3><ul><li>拷贝初始化：使用等号初始化 (只能初始化一个变量)</li><li>直接初始化：不使用等号 (可初始化具有多个初始值的对象)</li></ul><h2 id="string"><a class="anchor" href="#string">#</a> string</h2><p>初始化方式</p><ul><li>string s1</li><li>string s2(s1)</li><li>string s3=s1</li><li>string s3=&quot;value&quot;</li><li>string s4(n,'c')</li></ul><p>注 1：字符串字面值与 string 是不同类型 (因为历史及与 C 兼容等原因)<br>注 2：cctype 头文件中提供了一系列判断字符操作，例如判断是否是字母、数字、大写字母 等。<br>处理每个字符</p><ul><li>使用基于范围的 for 语句</li><li>如果想改变，则定义循环变量为引用类型</li><li>也可以通过索引访问，不过需要特别注意不要越界</li></ul><h2 id="vector"><a class="anchor" href="#vector">#</a> vector</h2><ul><li>允许使用列表初始化</li><li>允许提供一个元素数量，默认初始化 指定数量的元素</li><li>允许索引访问元素，但不能用下标形式添加元素</li></ul><p>操作</p><ul><li>push_back：添加到末尾</li></ul><h2 id="迭代器"><a class="anchor" href="#迭代器">#</a> 迭代器</h2><p>begin ()：指向第一个元素<br>end ()：指向尾元素的下一个位置 (尾后迭代器)<br>注 1：容器为空时，均为尾后迭代器<br>注 2：C++11 引入了常量迭代器 - cbegin ()、cend ()<br>其它</p><ul><li>*iter：返回迭代器 iter 所指元素的引用</li><li>iter-&gt;mem：解引用 iter 并获取名为 mem 的成员 (等价 (*iter).mem)</li><li>++iter：令 iter 指示容器中的下一个元素</li><li>--iter：令迭代器指示容器中的上一个元素</li><li>注：迭代器运算也支持增减具体数字，使其移动若干个位置</li><li>iter1==iter2：判断两个迭代器是否相等 (指示同一元素或是同一个容器的尾后迭代器)</li><li>iter1&lt;iter2：判断前者是否比后者指示位置小</li><li>iter1-iter2：获得两个迭代器的距离 (右侧迭代器向前移动多少位置可以追上左侧迭代器，可能为负)</li></ul><p>箭头运算符 (-&gt;)：把解引用和成员访问两个操作结合在一起。</p><ul><li>成员访问即。操作</li></ul><h2 id="数组"><a class="anchor" href="#数组">#</a> 数组</h2><ul><li>数组的维度必须是一个常量表达式<ul><li>注：据说是因为数组作为 C++ 的内置数据类型，其空间分配在栈内存中，这部分空间的大小在编译时就要确定 (有的编译器支持了，但都不建议，因为容易爆栈)</li><li>动态大小可以使用 new 运算符分配到堆上</li></ul></li><li>默认情况下数组元素被默认初始化</li><li>注：与内置类型一样，函数内部定义了某种内置类型数组，默认初始化会令数组含有未定义的值</li></ul><p>注：与 vector 一样，数组元素应为对象，因此不存在引用的数组。</p><h3 id="显式初始化数组元素"><a class="anchor" href="#显式初始化数组元素">#</a> 显式初始化数组元素</h3><ul><li>可对数组元素进行列表初始化 (此时允许忽略数组维度，若未指定维度则编译器自动推测)</li></ul><p>字符数组特殊性</p><ul><li>字符数组可以用字符串字面值初始化，此时会额外多一个空字符 (\0)</li></ul><p>注：不允许对数组进行拷贝给其它数组和赋值给其它数组</p><ul><li>但是运行使用数组初始化 vector 对象，指明拷贝的首元素地址和尾后地址即可</li><li>vector<int>ivec(begin(array),end(array))</int></li></ul><p>注：(重要！) 在大多数表达式中，使用数组类型对象其实是使用一个指向该数组首元素的指针</p><ul><li>例如当使用数组作为一个 auto 变量初始值时，推断得到的类型是指针而非数组</li><li>指向数组元素的指针拥有更多功能，迭代器支持的运算数组的指针均支持</li><li>尾后指针：指向数组尾元素之后那个不存在的元素的地址，利用尾后指针可以像尾后迭代器一样判断</li></ul><p>标准库函数 begin、end：</p><ul><li>使用指针运算容易出错</li><li>C++11 提供了两个函数，分别返回数组首元素指针和尾后指针</li><li>begin(array)、end(array)</li></ul><p>关系运算符</p><ul><li>若两个指针指向同一个数组的元素，则还可以使用关系运算符进行比较</li></ul><h3 id="多维数组"><a class="anchor" href="#多维数组">#</a> 多维数组</h3><p>严格来说，C++ 语言中没有多维数组，通常所说的多维数组是数组的数组。<br>循环遍历多维数组时，需将外层类型定义为引用才能正确遍历下层数组</p><ul><li>如 for (auto &amp;row:array){</li><li>for(auto col:row)</li><li>} 才是合法的</li></ul><p>指针</p><ul><li>由多维数组名转换得来的指针是指向第一个内层数组的指针</li></ul><h1 id="第四章-表达式"><a class="anchor" href="#第四章-表达式">#</a> 第四章 表达式</h1><p>左值和右值</p><ul><li>左值：指求值结果为对象或函数的表达式，一个表示对象的非常量左值可以作为赋值运算符左侧运算对象。</li><li>右值：指一种表达式，其结果是值而非值所在的位置</li></ul><p>表达式语句</p><ul><li>C++ 中最低级别的计算，每个表达式都有对应的求值结果</li></ul><p>不为 0 的数值转 bool 都是 true<br>C++11 新标准规定商一律向 0 取整 (直接舍弃小数部分)<br>进行比较时，除非比较对象是布尔类型，否则不要使用布尔字面值 true 或 false 作为运算对象。</p><h2 id="赋值运算符"><a class="anchor" href="#赋值运算符">#</a> 赋值运算符</h2><h3 id="复合赋值运算符"><a class="anchor" href="#复合赋值运算符">#</a> 复合赋值运算符</h3><ul><li>使用复合赋值运算符只求值一次，使用普通运算符则求值两次 (一次运算，一次赋值)</li></ul><h3 id="递增和递减运算符"><a class="anchor" href="#递增和递减运算符">#</a> 递增和递减运算符</h3><ul><li>前置版本将对象本身作为左值返回 (值加 1 后直接返回改变了的运算对象)</li><li>后置版本则将对象原始值的副本作为右值返回</li><li>注：允许在一条语句中混用解引用和递增运算符</li></ul><h3 id="成员访问运算符"><a class="anchor" href="#成员访问运算符">#</a> 成员访问运算符</h3><ul><li>点运算符和箭头运算符均可用于访问成员</li><li>ptr-&gt;mem 等价于 (*ptr).mem</li></ul><h3 id="sizeof-运算符"><a class="anchor" href="#sizeof-运算符">#</a> sizeof 运算符</h3><ul><li>返回一条表达式或一个类型名字所占用的字节数</li><li>注：表达式类型返回的是其结果类型大小，并不实际计算其运算对象的值</li></ul><p>运算结果</p><ul><li>引用类型：得到被引用对象所占空间的大小</li><li>指针：得到指针本身所占空间大小</li><li>解引用指针：得到指针指向的对象所占空间的大小 (指针可以不需要有效)</li><li>数组：得到整个数组所占空间的大小，等同于对数组中所有元素各执行一次 sizeof 运算并求和 (注：sizeof 不会将数组转为指针来处理)<ul><li>因此可以以此除以单个元素大小得到数组中元素个数</li></ul></li><li>对 string 或 vector：返回该类型固定部分大小，不会计算对象中的元素占用了多少空间</li></ul><p>注：sizeof 返回的是一个常量表达式</p><h2 id="类型转换"><a class="anchor" href="#类型转换">#</a> 类型转换</h2><h3 id="隐式转换"><a class="anchor" href="#隐式转换">#</a> 隐式转换</h3><ul><li>低于整型类型可能会提升为整型</li><li>计算中，两个不同类型数值计算，宽度较小类型会提升为更大精度类型</li><li>在条件中，非布尔值转换成布尔类型</li><li>数组转换成指针：数组自动转换成指向数组首元素的指针<ul><li>当数组被用作 decltype、取地址符、sizeof、typeid 等运算符的运算对象时转换不会发生</li></ul></li></ul><p>指针的转换</p><ul><li>常量整数值 0 或字面值 nullptr 能转换成任意指针类型</li><li>指向任意非常量的指针能转换成 void*</li><li>指向任意对象的指针能转换成 const void*</li></ul><h3 id="显式转换"><a class="anchor" href="#显式转换">#</a> 显式转换</h3><p>注：避免强制类型转换</p><h4 id="旧式强制类型转换"><a class="anchor" href="#旧式强制类型转换">#</a> 旧式强制类型转换</h4><ul><li>type (expr)</li><li>(type)expr</li><li>注：旧式强制类型转换分别具有与 const_cast、static_cast 或 reinterpret_cast 相似的行为。</li></ul><h4 id="static_cast"><a class="anchor" href="#static_cast">#</a> static_cast</h4><ul><li>任何具有明确定义的类型转换，只要不包含底层 const 就可以使用<ul><li>T t=static_cast<t>(val)</t></li><li>还可以使用这个将存放于 void* 的指针转换回来</li></ul></li></ul><h4 id="const_cast"><a class="anchor" href="#const_cast">#</a> const_cast</h4><ul><li>可以将常量对象转换为非常量对象：即去掉 const 性质</li><li>转换后编译器就不会阻止我们对该对象进行写操作</li><li>注：如果对象本身不是常量，获得写操作是合法的。但若本身是一个常量，写操作可能产生未定义行为</li></ul><h4 id="reinterpret_cast"><a class="anchor" href="#reinterpret_cast">#</a> reinterpret_cast</h4><ul><li>通常为运算对象的位模式提供较低层次上的重新解释</li></ul><h1 id="第五章-语句"><a class="anchor" href="#第五章-语句">#</a> 第五章 语句</h1><p>空语句：『;』<br>空块：『{}』<br>异常处理</p><ul><li>throw 表达式</li><li>try 语句块</li><li>一套异常类 (异常类型具有 what 成员函数，返回 C 风格字符串，无初始值异常类型返回内容由编译器决定)</li></ul><h1 id="第六章-函数"><a class="anchor" href="#第六章-函数">#</a> 第六章 函数</h1><ul><li>形参和实参</li><li>函数返回类型不能是数组或函数类型，不过可以是指向数组或函数的指针</li></ul><p>局部静态对象</p><ul><li>标记为 static 的局部变量</li><li>在程序的执行路径第一次经过对象定义语句时初始化，直到程序终止才销毁</li><li>生命周期不受函数本身控制</li><li>注：若未有显式初始值，则执行值初始化</li></ul><p>参数传递</p><ul><li>引用传递 (传引用调用)：形参是引用类型时<ul><li>也可以利用这个返回额外信息</li></ul></li><li>值传递：实参的值被拷贝给形参时 (两个对象独立)<ul><li>注：指针形参与其它非引用类型一样，也属于拷贝的指针的值</li></ul></li></ul><p>注：若函数无需改变引用形参的值，最好将其声明为常量引用。</p><ul><li>常量引用可接受范围更大 (包括常量和非常量对象)，而且可以起到标记函数不会修改传入对象的功能</li></ul><p>数组作为参数</p><ul><li>一般需要传递长度相关信息</li><li>或使用数组引用形参<ul><li>func(int (&amp;array)[10])</li></ul></li></ul><p>main 的命令行选项</p><ul><li>main 函数可选具有形参的实现，使用户可从命令行传递参数</li></ul><h2 id="可变形参的函数"><a class="anchor" href="#可变形参的函数">#</a> 可变形参的函数</h2><p>当无法预知应该向函数传递几个实参时</p><ul><li>如果所有实参类型相同：initializer_list (标准库类型)，用于表示某种特定类型的值的数组</li><li>实参类型不同：可变参数模板</li><li>注：还有一种特殊形参类型 (省略符)</li></ul><p>initializer_list</p><ul><li>initializer_list<t>lst</t></li><li>lst.size()</li><li>lst.begin ()：首元素指针</li><li>lst.end ()：尾后指针</li><li>注：其中的元素永远是常量值</li></ul><p>省略符形参 (...)</p><ul><li>为了便于 C++ 程序访问某些特殊 C 代码设计</li><li>只能出现在形参列表的最后一个位置</li><li>通常，省略符形参不应用于其它目的</li></ul><h2 id="不要返回局部对象的引用或指针"><a class="anchor" href="#不要返回局部对象的引用或指针">#</a> 不要返回局部对象的引用或指针</h2><p>函数完成后，它所占用的存储空间也会随之释放。</p><ul><li>函数终止意味着局部变量的引用将指向无效内存区域</li></ul><h2 id="返回值"><a class="anchor" href="#返回值">#</a> 返回值</h2><ul><li>调用一个返回引用的函数得到左值</li><li>其它返回类型得到右值</li></ul><p>列表初始化返回值</p><ul><li>C++11 标准规定：函数可以返回花括号包围的值的列表</li></ul><p>返回数组指针</p><ul><li>尾置返回类型：尾置返回类型跟在形参列表后并以一个 -&gt; 符号开头</li><li>auto func (int i)-&gt;int (*)[10] //func 接受一个 int 类型实参，返回一个指向含有 10 个整数的指针</li><li>注：若知道返回指针指向的数组，可使用 decltype 表示返回类型</li></ul><h2 id="函数重载"><a class="anchor" href="#函数重载">#</a> 函数重载</h2><ul><li>如果形参是某种类型的指针或引用，可通过区分指向的是常量对象或非常量对象实现函数重载</li><li>其它 const 形参与普通形参的差别则不能构成重载</li></ul><p>const_cast 与重载</p><ul><li>将非常量对象转换为常量实参，以做到调用常量形参的重载函数 (如果同时存在非常量版本，而想调用常量版本时)</li></ul><h2 id="默认参数"><a class="anchor" href="#默认参数">#</a> 默认参数</h2><ul><li>局部变量不能作为默认实参</li><li>此外只要表达式的类型能转换成形参所需类型，该表达式就能作为默认实参：同名局部变量虽然会隐藏外层对象，但不会影响默认实参</li></ul><h2 id="内联函数与-constexpr-函数"><a class="anchor" href="#内联函数与-constexpr-函数">#</a> 内联函数与 constexpr 函数</h2><ul><li>函数前加上 inline (内联说明只是向编译器发出请求，编译器可以选择忽略)</li><li>constexpr 函数返回类型及所有形参类型都得是字面值类型</li></ul><p>注 1：constexpr 函数被隐式指定为内联函数，编译器会在编译过程中展开<br>注 2：constexpr 函数调用时，传递常量表达式则返回常量表达式。传递非常量表达式则返回的也会是非常量表达式。即 constexpr 不一定返回常量表达式。</p><h2 id="调试帮助"><a class="anchor" href="#调试帮助">#</a> 调试帮助</h2><p>assert 预处理宏</p><ul><li>assert(expr)</li><li>对 expr 求值，若表达式为 false，assert 输出信息并终止程序执行。否则什么也不做。</li></ul><p>NDEBUG 预处理变量</p><ul><li>assert 的行为依赖 NDEBUG 的预处理变量的状态</li><li>若定义了 NDEBUG 则 assert 什么也不做 (默认状态下未定义，assert 将执行运行时检查)</li></ul><p><code>__func__</code></p><ul><li>编译器定义的一个局部静态变量，用于存放函数的名字</li></ul><p><code>__FILE__</code></p><ul><li>存放文件名的字符串字面值</li></ul><p><code>__LINE__</code></p><ul><li>存放当前行号的整型字面值</li></ul><p><code>__TIME__</code></p><ul><li>存放文件编译时间的字符串字面值</li></ul><p><code>__DATA__</code></p><ul><li>存放文件编译日期的字符串字面值</li></ul><h3 id="函数指针"><a class="anchor" href="#函数指针">#</a> 函数指针</h3><p>要想声明一个可以指向函数的指针，只需用指针替换函数名即可</p><ul><li>bool (*pf)(xxxxx) // 注：*pf 的括号必不可少，否则就是一个返回值为 bool 指针的函数了</li><li>当我们把函数名作为一个值使用时，该函数自动地转换成指针</li><li>此外可以直接使用指向函数的指针调用该函数，无需提前解引用指针</li></ul><p>函数指针形参</p><ul><li>与数组类似，不能直接定义函数类型的形参</li><li>但是形参可以是指向函数的指针</li><li>void func(bool (*pf)(xxxxx))<ul><li>如果明确知道返回函数是哪一个，可使用类型别名或 decltype 简化</li><li>typedef decltype(myfunc) *callbackName</li></ul></li><li>可以直接把函数作为实参使用</li></ul><h1 id="第七章-类"><a class="anchor" href="#第七章-类">#</a> 第七章 类</h1><p>定义在类内部的函数是隐式的 inline 函数。<br>当我调用成员函数时，实际上是替某个对象调用。成员函数通过一个名为 this 的额外隐式参数来访问调用它的那个堆对象。</p><ul><li>默认情况下，this 是指向类类型非常量版本的常量指针</li><li>常量对象以及常量对象的引用或指针都只能调用常量成员函数</li><li>注：一个 const 成员函数如果以引用方式返回 *this，则返回类型将是常量引用 (不可再做修改)。</li></ul><h2 id="构造函数"><a class="anchor" href="#构造函数">#</a> 构造函数</h2><ul><li>构造函数不能声明为 const</li><li>当我们创建类的一个 const 对象时，直到构造函数完成初始化过程，对象才能真正取得其 常量 属性：因此构造函数在 const 对象构造过程中可以向其写值</li></ul><p>注：当对象被默认初始化或值初始化时自动执行默认构造函数。<br>例如：</p><ul><li>Sales_data obj1 (); // 错误：声明了一个函数而非对象</li><li>Sales_data obj3; // 正确：默认初始化 obj2 对象</li></ul><h3 id="合成的默认构造函数"><a class="anchor" href="#合成的默认构造函数">#</a> 合成的默认构造函数</h3><p>只有当类没有声明任何构造函数时编译器才会自动生成</p><ul><li>如果存在类内初始值，用其初始化成员</li><li>否则，默认初始化该成员</li><li>即：通过相应类内初始值初始化或执行默认初始化</li><li>=default：要求编译器生成构造函数</li></ul><h3 id="构造函数初始值列表"><a class="anchor" href="#构造函数初始值列表">#</a> 构造函数初始值列表</h3><ul><li>(构造函数中参数后冒号与花括号之间) 可用于成员初始化</li><li>fun(const std::string &amp;name):Name(name){}</li><li>例如 const 只能使用这种方式初始值 (而不能在花括号里面赋值)</li><li>注：该列表只说明用于初始化成员的值，而不限定具体执行顺序，具体顺序与其在类中定义的出现顺序一致。(因此最好保持顺序一致，或避免使用某些成员初始化其它成员)</li></ul><p>注 1：当我们提供一个类内初始值时，必须以符号 = 或 花括号表示。<br>注 2：初始化和赋值的区别事关底层效率问题，前者直接初始化数据成员，后者则先初始化再赋值。(因此建议使用构造函数初始值)</p><h3 id="委托构造函数"><a class="anchor" href="#委托构造函数">#</a> 委托构造函数</h3><p>一个委托构造函数使用它所属类的其它构造函数执行它自己的初始化过程。</p><ul><li>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。</li></ul><h3 id="隐式的类类型转换"><a class="anchor" href="#隐式的类类型转换">#</a> 隐式的类类型转换</h3><p>使用 explicit 可抑制构造函数定义的隐式转换</p><ul><li>当以 explicit 声明构造函数时，它将只能以直接初始化的形式使用</li><li>且编译器不会在自动转换过程中使用该构造函数</li></ul><h2 id="class-与-struct"><a class="anchor" href="#class-与-struct">#</a> class 与 struct</h2><p>唯一区别是：两者默认访问权限不一样</p><ul><li>struct：定义在第一个访问修饰符之前的成员是 public</li><li>class：第一个访问修饰符之前的成员是 private</li><li>一般当定义类所有成员都是 public 时采用 struct</li></ul><h2 id="可变数据成员"><a class="anchor" href="#可变数据成员">#</a> 可变数据成员</h2><p>变量声明中加入 mutable 关键字</p><ul><li>永远不会是 const</li><li>即使作为 const 对象成员</li></ul><h2 id="友元"><a class="anchor" href="#友元">#</a> 友元</h2><p>每个类复制控制自己的友元类或友元函数</p><ul><li>还可以某类成员函数成为自己的友元</li></ul><h2 id="类的声明"><a class="anchor" href="#类的声明">#</a> 类的声明</h2><p>前向声明</p><ul><li>class className;</li><li>引入类名并指明这是一个类类型</li><li>在它声明之后定义之前是一个『不完全类型』</li></ul><p>不完全类型</p><ul><li>只能在非常有限的情况下使用：可以定义指向这种类型的指针或引用，也可以声明 (但不能定义) 以不完全类型作为参数或返回类型的函数。</li></ul><h2 id="类作用域"><a class="anchor" href="#类作用域">#</a> 类作用域</h2><p>编译器处理完类中全部声明后才会处理成员函数的定义。</p><h2 id="聚合类"><a class="anchor" href="#聚合类">#</a> 聚合类</h2><p>聚合类使得用户可直接访问其成员，且具有特殊的初始化语法形式。</p><ul><li>所有成员都是 public 的</li><li>没有定义任何构造函数</li><li>没有类内初始值</li><li>没有基类，有没有虚函数</li></ul><p>可以使用花括号初始化聚合类的数据成员，初始值的顺序必须与声明一致。</p><h3 id="字面值常量类"><a class="anchor" href="#字面值常量类">#</a> 字面值常量类</h3><p>数据成员都是字面值类型的聚合类是字面值常量类。</p><ul><li>注：还有一些满足额外条件的非聚合类也可以是字面值常量类</li></ul><h2 id="类的静态成员"><a class="anchor" href="#类的静态成员">#</a> 类的静态成员</h2><p>成员与类本身直接相关，而不是与类的各个对象保持关联。<br>静态成员函数</p><ul><li>静态成员函数不包含 this 指针，静态成员函数不能声明为 const</li></ul><p>静态数据成员</p><ul><li>类似于全局变量，静态数据成员定义在任何函数之外，一旦被定义，将存在于程序整个生命周期</li><li>通常类的静态成员不应在类内部初始化，不过可以为其提供 const 类内初始值</li><li>注：<ul><li>静态数据成员可以是不完全类型</li><li>静态数据成员类型可以就是它所属类型 (普通成员只能声明所属类型的指针或引用)</li><li>可以使用静态成员作为默认实参</li></ul></li></ul><div class="tags"><a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 笔记</a> <a href="/tags/CPP/" rel="tag"><i class="ic i-tag"></i> CPP</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-10-06 12:28:37" itemprop="dateModified" datetime="2023-10-06T12:28:37+08:00">2023-10-06</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>WangJiaYing <i class="ic i-at"><em>@</em></i>CWHISME</li><li class="link"><strong>本文链接：</strong> <a href="https://wangjiaying.top/2023/10/02/CPP_Primer_%E7%AC%AC%E4%BA%94%E7%89%88_%E7%AC%94%E8%AE%B0-1/" title="《C++ Primer (第五版)》- 笔记 (1)">https://wangjiaying.top/2023/10/02/CPP_Primer_第五版_笔记-1/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/09/25/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="prev" data-background-image="&#x2F;blogimages&#x2F;2023&#x2F;2023-09-25&#x2F;book.webp" title="《游戏编程模式》-笔记"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 阅读笔记</span><h3>《游戏编程模式》-笔记</h3></a></div><div class="item right"><a href="/2023/10/06/%E8%99%9A%E5%B9%BB5%E5%8A%A8%E7%94%BB%E9%80%82%E9%85%8D-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="next" data-background-image="&#x2F;images&#x2F;coverimages&#x2F;large&#x2F;629d4efe1a8708add218e85f5c905497_3_2_art.webp" title="虚幻5动画适配方式-笔记"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 虚幻引擎</span><h3>虚幻5动画适配方式-笔记</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%80%E5%A7%8B"><span class="toc-number">2.</span> <span class="toc-text">第一章 开始</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">第二章 变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">3.1.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%80%BC%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.1.</span> <span class="toc-text">初始值 (值初始化)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.2.</span> <span class="toc-text">列表初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.3.</span> <span class="toc-text">默认初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.4.</span> <span class="toc-text">变量声明和定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.1.5.</span> <span class="toc-text">作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">3.2.2.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">3.2.3.</span> <span class="toc-text">const 限定符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">const 的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C-const"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">指针和 const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E6%8C%87%E9%92%88"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">const 指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr-%E5%92%8C%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.2.4.</span> <span class="toc-text">constexpr 和常量表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#constexpr-%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">constexpr 变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constexpr-%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">constexpr 函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">处理类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">3.3.1.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">3.3.2.</span> <span class="toc-text">auto 类型说明符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype-%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">3.3.3.</span> <span class="toc-text">decltype 类型指示符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.</span> <span class="toc-text">自定义数据结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text">第三章 字符串、向量和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84-using-%E5%A3%B0%E6%98%8E"><span class="toc-number">4.1.</span> <span class="toc-text">命名空间的 using 声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.1.1.</span> <span class="toc-text">直接初始化和拷贝初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string"><span class="toc-number">4.2.</span> <span class="toc-text">string</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector"><span class="toc-number">4.3.</span> <span class="toc-text">vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">4.5.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">4.5.1.</span> <span class="toc-text">显式初始化数组元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">4.5.2.</span> <span class="toc-text">多维数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">第四章 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.1.</span> <span class="toc-text">赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.1.1.</span> <span class="toc-text">复合赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.1.2.</span> <span class="toc-text">递增和递减运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.1.3.</span> <span class="toc-text">成员访问运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.1.4.</span> <span class="toc-text">sizeof 运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.2.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.2.1.</span> <span class="toc-text">隐式转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.2.2.</span> <span class="toc-text">显式转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A7%E5%BC%8F%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">旧式强制类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static_cast"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">static_cast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const_cast"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">const_cast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reinterpret_cast"><span class="toc-number">5.2.2.4.</span> <span class="toc-text">reinterpret_cast</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.</span> <span class="toc-text">第五章 语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">第六章 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%BD%A2%E5%8F%82%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">可变形参的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E6%88%96%E6%8C%87%E9%92%88"><span class="toc-number">7.2.</span> <span class="toc-text">不要返回局部对象的引用或指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">7.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">7.4.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">7.5.</span> <span class="toc-text">默认参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E4%B8%8E-constexpr-%E5%87%BD%E6%95%B0"><span class="toc-number">7.6.</span> <span class="toc-text">内联函数与 constexpr 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%B8%AE%E5%8A%A9"><span class="toc-number">7.7.</span> <span class="toc-text">调试帮助</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">7.7.1.</span> <span class="toc-text">函数指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">第七章 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.1.</span> <span class="toc-text">合成的默认构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-number">8.1.2.</span> <span class="toc-text">构造函数初始值列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.3.</span> <span class="toc-text">委托构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.1.4.</span> <span class="toc-text">隐式的类类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class-%E4%B8%8E-struct"><span class="toc-number">8.2.</span> <span class="toc-text">class 与 struct</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">8.3.</span> <span class="toc-text">可变数据成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">8.4.</span> <span class="toc-text">友元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">8.5.</span> <span class="toc-text">类的声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">8.6.</span> <span class="toc-text">类作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E7%B1%BB"><span class="toc-number">8.7.</span> <span class="toc-text">聚合类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F%E7%B1%BB"><span class="toc-number">8.7.1.</span> <span class="toc-text">字面值常量类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">8.8.</span> <span class="toc-text">类的静态成员</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2023/10/02/CPP_Primer_%E7%AC%AC%E4%BA%94%E7%89%88_%E7%AC%94%E8%AE%B0-1/" rel="bookmark" title="《C++ Primer(第五版)》-笔记(1)">《C++ Primer(第五版)》-笔记(1)</a></li><li><a href="/2023/10/22/CPP-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%AC%94%E8%AE%B0-2/" rel="bookmark" title="《C++ Primer(第五版)》-笔记(2)">《C++ Primer(第五版)》-笔记(2)</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="WangJiaYing" data-src="/images/../img/avator"><p class="name" itemprop="name">CWHISME</p><div class="description" itemprop="description">己所不欲，勿施于人</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">123</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">22</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">32</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N3aGlzbWU=" title="https:&#x2F;&#x2F;github.com&#x2F;cwhisme"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9jd2hpc21lLTMzL3Bvc3Rz" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;cwhisme-33&#x2F;posts"><i class="ic i-zhihu"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmN3aGlzbWVAMTI2LmNvbQ==" title="mailto:cwhisme@126.com"><i class="ic i-envelope"></i></span> <a href="/atom.xml" title="&#x2F;atom.xml" class="item feedback"><i class="ic i-heart"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-clock"></i>统计</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/09/25/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-%E7%AC%94%E8%AE%B0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/10/06/%E8%99%9A%E5%B9%BB5%E5%8A%A8%E7%94%BB%E9%80%82%E9%85%8D-%E7%AC%94%E8%AE%B0/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/" title="分类于 虚幻引擎">虚幻引擎</a></div><span><a href="/2017/03/20/2017-3-20-UE4-Incomplete-types-are-not-allowed/" title="UE4.15 不允许使用不完整的类型错误">UE4.15 不允许使用不完整的类型错误</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Unity3D/" title="分类于 Unity3D">Unity3D</a> <i class="ic i-angle-right"></i> <a href="/categories/Unity3D/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="分类于 性能优化">性能优化</a></div><span><a href="/2022/12/28/%E6%8F%AD%E7%A7%98Unity%E7%9A%84%E9%BB%91%E7%9B%92%E4%B8%96%E7%95%8C-%E7%AC%94%E8%AE%B0/" title="揭秘Unity的黑盒世界-笔记">揭秘Unity的黑盒世界-笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="分类于 阅读笔记">阅读笔记</a></div><span><a href="/2023/08/04/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-5/" title="《.NET内存管理宝典》-笔记(5)">《.NET内存管理宝典》-笔记(5)</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment count_3"></ul></div></div><div class="status"><div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">WangJiaYing @ Jiaying's Note</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">728k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">11:02</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NXSElTTUUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/10/02/CPP_Primer_第五版_笔记-1/",favicon:{show:"（●´3｀●）",hide:"(´Д｀)"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,justifiedGallery:!0,jquery:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script><script src="https://cdn.staticfile.org/pjax/0.2.8/pjax.min.js"></script><script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script><script src="https://cdn.staticfile.org/algoliasearch/4.17.0/algoliasearch-lite.umd.js"></script><script src="https://cdn.staticfile.org/instantsearch.js/4.54.1/instantsearch.production.min.js"></script><script src="https://cdn.staticfile.org/lozad.js/1.16.0/lozad.min.js"></script><script src="https://cdn.staticfile.org/quicklink/2.3.0/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/js/DateTimeAfeterCalc.js" async></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js" async></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?62952472c154f9131a14a4ab57bfefec";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html>