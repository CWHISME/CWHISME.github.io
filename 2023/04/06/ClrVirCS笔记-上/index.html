<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="CWHISME" href="https://wangjiaying.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="CWHISME" href="https://wangjiaying.top/atom.xml"><link rel="alternate" type="application/json" title="CWHISME" href="https://wangjiaying.top/feed.json"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="C#,笔记"><link rel="canonical" href="https://wangjiaying.top/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8A/"><title>CLR VIR C# 笔记 (上) - 阅读笔记 | Jiaying's Note = CWHISME = 人不能没有梦想，也要有足够的敬畏</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CLR VIR C# 笔记 (上)</h1><div class="meta"><span class="item" title="创建时间：2023-04-06 13:27:19"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-04-06T13:27:19+08:00">2023-04-06</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>17k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>16 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiaying's Note</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/blogimages/2023/2023-04-06/title.jpg"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" itemprop="item" rel="index" title="分类于 阅读笔记"><span itemprop="name">阅读笔记</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangjiaying.top/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8A/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/../img/avator"><meta itemprop="name" content="WangJiaYing"><meta itemprop="description" content="人不能没有梦想，也要有足够的敬畏, 己所不欲，勿施于人"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="CWHISME"></span><div class="body md" itemprop="articleBody"><h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>本来计划的是 3 月份就看完，结果 4 月 2 号了还剩两章，虽然这跟到后面看得更仔细有关，但是公司上个月突然要求加起班来也有关系，导致每周上班时间只有两天可以提前回家看书。</p><p>不过，在昨天 清明节 总算把这本书看完了！</p><p>看了下语雀的笔记创建记录：</p><p><img data-src="/blogimages/2023/2023-04-06/Snipaste_2023-04-06_13-30-02.jpg" alt=""></p><p>已经记不起什么时候开始看的，笔记是 2 月 27 日创建的，以这个时间点开始也一个月出头了，基本上回家就是看这本书</p><p>刚拿到手感觉是真厚，最开始做笔记只按照分类记录了重点：后面觉得这样不大行，越记就越庞大</p><p>而且书的章节本身其实可以看做就是有根据功能分门别类的，于是从第九章开始，以章节划分开始记录</p><ul><li><p>因为是用手机记录的，所以有的英文字母用的小写</p></li><li><p>《CLR VIR C#》 太厚了，由于记录太多，分成了成两篇上传</p></li></ul><p>总的来说，值得一看，获益良多。</p><h1 id="基本名称"><a class="anchor" href="#基本名称">#</a> 基本名称</h1><ul><li>FCL：framework class library</li><li>CTS：common type system</li><li>CLI：cts 和其它组件提交给 ECMA 形成（公共语言基础结构）</li><li>CLS：公共语言规范，common language specification，语言互操作的标准规范，为支持不同语言互操作，详细定义了一个最小功能集，是 clr/cts 的子集。规定类型成员要么是字段（数据），要么是方法（行为）<ul><li>CLSCompliantAttribute 可以标记类中公共成员必须符合 cls 规范（但是反射可以强行访问非公共、不合 cls 的自字段）</li></ul></li><li>CIL：Common Intermediate Language 通用中间语言，是介于源代码和本机机器指令中间的代码</li><li>蓝色体 代表关键字，浅蓝色体 代表类型，比如大写 string 表示基元类型</li><li>值类型 equals 最好重写，内置反射调用</li><li>友元程序集</li><li>dynamic 基元类型<ul><li>实际上就是 Object</li><li>字段、参数或返回类型若使用 dynamic，编译器会附加 dynamicattribute 特性（局部变量使用不会附加特性，因为限制在方法内部使用）</li><li>所有表达式都能隐式转为 dynamic：因为所有表达式最终都生成从 Object 派生的类型</li><li>虽然 Object 不允许隐式转换为其它类型，但是 dynamic 可以，不过运行时会额外验证转型保证类型安全性</li></ul></li><li>分部类（partial）</li><li>分部方法<ul><li>若没有对分部方法 实现，调用分部方法的代码会直接被编译器优化掉，也不会生成分部方法的元数据：包括调用方法传递参数造成的计算也会被优化掉，可以提高性能</li><li>只能在分部类或结构中声明</li><li>分部方法只能返回 void，参数不能用 out 标记：因为方法在运行时可能不存在</li><li>如果附加了特性，编译器会合并两个方法的特性（参数特性也一样）</li><li>分部方法被视为 private（不过编译器简直添加访问修饰符？）</li></ul></li><li>csp（component software programming） 是 oop 发展极致结果</li><li>system.appdomain</li><li>显式接口方法实现 (EIMI)：将定义方法的接口名称作为方法名前缀（explicit interface method implementation）</li><li>基类还是接口？<ul><li>『属于』 和 『能做』 的关系</li></ul></li></ul><h1 id="其它"><a class="anchor" href="#其它">#</a> 其它</h1><ul><li>clr 基于栈</li><li>操作符重载：public static （type） operator（操作符）</li><li>转换操作符重载：一种类型转换为另一种类型</li><li>要求参数类型和返回类型二者其一必有定义转换方法类型相同</li><li>隐式：public static implicit operator （return type）（in type）</li><li>显式：public static explicit operator （return type）（in type）</li><li>c# 编译器检测到代码正在使用的某个类型对象实际期望的是另一种类型对象，则查找能隐式转换操作符方法，若找到则生成调用方法代码（显式也一样）</li><li>使用强制类型转换表达式时，c# 生成代码调用显式操作符重载方法，使用 c# as is 时则不会调用</li><li>扩展方法：<ul><li>实际上是对一个静态方法的调用（所以不会对调用实例做 null 检查，扩展方法可能接受 null 实例）</li><li>可以为接口定义扩展方法</li><li>可以为委托类型定义扩展方法</li><li>可以为枚举添加扩展方法</li><li>扩展方法是静态方法，若作为委托，编译器是耍了小花招的，生成特殊代码来处理引用的静态方法传递第一个 this (调用实例) 参数</li><li>编译器会先搜索类型自身或基类是否存在对应参数实例方法，没有找到就会搜索所有静态文件找到对应扩展方法，并生成 il 代码调用静态方法</li><li>在 c# 中，一旦用 this 关键字标记了某个静态方法的第一个参数，编译器就会在内部向该方法应用 extensionattribute 特性，并持久化存储在元数据中，任何静态类只要包含了至少一个扩展方法，其元数据也会应用该特性，同理任何程序集只要包含了一个符合上述特点的静态类，元数据也会应用该特性 —— 以加快编译器搜索速度：可以只扫描指定程序集 - 指定静态类 - 指定扩展方法</li><li>扩展一个类型时，其派生类也会被扩展</li><li>扩展方法不能引用它们正在扩展的类的私有成员或受保护成员，因此不能完全替代更传统的类继承</li></ul></li><li>decimal 是个类</li><li>内联代码？</li><li>委托实际只是提供了 4 个方法的一个类定义<ul><li>构造器、invoke 方法、begininvoke 方法、endinvoke 方法</li></ul></li><li>协变指定返回类型的兼容性</li><li>逆变指定参数的兼容性</li><li>convert.changetype</li></ul><h1 id="il"><a class="anchor" href="#il">#</a> IL</h1><ul><li>call：可调用静态方法，实例方法和虚方法<ul><li>调用实例方法和虚方法必须指定引用了对象的变量，该指令假定该变量不为 null</li></ul></li><li>callvirt：可调用实例方法和虚方法，不能调用静态方法（需要对变量做 null 检查，因此比 call 慢）<ul><li>并且调用虚实例方法时，还需要检查发出调用对象的实际类型，然后以多态方式调用</li></ul></li><li>编译器会在程序集方法定义表中用标志 (flag) 指明方法是实例方法、虚方法、静态方法<ul><li>调用这些方法时，编译器会判断对应方法定义的标志 (flag) 生成对应调用指令</li></ul></li><li>c# 用 callvirt 指令调用所有实例方法</li><li>编译器调用值类型定义的方法时，倾向于使用 call 指令<ul><li>因为值类型实例的本质保证永不为 null</li><li>并且要是以虚方式调用值类型中虚方法，会导致值类型装箱</li></ul></li><li>无论 call 还是 callvirt 都接受隐藏的 this 实参作为方法第一个参数（操作的对象）</li><li>设计类型应该尽量减少虚方法数量：<ul><li>~ 调用虚方法比非虚方法更慢：clr 必须在运行时查找对象类型，以判断要调用的方法由哪个类型定义（密封类可由 jit 优化调用，因为不需要判断是否还有派生类重载）</li><li>密封类型的虚方法调用，会被优化，性能更好</li><li>一旦将某个方法、属性或事件设置为 virtual，基类就会丧失对其行为和状态的部分控制权</li><li>~jit 不能内嵌（inline）虚方法</li><li>new virtual 可以重写虚方法</li></ul></li><li>内联函数：<ul><li>MethodImpl(MethodImplOptions.AggressiveInlining)</li></ul></li></ul><h1 id="类"><a class="anchor" href="#类">#</a> 类</h1><ul><li><p>字段定义时<strong>直接赋值</strong>，称为 内联初始化</p></li><li><p>内联初始化：指在代码中直接赋值来初始化，而不是将对构造器的调用写出来</p></li><li><p>实际上 c# 是在构造器中初始化的，这只是提供的一种简化语法</p></li><li><p>使用内联语法而非构造器中赋值，会有一些性能问题需要考虑</p></li><li><p>有多个构造器时，每个构造器都会被插入内联变量初始化代码，然后调用基类构造方法，最后插入构造方法自身的代码（因此存在 代码膨胀效应）—— 若是在构造函数中自己初始化，可以复用同样的初始化构造函数，以减少这种情况</p></li><li><p>对引用类型标记 readonly，只是单纯这个地址引用不可变，其内部数据依然可变</p></li><li><p>反序列化使用 getuninitializedobject 为对象分配内存，避免调用构造器（另外，memberclone 也不会导致调用）</p></li><li><p>避免在构造函数中调用虚方法：因为父类构造函数初始化更早，子类若重写了虚方法的行为不可预测</p></li><li><p>声明为密封类可提高性能，JIT 就不再需要考虑其他的可能性而放开手脚进行优化：</p><ul><li>密封类型的虚方法调用，会被优化，性能更好</li><li>数组是支持协变的：JIT 在将一个项目分配到数组之前必须检查对象的类型。当使用密封类型时，JIT 可以取消检查</li><li>数组转换成 Span：与数组同理</li><li>当对象类型转换时：当转换到一个非密封的类型时，运行时必须检查层次结构中的所有类型</li></ul></li><li><p>编译器自动生成的代码都是 sealed 密封类</p></li></ul><h1 id="值类型"><a class="anchor" href="#值类型">#</a> 值类型</h1><ul><li>值类型没有默认无参构造函数（所以也不支持内联初始化语法）</li><li>并且不允许定义无参构造函数（但是 clr 允许）</li><li>值类型的构造函数只有显式调用才会执行</li><li>结构体构造函数中，可以允许直接：this=new xxx () 初始化所有字段，然后再覆盖</li></ul><h1 id="静态构造方法类型构造器"><a class="anchor" href="#静态构造方法类型构造器">#</a> 静态构造方法（类型构造器）</h1><ul><li>只能定义一个无参的静态构造方法，由 clr 在类型第一次被访问时调用</li><li>只能访问静态字段（用来初始化它们）</li><li>结构体（值类型）静态字段也可以使用内联初始化语法</li><li>类型构造器调用比较麻烦：jit 在编译一个方法时，会查看代码中引用了哪些类型，任何一个类型定义了静态构造器，编译器会检查当前 appdomain 是否已经执行过，若没有执行，则添加执行代码调用<ul><li>初始化调用时，clr 会使用互斥线程同步锁保证同一个 appdomain 只会初始化一次</li><li>所以是线程安全的，因此单例可以这样整？饿汉模式？</li></ul></li><li>！值类型的构造方法可能不会被调用</li></ul><h1 id="工具"><a class="anchor" href="#工具">#</a> 工具</h1><ul><li>*.rsp：响应文件，包含了一组编译器命令行开关的文本文件，使用 csc.exe @my.rsp 代码.cs</li></ul><p>全局 csc.rsp</p><ul><li>AL.exe：程序集链接器</li><li>assemblyversion：非常重要，存储于 assemblydef 清单元数据表，唯一性标识程序集</li></ul><h1 id="第九章-参数"><a class="anchor" href="#第九章-参数">#</a> 第九章 参数</h1><p>可选参数和命名参数</p><ul><li>一旦为参数分配了默认值，编译器会对参数应用 optionalattribute 特性及 defaultparametervalueattribute 特性。<strong>并</strong>生成对应元数据</li><li>后续编译器发现某个方法调用缺失部分实参，就可以确定是否是可选实参，并从元数据提取默认值自动嵌入调用中</li></ul><p>隐式类型局部变量</p><ul><li>var：只能声明局部变量，由编译器推断</li></ul><p>传引用方式向方法传递参数</p><ul><li>out</li><li>ref</li><li>两者生成 il 代码一样，只有元数据有一个 bit 差异：用于记录是 out 还是 ref</li><li>从 il 和 clr 来看：都是导致传递指向实例的一个指针（主要差别在于编译器的验证准则）</li><li>大的值类型可避免复制开销</li></ul><p>可变参数：</p><ul><li>params：必须位于参数最后一位</li><li>编译器会应用 paramarrayattribute 特性</li><li>调用时，若没有找到对应的普通方法，则生成代码构造一个数组来调用它</li><li>会有额外性能开销，例如造成数组分配：数组必须在堆上分配、数组元素必须初始化、数组内存最终会被垃圾回收（传递 null 不会分配）</li></ul><p>参数和返回类型设计规范</p><ul><li>参数尽量指定最弱类型：例如接口比基类更好</li><li>返回类型：最好声明为最强类型 (防止受限特定类型)</li></ul><h1 id="第十章-属性"><a class="anchor" href="#第十章-属性">#</a> 第十章 属性</h1><p>属性看起来和字段类似，但本质是方法<br>取决于属性定义，编译器在程序集生成以下两项或三项：</p><ul><li>代表 get 访问器的方法</li><li>代表 set 访问器的方法<ul><li>set 编译出来的方法会有定义类型的 value 默认参数</li></ul></li><li>程序集元数据会有属性定义 (必然生成)<ul><li>包含一些标志 (flag) 及属性类型等信息</li><li>用于在 属性 这个抽象概念与其访问器方法之间建立一个联系</li><li>clr 不使用这种元数据信息，主要是给编译器或其它工具通过 <strong>PropertyInfo</strong> 来获得信息</li></ul></li></ul><p>自动属性（Automatically Implemented Property）简称 AIP</p><ul><li>其私有字段名由编译器自动生成，因此序列化数据可能出问题</li></ul><p>与字段对比：</p><ul><li>属性不能作为 out 或 ref 传引用</li><li>属性方法可能抛出异常，字段访问永远不会</li><li>属性方法可能花较长时间运行，字段访问总是立即完成</li><li>连续多次调用，属性方法每次可能返回不同值</li><li>属性方法可能需要额外内存，或返回对象并非指向对象状态一部分，造成对返回对象的修改作用不到原始对象上（使用会返回一个拷贝的属性很容易引起混淆）</li></ul><p>如果属性实现了 IEnumerable，属性就被认为是集合</p><p>可以这样初始化：</p>Prop={"1","2","3"} dic={{"1",1},{"2",22},{"3",33}}<hr><p>匿名类型</p><ul><li>与匿名函数一样，会生成一个新的类</li><li>编译器定义匿名类型时，若发现源代码中定义了多个具有相同结构的匿名类型，会只生成一份类型定义，虽然还是会创建多个实例<ul><li>相同结构：相同名称和类型，指定顺序相同</li></ul></li></ul><p>Tuple</p><ul><li>Tuple.Create 简化代码，自动推断类型</li></ul><p>System.dynamic.ExpandObject<br>有参属性</p><ul><li>C# 称为 索引器</li><li>可以将 索引器 看作对 [] 符号的重载</li><li>一个类型可定义多个索引器</li><li>默认索引器名称为 set_Item，使用 IndexerName 特性 可以让编译器为索引器 (属性) 自动生成的名字进行自定义重命名<ul><li>特性本身不进入元数据</li><li>例如 string 的索引器名称是 Chars</li></ul></li></ul><p>性能</p><ul><li>对于简单的 get、set 访问器方法，JIT 会将代码内联（调试版本不会优化）</li></ul><h1 id="第十一章-事件"><a class="anchor" href="#第十一章-事件">#</a> 第十一章 事件</h1><ul><li>委托是不可变的</li><li>事件参数传递：EventArgs</li><li>事件成员：EventHandler</li><li>事件编译出的添加、移除方法利用原子操作，以线程安全的一种模式更新值</li><li>试图删除从未添加的方法，Delegate 内部不会做任何事情（不会抛出异常或警告）</li><li>除了自动生成的三个构造代码，编译器还会在元数据附加记录项，用于建立 &quot;事件&quot; 抽象概念 与 add remove 访问器方法的联系（flag、基础委托类型、访问器方法）<ul><li>不过 clr 本身是不会用这些元数据信息的，只编译器等工具会利用这些元数据信息， EventInfo</li></ul></li><li>通过 +=、-= 移除添加事件，会被编译器编译为调用自动生成的 add、remove 方法</li><li>移除事件时，需要扫描委托列表寻找一个恰当匹配：包装方法和传递方法相同</li><li>可以显式实现事件，避免编译器自动生成代码：事件访问器</li></ul><h1 id="第十二章-泛型"><a class="anchor" href="#第十二章-泛型">#</a> 第十二章 泛型</h1><ul><li>面向对象 代码重用，泛型 算法重用</li><li>泛型引用类型、泛型值类型、泛型接口、泛型委托、泛型方法（不允许泛型枚举类型）</li><li>优势<ul><li>源代码保护</li><li>类型安全</li><li>更清晰代码：编译器强制类型安全性，减少强制类型转换次数</li><li>更好的性能：省略强制类型转换消耗；避免值类型装箱消耗</li></ul></li><li>泛型同样会创建类型对象（type object）内部数据结构：开放类型，开放类型不允许创建实例</li><li>代码引用泛型类型时，指定泛型参数后成为 封闭类型；可仅指定部分泛型参数，会导致创建新的开放类型对象</li><li>泛型的静态构造方法和静态字段，针对每个封闭类型都有一份，不共享</li><li>使用泛型类型并指定类型实参时，实际是在 clr 中定义了一个新的类型对象，新类型派生自泛型父类</li><li>缺点<ul><li>代码爆炸：clr 优化方式是对引用类型进行共享 (都属于指针操作)，但是值类型实参不行，因为可能要用不同的本机 cpu 指令操纵这些值</li></ul></li><li>委托实际只是提供了 4 个方法的一个类定义<ul><li>构造器、invoke 方法、begininvoke 方法、endinvoke 方法</li></ul></li><li>协变量：泛型类型参数可以从一个类更改为它的某个基类</li><li>逆变量：泛型类型参数可以从一个类更改为它的某个派生类</li><li>不变量：泛型参数不能更改</li><li>泛型方法<ul><li>作为 out/ref 实参传递的变量必须具有与方法参数相同类型</li><li>编译器支持在调用泛型方法时进行 类型推断</li><li>有重载时，编译器 (类型推断) 先考虑明确匹配，再考虑泛型匹配 (也可指定泛型实参明确调用泛型方法)</li></ul></li><li>泛型约束<ul><li>限制能指定成泛型实参的类型</li><li>可用于泛型类型的类型参数、泛型方法类型参数</li><li>派生类不能修改重写的虚方法在父类指定过的约束</li><li>主要约束：非密封类的一个引用类型<ul><li>指定类型要么是约束类型相同类型，要么是约束类型的子类</li><li>特殊主要约束：class (引用类型)、struct (值类型)</li></ul></li><li>次要约束：可指定零个或多个次要约束，代表接口类型</li><li>类型参数约束 (裸类型约束)：指定类型实参要么是约束类型，要么是约束类型子类<ul><li>Exp&lt;T,TBase&gt; where T:TBase</li></ul></li><li>构造器约束：new ()，约束类型实参是实现了公共无参构造方法的非抽象类型</li></ul></li><li>default (T)：引用类型设为 null，值类型将所有位设为 0</li><li>泛型类型转型</li><li>与 null 比较（值类型未约束为 struct 情况才能用但始终非 null）</li><li>不允许将类型参数约束为具体值类型<ul><li>因为不可能存在从值类型派生的类型，如果允许约束成具体值类型，还不如不要泛型</li></ul></li><li>泛型类型变量作为操作数使用 (操作符运算)<ul><li>值类型不允许</li></ul></li></ul><h1 id="第十三章-接口"><a class="anchor" href="#第十三章-接口">#</a> 第十三章 接口</h1><ul><li>终极基类 System.Object 定义 4 个公共实例方法：tostring、gethashcode、equals、gettype<ul><li>因此接口也允许调用 Object 方法</li></ul></li><li>Object 派生类继承：<ul><li>方法签名：使代码认为自己是在操作 Object 类实例，但实际操作的可能是其它类实例</li><li>方法实现：使开发人员定义 Object 派生类时不必手动实现 Object 的方法</li></ul></li><li>接口：对一组方法签名进行统一命名<ul><li>因此还可定义事件、无参属性和有参属性 (索引器)，因为它们本质是方法</li></ul></li><li>在 clr 看来，接口定义就是类型定义：clr 会为接口类型对象定义内部数据结构，并能通过反射机制查询接口类型功能</li><li>实现接口的方法若没有显式标记为 virtual，编译器会自动标记为 virtual+sealed<ul><li>派生类不能重写 sealed 方法，但可以重新继承同一接口并提供自己的实现</li></ul></li><li>值类型也可实现零个或多个接口，但值类型的实例转换为接口时会导致装箱<ul><li>因为接口变量是引用，必须指向堆上对象，使 clr 能检查对象的类型对象指针，从而判断对象的确切类型</li><li>调用已装箱值类型方法时，clr 会跟随对象的类型对象指针找到类型对象的方法表，从而调用正确方法</li></ul></li><li>类型加载到 clr 时，会为对象创建并初始化一个方法表<ul><li>类型引入的每个新方法都有对应记录项</li><li>继承的所有虚方法也会添加记录项 (有继承层次基类定义的，也有接口类型定义的)</li></ul></li><li>显式接口方法实现 (EIMI)：将定义方法的接口名称作为方法名前缀<ul><li>不允许指定访问性，编译器生成元数据时，会自动设置为 private</li><li><ol><li>没有文档解释具体实现，没有智能感知支持、2. 值类型实例转换为接口时发生装箱、3. EIMI 不能由派生类调用</li></ol></li></ul></li><li>接口方法理想情况下应该是强类型的</li><li>C# 编译器为接口约束生成特殊 il 指令 (constrained)，导致在值类型上调用接口方法而不装箱（不用接口约束便无法生成，调用接口方法就会导致装箱）<ul><li>指：约束了泛型参数一定得实现某个接口时，实现了接口的值类型可以不装箱放进去？（待测试，搞不清楚）</li><li>例外：值类型实例上调用</li></ul></li></ul><h1 id="第十四章-字符-字符串和文本处理"><a class="anchor" href="#第十四章-字符-字符串和文本处理">#</a> 第十四章 字符、字符串和文本处理</h1><ul><li>字符 (Char)：总是表示成 16 位 Unicode 代码值</li><li>Char getunicodecategory 方法返回一个枚举，标志该字符是由 Unicode 定义的控制字符、货币符号、小写字母、大写字母、标点符号、数学符号或者其它字符<ul><li>同时也提供了一些静态方法用于判断</li></ul></li><li>ToLowerInvariant、ToUpperInvariant：以忽略语言文化方式将字符串转换为小写或大写形式<ul><li>微软对执行大写比较的代码做了优化</li></ul></li><li>Covert 类型转换内部使用了 checked 检查</li><li>字符串<ul><li>直接使用字面值 (literal) 会被编译至元数据，并在运行时加载和引用</li><li>C# 不允许使用 new 操作符从字面值字符串构造 String 对象</li><li>il 中使用 ldstr 从元数据获得字面值字符串构造 String 对象</li><li>字面值字符串连接会被编译时直接连接并放入元数据，非字面值连接则在运行时进行</li></ul></li><li>字符串比较<ul><li>equals</li><li>compare</li><li>startswith</li><li>endswith</li><li>currentculture.compareinfo.compare</li><li>StringComparer：大量不同字符串反复执行同一种比较</li></ul></li><li>字符串留用<ul><li>clr 初始化会创建一个内部哈希表，key 为字符串，value 则为托管堆中的 string 对象引用</li><li>intern、isinterned</li><li>加载时默认留用所有字面值字符串 (可设置，并取决于 clr)</li><li>除非显式调用 intern，否则不要以 字符串已留用 前提写代码</li></ul></li><li>Char 代表一个 16 位 Unicode 码值，但是不一定等同于一个抽象的 Unicode 字符<ul><li>可能需要多个字符表示一个 Unicode 字符</li><li>有的 Unicode 字符需要两个 16 位值表示，称为 高位代理项 和 低位代理项，使其能表示 100 万个以上的字符</li></ul></li><li>stringbuilder<ul><li>字符数组，超过分配大小后，会分配新的字符数组，前一个字符数组会被回收</li><li>只有超出容量或 tostring 会导致分配新的对象</li></ul></li><li>string.format：替换参数花括号中可以使用『:』指定格式化信息</li><li>定制格式化器<ul><li>IFormatProvider</li></ul></li><li>安全字符串：System.Security.SecureString<ul><li>会在内部分配非托管内存，包含一个字符数组，字符经过加密</li><li>调用操作接口时，会先 解密 - 操作 - 加密，因此性能一般</li></ul></li></ul><h1 id="第十五章-枚举类型和位标志"><a class="anchor" href="#第十五章-枚举类型和位标志">#</a> 第十五章 枚举类型和位标志</h1><ul><li>结构：简单来说只是一个结构，其中定义了一组常量和一个实例字段</li><li>枚举类型定义的符号是常量值，编译时会用数值替换符号</li><li>getunderlyingtype：获取容纳枚举类型值的基础类型</li><li>Type.getenumunderlyingtype：同上</li><li>操作符实际作用于内部的 value 实例字段</li><li>IsDefined：通过反射查找，很慢</li><li>Flag 标志：ToString 会自动拼接（不定义该标志，ToString (&quot;F&quot;) 也可以）</li></ul><h1 id="第十六章-数组"><a class="anchor" href="#第十六章-数组">#</a> 第十六章 数组</h1><ul><li>一维 0 基数组 (向量) 性能最好<ul><li>有专用 il 指令处理</li><li>访问元素时不需要从指定索引减去偏移量</li><li>索引检查会在循环外判断</li></ul></li><li>[][]：交错数组 (性能其次)</li><li>[,]：多维数组 (性能不好，最好以交错数组代替)</li><li>Array.Copy：不仅仅是将元素从一个数组复制到另一个<ul><li>方法还能正确处理内存重叠区域</li><li>方法还能在复制每个数组元素时进行必要的类型转换 (如自动装箱拆箱、转型、加宽基元类型)</li><li>BlockCopy：比之更快，不过仅支持基元类型且不提供转型能力</li></ul></li><li>结构体中可使用 fixed 嵌入 (内联) 值类型一维 0 基数组，可在栈上分配（unsafe 代码）</li></ul><h1 id="第十七章-委托"><a class="anchor" href="#第十七章-委托">#</a> 第十七章 委托</h1><ul><li>自定义委托会导致编辑器定义一个完整的类，该类继承 MulticastDelegate<ul><li>包含 4 个方法：构造器、invoke 方法、begininvoke 方法、endinvoke 方法</li><li>MulticastDelegate<ul><li>_target (Object)：当委托包装静态方法时该字段为 null，实例方法为回调方法要操作的实例对象</li><li>_methodPtr (IntPtr)：clr 用来标识要回调的方法</li><li>_invocationList (Object)：通常为 null，构造委托链时引用一个委托数组</li></ul></li></ul></li><li>所有委托都有一个接受两个参数的构造器：一个是对象引用，另一个是引用了回调方法的整数</li><li>方法地址 IntPtr 值：从 MethodDef 或 MemberRef 元数据 token 获得</li><li>健壮性：一个系统对于参数变化的不敏感性</li><li>可靠性：一个系统的正确性，固定一个参数可以产生稳定、可预测的输出</li><li>委托 target 能取到？</li><li>除非内置 Action、Func 满足不了需求，如：需要利用委托传引用、可变参数，否则不要自定义委托</li><li>不引用成员变量、局部变量的匿名方法被编译为静态匿名函数并在第一次调用时缓存委托，性能更好，因为还不需要额外 this 参数</li></ul><h1 id="第十八章-定制特性"><a class="anchor" href="#第十八章-定制特性">#</a> 第十八章 定制特性</h1><ul><li>定制特性其实是一个类型的实例<ul><li>将特性应用于目标元素时，语法类似于调用类的某个实例构造器</li></ul></li><li>特性类型本质上还是类，而类是可以应用特性的（attributeusage）<ul><li>不将 allowmultiple 明确设置为 true，特性就只能向选定目标元素应用一次</li><li>inherited：指出特性在应用于基类时，是否同时应用于派生类和重写的方法</li><li>若未设置 attributeusage，则编译器和 clr 会假定该特性能应用于所有目标元素，每个目标元素最多一次，且可继承</li></ul></li><li>可想象为：它是类的实例，被序列化成驻留在元数据中的字节流，运行时可对元数据中字节进行反序列化，从而构造出类的实例</li><li>如果只想判断目标是否应用特性，使用 isdefined 更高效：它不会构造特性对象，不会调用构造器，也不会设置字段和属性<ul><li>getcustomattribute：会构造特性对象，每次调用都会构造指定特性类型的新实例</li><li>不管调用哪个，内部都必须扫描托管模块元数据，执行字符串比较来定位指定的定制特性类，可考虑缓存结果</li></ul></li><li>两个特性实例的相互匹配：可在自己的定制特性类中重写 equals 来移除反射的使用，以提高性能（默认的 equals 会在类型一致时，再反射字段比较）</li><li>customattributedata：在查找特性的同时禁止执行特性类中的代码</li><li>conditionalattribute：条件特性类<ul><li>编译器如果发现向目标应用了该特性，仅具有指定预定义时才会在元数据中生成特性信息</li><li>应用于方法时，若无预定义，则调用方法处会代码会直接去掉</li></ul></li></ul><h1 id="第十九章-可空值类型"><a class="anchor" href="#第十九章-可空值类型">#</a> 第十九章 可空值类型</h1><ul><li>操作可空值类型的速度慢于非可空值类型</li><li>&amp;：按位与 (相同为 1，不同为 0)</li><li>|：按位或 (有 1 则 1，无 1 则 0)</li><li>对于自己的值类型重载的操作符，编译器能自动调用其可空实例的</li><li>??：如果左边为空，则返回右边操作数的值</li><li>可空值类型装箱<ul><li>当 clr 对可空值类型实例进行装箱时，若其为空，则不装箱任何东西</li><li>若不为空，则取出其中的值进行装箱</li></ul></li><li>通过可空值类型调用 gettype，会返回内部实际值类型</li></ul><h1 id="第二十一章-托管堆和垃圾回收"><a class="anchor" href="#第二十一章-托管堆和垃圾回收">#</a> 第二十一章 托管堆和垃圾回收</h1><ul><li>托管堆：clr 维护 NextObjPtr 指针</li><li>类型对象指针、同步块索引<ul><li>32 位：各自 32 位</li><li>64 位：各自 64 位，因此每个对象额外 16 字节开销</li></ul></li><li>NextObjPtr：在此放入新对象，初始化对象后，指针加上对象占用字节数得到新值</li><li>GC<ul><li>暂停所有线程，进入标记阶段</li><li>遍历堆中所有对象，将同步块索引字段中的一位设为 0</li><li>检查所有活动根，查看其引用对象</li><li>任何根若引用了堆上对象，则标记该对象：同步块索引中的位设为 1，被标记后，继续检查该对象中的根，若其中对象被标记则不重新检测</li><li>标记完成后，进入压缩阶段，压缩存活对象使其占用连续空间（大对象堆默认不压缩）<ul><li>提升将来访问性能</li><li>解决堆内存空间碎片化问题</li></ul></li><li>修改指针指向新地址 (所以使用指针需要 fixed)</li></ul></li><li>分为三代：0、1、2 代，每代容量会自动计算，运行时也会进行调节，根据应用程序要求的内存负载自动优化</li><li>GC 触发条件<ul><li>手动调用 GC（不推荐）</li><li>系统报告内存过低</li><li>CLR 卸载 AppDomain</li><li>CLR 正在关闭</li></ul></li><li>大对象：超过 85000 字节，处于第二代，默认不压缩（可能会导致内存碎片）</li><li>分为 工作站 服务器 两种 GC 模式</li><li>子模式<ul><li>并发（默认）：内存足够的情况下，可能不压缩内存，消耗内存通常比非并发更多</li><li>非并发</li></ul></li><li>手动调用回收（不推荐），会导致代的预算发生调整，最好让程序根据应用程序行为调整各代预算。</li><li>Finalize：终结器，实现其的对象成为垃圾后，在垃圾回收完毕后才调用<ul><li>可终结对象在垃圾回收时必须存活，导致被提升到下一代，临时复活后会活得比正常时间长，所以一定程度会增加内存消耗</li><li>执行时间、顺序控制不了（不要访问另外实现了终结器的对象）</li><li>clr 用一个专用的、高优先级线程执行终结器方法避免死锁（因此若有终结器方法阻塞、等待信号量会导致线程无法再调用其它终结器 -&gt; 内存泄露）</li></ul></li><li>终结器内部原理<ul><li>创建对象实例时，若发现对象定义了终结器方法，则加入终结器列表</li><li>垃圾回收时，扫描到回收对象处于终结器列表，则移除列表并添加至 f-reachable 队列</li><li>一个特殊的高优先级线程专门调用 F-reachable (可达的) 队列中的终结器方法（因此不要对执行代码的线程做出任何假设）</li><li>reachable (可达的) 使其指向对象保持可达（复活）—— 标记时，将同时递归标记对象引用的对象，所有引用对象也将保持复活</li><li>标记完成后，复活对象也会被提升到老的一代（并不理想）</li><li>最后，特殊的终结器线程清空 freachable 队列，执行每个终结器方法</li><li>下一次对老一代进行垃圾回收时，才能发现终结器对象成为真正的垃圾</li><li>所以，回收一个终结器对象需要不止一次垃圾回收，甚至也不止两次</li></ul></li><li>创建封装了本机资源的托管类型时，应该先从 SafeHandle 派生出一个类</li><li>C# 内置的托管资源操作类，如果不调用 dispose，就得等到它被垃圾回收通过终结器释放资源了</li><li>StreamWriter：会将数据缓存在自己的内存缓冲区，缓冲区满时才会将对象数据写入 Stream<ul><li>该类没有实现终结器，不显式调用 dispose 会导致数据丢失</li></ul></li><li>如果一个类要包装可能很大的本机资源，可使用对应方法提示垃圾回收器实际情况以便处理：<ul><li>GC.AddMemoryPressure</li><li>GC.RemoveMemoryPressure</li></ul></li><li>包装数量有限的本机资源：HandleCollector，计数太大就强制回收</li><li>clr 为每个 appdomain 都提供了一个 GC 句柄表<ul><li>对托管堆对象一个引用</li><li>指出如何控制或监视对象的标记</li></ul></li><li>GCHandle（结构体）用于 添加或删除 GC 句柄表记录项<ul><li>weak：可检测垃圾回收器在什么时候判定该对象在应用程序代码中不可达</li><li>weaktrackresurrection：同上，不过对象终结器 (若有的话) 已执行，内存已回收</li><li>normal：即使应用程序没有根引用该对象，该对象也必须留在内存</li><li>Pinned：即使应用程序没有根引用该对象，该对象也必须留在内存，且发生垃圾回收时，该对象内存不能压缩（需要将内存地址交给本机代码时，这个功能比较好用）</li><li>注 1：使用 clr 的 P/Invoke 机制调用方法时，clr 会自动帮忙固定实参，并在本机方法返回时解除固定。</li><li>注 2：只有将托管对象指针传递给本机代码，且本机代码方法返回后仍需使用该对象时，才需要显式使用 GCHandle 类型</li></ul></li><li>fixed<ul><li>比分配一个固定 GC 句柄高效很多</li><li>编译器在局部变量上生成一个特殊 已固定 标志，垃圾回收期间检测根内容，若根不为空则知道在压缩阶段不要移动变量引用对象</li></ul></li><li>WeakReference<ul><li>其实是包装了一个 GCHandle 实例的面向对象包装器</li><li>实例必须在堆上分配，比 GCHandle 实例更重</li></ul></li><li>ConditionalWeakTable<ul><li>内部存储了对作为 key 传递对象的弱引用（一个 WeakReference 对象），保证不会因为表的存在而使对象 被迫 存活</li><li>保证只要 key 所标识的对象在内存，值就肯定在内存中</li><li>可以实现类似 xaml 依赖属性 机制</li></ul></li></ul><h1 id="第二十二章-clr-寄宿和-appdomain"><a class="anchor" href="#第二十二章-clr-寄宿和-appdomain">#</a> 第二十二章 CLR 寄宿和 AppDomain</h1><ul><li>AppDomain<ul><li>clr 初始化时会创建第一个默认 appdomain，只有进程结束才会被销毁</li><li>相互之间不能直接访问<ul><li>相互有清晰的分隔和边界，容易单独卸载而不影响其它 appdomain</li><li>想要相互访问对象，必须 按引用封送 (marshal-by-reference)，或 按值封送 (marshal-by-value)</li></ul></li><li>可以被卸载：不支持卸载程序集，但是能卸载包含程序集的 appdomain</li><li>可以单独保护：可以设置运行权限</li><li>可以单独配置：appdomain 创建后会关联一组配置设置（涉及搜索路径、版本绑定重定向、卷影复制及加载器优化）</li></ul></li><li>windows 每个应用程序都在自己的进程地址 (虚拟地址) 空间运行，即进程隔离<ul><li>创建进程开销很大，如需要大量内存虚拟化进程地址空间</li><li>appdomain 同样提供了清晰隔离（保护、配置和终止每一个应用所需的隔离），使得可以提供一个进程运行多个托管程序</li></ul></li><li>Loader 堆<ul><li>每个 appdomain 都有自己的 loader 堆，每个 loader 堆都记录了自 appdomain 创建以来已访问过的哪些类型</li><li>loader 堆中每个类型都有一个方法表</li><li>方法表中的每个记录项都指向 jit 编译的本机代码 (前提是方法执行过)</li></ul></li><li>进程<ul><li>appdomain 1<ul><li>loader 堆</li><li>程序集</li></ul></li><li>appdomain 2<ul><li>loader 堆</li><li>程序集</li></ul></li><li>appdomain 中立 的程序集<ul><li>loader 堆</li><li>程序集：MSCorLib.dll</li></ul></li></ul></li><li>jit 编译的代码不共享，每个 appdomain 都有一份</li><li>多个 appdomain 使用的类型在每个 appdomain 都有一组静态字段</li><li>appdomain 中立的程序集：以 中立 方式加载的程序集会共享，不过以 中立 方式加载的程序集，永远不能卸载，回收其资源的唯一方法是终止进程</li><li>跨越 appdomain 边界访问对象（跨域？）<ul><li>同步执行的：一个 appdomain 方法执行完毕，才能执行另一个的方法，不能多个 appdomain 方法并发执行</li><li>按引用封送（继承 marshalbyrefobject）<ul><li>生成代理类型，并创建代理类型实例</li><li>调用方法时，切换至另一个 appdomain 执行</li><li>实例字段通过反射设置或获取</li><li>使用 租约管理器 保持原始对象存活</li><li>性能较差</li><li>应该避免静态成员（总是在调用 appdomain 的上下文访问）</li></ul></li><li>按值封送（继承普通 object）<ul><li>标记 Serializable 特性</li><li>clr 将对象的实例字段序列化成一个字节数组</li><li>从源 appdomain 复制到目标 appdomain</li><li>反序列化字节数组，这会强制 clr 将定义了 被反序列化类型 的程序集加载到目标 appdomain (若未加载)</li><li>创建对象实例，并利用字节数组中的值初始化对象字段</li><li>调用方法时，由于是真实对象，因此不会发生 appdomain 线程切换（卸载源 appdomain 也不再影响该对象）</li></ul></li></ul></li><li>卸载 appdomain：步骤</li><li>监视 appdomain<ul><li>appdomain 静态 MonitoringEnabled：设置为 true 后便不能关闭</li><li>开启后，可查询（只保证在上一次垃圾回收时是准确的）：</li><li>MonitoringSurvivedProcessMemorySize：当前 clr 所有 appdomain 使用的字节数</li><li>MonitoringTotalAllocatedMemorySize：特定 appdomain 已分配字节数</li><li>MonitoringSurvivedMemorySize：特定 appdomain 当前正在使用的字节数</li><li>MonitoringTotalProcessorTime：特定 appdomain 的 cpu 占用率</li></ul></li><li>appdomain firstchance 异常通知<ul><li>每个 appdomain 都可关联一组回调方法，clr 开始查找 appdomain 中的 catch 块时被调用</li><li>可利用此做日志记录操作</li></ul></li><li>代码运行时会访问其它类型，引用另一个程序集中类型时，clr 会定位所需程序集，并将其加载到同一个 appdomain 中</li><li>关闭进程：Environment.Exit</li></ul><h1 id="第二十三章-程序集加载和反射"><a class="anchor" href="#第二十三章-程序集加载和反射">#</a> 第二十三章 程序集加载和反射</h1><ul><li>clr 不提供卸载单独程序集的能力</li><li>程序集加载<ul><li>引用另一个程序集中类型时，clr 会定位所需程序集，并将其加载到同一个 appdomain 中</li><li>clr 内部也是调用 assembly 静态 load 方法</li><li>appdomain 也提供了 load 方法<ul><li>不过是实例方法</li><li>clr 通过发出调用的 appdomain 设置定位和加载（可能找不到）</li><li>存在问题，应该避免</li></ul></li><li>loadfrom<ul><li>首先调用 assemblyname 的 静态 getassemblyname 方法打开指定文件</li><li>找到 assemblyref 元数据表的记录项，提取程序集标识信息</li><li>以 assemblyname 形式返回（并关闭文件）</li><li>随后 loadfrom 方法内部调用 assembly 静态 load 方法，将 assemblyname 传入</li><li>clr 应用版本绑定重定向策略，并在各个位置查找匹配程序集</li><li>若找到匹配程序集则加载，并返回代表程序集的 assembly 对象</li><li>若没有找到，则 loadfrom 会加载传递路径中的程序集</li><li>若已加载具有相同标识程序集，则会直接返回代表程序集的 assembly 对象</li><li>注 1：loadfrom 允许传入 url</li><li>注 2：由于一台机器可能存在相同标识的多个程序集，且 loadfrom 会在内部调用 load，因此 clr 可能加载的不是指定文件</li></ul></li><li>loadfile<ul><li>从任意路径加载程序集，而且可以将相同标识程序集多次加载到同一 appdomain</li><li>clr 不会自动解析任何依赖性问题</li><li>代码必须向 appdomain 的 assemblyresolve 事件登记，并让事件回调显式加载依赖程序集</li></ul></li></ul></li><li>若代码只想反射分析程序集元数据<ul><li>使用 assembly reflectiononlyfrom 或 reflectiononlyload（少见）</li><li>使用上述方法加载程序集时，clr 禁止程序集中任何代码运行</li><li>依赖：reflectiononlyassemblyresolve 事件</li></ul></li><li>在 appdomain 的 assemblyresolve 事件登记后，可以手动处理依赖程序集加载</li><li>反射<ul><li>严重依赖字符串</li><li>编译时无法保证类型安全性</li><li>速度较慢<ul><li>字符串名称标识类型及成员</li><li>使用 reflection 命名空间中类型扫描程序集元数据时，反射机制会不停地执行字符串搜索</li><li>通常字符串搜索不区分大小写，因此进一步影响速度</li><li>反射调用成员（方法）时，首先必须将实参打包成数组，然后在内部将实参解包到线程栈上</li><li>在调用方法前，还必须检查实参是否有正确的数据类型</li></ul></li></ul></li><li>因此，晚期绑定不推荐用反射调用，可以：<ul><li>让类型从已知基类型派生，运行时构造派生类型实例，调用虚方法</li><li>让类型实现已知接口，在运行时构造实例，再调用接口方法 (推荐)</li><li>这样访问对象成员可以获得更好的性能，并确保编译时的安全性</li></ul></li><li>在一个 appdomain 中，每个类型只会有一个 type 对象</li><li>反射方法字符串为这些名称定义了 巴克斯 - 诺尔范式（Backus-Naurform，BMF） 语法</li><li>typeof（早期绑定） 获取类型比 gettype（晚期绑定） 更快</li><li>Type 对象是轻量级引用，更多信息必须通过 gettypeinfo (不过性能更低) 获取 typeinfo（其也可以转型为 type）</li><li>反射构造类型实例<ul><li>Activator.CreateInstance<ul><li>运行在不调用值类型构造器的情况下创建值类型的实例</li></ul></li><li>Activator.CreateInstanceFrom</li><li>AppDomain.CreateInstance</li><li>AppDomain.CreateInstanceAndUnwrap</li><li>AppDomain.CreateInstanceFrom</li><li>AppDomain.CreateInstanceFromAndUnwrap</li><li>Reflection.ConstructorInfo：Type 对象引用可获取构造方法信息，调用后构造类型实例并调用构造器</li><li>创建数组类型：Array.CreateInstance</li><li>创建委托：MethodInfo.CreateDelegate</li><li>构造泛型类型实例首先要获取开放类型的引用，然后调用 MakeGenericType 传递生成封闭类型参数</li></ul></li><li>反射类型成员：MemberInfo (抽象基类)<ul><li>TypeInfo</li><li>FieldInfo</li><li>MethodBase<ul><li>ConstructorInfo</li><li>MethodInfo</li></ul></li><li>PropertyInfo</li><li>EventInfo</li></ul></li><li>反射时传引用<ul><li>类型 &amp;（巴克斯 - 诺尔范式）</li><li>type.makebyreftype</li></ul></li><li>若为了提高性能，缓存 Type 和 MemberInfo 派生对象会消耗更多内存<ul><li>clr 内部用更精简的方式表示这种信息，clr 不需要这些大对象就，能运行，之所以创建这些对象是为了方便开发人员</li><li>精简方式：<ul><li>可以使用运行时句柄代替对象以减小内存</li><li>RuntimeTypeHandle</li><li>RuntimeFieleHandle</li><li>RuntimeMethodHandle</li><li>上述都是值类型，只包含一个 IntPtr 字段，引用 appdomain 的 loader 堆中一个类型、字段或方法</li></ul></li><li>使用方法：<ul><li>type.gettypehandle（gettypefromhandle 转回去）</li><li>fieldinfo.fieldhandle（转换同上）</li><li>methodinfo.methodhandle（转换同上）</li><li>获得 handle 后原对象可被释放（猜测？存疑）</li></ul></li></ul></li></ul><h1 id="第二十四章-运行时序列化"><a class="anchor" href="#第二十四章-运行时序列化">#</a> 第二十四章 运行时序列化</h1><ul><li>类型默认是不可序列化的，必须应用定制特性：Serializable<ul><li>特性可以应用于 引用类型、值类型、枚举和委托类型</li><li>枚举和委托默认总是可序列化（所以不必显式调用）</li><li>该特性不会被派生类继承</li><li>注：自动属性序列化会有问题，因为其字段值由编译器自动生成，名称每次编译可能不同，因此在允许序列化的类型中不要用</li></ul></li><li>序列化会读取对象所有实例字段，包括私有<ul><li>NonSerializable 特性可以标记指定字段不被序列化</li></ul></li><li>序列化、反序列化可允许自动调用方法<ul><li>OnSerializing 特性：序列化前首先调用</li><li>OnSerialized 特性：序列化完毕调用</li><li>OnDeserializing 特性：反序列化前首先调用</li><li>OnDeserialized 特性：反序列化完毕调用</li><li>定义的方法必须获取一个 StreamingContext 参数</li></ul></li><li>反序列化类型存在新增字段会报错<ul><li>可以为新增字段应用 OptionalField 特性</li></ul></li><li>System.Runtime.Serialization.Formatters.Binary：二进制序列化<ul><li>其实现 System.Runtime.Serialization.IFormatter 接口</li><li>默认输出程序集完整标识：文件名、版本号、语言文化、公钥信息<ul><li>反序列化时，通过 assembly load 确保程序集已加载</li><li>查找匹配类型（找不到则抛出异常）</li><li>找到则创建实例，并通过反射用流数据初始化字段（若不完全匹配则抛出异常，可选 OptionalField 忽略）</li></ul></li></ul></li><li>格式化器如何序列化<ul><li>调用 FormatterServices 提供的静态方法</li><li>GetSerializableMembers：反射获取未标记 NonSerualized 的实例字段</li><li>反射获取值</li><li>写入程序集标识和类型完整名称</li><li>遍历反射获取的数组，写入每个成员名称和值</li></ul></li><li>格式化器如何反序列化<ul><li>从流中读取程序集和完整类型名称</li><li>确保程序集加载</li><li>gettypefromassembly 获取反序列化对象类型</li><li>调用 FormatterServices 提供的方法</li><li>GetUnInitializedObject：构造对象，但不调用构造方法，对象所有字段初始化为 0 或 null</li><li>GetSerializableMembers：反射获取字段信息</li><li>根据流中信息初始化值的数组</li><li>调用 PoulateObjectMembers 方法反射初始化值</li></ul></li><li>为提高更多操作，并避免反射开销<ul><li>可以实现 ISerializable 接口，该接口会由格式化器使用</li><li>若一个类型实现了该接口，格式化器将忽略前面说的定制特性</li><li>实现接口的类型需要定义带两个参数的特殊构造器：name (SerializationInfo info,StreamingContext context)，这个构造器在反序列化时被调用</li></ul></li><li>类型序列化为不同类型以及对象反序列化为不同对象<ul><li>序列化单例（贪婪模式），并保证反序列化后也只有一个：实现的 ISerializable 接口方法 序列化实现 IObjectReference 的类型，该类型的方法直接返回单例对象</li><li>在反序列化时，会调用其静态构造方法构成其单例对象</li><li>反序列化时，若发现类型实现了 IObjectReference 接口，会调用其 GetRealObject 方法</li></ul></li><li>序列化代理<ul><li>必须实现 ISerializationSrurogate 接口</li><li>允许开发人员序列化最初没有设计成要序列化的类型</li><li>运行开发人员提供一种方式将类型一个版本映射到另一个版本</li><li>通过 SurrogateSelector 在 IFormatter (格式化器) 注册</li></ul></li><li>反序列化和序列化时不同类型<ul><li>SerializationBinder</li><li>可以重写 类型<ul><li>BindToType</li><li>BindToName</li></ul></li><li>继承 SerializationBinder 实现自己的类，然后在格式化器注册</li></ul></li><li>Xml 序列化<ul><li>XmlSerializer</li><li>DataContractSerializer</li></ul></li><li>可以通过二进制序列化简单实现对象的 深拷贝</li></ul><div class="tags"><a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C#</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 笔记</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-04-28 17:12:24" itemprop="dateModified" datetime="2023-04-28T17:12:24+08:00">2023-04-28</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>WangJiaYing <i class="ic i-at"><em>@</em></i>CWHISME</li><li class="link"><strong>本文链接：</strong> <a href="https://wangjiaying.top/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8A/" title="CLR VIR C# 笔记 (上)">https://wangjiaying.top/2023/04/06/ClrVirCS笔记-上/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/03/28/C-%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%B5%8B%E8%AF%95/" itemprop="url" rel="prev" data-background-image="&#x2F;images&#x2F;coverimages&#x2F;large&#x2F;9bd9b167gy1g4lhdrbztdj21hc0xc11p.webp" title="C#类型方法调用测试"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 理论研究</span><h3>C#类型方法调用测试</h3></a></div><div class="item right"><a href="/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="next" data-background-image="&#x2F;blogimages&#x2F;2023&#x2F;2023-04-06&#x2F;title.jpg" title="CLR VIR C# 笔记(下)-多线程"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 阅读笔记</span><h3>CLR VIR C# 笔记(下)-多线程</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%90%8D%E7%A7%B0"><span class="toc-number">2.</span> <span class="toc-text">基本名称</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">3.</span> <span class="toc-text">其它</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#il"><span class="toc-number">4.</span> <span class="toc-text">IL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">值类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9E%8B%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">静态构造方法（类型构造器）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-number">8.</span> <span class="toc-text">工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%8F%82%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">第九章 参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%B1%9E%E6%80%A7"><span class="toc-number">10.</span> <span class="toc-text">第十章 属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E4%BA%8B%E4%BB%B6"><span class="toc-number">11.</span> <span class="toc-text">第十一章 事件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E6%B3%9B%E5%9E%8B"><span class="toc-number">12.</span> <span class="toc-text">第十二章 泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%8E%A5%E5%8F%A3"><span class="toc-number">13.</span> <span class="toc-text">第十三章 接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E5%AD%97%E7%AC%A6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86"><span class="toc-number">14.</span> <span class="toc-text">第十四章 字符、字符串和文本处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%BD%8D%E6%A0%87%E5%BF%97"><span class="toc-number">15.</span> <span class="toc-text">第十五章 枚举类型和位标志</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E6%95%B0%E7%BB%84"><span class="toc-number">16.</span> <span class="toc-text">第十六章 数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E5%A7%94%E6%89%98"><span class="toc-number">17.</span> <span class="toc-text">第十七章 委托</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-%E5%AE%9A%E5%88%B6%E7%89%B9%E6%80%A7"><span class="toc-number">18.</span> <span class="toc-text">第十八章 定制特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E5%8F%AF%E7%A9%BA%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.</span> <span class="toc-text">第十九章 可空值类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%89%98%E7%AE%A1%E5%A0%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">20.</span> <span class="toc-text">第二十一章 托管堆和垃圾回收</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0-clr-%E5%AF%84%E5%AE%BF%E5%92%8C-appdomain"><span class="toc-number">21.</span> <span class="toc-text">第二十二章 CLR 寄宿和 AppDomain</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E9%9B%86%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8F%8D%E5%B0%84"><span class="toc-number">22.</span> <span class="toc-text">第二十三章 程序集加载和反射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">23.</span> <span class="toc-text">第二十四章 运行时序列化</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8A/" rel="bookmark" title="CLR VIR C# 笔记(上)">CLR VIR C# 笔记(上)</a></li><li><a href="/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="bookmark" title="CLR VIR C# 笔记(下)-多线程">CLR VIR C# 笔记(下)-多线程</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="WangJiaYing" data-src="/images/../img/avator"><p class="name" itemprop="name">CWHISME</p><div class="description" itemprop="description">己所不欲，勿施于人</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">101</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">21</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">30</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N3aGlzbWU=" title="https:&#x2F;&#x2F;github.com&#x2F;cwhisme"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9jd2hpc21lLTMzL3Bvc3Rz" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;cwhisme-33&#x2F;posts"><i class="ic i-zhihu"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmN3aGlzbWVAMTI2LmNvbQ==" title="mailto:cwhisme@126.com"><i class="ic i-envelope"></i></span> <a href="/atom.xml" title="&#x2F;atom.xml" class="item feedback"><i class="ic i-heart"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/bookmark/" rel="section"><i class="ic i-tag"></i>书签</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-magic"></i>链接</a><ul class="submenu"><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li></ul></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/03/28/C-%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%B5%8B%E8%AF%95/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Unity3D/" title="分类于 Unity3D">Unity3D</a> <i class="ic i-angle-right"></i> <a href="/categories/Unity3D/%E8%B5%84%E6%BA%90%E8%AE%BE%E7%BD%AE/" title="分类于 资源设置">资源设置</a></div><span><a href="/2022/10/26/%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E6%A0%BC%E5%BC%8F%E8%AE%BE%E7%BD%AE%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%BB%E7%BB%93/" title="图片资源格式设置测试与总结">图片资源格式设置测试与总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Unity3D/" title="分类于 Unity3D">Unity3D</a></div><span><a href="/2017/05/10/2017-5-10-Unity-Kinect/" title="Unity Kinect 开发">Unity Kinect 开发</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%9A%E5%AE%A2/" title="分类于 博客">博客</a></div><span><a href="/2015/12/30/MarkDown%E8%AF%AD%E6%B3%95/" title="MarkDown语法">MarkDown语法</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment count_3"></ul></div></div><div class="status"><div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">WangJiaYing @ Jiaying's Note</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">536k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">8:07</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/04/06/ClrVirCS笔记-上/",favicon:{show:"（●´3｀●）",hide:"(´Д｀)"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script><script src="https://cdn.staticfile.org/pjax/0.2.8/pjax.min.js"></script><script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@3.6.2/dist/fetch.umd.min.js"></script><script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script><script src="https://cdn.staticfile.org/algoliasearch/4.17.0/algoliasearch-lite.umd.js"></script><script src="https://cdn.staticfile.org/instantsearch.js/4.54.1/instantsearch.production.min.js"></script><script src="https://cdn.staticfile.org/lozad.js/1.16.0/lozad.min.js"></script><script src="https://cdn.staticfile.org/quicklink/2.3.0/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/js/DateTimeAfeterCalc.js"></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?62952472c154f9131a14a4ab57bfefec";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html>