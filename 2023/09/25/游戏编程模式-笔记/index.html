<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="CWHISME" href="https://wangjiaying.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="CWHISME" href="https://wangjiaying.top/atom.xml"><link rel="alternate" type="application/json" title="CWHISME" href="https://wangjiaying.top/feed.json"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="笔记"><link rel="canonical" href="https://wangjiaying.top/2023/09/25/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-%E7%AC%94%E8%AE%B0/"><title>《游戏编程模式》- 笔记 - 阅读笔记 | Jiaying's Note = CWHISME = 人不能没有梦想，也要有足够的敬畏</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">《游戏编程模式》- 笔记</h1><div class="meta"><span class="item" title="创建时间：2023-09-25 16:31:19"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-09-25T16:31:19+08:00">2023-09-25</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>7.6k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiaying's Note</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="/blogimages/2023/2023-09-25/book.webp"></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" itemprop="item" rel="index" title="分类于 阅读笔记"><span itemprop="name">阅读笔记</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://wangjiaying.top/2023/09/25/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/../img/avator"><meta itemprop="name" content="WangJiaYing"><meta itemprop="description" content="人不能没有梦想，也要有足够的敬畏, 己所不欲，勿施于人"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="CWHISME"></span><div class="body md" itemprop="articleBody"><h1 id="前言"><a class="anchor" href="#前言">#</a> 前言</h1><p>说实话，关于正经游戏模式的书还是有点少，这本算是少数中的其中之一。</p><p>整本书看下来，发现书里并没有按照类似常规 “23 种设计模式” 这种概念来讲述，有不少其实都不存在于常规设计模式当中：<br>比如双缓冲、空间分区、脏标记等... 确实跟书名更符一点，讲的是 “游戏编程模式”，而不是单纯的设计模式。</p><p>不过，要说是是游戏程序设计方面的书籍，本书肯定是算的。总之值得一看。</p><h1 id="介绍"><a class="anchor" href="#介绍">#</a> 介绍</h1><p>设计模式相关的书籍，主要是为了做到如何更好组织程序</p><ul><li>编写超出大脑思考范围的程序，需要更好的设计与组织。</li><li>宝藏埋在代码深处，而许多人正在它们之上路过。</li></ul><p>作者将其描述的模式分为：序列型、行为型、解藕型、优化型</p><h1 id="架构-性能和游戏"><a class="anchor" href="#架构-性能和游戏">#</a> 架构、性能和游戏</h1><p>解藕</p><ul><li>解藕符合最少知识原则：如果两块代码耦合，意味着必须同时搞清楚两者，而如果解藕，只需要了解其一</li></ul><p>维护设计</p><ul><li>一个良好的设计必须在实现新需求时优雅地融入，否则就会死于一个又一个『小补丁』</li><li>在项目生命周期维护一个良好的架构需要很大努力</li></ul><p>许多模式会让代码更加灵活，但是依赖于一些运行时成本的机制 (如接口、消息、虚函数等)。</p><h2 id="寻求平衡"><a class="anchor" href="#寻求平衡">#</a> 寻求平衡</h2><ul><li>良好架构：在项目生命周期内更容易理解代码</li><li>快速的运行时性能</li><li>快速完成所需功能</li></ul><p>它们一部分是冲突的，需要权衡</p><h2 id="要点"><a class="anchor" href="#要点">#</a> 要点</h2><ul><li>抽象和解藕能够使程序开发变得更快和简单，但不必浪费时间来做，除非确信存在问题的代码需要这种灵活性</li><li>在开发周期中要对性能进行思考和设计，但要推迟会降低灵活性、底层的、详尽的优化</li><li>尽快探索游戏设计空间，但不要走得太快留下烂摊子</li><li>如果将要删除代码，那么不需要浪费时间将其整理得很整洁</li><li>乐在其中</li></ul><h1 id="再探设计模式"><a class="anchor" href="#再探设计模式">#</a> 再探设计模式</h1><h2 id="命令模式"><a class="anchor" href="#命令模式">#</a> 命令模式</h2><p>『命令就是一个对象化 (实例化) 的方法调用』</p><ul><li>将某个概念转化为一块数据、一个对象 (或者可以认为是传入函数的变量等)</li><li>支持 undo、redo 的命令模式与备忘录模式有点类似，但区别在于备忘录模式是记录所有数据，而命令模式仅需记录该条命令改变的数据</li></ul><p>示例：关卡编辑、角色 (包括 AI) 控制</p><h2 id="享元模式"><a class="anchor" href="#享元模式">#</a> 享元模式</h2><p>一般用于太多对象并考虑对其进行轻量化时<br>享元模式通过将对象数据切分成两种类型解决共同数据问题</p><ol><li>不属于单一实例对象并且能够被所有对象共享的数据 (内部状态)</li><li>单一对象实例特有数据 (外部状态)</li></ol><p>示例：地图绘制，地块类型等数据</p><h3 id="森林之树"><a class="anchor" href="#森林之树">#</a> 森林之树</h3><p>『迷雾升起，一片雄伟、古老而茂密的森林在眼前展现。数不尽的远古铁杉铺面而来，宛如一座绿色的大教堂。漫天树叶像是褪色的巨大玻璃穹顶，将阳光滤碎成细密的水雾，透过高大树干的间隙，你能感到这庞大的森林往远方渐逝。』</p><h2 id="观察者模式"><a class="anchor" href="#观察者模式">#</a> 观察者模式</h2><p>MVC 一般必然都会用到。<br>C# event 亦是。<br>分为『容器』方式和链表方式<br>链式观察者</p><ul><li>避免动态容器扩容导致的内存分配</li><li>链表节点池 (指向观察者及下一个链表)，可以使得多个链表节点指向同一个观察者，使得一个观察者可以同时观察多个被观察对象。</li></ul><p>注：观察者模式非常适合于一些不相干的模块之间的通信问题，但并不适合于单个紧凑的模块内部的通信。<br>目的：解藕<br>示例：成就系统、数据绑定</p><h2 id="原型模式"><a class="anchor" href="#原型模式">#</a> 原型模式</h2><p>如 prefab<br>原型数据建模</p><ul><li>如 BOSS 或某些特殊物品，通常是游戏中某一对象的重定义版本</li><li>即可定义：原型 + 额外数据</li></ul><h2 id="单例模式"><a class="anchor" href="#单例模式">#</a> 单例模式</h2><p>谨慎使用，避免使用、避免滥用。<br>单例会尽可能将初始化延后 (懒汉)，所以到那时它们所需信息一般都可获得。</p><ul><li>只要不是循环依赖，一个单例甚至可以在其初始化时引用另一个单例。</li><li>可以继承单例，例如使用简单的编译跳转，实现不同平台绑定到具体类型</li></ul><p>不推荐单例的原因：单例模式就是一个全局状态，只是被封装到类中了而已</p><ol><li>全局变量有害，令代码晦涩难懂</li><li>全局变量促进耦合，控制对实例的访问才能控制耦合</li><li>并发不友好</li></ol><p>注：不访问或不修改全局状态的函数称为『纯函数』，纯函数易于理解、利于编译器优化，并能使用诸如记忆缓存、重用调用结果等技巧。<br>为实例提供便捷访问方式</p><ul><li>传递参数</li><li>在基类获取</li><li>通过其它全局对象访问</li><li>通过 服务定位器访问 (定义一个类专门用来给对象做全局访问)</li></ul><h2 id="状态模式"><a class="anchor" href="#状态模式">#</a> 状态模式</h2><h3 id="有限状态机"><a class="anchor" href="#有限状态机">#</a> 有限状态机</h3><ul><li>借鉴了计算机科学里的自动机理论中的一种数据结构 (图灵机) 思想。</li><li>FSMs 可以看作最简单的图灵机</li></ul><p>表达的是：</p><ul><li>拥有一组状态，且可以在这组状态之间进行切换</li><li>状态机同一时刻只能处于一种状态</li><li>状态机会接收一组输入或事件</li><li>每一个状态有一组转换，每一个转换都关联着一个输入并指向另一个状态</li></ul><p>整个状态机可以分为：状态、输入和转换<br>注：部分状态机实例 (没有内部状态) 可通过享元模式复用</p><h3 id="并发状态机"><a class="anchor" href="#并发状态机">#</a> 并发状态机</h3><p>角色在持枪过程中可以跑、跳和躲避，并能在过程中开火，若执着于传统的有限状态机，那么之前的状态可能都需要加倍：对于已存在状态，需要定另一个 (附加额外操作的) 状态。</p><ul><li>并发状态机即另外定义一个状态机，与基础状态机同时运行</li><li>适用于两个状态没什么关系的时候 (也许还需要加点额外判断)，但至少比单层有限状态机更能完成任务</li></ul><h3 id="层次状态机"><a class="anchor" href="#层次状态机">#</a> 层次状态机</h3><p>比如有一个『on ground』状态用于处理跳跃状态和躲避状态，站立、走路、跑步状态则可以从这个『on ground』状态继承而来。</p><ul><li>一个状态有一个父状态，当一个事件进来时，如果子状态不处理则沿继承链传给父状态处理。</li><li>或使用状态栈实现状态链</li></ul><h3 id="下推自动机"><a class="anchor" href="#下推自动机">#</a> 下推自动机</h3><p>解决有限状态机没有历史记录问题。</p><ul><li>下推自动机有一个状态栈</li><li>在一个有限状态机里，当有一个状态切进来时，则替换之前状态</li><li>下推状态机除此之外还提供额外选择：<ul><li>可以把新状态放入栈中 (当前状态即存在栈顶)</li><li>可以弹出栈顶状态 (上一个状态变成新的栈顶状态)</li></ul></li></ul><h1 id="序列型模式"><a class="anchor" href="#序列型模式">#</a> 序列型模式</h1><h2 id="双缓冲"><a class="anchor" href="#双缓冲">#</a> 双缓冲</h2><p>当今多数游戏中，每个像素占 32 位：红、绿、蓝 各占 8 位，剩余 8 位保留做其它各种用途。<br>显示器从左至右，从上至下绘制显示器像素，会从帧缓冲区获知这些像素该是何种颜色。</p><ul><li>各种高级图形算法，本质上都是为了向这个帧缓冲数组写东西</li></ul><p>撕裂</p><ul><li>显示器访问速度 (屏幕刷新率) 比显卡写入速度 (帧率) 更快</li><li>GPU 的帧率超过显示器后、或在帧率较低的时候都可能会出现撕裂的情况：其本质是帧率和屏幕刷新率的不一致导致</li></ul><p>适用双缓冲情景：</p><ul><li>需要维护一些被逐步改变着的状态量</li><li>同个状态可能会在其被修改的同时被访问到</li><li>希望避免访问状态的代码能看到具体的工作过程</li><li>希望能够读取状态但不希望等待写入操作完成</li></ul><p>注意</p><ul><li>双缓冲需要在写入完成后进行一次交换操作，操作必须是原子性的</li><li>双缓冲意味着增加了内存使用</li></ul><p>双缓冲模式所解决的核心问题是对状态同时进行修改和访问的冲突 (并非只针对图形)</p><ul><li>状态被另一个线程或中断代码直接访问</li><li>进行状态修改的代码访问到了其正在修改的那个状态</li></ul><p>例如：战斗中事件状态？<br>做法</p><ul><li>交换缓冲区指针或引用 (需要注意外部不能缓冲这个引用，因为引用指向地址可能错误)</li><li>在两个缓冲区之间进行数据拷贝</li></ul><h2 id="游戏循环"><a class="anchor" href="#游戏循环">#</a> 游戏循环</h2><p>实现用户输入和处理器速度在游戏行进时间上的解藕。<br>一个游戏循环在游戏过程中持续运转，每循环一次，非阻塞地处理用户的输入、更新游戏状态并渲染游戏。它跟踪流逝的时间并控制游戏的速率。<br>关键部分：</p><ul><li>非阻塞用户输入</li><li>帧时间适配<ul><li>非同步的固定时间步长 (尽可能快执行更新循环)</li><li>同步的固定时长 (让循环以固定时间步长运行：增加延时或追赶帧时间)</li><li>变时步长 (使游戏变得不确定)</li><li>定时更新迭代，变时渲染 (最复杂且最具适配性)</li></ul></li></ul><h2 id="更新方法"><a class="anchor" href="#更新方法">#</a> 更新方法</h2><p>通过对所有对象实例同时进行帧更新来模拟一系列相互独立的游戏对象。<br>注 1：所有对象都在每帧进行模拟，但并非真正同步。且对象更新顺序亦有很大影响，因为 A 更新时，看到的 B 的状态是前一帧的。(除非借助双缓冲模式)<br>注 2：在更新期间修改对象列表必须谨慎</p><ul><li>更新期间删除列表对象可能导致某项被跳过</li><li>添加新对象则会导致新对象提前一帧更新</li></ul><p>update 依存：</p><ul><li>实体类中</li><li>组件类中</li><li>代理类中</li></ul><p>处理非激活对象</p><ul><li>过多无需被更新的对象会导致 CPU 浪费额外时间来遍历，并破坏缓存。若非激活对象较多，可考虑单独一个列表维护</li></ul><h1 id="行为型模式"><a class="anchor" href="#行为型模式">#</a> 行为型模式</h1><h2 id="字节码"><a class="anchor" href="#字节码">#</a> 字节码</h2><h3 id="解释器模式"><a class="anchor" href="#解释器模式">#</a> 解释器模式</h3><p>缺点</p><ul><li>从磁盘加载它需要进行实例化并串联成堆的小对象</li><li>这些对象与它们之间的指针占用大量内存</li><li>遍历子表达式、虚函数调用均对缓存不友好</li></ul><h3 id="虚拟机器码"><a class="anchor" href="#虚拟机器码">#</a> 虚拟机器码</h3><p>由虚拟机 (VM) 执行</p><ul><li>高密度</li><li>线性</li><li>底层</li><li>迅速</li></ul><p>字节码模式</p><ul><li>指令集定义了一套可以执行的底层操作，一系列指令被编码为字节序列，虚拟机逐条执行指令栈上的这些指令</li><li>通过组合指令，即可完成很多高级行为</li></ul><h3 id="堆栈机"><a class="anchor" href="#堆栈机">#</a> 堆栈机</h3><p>指令<br>字面值指令 + 数据<br>指令分类</p><ul><li>外部基本操作：虚拟机之外，引擎内部，做一些玩家能看到的事情，决定字节码能够表达的真正行为</li><li>内部基本操作：操作虚拟机内部的值 —— 字面值、算数运算符、操作栈的指令等</li><li>控制流：让指令有选择执行或循环重复执行，即跳转</li><li>抽象化：复用，方法调用</li></ul><h3 id="语法转换工具"><a class="anchor" href="#语法转换工具">#</a> 语法转换工具</h3><p>一个图形界面以让用户定义行为，随后转换为字节码<br>注 1：用户其实可以绕过编译器，手动编写一些恶意字节码<br>注 2：ANTLR 或 Bison 解析器生成器</p><h3 id="设计决策"><a class="anchor" href="#设计决策">#</a> 设计决策</h3><p>基于栈虚拟机</p><ul><li>指令较小</li><li>代码生成简单</li><li>指令数更多</li></ul><p>基于寄存器虚拟机</p><ul><li>指令更大：需要记录参数在栈中偏移量</li><li>指令更少：每个指令能做更多的事</li></ul><h2 id="子类沙盒"><a class="anchor" href="#子类沙盒">#</a> 子类沙盒</h2><p>使用基类提供的操作集合来定义子类中的行为。</p><ul><li>基类定义保护的方法供给子类调用</li><li>基类可能会与许多不同游戏系统耦合，而子类不会</li></ul><p>注：它去掉了继承类的耦合，但这是通过把耦合聚集到基类自身来实现的。（基类可能会变得更大且越难以维护）<br>适用情景：</p><ul><li>有一个带有大量子类的基类</li><li>基类能够提供所有子类可能需要执行的操作集合</li><li>在子类之间有重叠代码，使它们之间更简便共享代码</li><li>希望使这些继承类与其它代码之间耦合最小化</li></ul><h2 id="类型对象"><a class="anchor" href="#类型对象">#</a> 类型对象</h2><p>通过创建一个类来支持新类型的灵活创建，其每个实例都代表一个不同的对象类型。<br>继承树实现 (is-a 关系)</p><ul><li>游戏中每只怪物实例都将属于某一种派生的怪物种族，种族越多继承树就越庞大</li></ul><p>包含 (has-a 种类) 实现</p><ul><li>每个怪物包含种族数据 (初始生命值、攻击等)</li></ul><p>『定义一个类型对象类和一个持有类型对象类，每个类型对象表示一个不同的逻辑类型。每个持有类型对象类的实例引用一个描述其类型的类型对象。』<br>使用情景：</p><ul><li>需要定义一系列不同『种类』的东西，又不想硬编码进类型系统</li><li>不知道将来会有什么类型</li><li>需要在不重新编译或修改代码的情况下，修改或添加新的类型</li></ul><p>注：在 C++ 内部，虚方法通过 虚函数表 (vtable) 实现，一个虚函数表是包含了函数指针集合的简单结构体，每个函数指针指向类里一个虚方法。每个类在内存驻存一张虚函数表。每个实例都有一个指向其类虚函数表的指针。当调用虚函数时，代码首先从对象虚函数表中查找，通过存储在表里的函数指针进行函数调用。<br>缺点</p><ul><li>通过类型对象去定义类型相关的数据非常容易，但是定义类型相关的行为却很难</li><li>解决方式：<ul><li>简单方式：是创建一个固定的预定义行为集合，让类型对象中数据从中任选其一</li><li>复杂方式：支持在数据中定义行为 (解释器模式或字节码模式)</li></ul></li></ul><p>通过继承共享数据</p><ul><li>没错，数据之间也可以通过继承共享</li><li>分为动态继承 (基类可能会动态变更) 或静态 (基类属性不变) 直接复制给子类</li></ul><p>类型对象应该封装还是暴露</p><ul><li>如果封装<ul><li>类型对象模式的复杂性对代码库其它部分不可见，成为持有类型对象才关心的实现细节</li><li>持有类型对象可以选择性重写类型对象的行为</li><li>需要给类型对象暴露的所有内容提供转发函数</li></ul></li><li>如果公开类型对象<ul><li>外部代码在没有持有类型对象类实例的情况下就能访问类型对象</li><li>类型对象现在是对象公共 API 的一部分</li></ul></li></ul><h1 id="解藕型模式"><a class="anchor" href="#解藕型模式">#</a> 解藕型模式</h1><p>我们几乎没有可能不去更改程序的功能或特性，而解藕能够让变化变得简单点。<br>某块代码中的变化通常不会影响到另一块代码</p><ul><li>组件将游戏中不同域相互解藕成单一实体</li><li>事件队列能够静态而且及时地将两个通信中的对象解藕开来</li><li>服务器定位器允许代码访问功能却不需要被绑定到提供服务的代码上</li></ul><h2 id="组件模式"><a class="anchor" href="#组件模式">#</a> 组件模式</h2><p>『允许一个单一的实体跨越多个不同域而不会导致耦合』</p><ul><li>软件设计的趋势是尽可能使用组合而不是继承</li><li>为实现两个类之间的代码共享，应该让它们拥有同一个类的实例而不是继承同一个类</li></ul><p>单一实体横跨了多个域，为保持域之间的相互隔离，每个域的代码都独立地放在自己的组件类中。实体本身则简化为这些组件的容器。<br>使用情景：</p><ul><li>有一个涉及多个域的类，但也能够用在别的地方</li><li>一个类越来越庞大、难以开发</li><li>希望定义许多共享不同能力的对象，但采用继承方式却无法精确重用代码</li></ul><p>注 1：组件模式相较直接在类中实现，引入了更多复杂性：每个概念上的对象成为一系列必须被同时实例化、初始化，并正确关联的集群。不同组件间通信也变得更具挑战性。<br>注 2：组件指针属于二级引用，在循环代码中可能导致更低性能</p><h3 id="组件之间传递信息"><a class="anchor" href="#组件之间传递信息">#</a> 组件之间传递信息</h3><ol><li>通过修改容器对象的状态 (状态共享)<ul><li>使组件间可以保持解藕</li><li>要求组件间任何需要共享的数据都由容器对象进行共享</li><li>使得信息传递变得隐秘，同时对组件执行的顺序产生依赖</li></ul></li><li>直接相互引用 (组件之间会有耦合)</li><li>通过传递信息的方式 (最复杂)</li></ol><h2 id="事件队列"><a class="anchor" href="#事件队列">#</a> 事件队列</h2><p>『对消息或事件的发送与受理进行时间上的解藕』<br>事件队列是一个按照先进先出顺序存储一系列通知或请求的队列。请求可由处理直接处理或转交给对其感兴趣模块，使消息的处理变得动态且非实时。</p><ul><li>在很多方面，可以看作是观察者模式的异步版本</li></ul><p>使用情景：</p><ul><li>相比观察者模式的直接 『派发 - 处理』模式，队列提供给拉取请求的代码块一些控制权：接收者可以延迟处理，聚合请求或完全废弃它们</li><li>使得队列在发送端需要实时反馈时显得不适用</li><li>如播放音效：解藕播放与受理，并避免两个同类音效同时叠加播放</li></ul><p>注 1：队列事件视图比同步系统中的事件具有更重量级的数据结构：后者只需通知然后接收者可以通过检查系统环境获知，而队列则需要在事件发生时记录以便稍后处理消息时使用。<br>注 2：当消息系统是同步时，注意可能导致消息循环的情景，如避免在处理事件端代码中发送事件。</p><h3 id="环形缓冲区"><a class="anchor" href="#环形缓冲区">#</a> 环形缓冲区</h3><h3 id="设计决策-2"><a class="anchor" href="#设计决策-2">#</a> 设计决策</h3><p>入队的是什么</p><ul><li>事件：就有点类似异步观察者模式</li><li>消息：一个『消息』或『请求』描述一种期望发生在『将来』的行为，或者可以认为是一种异步 API 服务</li></ul><p>读取者</p><ul><li>单播队列：当一个队列是一个类 API 本身的一部分时</li><li>广播队列：类似事件系统</li><li>工作队列：可以有多个处理者，不过队列中一项只能投递给一个处理者</li></ul><p>写入者</p><ul><li>一个写入者：类似同步观察者模式<ul><li>隐式知道事件来源</li><li>通常允许多个读取者</li></ul></li><li>多个写入者：类似『全局』或『中央』事件总线工作原理</li></ul><p>同步消息提醒模式下，调用执行只有在所有接收者都处理完消息后才会返回到发送者。</p><h2 id="服务定位器"><a class="anchor" href="#服务定位器">#</a> 服务定位器</h2><p>『为某服务提供一个全局访问入口来避免使用者与该服务具体实现类之间产生耦合』</p><ul><li>一个服务类为一系列操作定义了一个抽象接口</li><li>一个具体的服务提供器实现这个接口</li><li>一个单独的服务定位器通过查找一个合适的提供器来提供这个服务的访问，同时屏蔽了提供器的具体类型和定位这个服务的过程</li><li>注：由于使用接口抽象，因此可以方便地使用装饰器模式额外为服务提供器附加额外功能</li></ul><p>注：注意处理服务不能被定位器使用时的处理</p><h1 id="优化型模式"><a class="anchor" href="#优化型模式">#</a> 优化型模式</h1><h2 id="数据局部性"><a class="anchor" href="#数据局部性">#</a> 数据局部性</h2><p>『通过合理组织数据利用 CPU 的缓存机制来加快内存访问速度』<br>我们能更快地处理数据，但不能更快地获取数据</p><ul><li>CPU 进行运算时需要从主存取出数据并置入寄存器</li><li>RAM 的存取速度远远跟不上 CPU 的速度，甚至从未接近</li></ul><p>数据获取 (缓存)</p><ul><li>利用数据的时空局部性，获取数据时同时缓存数据及相关数据。</li></ul><p>数据即性能</p><ul><li>缓存失效与面向数据局部性的代码，性能相差可能几十倍，由于缓存机制，组织数据的方式会直接影响性能 (包括代码也是在内存中，需要载入 CPU 执行)</li><li>缓存行：优化的目标在于尽量将数据结构组织，使其在内存中两两相邻</li></ul><p>使用情景</p><ul><li>找到出现性能热点的地方</li><li>不需要在不常执行之处：结果会更加复杂笨拙</li></ul><p>使用须知</p><ul><li>抽象化意味着要通过指针或引用访问对象，导致在内存中来回跳转，引发缓存未命中的现象</li><li>越是在数据局部性上下功夫，就越要牺牲继承、接口及这些手段带来的好处</li></ul><p>CPU 流水线</p><ul><li>免分支预测，导致 CPU 预测失准和流水线停顿<ul><li>现代 CPU 单条指令需要多个时钟周期来完成，为了让 CPU 保持忙碌，因此引入流水线以便多条指令并行执行</li></ul></li><li>流水线模式：CPU 猜测哪些指令接下来会被执行，顺序结构很简单，控制流结构很麻烦，需要分支猜测：分析前面代码走向，预测下一次代码执行流（因此出现控制流代码会降低面向数据设计的性能，因此关键代码最好避开控制流）</li></ul><p>冷 / 热代码分解</p><ul><li>每帧需要检查和修改的变量 (如位置)</li><li>非每帧需要用到的处理意外情况的变量 (如怪物掉落数据)</li></ul><h3 id="设计决策-3"><a class="anchor" href="#设计决策-3">#</a> 设计决策</h3><ul><li>避开继承<ul><li>或者至少在进行缓存优化之处避开</li></ul></li><li>为不同的对象类型使用相互独立的数组</li></ul><p>游戏实体的定义 (主要指配合组件模式)</p><ul><li>假如游戏实体通过类中的指针索引其组件<ul><li>可以将组件存于相邻数组中，游戏实体并不关心组件存储，这样组织可以对迭代过程进行优化</li><li>对于给定实体，很容易通过其指针获取对应组件</li><li>在内存中移动组件较困难：启用禁用组件，对其移动 (排序) 时，可能一不小心就破坏了指针关联，必须确保对实体相应指针进行更新</li></ul></li><li>假如游戏实体通过一系列 ID 进行索引更新<ul><li>更加复杂 (相比指针)</li><li>速度更慢：不大可能比遍历原始指针更快，通过 ID 获取组件可能也涉及到哈希查找问题</li><li>需要访问组件管理器：存储组件数组的管理类来提供 ID 获取组件的对应接口</li></ul></li><li>假如游戏实体本身就只是个 ID<ul><li>若将游戏实体所有行为和状态都从主类移动到组件中，游戏实体唯一要做的就是将自己与其组件绑定</li><li>实体类变得很小，只是个数值包装</li><li>实体类本身为空</li><li>无需管理其生命周期 (现在实体只是某些内置类型的值)</li><li>检索一个实体的所有组件会很慢：与前一个方案问题类似，为某个实体寻找对应组件需要进行 ID 映射带来开销 (或者将实体 ID 对应为其组件所在数组索引，但这样所有组件必须保持平行，导致不能排序)</li></ul></li></ul><h2 id="脏标记模式"><a class="anchor" href="#脏标记模式">#</a> 脏标记模式</h2><p>『将工作推迟到必要时进行以避免不必要的工作』<br>一组原始数据随时间变化，一组衍生数据经过一些代价昂贵的操作由这些数据确定。一个脏标记跟踪这个衍生数据是否和原始数据同步，它在原始数据改变时被设置。如果它被设置，那么当需要衍生数据时，它们就会被重新计算并清除标记，否则仅使用缓存数据。<br>使用情景</p><ul><li>这个模式解决一个相当特定的问题</li><li>仅当性能问题严重到值得增加代码复杂度时才使用</li></ul><p>其它要求</p><ul><li>原始数据修改次数比衍生数据的使用次数多</li><li>递增更新数据十分困难<ul><li>例如在容器里放东西，更新容器总量，每当增加或减少时重新统计 —— 这样还不如使用动态总重量：增加或减少物品时直接在总量上进行操作（例如属性系统）</li></ul></li></ul><p>注意</p><ul><li>延时太长会有代价<ul><li>这个模式将某些耗时工作推迟到真正需要时才执行</li><li>而真正需要时，往往刻不容缓</li></ul></li><li>必须保证每次状态改动时都设置脏标记</li><li>必须在内存中保存上次的衍生数据</li></ul><h2 id="对象池"><a class="anchor" href="#对象池">#</a> 对象池</h2><p>内存碎片化</p><ul><li>如同乱停的车和规矩停放的车，可停数量差异一样。</li><li>即使碎片化情况很少，它也依然在削减着堆内存并使其成为一个千疮百孔而不可用的泡沫块。</li></ul><p>使用情景</p><ul><li>需要频繁创建和销毁对象</li><li>对象的大小一致</li><li>在堆上进行对象内存分配较慢或会产生内存碎片时</li><li>每个对象封装着获取代价昂贵且可重用的资源</li></ul><p>注意</p><ul><li>每个对象的内存大小是固定的 (应当是一个类型)</li><li>重用对象不会被自动清理 (若没有适当重设，可能保留上一次的数据)</li><li>未使用的对象将占用内存 (并会阻碍垃圾回收释放它指向的对象)</li></ul><p>空闲表</p><ul><li>O (1) 的时间复杂度</li><li>一个头指针，依次指向形成链表</li><li>使用时取出当前头指针，并重置当前头指针为其指向的下一个空闲对象</li><li>回收时将回收对象指向当前头指针，然后重置当前头指针为回收对象</li></ul><h2 id="空间分区"><a class="anchor" href="#空间分区">#</a> 空间分区</h2><p>『将对象存储在根据位置组织的数据结构中来高效地定位它们。』<br>基本要求是有一组对象，每个对象都具备某种位置信息。</p><ul><li>普通 (方格) 空间分区</li><li>四叉树 (二维)</li><li>八叉树 (三维)</li></ul><div class="tags"><a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 笔记</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-10-06 12:02:54" itemprop="dateModified" datetime="2023-10-06T12:02:54+08:00">2023-10-06</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>WangJiaYing <i class="ic i-at"><em>@</em></i>CWHISME</li><li class="link"><strong>本文链接：</strong> <a href="https://wangjiaying.top/2023/09/25/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-%E7%AC%94%E8%AE%B0/" title="《游戏编程模式》- 笔记">https://wangjiaying.top/2023/09/25/游戏编程模式-笔记/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/09/18/%E8%99%9A%E5%B9%BB5%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-C/" itemprop="url" rel="prev" data-background-image="&#x2F;images&#x2F;coverimages&#x2F;large&#x2F;006ZFECEgy1fr1x6dgae1j315o0xrtv9.webp" title="虚幻5基础学习笔记-详细(C++)"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>虚幻5基础学习笔记-详细(C++)</h3></a></div><div class="item right"><a href="/2023/10/02/CPP_Primer_%E7%AC%AC%E4%BA%94%E7%89%88_%E7%AC%94%E8%AE%B0-1/" itemprop="url" rel="next" data-background-image="&#x2F;blogimages&#x2F;2023&#x2F;2023-10-02&#x2F;book.webp" title="《C++ Primer(第五版)》-笔记(1)"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> C++</span><h3>《C++ Primer(第五版)》-笔记(1)</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84-%E6%80%A7%E8%83%BD%E5%92%8C%E6%B8%B8%E6%88%8F"><span class="toc-number">3.</span> <span class="toc-text">架构、性能和游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%B1%82%E5%B9%B3%E8%A1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">寻求平衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%81%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">要点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%8D%E6%8E%A2%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">再探设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">命令模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">享元模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E4%B9%8B%E6%A0%91"><span class="toc-number">4.2.1.</span> <span class="toc-text">森林之树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">状态模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">4.6.1.</span> <span class="toc-text">有限状态机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">4.6.2.</span> <span class="toc-text">并发状态机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">4.6.3.</span> <span class="toc-text">层次状态机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">4.6.4.</span> <span class="toc-text">下推自动机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">序列型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="toc-number">5.1.</span> <span class="toc-text">双缓冲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.2.</span> <span class="toc-text">游戏循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">更新方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">行为型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">6.1.</span> <span class="toc-text">字节码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.1.</span> <span class="toc-text">解释器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%99%A8%E7%A0%81"><span class="toc-number">6.1.2.</span> <span class="toc-text">虚拟机器码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E6%9C%BA"><span class="toc-number">6.1.3.</span> <span class="toc-text">堆栈机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7"><span class="toc-number">6.1.4.</span> <span class="toc-text">语法转换工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%86%B3%E7%AD%96"><span class="toc-number">6.1.5.</span> <span class="toc-text">设计决策</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E6%B2%99%E7%9B%92"><span class="toc-number">6.2.</span> <span class="toc-text">子类沙盒</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.3.</span> <span class="toc-text">类型对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E8%97%95%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">解藕型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">组件模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF"><span class="toc-number">7.1.1.</span> <span class="toc-text">组件之间传递信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97"><span class="toc-number">7.2.</span> <span class="toc-text">事件队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">7.2.1.</span> <span class="toc-text">环形缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%86%B3%E7%AD%96-2"><span class="toc-number">7.2.2.</span> <span class="toc-text">设计决策</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8"><span class="toc-number">7.3.</span> <span class="toc-text">服务定位器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">优化型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-number">8.1.</span> <span class="toc-text">数据局部性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%86%B3%E7%AD%96-3"><span class="toc-number">8.1.1.</span> <span class="toc-text">设计决策</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%8F%E6%A0%87%E8%AE%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">脏标记模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="toc-number">8.3.</span> <span class="toc-text">对象池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E5%8C%BA"><span class="toc-number">8.4.</span> <span class="toc-text">空间分区</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8A/" rel="bookmark" title="《CLR VIR C#》笔记(上)">《CLR VIR C#》笔记(上)</a></li><li><a href="/2023/04/06/ClrVirCS%E7%AC%94%E8%AE%B0-%E4%B8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="bookmark" title="《CLR VIR C#》笔记(下)-多线程">《CLR VIR C#》笔记(下)-多线程</a></li><li><a href="/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B8%B8%E6%88%8F%E5%AE%8C%E7%BE%8E%E5%BC%80%E5%8F%91-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《设计模式与游戏完美开发》-笔记">《设计模式与游戏完美开发》-笔记</a></li><li><a href="/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《数据结构与算法之美》-笔记">《数据结构与算法之美》-笔记</a></li><li><a href="/2023/06/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8_1/" rel="bookmark" title="《.NET内存管理宝典》-笔记(1)">《.NET内存管理宝典》-笔记(1)</a></li><li><a href="/2023/06/26/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-2/" rel="bookmark" title="《.NET内存管理宝典》-笔记(2)">《.NET内存管理宝典》-笔记(2)</a></li><li><a href="/2023/07/12/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-3/" rel="bookmark" title="《.NET内存管理宝典》-笔记(3)">《.NET内存管理宝典》-笔记(3)</a></li><li><a href="/2023/07/19/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-4/" rel="bookmark" title="《.NET内存管理宝典》-笔记(4)">《.NET内存管理宝典》-笔记(4)</a></li><li><a href="/2023/08/04/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-5/" rel="bookmark" title="《.NET内存管理宝典》-笔记(5)">《.NET内存管理宝典》-笔记(5)</a></li><li><a href="/2023/08/21/NET%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9D%E5%85%B8-6-%E5%AE%8C/" rel="bookmark" title="《.NET内存管理宝典》-笔记(6)[完]">《.NET内存管理宝典》-笔记(6)[完]</a></li><li class="active"><a href="/2023/09/25/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-%E7%AC%94%E8%AE%B0/" rel="bookmark" title="《游戏编程模式》-笔记">《游戏编程模式》-笔记</a></li><li><a href="/2023/10/02/CPP_Primer_%E7%AC%AC%E4%BA%94%E7%89%88_%E7%AC%94%E8%AE%B0-1/" rel="bookmark" title="《C++ Primer(第五版)》-笔记(1)">《C++ Primer(第五版)》-笔记(1)</a></li><li><a href="/2023/10/22/CPP-Primer-%E7%AC%AC%E4%BA%94%E7%89%88-%E7%AC%94%E8%AE%B0-2/" rel="bookmark" title="《C++ Primer(第五版)》-笔记(2)">《C++ Primer(第五版)》-笔记(2)</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="WangJiaYing" data-src="/images/../img/avator"><p class="name" itemprop="name">CWHISME</p><div class="description" itemprop="description">己所不欲，勿施于人</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">126</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">23</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">34</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N3aGlzbWU=" title="https:&#x2F;&#x2F;github.com&#x2F;cwhisme"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9jd2hpc21lLTMzL3Bvc3Rz" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;cwhisme-33&#x2F;posts"><i class="ic i-zhihu"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmN3aGlzbWVAMTI2LmNvbQ==" title="mailto:cwhisme@126.com"><i class="ic i-envelope"></i></span> <a href="/atom.xml" title="&#x2F;atom.xml" class="item feedback"><i class="ic i-heart"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-clock"></i>统计</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/09/18/%E8%99%9A%E5%B9%BB5%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-C/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/10/02/CPP_Primer_%E7%AC%AC%E4%BA%94%E7%89%88_%E7%AC%94%E8%AE%B0-1/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8D%9A%E5%AE%A2/" title="分类于 博客">博客</a></div><span><a href="/2022/12/23/%E4%BF%AE%E5%A4%8DShoka%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E9%97%AE%E9%A2%98/" title="修复 Shoka 主题的一点小问题">修复 Shoka 主题的一点小问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%90%86%E8%AE%BA%E7%A0%94%E7%A9%B6/" title="分类于 理论研究">理论研究</a></div><span><a href="/2021/03/09/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%AF%86/" title="网络协议加密">网络协议加密</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Unity3D/" title="分类于 Unity3D">Unity3D</a> <i class="ic i-angle-right"></i> <a href="/categories/Unity3D/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" title="分类于 图形学">图形学</a></div><span><a href="/2016/12/15/Tri-planar-Terrain-%E4%BA%8C-%E9%94%99%E8%AF%AF%E4%BF%AE%E6%AD%A3/" title="Tri-planar Terrain (二) 错误修正">Tri-planar Terrain (二) 错误修正</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment count_3"></ul></div></div><div class="status"><div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">WangJiaYing @ Jiaying's Note</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">743k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">11:15</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NXSElTTUUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/09/25/游戏编程模式-笔记/",favicon:{show:"（●´3｀●）",hide:"(´Д｀)"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,justifiedGallery:!0,jquery:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script><script src="https://cdn.staticfile.org/pjax/0.2.8/pjax.min.js"></script><script src="https://cdn.staticfile.net/animejs/3.2.2/anime.min.js"></script><script src="https://cdn.staticfile.org/algoliasearch/4.17.0/algoliasearch-lite.umd.js"></script><script src="https://cdn.staticfile.org/instantsearch.js/4.54.1/instantsearch.production.min.js"></script><script src="https://cdn.staticfile.org/lozad.js/1.16.0/lozad.min.js"></script><script src="https://cdn.staticfile.org/quicklink/2.3.0/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/js/DateTimeAfeterCalc.js" async></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js" async></script></body></html>