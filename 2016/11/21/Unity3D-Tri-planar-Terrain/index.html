<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="WangJiaYing" href="https://cwhisme.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="WangJiaYing" href="https://cwhisme.github.io/atom.xml"><link rel="alternate" type="application/json" title="WangJiaYing" href="https://cwhisme.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Unity3D,Shader"><link rel="canonical" href="https://cwhisme.github.io/2016/11/21/Unity3D-Tri-planar-Terrain/"><title>Unity3D Tri-planar Terrain - Shader - Unity3D | Jiaying's Note = WangJiaYing = 人不能没有梦想，也要有足够的敬畏</title><meta name="generator" content="Hexo 5.4.2"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Unity3D Tri-planar Terrain</h1><div class="meta"><span class="item" title="创建时间：2016-11-21 19:22:05"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2016-11-21T19:22:05+08:00">2016-11-21</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>19k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>17 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Jiaying's Note</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeudstjqj20zk0m8k3r.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/9bd9b167gy1g2qk3q3oboj21hc0u0k4b.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclhpw3lwj20zk0m8gvw.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicljitigmj20zk0m87fp.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclfw2t96j20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicitspjpbj20zk0m81ky.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Unity3D/" itemprop="item" rel="index" title="分类于 Unity3D"><span itemprop="name">Unity3D</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Unity3D/Shader/" itemprop="item" rel="index" title="分类于 Shader"><span itemprop="name">Shader</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://cwhisme.github.io/2016/11/21/Unity3D-Tri-planar-Terrain/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/../img/avator"><meta itemprop="name" content="CWHISME"><meta itemprop="description" content="人不能没有梦想，也要有足够的敬畏, ✧⁺˚⁺ପ(๑･ω･)੭ु⁾⁾ 好好学习天天向上"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="WangJiaYing"></span><div class="body md" itemprop="articleBody"><h2 id="前言"><a class="anchor" href="#前言">#</a> 前言</h2><p>Triplanar mapping 是一种三维贴图方式，分别计算 Z、Y、Z 三个方向的贴图贡献，然后混合。因此它相比一般的二维 UV 贴图方式，最大的好处大概就是：可以避免贴图拉伸。</p><p>而我也是基于这个好处，才想研究下它的。</p><p>对这个技术，在 Unity3D 官方文档上，有过一段提及，链接地址：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9TTC1WZXJ0ZXhGcmFnbWVudFNoYWRlckV4YW1wbGVzLmh0bWw=">https://docs.unity3d.com/Manual/SL-VertexFragmentShaderExamples.html</span></p><p>另外还有一个参考地址，比官方的说明可详细多了：<br><span class="exturl" data-url="aHR0cDovL3d3dy5tYXJ0aW5wYWxrby5jb20vdHJpcGxhbmFyLW1hcHBpbmc=">http://www.martinpalko.com/triplanar-mapping</span></p><p>当然示例主要是对模型，而对于地形来说，就不可能这样简单实现了，我也在网络上找过，相关中文资料基本上没有...... 英文资料... 就不多说了。而对于 Unity3D Terrain 相关的 Triplanar 资料，很抱歉，似乎根本就没有（当然，插件好像还是存在的）。</p><p>于是把官方的 Buildin Shader Download 下来，决定自己结合对于单独 Object 的资料进行处理下，建立一个适用于地形的 Triplanar Shader.</p><h2 id="原理"><a class="anchor" href="#原理">#</a> 原理</h2><p>更深层次的原理我也就没研究了，简单说下实现原理吧。<br>对于普通 Object 的实现，主要大概分为五步：<br>1. 取世界坐标 xy、xz、yz 作为三个轴向的 UV<br>2. 对 UV 通过 UVScale，或者说 TextureScale 进行缩放<br>3. 使用三个 UV 分别对贴图进行采样，计算出三个方向单独贴图采样<br>4. 计算法线方向，并对法线进行处理 (法线后面扮演了一个权重调整的角色，很重要)<br>5. 使用三个 UV 方向计算出来贴分别相乘法线的 X、Y、Z 并相加，取得最后的采样值，作为最终颜色</p><p>如果有法线的话，需要照此步骤依次对法线做同样的处理。</p><h2 id="实现"><a class="anchor" href="#实现">#</a> 实现</h2><p>OK, 现在轮到实现上来了。<br>首先，可以打开下载下来的 Buildin 地形 shader 看一下，主要大约就是 Standard-FirstPass.shader 了。</p><p>考虑到查看方便性问题.... 我决定还是贴一下代码：</p><pre><code class="language-cg">Shader &quot;Nature/Terrain/Standard&quot; &#123;
	Properties &#123;
		// set by terrain engine
		[HideInInspector] _Control (&quot;Control (RGBA)&quot;, 2D) = &quot;red&quot; &#123;&#125;
		[HideInInspector] _Splat3 (&quot;Layer 3 (A)&quot;, 2D) = &quot;white&quot; &#123;&#125;
		[HideInInspector] _Splat2 (&quot;Layer 2 (B)&quot;, 2D) = &quot;white&quot; &#123;&#125;
		[HideInInspector] _Splat1 (&quot;Layer 1 (G)&quot;, 2D) = &quot;white&quot; &#123;&#125;
		[HideInInspector] _Splat0 (&quot;Layer 0 (R)&quot;, 2D) = &quot;white&quot; &#123;&#125;
		[HideInInspector] _Normal3 (&quot;Normal 3 (A)&quot;, 2D) = &quot;bump&quot; &#123;&#125;
		[HideInInspector] _Normal2 (&quot;Normal 2 (B)&quot;, 2D) = &quot;bump&quot; &#123;&#125;
		[HideInInspector] _Normal1 (&quot;Normal 1 (G)&quot;, 2D) = &quot;bump&quot; &#123;&#125;
		[HideInInspector] _Normal0 (&quot;Normal 0 (R)&quot;, 2D) = &quot;bump&quot; &#123;&#125;
		[HideInInspector] [Gamma] _Metallic0 (&quot;Metallic 0&quot;, Range(0.0, 1.0)) = 0.0	
		[HideInInspector] [Gamma] _Metallic1 (&quot;Metallic 1&quot;, Range(0.0, 1.0)) = 0.0	
		[HideInInspector] [Gamma] _Metallic2 (&quot;Metallic 2&quot;, Range(0.0, 1.0)) = 0.0	
		[HideInInspector] [Gamma] _Metallic3 (&quot;Metallic 3&quot;, Range(0.0, 1.0)) = 0.0
		[HideInInspector] _Smoothness0 (&quot;Smoothness 0&quot;, Range(0.0, 1.0)) = 1.0	
		[HideInInspector] _Smoothness1 (&quot;Smoothness 1&quot;, Range(0.0, 1.0)) = 1.0	
		[HideInInspector] _Smoothness2 (&quot;Smoothness 2&quot;, Range(0.0, 1.0)) = 1.0	
		[HideInInspector] _Smoothness3 (&quot;Smoothness 3&quot;, Range(0.0, 1.0)) = 1.0

		// used in fallback on old cards &amp; base map
		[HideInInspector] _MainTex (&quot;BaseMap (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;
		[HideInInspector] _Color (&quot;Main Color&quot;, Color) = (1,1,1,1)
	&#125;

	SubShader &#123;
		Tags &#123;
			&quot;Queue&quot; = &quot;Geometry-100&quot;
			&quot;RenderType&quot; = &quot;Opaque&quot;
		&#125;

		CGPROGRAM
		#pragma surface surf Standard vertex:SplatmapVert finalcolor:SplatmapFinalColor finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
		#pragma multi_compile_fog
		#pragma target 3.0
		// needs more than 8 texcoords
		#pragma exclude_renderers gles
		#include &quot;UnityPBSLighting.cginc&quot;

		#pragma multi_compile __ _TERRAIN_NORMAL_MAP

		#define TERRAIN_STANDARD_SHADER
		#define TERRAIN_SURFACE_OUTPUT SurfaceOutputStandard
		#include &quot;TerrainSplatmapCommon.cginc&quot;

		half _Metallic0;
		half _Metallic1;
		half _Metallic2;
		half _Metallic3;
		
		half _Smoothness0;
		half _Smoothness1;
		half _Smoothness2;
		half _Smoothness3;

		void surf (Input IN, inout SurfaceOutputStandard o) &#123;
			half4 splat_control;
			half weight;
			fixed4 mixedDiffuse;
			half4 defaultSmoothness = half4(_Smoothness0, _Smoothness1, _Smoothness2, _Smoothness3);
			SplatmapMix(IN, defaultSmoothness, splat_control, weight, mixedDiffuse, o.Normal);
			o.Albedo = mixedDiffuse.rgb;
			o.Alpha = weight;
			o.Smoothness = mixedDiffuse.a;
			o.Metallic = dot(splat_control, half4(_Metallic0, _Metallic1, _Metallic2, _Metallic3));
		&#125;
		ENDCG
	&#125;

	Dependency &quot;AddPassShader&quot; = &quot;Hidden/TerrainEngine/Splatmap/Standard-AddPass&quot;
	Dependency &quot;BaseMapShader&quot; = &quot;Hidden/TerrainEngine/Splatmap/Standard-Base&quot;

	Fallback &quot;Nature/Terrain/Diffuse&quot;
&#125;

</code></pre><p>初一看，大概会觉得地形 shader “也不过如此”，参数很多，实现很少 —— 那就错了！<br>因为它引用到了 Unity 内置头文件 “TerrainSplatmapCommon.cginc”，好些个实现方法，都在那里面的。而影响地形最主要的一个，就是 “SplatmapMix” 方法，该方法，可以打开头文件 “TerrainSplatmapCommon.cginc” 进行查看。<br>而且，因为本身计算贴图就是这儿，所以我们需要修改的，也是这一块儿。</p><p>那么，稍微查看一下：</p><pre><code class="language-cg">#ifdef TERRAIN_STANDARD_SHADER
void SplatmapMix(Input IN, half4 defaultAlpha, out half4 splat_control, out half weight, out fixed4 mixedDiffuse, inout fixed3 mixedNormal)
#else
void SplatmapMix(Input IN, out half4 splat_control, out half weight, out fixed4 mixedDiffuse, inout fixed3 mixedNormal)
#endif
&#123;
	splat_control = tex2D(_Control, IN.tc_Control);
	weight = dot(splat_control, half4(1,1,1,1));

	#if !defined(SHADER_API_MOBILE) &amp;&amp; defined(TERRAIN_SPLAT_ADDPASS)
		clip(weight == 0.0f ? -1 : 1);
	#endif

	// Normalize weights before lighting and restore weights in final modifier functions so that the overal
	// lighting result can be correctly weighted.
	splat_control /= (weight + 1e-3f);

	mixedDiffuse = 0.0f;
	#ifdef TERRAIN_STANDARD_SHADER
		mixedDiffuse += splat_control.r * tex2D(_Splat0, IN.uv_Splat0) * half4(1.0, 1.0, 1.0, defaultAlpha.r);
		mixedDiffuse += splat_control.g * tex2D(_Splat1, IN.uv_Splat1) * half4(1.0, 1.0, 1.0, defaultAlpha.g);
		mixedDiffuse += splat_control.b * tex2D(_Splat2, IN.uv_Splat2) * half4(1.0, 1.0, 1.0, defaultAlpha.b);
		mixedDiffuse += splat_control.a * tex2D(_Splat3, IN.uv_Splat3) * half4(1.0, 1.0, 1.0, defaultAlpha.a);
	#else
		mixedDiffuse += splat_control.r * tex2D(_Splat0, IN.uv_Splat0);
		mixedDiffuse += splat_control.g * tex2D(_Splat1, IN.uv_Splat1);
		mixedDiffuse += splat_control.b * tex2D(_Splat2, IN.uv_Splat2);
		mixedDiffuse += splat_control.a * tex2D(_Splat3, IN.uv_Splat3);
	#endif

	#ifdef _TERRAIN_NORMAL_MAP
		fixed4 nrm = 0.0f;
		nrm += splat_control.r * tex2D(_Normal0, IN.uv_Splat0);
		nrm += splat_control.g * tex2D(_Normal1, IN.uv_Splat1);
		nrm += splat_control.b * tex2D(_Normal2, IN.uv_Splat2);
		nrm += splat_control.a * tex2D(_Normal3, IN.uv_Splat3);
		mixedNormal = UnpackNormal(nrm);
	#endif
&#125;
</code></pre><p>唔... 看起来信息量略大啊。</p><p>实际上，功能也就是计算四个通道的 Diffuse 贴图和法线贴图而已，只是因为有四个通道分别对应控制贴图的 R、G、B、A，所以看起来才一大团，理解就好。<br>而且，后面加入了对 triplanar 的计算之后....... 还得翻一番。</p><p>然后是顶点计算：</p><pre><code class="language-cg">void SplatmapVert(inout appdata_full v, out Input data)
&#123;
	UNITY_INITIALIZE_OUTPUT(Input, data);
	data.tc_Control = TRANSFORM_TEX(v.texcoord, _Control);	// Need to manually transform uv here, as we choose not to use 'uv' prefix for this texcoord.
	float4 pos = UnityObjectToClipPos(v.vertex);
	UNITY_TRANSFER_FOG(data, pos);

#ifdef _TERRAIN_NORMAL_MAP
	v.tangent.xyz = cross(v.normal, float3(0,0,1));
	v.tangent.w = -1;
#endif
&#125;
</code></pre><p>内置的地形 Shader 暂时就看到这里，那么在修改之前，首先，我们需要确定一件事儿：相对于默认地形 Shader，如果想把它修改成 triplanar, 差了哪些参数？</p><p>答：worldPos (世界坐标)、worldNormal (世界空间法线)</p><p>这两个参数都是从 Vertex 片段程序中计算，而看看上面那段 SplatmapVert 程序，明显没有计算 —— 因为一般使用也用不上。<br>既然如此，我们就得自食其力了。</p><p>将 CGPROGRAM 下一行的 #pragma 修改如下：</p><pre><code class="language-cg">#pragma surface surf Standard vertex:vert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
</code></pre><p>然后新建一个我们自己的 Input Struct，用于将参数从顶点程序传入片段..... 噢，对于 Unity3D 的 Surface Shader，应该叫做 “surf” 处理程序 (嘛... 实际上就是被 Unity 自动嵌入片段程序中的一个方法而已)。</p><pre><code class="language-cg">		struct Input
		&#123;
			float2 tc_Control : TEXCOORD4;
			float3 wNormal;
			float3 worldPos;
			UNITY_FOG_COORDS(5)
		&#125;;
</code></pre><p>因为只需要这么几个参数，使用 Triplanar 计算的地形是不需要贴图 UV 的，所以就这样了。</p><p>OK！然后是我们自己的顶点计算程序：</p><pre><code class="language-cg">		void vert(inout appdata_full v, out Input o)
		&#123;
			UNITY_INITIALIZE_OUTPUT(Input, o);
			o.tc_Control = TRANSFORM_TEX(v.texcoord, _Control);
			float4 pos = mul(UNITY_MATRIX_MVP, v.vertex);
			UNITY_TRANSFER_FOG(o, pos);

			o.wNormal =normalize(mul(_Object2World, fixed4(v.normal, 0)).xyz);

			#ifdef _TERRAIN_NORMAL_MAP
			v.tangent.xyz = cross(v.normal, float3(0, 0, 1));
			v.tangent.w = -1;
			#endif
		&#125;
</code></pre><p><font color="red"><b>在这儿，一定、必定以及肯定：要注意一件事儿：UNITY_INITIALIZE_OUTPUT (Input, o)</b></font></p><p>这个 Unity 内置的宏将会初始化 Input 结构体中的变量，但是它是根据 “名字” 来的！所以，千万得跟内置的名字一样才行！比如说 “worldPos”，就一定得叫这个名字才行 —— 刚开始我就取名叫 “wPos”，结果坑的我一脸。最后浪费了好大一段时间，调试最终结果不正确的问题！<br>但是这个宏的实际定义方法，我却没在 Unity 的头文件中找到，若有人翻到了，希望提醒一声！</p><p>接下来，我们就可以在 Surf 方法中，具体处理了。</p><p>然后，稍微把 TerrainSplatmapCommon.cginc 中的 SplatmapMix 移过来一点:</p><pre><code class="language-cg">			splat_control = tex2D(_Control, IN.tc_Control);
			weight = dot(splat_control, half4(1, 1, 1, 1));
			splat_control /= (weight + 1e-3f);
</code></pre><p>按照上述几个步骤进进行处理：</p><pre><code class="language-cg">			//triplanar---------------&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
			//计算权重
			float3 N =normalize( IN.wNormal);
			half3 blendWeights = pow(abs(IN.wNormal), _TriplanarBlendSharpness);
			blendWeights /= dot(blendWeights, 1.0);
			half2 xUV = IN.worldPos.zy;// / _TextureScale;
			half2 yUV = IN.worldPos.xz;// / _TextureScale;
			half2 zUV = IN.worldPos.xy;// / _TextureScale;

			//通常 Triplanar实现，只是多了三张贴图处理
			fixed4 tex0X =  tex2D(_Splat0, (xUV*_Splat0_ST.xy + _Splat0_ST.zw)/ _TextureScale);
			fixed4 tex0Y = tex2D(_Splat0, (yUV*_Splat0_ST.xy + _Splat0_ST.zw) / _TextureScale);
			fixed4 tex0Z = tex2D(_Splat0, (zUV*_Splat0_ST.xy + _Splat0_ST.zw) / _TextureScale);

			fixed4 tex1X = tex2D(_Splat1, (xUV*_Splat1_ST.xy + _Splat1_ST.zw) / _TextureScale);
			fixed4 tex1Y = tex2D(_Splat1, (yUV*_Splat1_ST.xy + _Splat1_ST.zw) / _TextureScale);
			fixed4 tex1Z =  tex2D(_Splat1, (zUV*_Splat1_ST.xy + _Splat1_ST.zw) / _TextureScale);

			fixed4 tex2X = tex2D(_Splat2, (xUV*_Splat2_ST.xy + _Splat2_ST.zw)/ _TextureScale);
			fixed4 tex2Y = tex2D(_Splat2, (yUV*_Splat2_ST.xy + _Splat2_ST.zw)/ _TextureScale);
			fixed4 tex2Z = tex2D(_Splat2, (zUV*_Splat2_ST.xy + _Splat2_ST.zw)/ _TextureScale);

			fixed4 tex3X = tex2D(_Splat3, (xUV*_Splat3_ST.xy + _Splat3_ST.zw)/ _TextureScale);
			fixed4 tex3Y = tex2D(_Splat3, (yUV*_Splat3_ST.xy + _Splat3_ST.zw)/ _TextureScale);
			fixed4 tex3Z = tex2D(_Splat3, (zUV*_Splat3_ST.xy + _Splat3_ST.zw)/ _TextureScale);

			fixed4 tex0 = tex0X*blendWeights.x + tex0Y * blendWeights.y + tex0Z * blendWeights.z;
			fixed4 tex1 =  tex1X*blendWeights.x + tex1Y * blendWeights.y + tex1Z * blendWeights.z;
			fixed4 tex2 = tex2X*blendWeights.x + tex2Y * blendWeights.y + tex2Z * blendWeights.z;
			fixed4 tex3 = tex3X*blendWeights.x + tex3Y * blendWeights.y + tex3Z * blendWeights.z;

			//融合权重，添加高光
			tex0 *= splat_control.r *half4(1.0, 1.0, 1.0, defaultSmoothness.r);
			tex1 *= splat_control.g *half4(1.0, 1.0, 1.0, defaultSmoothness.g);
			tex2 *= splat_control.b *half4(1.0, 1.0, 1.0, defaultSmoothness.b);
			tex3 *= splat_control.a *half4(1.0, 1.0, 1.0, defaultSmoothness.a);

			mixedDiffuse = tex0 + tex1 + tex2 + tex3;
</code></pre><p>Diffuse 颜色就是这样处理了，法线贴图与此一致，就不在这儿贴出来浪费空间了。</p><p>如果注意到对 Splat_ST 的计算，这个跟 TRANSFORM_TEX 宏的功能差不多，如果有兴趣，也可以在 UnityCG.cginc 头文件找到，主要就是重新计算被修改了缩放大小的贴图：</p><pre><code class="language-cg">// Transforms 2D UV by scale/bias property
#define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)
</code></pre><h2 id="效果"><a class="anchor" href="#效果">#</a> 效果</h2><p><img data-src="/blogimages/oldpictures/2016.11.21-TriplanarCompare.png" alt="对比效果"></p><p>从图中可以非常明显地看出，Triplanar 技术对于贴图拉伸的补正作用。自带的地形 Shader 已经把贴图拉成线了，Triplanar 基本完全正常。</p><h2 id="总结"><a class="anchor" href="#总结">#</a> 总结</h2><p>OK，事情基本上到此为止了。</p><p>Triplanar 相对普通贴图方式，效果很大，但是还有一点需要注意：性能。</p><p>因为 Triplanar 会分别对每张贴图都采样三次，再加上其它计算的消耗，也就是是说它功能虽好，但是性能注定会比普通贴图方式更耗 —— 至少也是 2 倍吧。</p><p>所以，任何事情，都不是无偿的啊。</p><p>而我之所以研究这个，还是跟自己做的 Demo 有关，普通游戏也就罢了，如果处理好斜坡贴都和陡度的话，还是可以在一定程度上掩盖贴图拉伸问题的。不过我这次做的 Demo，因为想加入 “挖地形” 的功能，比如说挖矿什么真的可以挖个坑之类的。那这个问题就比较突出了 —— 如果一锄子下去，地形都 “花了”，那就.......... 所以，才需要这么个东西。</p><p>—— 嘛，我承认最近快要离开的项目也想用这技术，最后貌似是采用的一个插件了。</p><p>就是这样。</p><h2 id="源码"><a class="anchor" href="#源码">#</a> 源码</h2><p>源码.... 本来不想贴出来的，毕竟这么大一坨。但是断断续续会让看的人很困扰的吧？<br>所以，源码如下：</p><p>版本：2016.11.21</p><pre><code class="language-cg">// Upgrade NOTE: replaced '_Object2World' with 'unity_ObjectToWorld'

//2016.11.18 by cwhisme
//Note:在基于Unity Buildin Terrain Shader的基础上修改
//Unity 内置的地形shader可以在官方网站上进行下载
//加入了Triplanar计算，避免贴图拉伸问题

Shader &quot;CWHISME/TriplannarTerrain&quot;
&#123;
	Properties&#123;
		// set by terrain engine
		[HideInInspector] _Control(&quot;Control (RGBA)&quot;, 2D) = &quot;red&quot; &#123;&#125;
		[HideInInspector] _Splat3(&quot;Layer 3 (A)&quot;, 2D) = &quot;white&quot; &#123;&#125;
		[HideInInspector] _Splat2(&quot;Layer 2 (B)&quot;, 2D) = &quot;white&quot; &#123;&#125;
		[HideInInspector] _Splat1(&quot;Layer 1 (G)&quot;, 2D) = &quot;white&quot; &#123;&#125;
		[HideInInspector] _Splat0(&quot;Layer 0 (R)&quot;, 2D) = &quot;white&quot; &#123;&#125;
		[HideInInspector] _Normal3(&quot;Normal 3 (A)&quot;, 2D) = &quot;bump&quot; &#123;&#125;
		[HideInInspector] _Normal2(&quot;Normal 2 (B)&quot;, 2D) = &quot;bump&quot; &#123;&#125;
		[HideInInspector] _Normal1(&quot;Normal 1 (G)&quot;, 2D) = &quot;bump&quot; &#123;&#125;
		[HideInInspector] _Normal0(&quot;Normal 0 (R)&quot;, 2D) = &quot;bump&quot; &#123;&#125;
		[HideInInspector][Gamma] _Metallic0(&quot;Metallic 0&quot;, Range(0.0, 1.0)) = 0.0
		[HideInInspector][Gamma] _Metallic1(&quot;Metallic 1&quot;, Range(0.0, 1.0)) = 0.0
		[HideInInspector][Gamma] _Metallic2(&quot;Metallic 2&quot;, Range(0.0, 1.0)) = 0.0
		[HideInInspector][Gamma] _Metallic3(&quot;Metallic 3&quot;, Range(0.0, 1.0)) = 0.0
		[HideInInspector] _Smoothness0(&quot;Smoothness 0&quot;, Range(0.0, 1.0)) = 1.0
		[HideInInspector] _Smoothness1(&quot;Smoothness 1&quot;, Range(0.0, 1.0)) = 1.0
		[HideInInspector] _Smoothness2(&quot;Smoothness 2&quot;, Range(0.0, 1.0)) = 1.0
		[HideInInspector] _Smoothness3(&quot;Smoothness 3&quot;, Range(0.0, 1.0)) = 1.0

		// used in fallback on old cards &amp; base map
		[HideInInspector] _MainTex(&quot;BaseMap (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;
		[HideInInspector] _Color(&quot;Main Color&quot;, Color) = (1,1,1,1)

		_TextureScale(&quot;Texture Scale&quot;,float) = 100
		_TriplanarBlendSharpness(&quot;Triplanar Blend Sharpness&quot;,float) = 1
	&#125;

		SubShader&#123;
		Tags&#123;
			&quot;Queue&quot; = &quot;Geometry-100&quot;
			&quot;RenderType&quot; = &quot;Opaque&quot;
		&#125;

		CGPROGRAM
		#pragma surface surf Standard vertex:vert finalcolor:SplatmapFinalColor finalprepass:SplatmapFinalPrepass finalgbuffer:SplatmapFinalGBuffer fullforwardshadows
		#pragma multi_compile_fog
		#pragma target 3.0
		// needs more than 8 texcoords
		#pragma exclude_renderers gles
		#include &quot;UnityPBSLighting.cginc&quot;

		#pragma multi_compile __ _TERRAIN_NORMAL_MAP

		//#define TERRAIN_STANDARD_SHADER
		#define TERRAIN_SURFACE_OUTPUT SurfaceOutputStandard
		//#include &quot;TerrainSplatmapCommon.cginc&quot;

		sampler2D _Control;
		float4 _Control_ST;
		sampler2D _Splat0, _Splat1, _Splat2, _Splat3;
		half4 _Splat0_ST, _Splat1_ST, _Splat2_ST, _Splat3_ST;
		#ifdef _TERRAIN_NORMAL_MAP
		sampler2D _Normal0, _Normal1, _Normal2, _Normal3;
		#endif

		half _Metallic0;
		half _Metallic1;
		half _Metallic2;
		half _Metallic3;

		half _Smoothness0;
		half _Smoothness1;
		half _Smoothness2;
		half _Smoothness3;

		float _TriplanarBlendSharpness;
		float _TextureScale;

		struct Input
		&#123;
			float2 tc_Control : TEXCOORD4;
			float3 wNormal;
			float3 worldPos;
			UNITY_FOG_COORDS(5)
		&#125;;

		void vert(inout appdata_full v, out Input o)
		&#123;
			UNITY_INITIALIZE_OUTPUT(Input, o);
			o.tc_Control = TRANSFORM_TEX(v.texcoord, _Control);
			float4 pos = mul(UNITY_MATRIX_MVP, v.vertex);
			UNITY_TRANSFER_FOG(o, pos);

			o.wNormal =normalize(mul(unity_ObjectToWorld, fixed4(v.normal, 0)).xyz);

			#ifdef _TERRAIN_NORMAL_MAP
			v.tangent.xyz = cross(v.normal, float3(0, 0, 1));
			v.tangent.w = -1;
			#endif
		&#125;

		void surf(Input IN, inout SurfaceOutputStandard o) &#123;
			half4 splat_control;
			half weight;
			fixed4 mixedDiffuse=0;
			half4 defaultSmoothness = half4(_Smoothness0, _Smoothness1, _Smoothness2, _Smoothness3);
			//SplatmapMix(IN, defaultSmoothness, splat_control, weight, mixedDiffuse, o.Normal);

			//Custom begin=================================================&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
			splat_control = tex2D(_Control, IN.tc_Control);
			weight = dot(splat_control, half4(1, 1, 1, 1));
			splat_control /= (weight + 1e-3f);

			//triplanar---------------&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
			//计算权重
			float3 N =normalize( IN.wNormal);
			half3 blendWeights = pow(abs(IN.wNormal), _TriplanarBlendSharpness);
			blendWeights /= dot(blendWeights, 1.0);
			half2 xUV = IN.worldPos.zy;// / _TextureScale;
			half2 yUV = IN.worldPos.xz;// / _TextureScale;
			half2 zUV = IN.worldPos.xy;// / _TextureScale;

			//通常 Triplanar实现，只是多了三张贴图处理
			fixed4 tex0X =  tex2D(_Splat0, (xUV*_Splat0_ST.xy + _Splat0_ST.zw)/ _TextureScale);
			fixed4 tex0Y = tex2D(_Splat0, (yUV*_Splat0_ST.xy + _Splat0_ST.zw) / _TextureScale);
			fixed4 tex0Z = tex2D(_Splat0, (zUV*_Splat0_ST.xy + _Splat0_ST.zw) / _TextureScale);

			fixed4 tex1X = tex2D(_Splat1, (xUV*_Splat1_ST.xy + _Splat1_ST.zw) / _TextureScale);
			fixed4 tex1Y = tex2D(_Splat1, (yUV*_Splat1_ST.xy + _Splat1_ST.zw) / _TextureScale);
			fixed4 tex1Z =  tex2D(_Splat1, (zUV*_Splat1_ST.xy + _Splat1_ST.zw) / _TextureScale);

			fixed4 tex2X = tex2D(_Splat2, (xUV*_Splat2_ST.xy + _Splat2_ST.zw)/ _TextureScale);
			fixed4 tex2Y = tex2D(_Splat2, (yUV*_Splat2_ST.xy + _Splat2_ST.zw)/ _TextureScale);
			fixed4 tex2Z = tex2D(_Splat2, (zUV*_Splat2_ST.xy + _Splat2_ST.zw)/ _TextureScale);

			fixed4 tex3X = tex2D(_Splat3, (xUV*_Splat3_ST.xy + _Splat3_ST.zw)/ _TextureScale);
			fixed4 tex3Y = tex2D(_Splat3, (yUV*_Splat3_ST.xy + _Splat3_ST.zw)/ _TextureScale);
			fixed4 tex3Z = tex2D(_Splat3, (zUV*_Splat3_ST.xy + _Splat3_ST.zw)/ _TextureScale);

			fixed4 tex0 = tex0X*blendWeights.x + tex0Y * blendWeights.y + tex0Z * blendWeights.z;
			fixed4 tex1 =  tex1X*blendWeights.x + tex1Y * blendWeights.y + tex1Z * blendWeights.z;
			fixed4 tex2 = tex2X*blendWeights.x + tex2Y * blendWeights.y + tex2Z * blendWeights.z;
			fixed4 tex3 = tex3X*blendWeights.x + tex3Y * blendWeights.y + tex3Z * blendWeights.z;

			//融合权重，添加高光
			tex0 *= splat_control.r *half4(1.0, 1.0, 1.0, defaultSmoothness.r);
			tex1 *= splat_control.g *half4(1.0, 1.0, 1.0, defaultSmoothness.g);
			tex2 *= splat_control.b *half4(1.0, 1.0, 1.0, defaultSmoothness.b);
			tex3 *= splat_control.a *half4(1.0, 1.0, 1.0, defaultSmoothness.a);

			mixedDiffuse = tex0 + tex1 + tex2 + tex3;

			//mixedDiffuse += 
			//mixedDiffuse += splat_control.g * tex2D(_Splat1, IN.uv_Splat1) * half4(1.0, 1.0, 1.0, defaultSmoothness.g);
			//mixedDiffuse += splat_control.b * tex2D(_Splat2, IN.uv_Splat2) * half4(1.0, 1.0, 1.0, defaultSmoothness.b);
			//mixedDiffuse += splat_control.a * tex2D(_Splat3, IN.uv_Splat3) * half4(1.0, 1.0, 1.0, defaultSmoothness.a);

			//---------法线---------&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
			#ifdef _TERRAIN_NORMAL_MAP
			fixed4 nrm = 0.0f;

			fixed4 nm0X = tex2D(_Normal0, (xUV* _Splat0_ST.xy + _Splat0_ST.zw)/ _TextureScale);
			fixed4 nm0Y = tex2D(_Normal0, (yUV* _Splat0_ST.xy + _Splat0_ST.zw) / _TextureScale);
			fixed4 nm0Z = tex2D(_Normal0, (zUV* _Splat0_ST.xy + _Splat0_ST.zw) / _TextureScale);
											
			fixed4 nm1X = tex2D(_Normal1, (xUV* _Splat1_ST.xy + _Splat1_ST.zw) / _TextureScale);
			fixed4 nm1Y = tex2D(_Normal1, (yUV* _Splat1_ST.xy + _Splat1_ST.zw) / _TextureScale);
			fixed4 nm1Z = tex2D(_Normal1, (zUV* _Splat1_ST.xy + _Splat1_ST.zw) / _TextureScale);
													  
			fixed4 nm2X = tex2D(_Normal2, (xUV* _Splat2_ST.xy + _Splat2_ST.zw)/ _TextureScale);
			fixed4 nm2Y = tex2D(_Normal2, (yUV* _Splat2_ST.xy + _Splat2_ST.zw)/ _TextureScale);
			fixed4 nm2Z = tex2D(_Normal2, (zUV* _Splat2_ST.xy + _Splat2_ST.zw)/ _TextureScale);
						 								
			fixed4 nm3X = tex2D(_Normal3, (xUV* _Splat3_ST.xy + _Splat3_ST.zw)/ _TextureScale);
			fixed4 nm3Y = tex2D(_Normal3, (yUV* _Splat3_ST.xy + _Splat3_ST.zw)/ _TextureScale);
			fixed4 nm3Z = tex2D(_Normal3, (zUV* _Splat3_ST.xy + _Splat3_ST.zw)/ _TextureScale);

			fixed4 nm0 = nm0X*blendWeights.x +nm0Y * blendWeights.y + nm0Z * blendWeights.z;
			fixed4 nm1 =  nm1X*blendWeights.x + nm1Y * blendWeights.y + nm1Z * blendWeights.z;
			fixed4 nm2 = nm2X*blendWeights.x + nm2Y * blendWeights.y + nm2Z * blendWeights.z;
			fixed4 nm3 = nm3X*blendWeights.x + nm3Y * blendWeights.y + nm3Z * blendWeights.z;

			nm0 *= splat_control.r;
			nm1 *= splat_control.g;
			nm2 *= splat_control.b;
			nm3 *= splat_control.a;

			nrm = nm0 + nm1 + nm2 + nm3;
			//nrm += splat_control.r * tex2D(_Normal0, IN.uv_Splat0);
			//nrm += splat_control.g * tex2D(_Normal1, IN.uv_Splat1);
			//nrm += splat_control.b * tex2D(_Normal2, IN.uv_Splat2);
			//nrm += splat_control.a * tex2D(_Normal3, IN.uv_Splat3);
			o.Normal = UnpackNormal(nrm);
			#endif
			//End Custom=================================================&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

			o.Albedo = max(fixed3(0.001, 0.001, 0.001), mixedDiffuse.rgb); 
			o.Alpha = weight;
			o.Smoothness = mixedDiffuse.a;
			o.Metallic = dot(splat_control, half4(_Metallic0, _Metallic1, _Metallic2, _Metallic3));
		&#125;

		void SplatmapFinalColor(Input IN, TERRAIN_SURFACE_OUTPUT o, inout fixed4 color)
		&#123;
			color *= o.Alpha;
			#ifdef TERRAIN_SPLAT_ADDPASS
			UNITY_APPLY_FOG_COLOR(IN.fogCoord, color, fixed4(0, 0, 0, 0));
			#else
			UNITY_APPLY_FOG(IN.fogCoord, color);
			#endif
		&#125;

		void SplatmapFinalPrepass(Input IN, TERRAIN_SURFACE_OUTPUT o, inout fixed4 normalSpec)
		&#123;
			normalSpec *= o.Alpha;
		&#125;

		void SplatmapFinalGBuffer(Input IN, TERRAIN_SURFACE_OUTPUT o, inout half4 diffuse, inout half4 specSmoothness, inout half4 normal, inout half4 emission)
		&#123;
			diffuse.rgb *= o.Alpha;
			specSmoothness *= o.Alpha;
			normal.rgb *= o.Alpha;
			emission *= o.Alpha;
		&#125;

		ENDCG
	&#125;

	Fallback &quot;Nature/Terrain/Diffuse&quot;
&#125;
</code></pre><div class="tags"><a href="/tags/Unity3D/" rel="tag"><i class="ic i-tag"></i> Unity3D</a> <a href="/tags/Shader/" rel="tag"><i class="ic i-tag"></i> Shader</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-12-22 11:29:48" itemprop="dateModified" datetime="2022-12-22T11:29:48+08:00">2022-12-22</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>CWHISME <i class="ic i-at"><em>@</em></i>WangJiaYing</li><li class="link"><strong>本文链接：</strong> <a href="https://cwhisme.github.io/2016/11/21/Unity3D-Tri-planar-Terrain/" title="Unity3D Tri-planar Terrain">https://cwhisme.github.io/2016/11/21/Unity3D-Tri-planar-Terrain/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2016/11/17/Unity3D%E8%B5%84%E6%BA%90%E5%BC%95%E7%94%A8%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipew8gmvyj20zk0m87wh.jpg" title="Unity3D资源引用查询工具"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 其它</span><h3>Unity3D资源引用查询工具</h3></a></div><div class="item right"><a href="/2016/12/15/Tri-planar-Terrain-%E4%BA%8C-%E9%94%99%E8%AF%AF%E4%BF%AE%E6%AD%A3/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeun65urj20zk0m81ii.jpg" title="Tri-planar Terrain (二) 错误修正"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Shader</span><h3>Tri-planar Terrain (二) 错误修正</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%88%E6%9E%9C"><span class="toc-number">4.</span> <span class="toc-text">效果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">源码</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2016/05/31/Unity3D%E4%B8%ADShader%E7%9A%84%E9%98%B4%E5%BD%B1/" rel="bookmark" title="Unity3D中Shader的阴影">Unity3D中Shader的阴影</a></li><li><a href="/2016/11/04/Shader-%E5%83%8F%E7%B4%A0%E6%89%AD%E6%9B%B2%E6%95%88%E6%9E%9C/" rel="bookmark" title="[Shader]像素扭曲效果">[Shader]像素扭曲效果</a></li><li class="active"><a href="/2016/11/21/Unity3D-Tri-planar-Terrain/" rel="bookmark" title="Unity3D Tri-planar Terrain">Unity3D Tri-planar Terrain</a></li><li><a href="/2016/12/15/Tri-planar-Terrain-%E4%BA%8C-%E9%94%99%E8%AF%AF%E4%BF%AE%E6%AD%A3/" rel="bookmark" title="Tri-planar Terrain (二) 错误修正">Tri-planar Terrain (二) 错误修正</a></li><li><a href="/2021/01/26/Unity3DSahder%E5%85%B3%E9%94%AE%E5%AD%97/" rel="bookmark" title="Unity3D Sahder 关键字">Unity3D Sahder 关键字</a></li><li><a href="/2021/02/02/Sahder%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/" rel="bookmark" title="Sahder内置函数">Sahder内置函数</a></li><li><a href="/2021/03/10/Sahder%E4%B8%AD%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%8F%8A%E5%BA%94%E7%94%A8/" rel="bookmark" title="Unity3D中Sahder深度图及应用">Unity3D中Sahder深度图及应用</a></li><li><a href="/2022/12/06/Unity%E7%9A%84%E9%98%B4%E5%BD%B1%E4%B8%8E%E5%85%89%E7%85%A7%E7%83%98%E7%84%99/" rel="bookmark" title="Unity 的阴影与光照烘焙">Unity 的阴影与光照烘焙</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="CWHISME" data-src="/images/../img/avator"><p class="name" itemprop="name">CWHISME</p><div class="description" itemprop="description">✧⁺˚⁺ପ(๑･ω･)੭ु⁾⁾ 好好学习天天向上</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">82</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">25</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N3aGlzbWU=" title="https:&#x2F;&#x2F;github.com&#x2F;cwhisme"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmN3aGlzbWVAMTI2LmNvbQ==" title="mailto:cwhisme@126.com"><i class="ic i-envelope"></i></span> <a href="/atom.xml" title="&#x2F;atom.xml" class="item feedback"><i class="ic i-heart"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/bookmark/" rel="section"><i class="ic i-tag"></i>书签</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-magic"></i>链接</a><ul class="submenu"><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li></ul></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2016/11/17/Unity3D%E8%B5%84%E6%BA%90%E5%BC%95%E7%94%A8%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2016/12/15/Tri-planar-Terrain-%E4%BA%8C-%E9%94%99%E8%AF%AF%E4%BF%AE%E6%AD%A3/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E7%90%86%E8%AE%BA%E7%A0%94%E7%A9%B6/" title="分类于 理论研究">理论研究</a></div><span><a href="/2022/10/31/%E5%85%B3%E4%BA%8E%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%9A%84%E4%BC%98%E5%8C%96/" title="关于对项目字符串拼接的优化研究">关于对项目字符串拼接的优化研究</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Unity3D/" title="分类于 Unity3D">Unity3D</a> <i class="ic i-angle-right"></i> <a href="/categories/Unity3D/%E5%85%B6%E5%AE%83/" title="分类于 其它">其它</a></div><span><a href="/2016/04/19/%E5%9C%A8Unity%E4%B8%AD%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BAMesh/" title="在Unity中动态创建Mesh">在Unity中动态创建Mesh</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Unity3D/" title="分类于 Unity3D">Unity3D</a> <i class="ic i-angle-right"></i> <a href="/categories/Unity3D/%E7%83%AD%E6%9B%B4/" title="分类于 热更">热更</a></div><span><a href="/2021/09/28/%E5%85%B3%E4%BA%8EInjectFix%E4%BD%9C%E4%B8%BA%E7%83%AD%E6%9B%B4%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%B0%E5%BD%95/" title="关于InjectFix作为热更的一点记录">关于InjectFix作为热更的一点记录</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment count_3"></ul></div></div><div class="status"><div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">CWHISME @ Jiaying's Note</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">396k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">6:01</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2016/11/21/Unity3D-Tri-planar-Terrain/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/js/DateTimeAfeterCalc.js"></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?67361fe63465615f68c9fb7091dd2f10";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></body></html>