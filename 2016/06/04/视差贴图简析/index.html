<!DOCTYPE html><meta name="viewport" content="height=device-height,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=0"><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="cwhisme"><meta name="author" content="CWHISME"><meta property="og:title" content="视差贴图简析"><meta property="og:description" content="cwhisme"><meta property="og:site_name" content="WangJiaYing"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><title>视差贴图简析 - WangJiaYing</title><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/DateTimeAfeterCalc.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/particles-bg.js"></script><script src="https://fastly.jsdelivr.net/gh/CWHISME/live2d_api_models@master/autoload.js"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script type="text/javascript" src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/js/script.js"></script><link href="https://fastly.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/css/style.css"><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script id="MathJax-script" src="https://fastly.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/tachyons@4.12.0/css/tachyons.min.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="WangJiaYing" type="application/atom+xml">
</head><body><canvas id="hackEffectCanvas" style="position:fixed;z-index:-1;pointer-events:none"></canvas><canvas class="fireworks" style="position:fixed;z-index:10;pointer-events:none"></canvas><div class="w-100 bg-1 ph5-ns ph3 text-light"><nav class="db dt-l w-100 mw8 center border-box pv3"><a class="db dtc-l v-mid link dim w-100 w-25-l tc tl-l mb2 mb0-l white" href="/" title="WangJiaYing"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/logo.svg" class="dib h3" alt="WangJiaYing"></a><div class="db dtc-l v-mid w-100 w-75-l tc tr-l"><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/" title="Home">Home </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/archives" title="Archives">Archives </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/tags" title="Tags">Tags </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/categories" title="Categories">Categories </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/bookmark" title="Bookmark">Bookmark </a><a class="link dim f6 f5-l dib mr3 mr4-l white" href="/about" title="About">About</a></div></nav><div class="w-100 mw8 center vh-40 dt"><div class="dtc v-mid white"><h1 class="f1-l f2-m tc tc-m tl-ns">视差贴图简析</h1><p class="f4 fw3 pab-100px tc tc-m tl-ns"><i class="fa fa-calendar-check-o" aria-hidden="true"></i> 2016-06-04&nbsp&nbsp <i class="fa fa-clock-o" aria-hidden="true"></i> <span id="dateTimeAfter">2016-06-04</span></p></div></div><div class="relative w-100 mw8 center white dn dn-m db-ns"><i class="header-icon fa fa-snowflake-o"></i></div></div><div class="w-100 ph2 ph4-m ph5-l mv5 mv6-l"><div class="content"><div class="mw8 center"><div class="cf"><div class="fl w-100 w-70-l mw7 left fw3 lh-copy pr4-ns pr0-m post-content"><div class="tags-container-vertical"><div class="tags-sub-container"><a class="fw3 ph1 dib" href="/tags/Shader/">#Shader</a></div></div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我很想这样说：<br>“今天花了相当长的时间，就为了研究视差贴图(Parallax)，可怎么试效果怎么不对！本来视差贴图也不过是在法线贴图的基础上发展出来的算法，法线贴图完全没问题，加上对视差贴图相关计算，这么久不行了呢？最终查了又查，发现居然是自己代码中关于视线的一个计算问题造成的！白白又浪费多的时间….这使我决定就算暂时不继续看书了，挤出点时间、再熬点夜，也得把这玩意好好进行分析下，写出来。”</p><p>实际上，那是发生在星期三的事儿了，最终还是拖到了周末。</p><h2 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h2><p>谈到视差贴图，那么就不得不说一下法线贴图了。视差贴图实际上属于法线贴图得一个优化版本，它在法线贴图的基础上，计算了一个视觉上的偏移，因此，法线贴图是其基础。</p><p>对于法线贴图，之前我似乎也没讨论过，所以就放这儿一并简单说一下吧。</p><h3 id="切空间"><a href="#切空间" class="headerlink" title="切空间"></a>切空间</h3><p>法线贴图的计算，一般都需要用到“切空间”。切空间即每个点以自身为准的一个坐标系统，之所以有这个概念，是因为只有以点自身为准的坐标系，才能做到“复用”。包括以物体坐标系为准之类的，都只能说适用于特定物体，详细情况可以参照《CG-可编程实时图形权威指南》第八章关于凹凸映射的解释。我就稍微画个图吧：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/oldpictures/2016.6.4-1_TangentSpace.jpg" alt="切空间"></p><p>简单来说，切空间就是以垂直点自身得法线、垂直法线的切线、垂直法线切线的Binormal组成的一个坐标系。法线贴图保存的东西，就是这儿的。</p><p>切空间至模型空间的矩阵由此构成：</p>$$ M_{切空间->模型空间}= \begin{bmatrix} T_x&B_x&N_x\\ T_y&B_y&N_y\\ T_z&B_z&N_z\\ \end{bmatrix} $$<p>所以，这个矩阵的逆矩阵，就是模型空间到切空间的转化矩阵。同时由于N、T、Bt这三个量构造的矩阵属于正交矩阵，正交矩阵的逆矩阵就是它本身的转置矩阵。所以求出模型空间到切空间的矩阵就简单了：</p><p>$$M_{模型空间-&gt;切空间}=M_{切空间-&gt;模型空间}^{-1}=M_{切空间-&gt;模型空间}^T$$</p><p>所以：</p>$$ M_{模型空间->切空间}= \begin{bmatrix} T_x&T_x&T_x\\ B_y&B_y&B_y\\ N_z&N_z&N_z\\ \end{bmatrix} $$<p>然后，我们使用这个矩阵就可以转化相应的向量了。无论最终是在切空间计算，或者是模型空间、世界空间，都取决于自己——反正只要都在一个空间，其它都是任意的。</p><h3 id="法线贴图格式"><a href="#法线贴图格式" class="headerlink" title="法线贴图格式"></a>法线贴图格式</h3><p>法线贴图的格式是经过压缩的，因为大家都知道，向量是“具有大小和方向的量”，那么对于规范化向量来说，虽然大小不用说了，不过那方向必定也还是有的，即[-1,1]范围。然后，对于图片来说，范围又只在[0,1]之间，所就得现将其映射至[-1,1]范围。这就只需要简单地乘以2再减一就可以了。</p><p>另外，还有一点就是：在Unity中，法线贴图被压缩为DTXnm格式，其中有效数据是alpha及green通道，代表XY分量，Z分量则由XY进行计算获得。所以，最终使用的时候，我们还需要再次进行解码，计算方式如下：</p><p>normal=normalTex.ag;<br>normal.z=sqrt(1-normal.x<em>normal.x-normal.y</em>normal.y);</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>现在终于轮到实现了。</p><p>作为一个Unity程序，现在当然是打开Unity，新建一个Unlit Shader了，删掉无用的代码。然后在appdata中添加两个变量normal及tangent的语义，以获取模型的法线及切线：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 normal : NORMAL;</span><br><span class="line">float4 tangent : TANGENT;</span><br></pre></td></tr></table></figure><p>接着，需要在传入片段程序的结构体v2f中，继续加入我们需要传入片段程序的变量，分别是视线、以及光源方向，这几个方向都属于切空间的，我们会在顶点程序中进行计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 V : TEXCOORD3;</span><br><span class="line">float3 L : TEXCOORD4;</span><br></pre></td></tr></table></figure><p>然后是顶点程序中的计算，首先缓存法线、切线，并计算出Binormal(注意最后Binormal乘以的w系数，这似乎是Unity对切线提供的某种缩放):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float3 N = v.normal;</span><br><span class="line">float3 T = v.tangent;</span><br><span class="line">float3 Bt =normalize( cross(N,T)*v.tangent.w);</span><br></pre></td></tr></table></figure><p>接着，构建相应的切空间矩阵，并将视线、光源方向皆转化为切空间坐标，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//构建前往切空间的矩阵</span><br><span class="line">float3x3 o2Surf = float3x3(T, Bt, N);</span><br><span class="line">//链接构建世界空间至切空间矩阵</span><br><span class="line">float3x3 w2Surf = mul(o2Surf, (float3x3)_World2Object);</span><br><span class="line"></span><br><span class="line">float3 wPos = mul(_Object2World,v.vertex);</span><br><span class="line">float3 V= _WorldSpaceCameraPos - wPos;</span><br><span class="line">o.V = mul(w2Surf,V);</span><br><span class="line">o.L = mul(w2Surf,_WorldSpaceLightPos0.xyz);</span><br></pre></td></tr></table></figure><p>最后，就是片段程序中的计算了，除了多了一个额外法线的计算，其它与前文所述并无不认同。<br>首先将传入片段程序的各个插值后的向量进行归一化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 V = normalize(i.V);</span><br><span class="line">float3 L = normalize(i.L);</span><br></pre></td></tr></table></figure><p>重点就是这儿，按照上边说的，将法线从贴图中解压出来，并替换掉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//解压法线</span><br><span class="line">float4 normalTex = tex2D(_BumpTex,i.uv);</span><br><span class="line">//映射至[-1,1]</span><br><span class="line">normalTex = normalTex * 2 - 1;</span><br><span class="line">float3	localNormal;</span><br><span class="line">localNormal = float3(normalTex.ag,0);</span><br><span class="line">localNormal.z = sqrt(1 - dot(localNormal, localNormal));</span><br></pre></td></tr></table></figure><p>上边的localNormal的Z分量计算跟上边谈到的是一个性质的，稍微思考一下就明白了哦。</p><p>现在，新的法线已经计算出来，用这个法线进行光照的计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">float4 diffuse = max(0, dot(localNormal, L))*col;</span><br><span class="line">float4 specialer = col*pow(max(0, dot(V, reflect(-L, localNormal))), 25);</span><br><span class="line">col = col*UNITY_LIGHTMODEL_AMBIENT +diffuse+ specialer;</span><br></pre></td></tr></table></figure><p>完。</p><p>效果如下：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/oldpictures/2016.6.4-2_NormalMap.JPG" alt="法线贴图"></p><h2 id="视差贴图"><a href="#视差贴图" class="headerlink" title="视差贴图"></a>视差贴图</h2><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>视差贴图(ParallaxMaping)是法线贴图的一个升级。</p><p>效果如下：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/oldpictures/2016.6.4-3_Parallax.gif" alt="视差贴图"></p><p>完。。。</p><p>怎么可能…当然确实是在法线贴图上改动不是大就是了。<br>首先是在属性中添加了两个变量“_ParallaxTex”即视差计算中需要的高度图，以及“_ParallaxHeight”用于调整这个高度图取值的一个float变量，一般来说是在0~0.08之间，太多就会糊掉了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_ParallaxTex(&quot;Parallax Texture&quot;, 2D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">_ParallaxHeight(&quot;Parallax Height&quot;,RANGE(0,0.08))=0.01</span><br></pre></td></tr></table></figure><p>然后，顶点程序基本上没什么变化，只是在片段程序中加了一段代码，用于计算UV偏移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//解压视差贴图</span><br><span class="line">float height = _ParallaxHeight* tex2D(_ParallaxTex, i.uv).a;</span><br><span class="line">float2 uvOffset =height*(V.xy / V.z);</span><br><span class="line"></span><br><span class="line">float2 uv = i.uv + uvOffset;</span><br></pre></td></tr></table></figure><p>然后使用新的UV对法线及贴图进行采样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//解压法线</span><br><span class="line">float4 normalTex = tex2D(_BumpTex,uv);</span><br><span class="line">//映射至[-1,1]</span><br><span class="line">normalTex = normalTex * 2 - 1;</span><br><span class="line">float3	localNormal;</span><br><span class="line">localNormal = float3(normalTex.ag,0);</span><br><span class="line">localNormal.z = sqrt(1 - dot(localNormal, localNormal));</span><br><span class="line"></span><br><span class="line">fixed4 col = tex2D(_MainTex, uv);</span><br><span class="line">float4 diffuse = max(0, dot(localNormal, L))*col;</span><br><span class="line">float4 specialer = col*pow(max(0, dot(V, reflect(-L, localNormal))), 25);</span><br><span class="line">col = col*UNITY_LIGHTMODEL_AMBIENT +diffuse+ specialer;</span><br></pre></td></tr></table></figure><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>法线贴图虽然可以做到表现一种凹凸不平的质感，不过最好的效果只是针对于垂直的方向，一旦角度变化，这个“凹凸”质感就会随视线角度的加大，而变的越发虚假。</p><p>视差贴图的理论就是，在法线贴图的基础上，通过计算视线角度对贴图的UV也进行一个偏移，增强法线贴图效果同时使其更不宜穿帮…当然，如果视线与点的夹角太大，依然是毫无作用的。</p><p>可以画个图稍微看看：</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/oldpictures/2016.6.4-4_mypicture.JPG" alt="图示"></p><p>在此，我们需要计算的，就是最终偏移点的UV，并使用这个新的UV进行采样。<br>根据三角形相似法则，计算这个偏移量的公式为：</p><p>$${Offset_x \over h}={V_x \over V_z}$$<br>$${Offset_y \over h}={V_y \over V_z}$$</p><p>所以就可由此计算偏移点：</p><p>$$Offset_x={h \times V_x \over V_z}$$<br>$$Offset_y={h \times V_y \over V_z}$$</p><p>更详细得情况可以参考<a href="">维基百科</a>，这儿我就不当搬运工了。</p><p><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/blogimages/oldpictures/2016.6.4-5_Parallax_compare.JPG" alt="法线贴图与视差贴图的比较"></p><h2 id="Unity提供函数"><a href="#Unity提供函数" class="headerlink" title="Unity提供函数"></a>Unity提供函数</h2><p>在Unity中，其实也提供了有关法线及视差计算的函数.<br>法线：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline fixed3 UnpackNormal(fixed4 packednormal)</span><br></pre></td></tr></table></figure><p>视差偏移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline float2 ParallaxOffset( half h, half height, half3 viewDir )</span><br></pre></td></tr></table></figure><p>有兴趣的话，也可以扒出来看看，虽然有些不一样，不过实际计算是差不多的。特别是视差偏移计算，Unity的函数多了点步骤：也就是在计算视线的分量之上添加了0.42，使得比值变小，也就是说最终计算出来的偏移也会变小，相当于缩放，不过要注意的上边计算h中，Unity也是不一样的。所以如果将我上边的视差计算换成Unity的ParallaxOffset函数，效果会有点轻微差别。<br>有时候如果觉得自己计算麻烦，这两个函数也都是可以直接拿来用的。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">//Author:CWHISME</span><br><span class="line">//Date:2016.6.4</span><br><span class="line">//Decription:</span><br><span class="line">Shader &quot;CWH/ParallaxMaping&quot;</span><br><span class="line">&#123;</span><br><span class="line">	Properties</span><br><span class="line">	&#123;</span><br><span class="line">		_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_BumpTex(&quot;Bump Texture&quot;, 2D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">		_ParallaxTex(&quot;Parallax Texture&quot;, 2D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">		_ParallaxHeight(&quot;Parallax Height&quot;,RANGE(0,0.08))=0.01</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader</span><br><span class="line">	&#123;</span><br><span class="line">		Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">		LOD 100</span><br><span class="line"></span><br><span class="line">		Pass</span><br><span class="line">		&#123;</span><br><span class="line">			Tags&#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			#pragma vertex vert</span><br><span class="line">			#pragma fragment frag</span><br><span class="line"></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			sampler2D _BumpTex;</span><br><span class="line">			sampler2D _ParallaxTex;</span><br><span class="line">			float _ParallaxHeight;</span><br><span class="line"></span><br><span class="line">			struct appdata</span><br><span class="line">			&#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">				float4 tangent : TANGENT;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			struct v2f</span><br><span class="line">			&#123;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">				float4 vertex : SV_POSITION;</span><br><span class="line">				//float3 N : TEXCOORD1;</span><br><span class="line">				//float3 T : TEXCOORD2;</span><br><span class="line">				//float3 Bt : TEXCOORD3;</span><br><span class="line">				float3 V : TEXCOORD1;</span><br><span class="line">				float3 L : TEXCOORD2;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			v2f vert (appdata v)</span><br><span class="line">			&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);</span><br><span class="line">				o.uv = v.uv;</span><br><span class="line">				float3 N = v.normal;</span><br><span class="line">				float3 T = v.tangent;</span><br><span class="line">				float3 Bt =normalize( cross(N,T)*v.tangent.w);</span><br><span class="line"></span><br><span class="line">				//构建前往切空间的矩阵</span><br><span class="line">				float3x3 o2Surf = float3x3(T, Bt, N);</span><br><span class="line">				//链接构建世界空间至切空间矩阵</span><br><span class="line">				float3x3 w2Surf = mul(o2Surf, (float3x3)_World2Object);</span><br><span class="line"></span><br><span class="line">				float3 wPos = mul(_Object2World,v.vertex);</span><br><span class="line">				float3 V= _WorldSpaceCameraPos - wPos;</span><br><span class="line">				o.V = mul(w2Surf,V);</span><br><span class="line">				o.L = mul(w2Surf,_WorldSpaceLightPos0.xyz);</span><br><span class="line">				return o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag (v2f i) : SV_Target</span><br><span class="line">			&#123;</span><br><span class="line">				//float3 N = normalize(i.N);</span><br><span class="line">				//float3 T = normalize(i.T);</span><br><span class="line">				//float3 Bt = normalize(i.Bt);</span><br><span class="line">				float3 V = normalize(i.V);</span><br><span class="line">				float3 L = normalize(i.L);</span><br><span class="line">				////构建前往切空间的矩阵</span><br><span class="line">				//float3x3 o2Surf = float3x3(T,Bt,N);</span><br><span class="line">				////链接构建世界空间至切空间矩阵</span><br><span class="line">				//float3x3 w2Surf = mul(o2Surf,(float3x3)_World2Object);</span><br><span class="line"></span><br><span class="line">				//float3 L = mul(w2Surf,_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">				//解压视差贴图</span><br><span class="line">				float height = _ParallaxHeight* tex2D(_ParallaxTex, i.uv).a;</span><br><span class="line">				float2 uvOffset =height*(V.xy / V.z);</span><br><span class="line"></span><br><span class="line">				float2 uv = i.uv + uvOffset;</span><br><span class="line"></span><br><span class="line">				//解压法线</span><br><span class="line">				float4 normalTex = tex2D(_BumpTex,uv);</span><br><span class="line">				//映射至[-1,1]</span><br><span class="line">				normalTex = normalTex * 2 - 1;</span><br><span class="line">				float3	localNormal;</span><br><span class="line">				localNormal = float3(normalTex.ag,0);</span><br><span class="line">				localNormal.z = sqrt(1 - dot(localNormal, localNormal));</span><br><span class="line"></span><br><span class="line">				fixed4 col = tex2D(_MainTex, uv);</span><br><span class="line">				float4 diffuse = max(0, dot(localNormal, L))*col;</span><br><span class="line">				float4 specialer = col*pow(max(0, dot(V, reflect(-L, localNormal))), 25);</span><br><span class="line">				col = col*UNITY_LIGHTMODEL_AMBIENT +diffuse+ specialer;</span><br><span class="line">				return col;</span><br><span class="line">			&#125;</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>本来打算一鼓作气就把这篇Blog写完的，结果理想是丰富的，现实，是骨感的。写法线贴图居然就花了一上午，而且回头看，居然内容也不是很多的样子…<br>感觉像是回到了小学(或者初中？)，当年考试的时候，试卷都从来没有做完的时候。<br>特别是语文，基本上阅读都还没做…完?突然就发现考试都结束了！<br>然后被问到为什么成绩这么差？就只好说：这不是我自己不行，是因为时间太少了啊，试卷一大半都还没做，结果能不差嘛？</p><p>呃…..</p><div class="tags-container-bottom"><i class="fa fa-tag pr3 text-main-color"></i><a class="fw3 ph1 dib" href="/tags/Shader/">#Shader</a></div><br><br><hr><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><div id="vcomments"></div><script>new Valine({el:"#vcomments",appId:"MsaVbSzIr9cIfikihDExdun9-gzGzoHsz",appKey:"Bj6SEFUBomrLOTWx9B8S6zQH",placeholder:"请输入评论内容~",avatar:"mp",visitor:!1})</script></div><div class="fl w-100 w-30-l center fw3 lh-copy pl4-ns tl black-50"><hr class="dn-l mw4 black-50 mt5"><div class="mt5 mt0-l site-author"><article class="dt db-l mw8 mw8-m mw5-ns center ml0-l bg-white mv3"><div class="dn dtc-m db-l v-mid tc pr4 pr0-l" style="min-width:6rem"><img src="https://fastly.jsdelivr.net/gh/CWHISME/CWHISME.github.io@master/img/photo.jpg" class="mb4-l br-100 h3 w3 h4-l w4-l dib" title="CWHISME"></div><div class="dtc db-l v-mid lh-copy measure center f6 black-50 tj">悲观主义的末日</div></article></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>分类</h3><p><a href="/categories/图形学/">图形学</a></p></div><hr class="dn-l mw4 black-50 mt5"><div class="mt5 tc tl-l"><h3>近期文章</h3><p><a href="/2022/12/10/%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/">协变和逆变</a></p><p><a href="/2022/12/06/Unity%E7%9A%84%E9%98%B4%E5%BD%B1%E4%B8%8E%E5%85%89%E7%85%A7%E7%83%98%E7%84%99/">Unity 的阴影与光照烘焙</a></p><p><a href="/2022/11/23/%E6%89%93%E5%8C%85AssetBundle%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86/">打包 AssetBundle 的基础规则整理</a></p><p><a href="/2022/11/18/StringBuilder%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E7%A0%94%E7%A9%B6/">StringBuilder 扩容规则研究</a></p><p><a href="/2022/11/17/%E6%B5%8B%E8%AF%95%E6%89%8B%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">简单测试手动垃圾回收</a></p></div></div></div></div></div></div><div class="bg-1 ph2 ph5-ns pv5"><div class="mv8"><div class="center tc"><div class="dib mh3"><a class="f3 f2-ns white dim" href="https://github.com/CWHISME" target="_blank"><i class="fa fa-github"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="mailto:cwhisme@126.com" target="_blank"><i class="fa fa-envelope"></i></a></div><div class="dib mh3"><a class="f3 f2-ns white dim" href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div></div><div class="f6 f5-ns center tc white pt5 fw3">Copyright © 2021 | Design & Hexo <a class="link dim white" target="_blank" rel="noopener" href="https://github.com/klugjo/hexo-theme-anodyne/">Jonathan Klughertz</a> | Modify By CWHISME</div></div></div></body></html>